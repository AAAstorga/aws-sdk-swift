// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Codepipeline {

    public struct ActionContext: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the action within the context of a job.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["name"] as? String
        }
    }

    public struct PipelineSummary: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The date and time of the last update to the pipeline, in timestamp format.
        public let updated: Date?
        /// The name of the pipeline.
        public let name: String?
        /// The version number of the pipeline.
        public let version: Int32?
        /// The date and time the pipeline was created, in timestamp format.
        public let created: Date?

        public init(updated: Date? = nil, name: String? = nil, version: Int32? = nil, created: Date? = nil) {
            self.updated = updated
            self.name = name
            self.version = version
            self.created = created
        }

        public init(dictionary: [String: Any]) throws {
            self.updated = dictionary["updated"] as? Date
            self.name = dictionary["name"] as? String
            self.version = dictionary["version"] as? Int32
            self.created = dictionary["created"] as? Date
        }
    }

    public struct FailureDetails: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The type of the failure.
        public let `type`: FailureType
        /// The message about the failure.
        public let message: String
        /// The external ID of the run of the action that failed.
        public let externalExecutionId: String?

        public init(type: FailureType, message: String, externalExecutionId: String? = nil) {
            self.`type` = `type`
            self.message = message
            self.externalExecutionId = externalExecutionId
        }

        public init(dictionary: [String: Any]) throws {
            guard let rawtype = dictionary["type"] as? String, let `type` = FailureType(rawValue: rawtype) else { throw InitializableError.missingRequiredParam("type") }
            self.`type` = `type`
            guard let message = dictionary["message"] as? String else { throw InitializableError.missingRequiredParam("message") }
            self.message = message
            self.externalExecutionId = dictionary["externalExecutionId"] as? String
        }
    }

    public struct ListActionTypesOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Provides details of the action types.
        public let actionTypes: [ActionType]
        /// If the amount of returned information is significantly large, an identifier is also returned which can be used in a subsequent list action types call to return the next set of action types in the list.
        public let nextToken: String?

        public init(actionTypes: [ActionType], nextToken: String? = nil) {
            self.actionTypes = actionTypes
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            guard let actionTypes = dictionary["actionTypes"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("actionTypes") }
            self.actionTypes = try actionTypes.map({ try ActionType(dictionary: $0) })
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct GetJobDetailsInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The unique system-generated ID for the job.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        public init(dictionary: [String: Any]) throws {
            guard let jobId = dictionary["jobId"] as? String else { throw InitializableError.missingRequiredParam("jobId") }
            self.jobId = jobId
        }
    }

    public struct CurrentRevision: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The revision ID of the current version of an artifact.
        public let revision: String
        /// The change identifier for the current revision.
        public let changeIdentifier: String
        /// The date and time when the most recent revision of the artifact was created, in timestamp format.
        public let created: Date?
        /// The summary of the most recent revision of the artifact.
        public let revisionSummary: String?

        public init(revision: String, changeIdentifier: String, created: Date? = nil, revisionSummary: String? = nil) {
            self.revision = revision
            self.changeIdentifier = changeIdentifier
            self.created = created
            self.revisionSummary = revisionSummary
        }

        public init(dictionary: [String: Any]) throws {
            guard let revision = dictionary["revision"] as? String else { throw InitializableError.missingRequiredParam("revision") }
            self.revision = revision
            guard let changeIdentifier = dictionary["changeIdentifier"] as? String else { throw InitializableError.missingRequiredParam("changeIdentifier") }
            self.changeIdentifier = changeIdentifier
            self.created = dictionary["created"] as? Date
            self.revisionSummary = dictionary["revisionSummary"] as? String
        }
    }

    public struct PutActionRevisionOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the current workflow state of the pipeline.
        public let pipelineExecutionId: String?
        /// Indicates whether the artifact revision was previously used in an execution of the specified pipeline.
        public let newRevision: Bool?

        public init(pipelineExecutionId: String? = nil, newRevision: Bool? = nil) {
            self.pipelineExecutionId = pipelineExecutionId
            self.newRevision = newRevision
        }

        public init(dictionary: [String: Any]) throws {
            self.pipelineExecutionId = dictionary["pipelineExecutionId"] as? String
            self.newRevision = dictionary["newRevision"] as? Bool
        }
    }

    public struct RetryStageExecutionOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the current workflow execution in the failed stage.
        public let pipelineExecutionId: String?

        public init(pipelineExecutionId: String? = nil) {
            self.pipelineExecutionId = pipelineExecutionId
        }

        public init(dictionary: [String: Any]) throws {
            self.pipelineExecutionId = dictionary["pipelineExecutionId"] as? String
        }
    }

    public struct ArtifactDetails: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The minimum number of artifacts allowed for the action type.
        public let minimumCount: Int32
        /// The maximum number of artifacts allowed for the action type.
        public let maximumCount: Int32

        public init(minimumCount: Int32, maximumCount: Int32) {
            self.minimumCount = minimumCount
            self.maximumCount = maximumCount
        }

        public init(dictionary: [String: Any]) throws {
            guard let minimumCount = dictionary["minimumCount"] as? Int32 else { throw InitializableError.missingRequiredParam("minimumCount") }
            self.minimumCount = minimumCount
            guard let maximumCount = dictionary["maximumCount"] as? Int32 else { throw InitializableError.missingRequiredParam("maximumCount") }
            self.maximumCount = maximumCount
        }
    }

    public struct ErrorDetails: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The system ID or error number code of the error.
        public let code: String?
        /// The text of the error message.
        public let message: String?

        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        public init(dictionary: [String: Any]) throws {
            self.code = dictionary["code"] as? String
            self.message = dictionary["message"] as? String
        }
    }

    public struct ActionConfigurationProperty: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the action configuration property.
        public let name: String
        /// Whether the configuration property is a key.
        public let key: Bool
        /// Whether the configuration property is secret. Secrets are hidden from all calls except for GetJobDetails, GetThirdPartyJobDetails, PollForJobs, and PollForThirdPartyJobs. When updating a pipeline, passing * * * * * without changing any other values of the action will preserve the prior value of the secret.
        public let secret: Bool
        /// The description of the action configuration property that will be displayed to users.
        public let description: String?
        /// Whether the configuration property is a required value.
        public let required: Bool
        /// The type of the configuration property.
        public let `type`: ActionConfigurationPropertyType?
        /// Indicates that the proprety will be used in conjunction with PollForJobs. When creating a custom action, an action can have up to one queryable property. If it has one, that property must be both required and not secret. If you create a pipeline with a custom action type, and that custom action contains a queryable property, the value for that configuration property is subject to additional restrictions. The value must be less than or equal to twenty (20) characters. The value can contain only alphanumeric characters, underscores, and hyphens.
        public let queryable: Bool?

        public init(name: String, key: Bool, secret: Bool, description: String? = nil, required: Bool, type: ActionConfigurationPropertyType? = nil, queryable: Bool? = nil) {
            self.name = name
            self.key = key
            self.secret = secret
            self.description = description
            self.required = required
            self.`type` = `type`
            self.queryable = queryable
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
            guard let key = dictionary["key"] as? Bool else { throw InitializableError.missingRequiredParam("key") }
            self.key = key
            guard let secret = dictionary["secret"] as? Bool else { throw InitializableError.missingRequiredParam("secret") }
            self.secret = secret
            self.description = dictionary["description"] as? String
            guard let required = dictionary["required"] as? Bool else { throw InitializableError.missingRequiredParam("required") }
            self.required = required
            if let `type` = dictionary["type"] as? String { self.`type` = ActionConfigurationPropertyType(rawValue: `type`) } else { self.`type` = nil }
            self.queryable = dictionary["queryable"] as? Bool
        }
    }

    public struct StageContext: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the stage.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["name"] as? String
        }
    }

    public struct StageExecution: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The status of the stage, or for a completed stage, the last status of the stage.
        public let status: StageExecutionStatus
        /// The ID of the pipeline execution associated with the stage.
        public let pipelineExecutionId: String

        public init(status: StageExecutionStatus, pipelineExecutionId: String) {
            self.status = status
            self.pipelineExecutionId = pipelineExecutionId
        }

        public init(dictionary: [String: Any]) throws {
            guard let rawstatus = dictionary["status"] as? String, let status = StageExecutionStatus(rawValue: rawstatus) else { throw InitializableError.missingRequiredParam("status") }
            self.status = status
            guard let pipelineExecutionId = dictionary["pipelineExecutionId"] as? String else { throw InitializableError.missingRequiredParam("pipelineExecutionId") }
            self.pipelineExecutionId = pipelineExecutionId
        }
    }

    public struct ActionExecution: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A summary of the run of the action.
        public let summary: String?
        /// The status of the action, or for a completed action, the last status of the action.
        public let status: ActionExecutionStatus?
        /// The ARN of the user who last changed the pipeline.
        public let lastUpdatedBy: String?
        /// The external ID of the run of the action.
        public let externalExecutionId: String?
        /// The URL of a resource external to AWS that will be used when running the action, for example an external repository URL.
        public let externalExecutionUrl: String?
        /// The system-generated token used to identify a unique approval request. The token for each open approval request can be obtained using the GetPipelineState command and is used to validate that the approval request corresponding to this token is still valid.
        public let token: String?
        /// The details of an error returned by a URL external to AWS.
        public let errorDetails: ErrorDetails?
        /// A percentage of completeness of the action as it runs.
        public let percentComplete: Int32?
        /// The last status change of the action.
        public let lastStatusChange: Date?

        public init(summary: String? = nil, status: ActionExecutionStatus? = nil, lastUpdatedBy: String? = nil, externalExecutionId: String? = nil, externalExecutionUrl: String? = nil, token: String? = nil, errorDetails: ErrorDetails? = nil, percentComplete: Int32? = nil, lastStatusChange: Date? = nil) {
            self.summary = summary
            self.status = status
            self.lastUpdatedBy = lastUpdatedBy
            self.externalExecutionId = externalExecutionId
            self.externalExecutionUrl = externalExecutionUrl
            self.token = token
            self.errorDetails = errorDetails
            self.percentComplete = percentComplete
            self.lastStatusChange = lastStatusChange
        }

        public init(dictionary: [String: Any]) throws {
            self.summary = dictionary["summary"] as? String
            if let status = dictionary["status"] as? String { self.status = ActionExecutionStatus(rawValue: status) } else { self.status = nil }
            self.lastUpdatedBy = dictionary["lastUpdatedBy"] as? String
            self.externalExecutionId = dictionary["externalExecutionId"] as? String
            self.externalExecutionUrl = dictionary["externalExecutionUrl"] as? String
            self.token = dictionary["token"] as? String
            if let errorDetails = dictionary["errorDetails"] as? [String: Any] { self.errorDetails = try Codepipeline.ErrorDetails(dictionary: errorDetails) } else { self.errorDetails = nil }
            self.percentComplete = dictionary["percentComplete"] as? Int32
            self.lastStatusChange = dictionary["lastStatusChange"] as? Date
        }
    }

    public struct StartPipelineExecutionInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the pipeline to start.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
        }
    }

    public struct StageState: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The state of the inbound transition, which is either enabled or disabled.
        public let inboundTransitionState: TransitionState?
        /// The state of the stage.
        public let actionStates: [ActionState]?
        /// The name of the stage.
        public let stageName: String?
        /// Information about the latest execution in the stage, including its ID and status.
        public let latestExecution: StageExecution?

        public init(inboundTransitionState: TransitionState? = nil, actionStates: [ActionState]? = nil, stageName: String? = nil, latestExecution: StageExecution? = nil) {
            self.inboundTransitionState = inboundTransitionState
            self.actionStates = actionStates
            self.stageName = stageName
            self.latestExecution = latestExecution
        }

        public init(dictionary: [String: Any]) throws {
            if let inboundTransitionState = dictionary["inboundTransitionState"] as? [String: Any] { self.inboundTransitionState = try Codepipeline.TransitionState(dictionary: inboundTransitionState) } else { self.inboundTransitionState = nil }
            if let actionStates = dictionary["actionStates"] as? [[String: Any]] {
                self.actionStates = try actionStates.map({ try ActionState(dictionary: $0) })
            } else { 
                self.actionStates = nil
            }
            self.stageName = dictionary["stageName"] as? String
            if let latestExecution = dictionary["latestExecution"] as? [String: Any] { self.latestExecution = try Codepipeline.StageExecution(dictionary: latestExecution) } else { self.latestExecution = nil }
        }
    }

    public struct PutActionRevisionInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the stage that contains the action that will act upon the revision.
        public let stageName: String
        /// The name of the action that will process the revision.
        public let actionName: String
        /// The name of the pipeline that will start processing the revision to the source.
        public let pipelineName: String
        public let actionRevision: ActionRevision

        public init(stageName: String, actionName: String, pipelineName: String, actionRevision: ActionRevision) {
            self.stageName = stageName
            self.actionName = actionName
            self.pipelineName = pipelineName
            self.actionRevision = actionRevision
        }

        public init(dictionary: [String: Any]) throws {
            guard let stageName = dictionary["stageName"] as? String else { throw InitializableError.missingRequiredParam("stageName") }
            self.stageName = stageName
            guard let actionName = dictionary["actionName"] as? String else { throw InitializableError.missingRequiredParam("actionName") }
            self.actionName = actionName
            guard let pipelineName = dictionary["pipelineName"] as? String else { throw InitializableError.missingRequiredParam("pipelineName") }
            self.pipelineName = pipelineName
            guard let actionRevision = dictionary["actionRevision"] as? [String: Any] else { throw InitializableError.missingRequiredParam("actionRevision") }
            self.actionRevision = try Codepipeline.ActionRevision(dictionary: actionRevision)
        }
    }

    public struct PutThirdPartyJobFailureResultInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let failureDetails: FailureDetails
        /// The clientToken portion of the clientId and clientToken pair used to verify that the calling entity is allowed access to the job and its details.
        public let clientToken: String
        /// The ID of the job that failed. This is the same ID returned from PollForThirdPartyJobs.
        public let jobId: String

        public init(failureDetails: FailureDetails, clientToken: String, jobId: String) {
            self.failureDetails = failureDetails
            self.clientToken = clientToken
            self.jobId = jobId
        }

        public init(dictionary: [String: Any]) throws {
            guard let failureDetails = dictionary["failureDetails"] as? [String: Any] else { throw InitializableError.missingRequiredParam("failureDetails") }
            self.failureDetails = try Codepipeline.FailureDetails(dictionary: failureDetails)
            guard let clientToken = dictionary["clientToken"] as? String else { throw InitializableError.missingRequiredParam("clientToken") }
            self.clientToken = clientToken
            guard let jobId = dictionary["jobId"] as? String else { throw InitializableError.missingRequiredParam("jobId") }
            self.jobId = jobId
        }
    }

    public struct Artifact: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The artifact's revision ID. Depending on the type of object, this could be a commit ID (GitHub) or a revision ID (Amazon S3).
        public let revision: String?
        /// The artifact's name.
        public let name: String?
        /// The location of an artifact.
        public let location: ArtifactLocation?

        public init(revision: String? = nil, name: String? = nil, location: ArtifactLocation? = nil) {
            self.revision = revision
            self.name = name
            self.location = location
        }

        public init(dictionary: [String: Any]) throws {
            self.revision = dictionary["revision"] as? String
            self.name = dictionary["name"] as? String
            if let location = dictionary["location"] as? [String: Any] { self.location = try Codepipeline.ArtifactLocation(dictionary: location) } else { self.location = nil }
        }
    }

    public struct JobData: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let actionTypeId: ActionTypeId?
        public let actionConfiguration: ActionConfiguration?
        public let artifactCredentials: AWSSessionCredentials?
        /// The output of the job.
        public let outputArtifacts: [Artifact]?
        public let encryptionKey: EncryptionKey?
        /// A system-generated token, such as a AWS CodeDeploy deployment ID, that a job requires in order to continue the job asynchronously.
        public let continuationToken: String?
        /// The artifact supplied to the job.
        public let inputArtifacts: [Artifact]?
        public let pipelineContext: PipelineContext?

        public init(actionTypeId: ActionTypeId? = nil, actionConfiguration: ActionConfiguration? = nil, artifactCredentials: AWSSessionCredentials? = nil, outputArtifacts: [Artifact]? = nil, encryptionKey: EncryptionKey? = nil, continuationToken: String? = nil, inputArtifacts: [Artifact]? = nil, pipelineContext: PipelineContext? = nil) {
            self.actionTypeId = actionTypeId
            self.actionConfiguration = actionConfiguration
            self.artifactCredentials = artifactCredentials
            self.outputArtifacts = outputArtifacts
            self.encryptionKey = encryptionKey
            self.continuationToken = continuationToken
            self.inputArtifacts = inputArtifacts
            self.pipelineContext = pipelineContext
        }

        public init(dictionary: [String: Any]) throws {
            if let actionTypeId = dictionary["actionTypeId"] as? [String: Any] { self.actionTypeId = try Codepipeline.ActionTypeId(dictionary: actionTypeId) } else { self.actionTypeId = nil }
            if let actionConfiguration = dictionary["actionConfiguration"] as? [String: Any] { self.actionConfiguration = try Codepipeline.ActionConfiguration(dictionary: actionConfiguration) } else { self.actionConfiguration = nil }
            if let artifactCredentials = dictionary["artifactCredentials"] as? [String: Any] { self.artifactCredentials = try Codepipeline.AWSSessionCredentials(dictionary: artifactCredentials) } else { self.artifactCredentials = nil }
            if let outputArtifacts = dictionary["outputArtifacts"] as? [[String: Any]] {
                self.outputArtifacts = try outputArtifacts.map({ try Artifact(dictionary: $0) })
            } else { 
                self.outputArtifacts = nil
            }
            if let encryptionKey = dictionary["encryptionKey"] as? [String: Any] { self.encryptionKey = try Codepipeline.EncryptionKey(dictionary: encryptionKey) } else { self.encryptionKey = nil }
            self.continuationToken = dictionary["continuationToken"] as? String
            if let inputArtifacts = dictionary["inputArtifacts"] as? [[String: Any]] {
                self.inputArtifacts = try inputArtifacts.map({ try Artifact(dictionary: $0) })
            } else { 
                self.inputArtifacts = nil
            }
            if let pipelineContext = dictionary["pipelineContext"] as? [String: Any] { self.pipelineContext = try Codepipeline.PipelineContext(dictionary: pipelineContext) } else { self.pipelineContext = nil }
        }
    }

    public struct PutApprovalResultInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the stage that contains the action.
        public let stageName: String
        /// The name of the action for which approval is requested.
        public let actionName: String
        /// Represents information about the result of the approval request.
        public let result: ApprovalResult
        /// The name of the pipeline that contains the action. 
        public let pipelineName: String
        /// The system-generated token used to identify a unique approval request. The token for each open approval request can be obtained using the GetPipelineState action and is used to validate that the approval request corresponding to this token is still valid.
        public let token: String

        public init(stageName: String, actionName: String, result: ApprovalResult, pipelineName: String, token: String) {
            self.stageName = stageName
            self.actionName = actionName
            self.result = result
            self.pipelineName = pipelineName
            self.token = token
        }

        public init(dictionary: [String: Any]) throws {
            guard let stageName = dictionary["stageName"] as? String else { throw InitializableError.missingRequiredParam("stageName") }
            self.stageName = stageName
            guard let actionName = dictionary["actionName"] as? String else { throw InitializableError.missingRequiredParam("actionName") }
            self.actionName = actionName
            guard let result = dictionary["result"] as? [String: Any] else { throw InitializableError.missingRequiredParam("result") }
            self.result = try Codepipeline.ApprovalResult(dictionary: result)
            guard let pipelineName = dictionary["pipelineName"] as? String else { throw InitializableError.missingRequiredParam("pipelineName") }
            self.pipelineName = pipelineName
            guard let token = dictionary["token"] as? String else { throw InitializableError.missingRequiredParam("token") }
            self.token = token
        }
    }

    public struct ArtifactLocation: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The type of artifact in the location.
        public let `type`: ArtifactLocationType?
        /// The Amazon S3 bucket that contains the artifact.
        public let s3Location: S3ArtifactLocation?

        public init(type: ArtifactLocationType? = nil, s3Location: S3ArtifactLocation? = nil) {
            self.`type` = `type`
            self.s3Location = s3Location
        }

        public init(dictionary: [String: Any]) throws {
            if let `type` = dictionary["type"] as? String { self.`type` = ArtifactLocationType(rawValue: `type`) } else { self.`type` = nil }
            if let s3Location = dictionary["s3Location"] as? [String: Any] { self.s3Location = try Codepipeline.S3ArtifactLocation(dictionary: s3Location) } else { self.s3Location = nil }
        }
    }

    public struct GetPipelineExecutionInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the pipeline about which you want to get execution details.
        public let pipelineName: String
        /// The ID of the pipeline execution about which you want to get execution details.
        public let pipelineExecutionId: String

        public init(pipelineName: String, pipelineExecutionId: String) {
            self.pipelineName = pipelineName
            self.pipelineExecutionId = pipelineExecutionId
        }

        public init(dictionary: [String: Any]) throws {
            guard let pipelineName = dictionary["pipelineName"] as? String else { throw InitializableError.missingRequiredParam("pipelineName") }
            self.pipelineName = pipelineName
            guard let pipelineExecutionId = dictionary["pipelineExecutionId"] as? String else { throw InitializableError.missingRequiredParam("pipelineExecutionId") }
            self.pipelineExecutionId = pipelineExecutionId
        }
    }

    public enum EncryptionKeyType: String, CustomStringConvertible {
        case kms = "KMS"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible {
        case created = "Created"
        case queued = "Queued"
        case dispatched = "Dispatched"
        case inprogress = "InProgress"
        case timedout = "TimedOut"
        case succeeded = "Succeeded"
        case failed = "Failed"
        public var description: String { return self.rawValue }
    }

    public struct DisableStageTransitionInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Specifies whether artifacts will be prevented from transitioning into the stage and being processed by the actions in that stage (inbound), or prevented from transitioning from the stage after they have been processed by the actions in that stage (outbound).
        public let transitionType: StageTransitionType
        /// The name of the stage where you want to disable the inbound or outbound transition of artifacts.
        public let stageName: String
        /// The reason given to the user why a stage is disabled, such as waiting for manual approval or manual tests. This message is displayed in the pipeline console UI.
        public let reason: String
        /// The name of the pipeline in which you want to disable the flow of artifacts from one stage to another.
        public let pipelineName: String

        public init(transitionType: StageTransitionType, stageName: String, reason: String, pipelineName: String) {
            self.transitionType = transitionType
            self.stageName = stageName
            self.reason = reason
            self.pipelineName = pipelineName
        }

        public init(dictionary: [String: Any]) throws {
            guard let rawtransitionType = dictionary["transitionType"] as? String, let transitionType = StageTransitionType(rawValue: rawtransitionType) else { throw InitializableError.missingRequiredParam("transitionType") }
            self.transitionType = transitionType
            guard let stageName = dictionary["stageName"] as? String else { throw InitializableError.missingRequiredParam("stageName") }
            self.stageName = stageName
            guard let reason = dictionary["reason"] as? String else { throw InitializableError.missingRequiredParam("reason") }
            self.reason = reason
            guard let pipelineName = dictionary["pipelineName"] as? String else { throw InitializableError.missingRequiredParam("pipelineName") }
            self.pipelineName = pipelineName
        }
    }

    public enum ActionCategory: String, CustomStringConvertible {
        case source = "Source"
        case build = "Build"
        case deploy = "Deploy"
        case test = "Test"
        case invoke = "Invoke"
        case approval = "Approval"
        public var description: String { return self.rawValue }
    }

    public enum StageRetryMode: String, CustomStringConvertible {
        case failed_actions = "FAILED_ACTIONS"
        public var description: String { return self.rawValue }
    }

    public struct GetJobDetailsOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The details of the job.  If AWSSessionCredentials is used, a long-running job can call GetJobDetails again to obtain new credentials. 
        public let jobDetails: JobDetails?

        public init(jobDetails: JobDetails? = nil) {
            self.jobDetails = jobDetails
        }

        public init(dictionary: [String: Any]) throws {
            if let jobDetails = dictionary["jobDetails"] as? [String: Any] { self.jobDetails = try Codepipeline.JobDetails(dictionary: jobDetails) } else { self.jobDetails = nil }
        }
    }

    public struct AcknowledgeJobOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Whether the job worker has received the specified job.
        public let status: JobStatus?

        public init(status: JobStatus? = nil) {
            self.status = status
        }

        public init(dictionary: [String: Any]) throws {
            if let status = dictionary["status"] as? String { self.status = JobStatus(rawValue: status) } else { self.status = nil }
        }
    }

    public struct PipelineExecution: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The status of the pipeline execution.   InProgress: The pipeline execution is currently running.   Succeeded: The pipeline execution completed successfully.    Superseded: While this pipeline execution was waiting for the next stage to be completed, a newer pipeline execution caught up and continued through the pipeline instead.    Failed: The pipeline did not complete successfully.  
        public let status: PipelineExecutionStatus?
        /// The version number of the pipeline that was executed.
        public let pipelineVersion: Int32?
        /// The ID of the pipeline execution.
        public let pipelineExecutionId: String?
        /// The name of the pipeline that was executed.
        public let pipelineName: String?
        /// A list of ArtifactRevision objects included in a pipeline execution.
        public let artifactRevisions: [ArtifactRevision]?

        public init(status: PipelineExecutionStatus? = nil, pipelineVersion: Int32? = nil, pipelineExecutionId: String? = nil, pipelineName: String? = nil, artifactRevisions: [ArtifactRevision]? = nil) {
            self.status = status
            self.pipelineVersion = pipelineVersion
            self.pipelineExecutionId = pipelineExecutionId
            self.pipelineName = pipelineName
            self.artifactRevisions = artifactRevisions
        }

        public init(dictionary: [String: Any]) throws {
            if let status = dictionary["status"] as? String { self.status = PipelineExecutionStatus(rawValue: status) } else { self.status = nil }
            self.pipelineVersion = dictionary["pipelineVersion"] as? Int32
            self.pipelineExecutionId = dictionary["pipelineExecutionId"] as? String
            self.pipelineName = dictionary["pipelineName"] as? String
            if let artifactRevisions = dictionary["artifactRevisions"] as? [[String: Any]] {
                self.artifactRevisions = try artifactRevisions.map({ try ArtifactRevision(dictionary: $0) })
            } else { 
                self.artifactRevisions = nil
            }
        }
    }

    public struct AcknowledgeJobInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A system-generated random number that AWS CodePipeline uses to ensure that the job is being worked on by only one job worker. Get this number from the response of the PollForJobs request that returned this job.
        public let nonce: String
        /// The unique system-generated ID of the job for which you want to confirm receipt.
        public let jobId: String

        public init(nonce: String, jobId: String) {
            self.nonce = nonce
            self.jobId = jobId
        }

        public init(dictionary: [String: Any]) throws {
            guard let nonce = dictionary["nonce"] as? String else { throw InitializableError.missingRequiredParam("nonce") }
            self.nonce = nonce
            guard let jobId = dictionary["jobId"] as? String else { throw InitializableError.missingRequiredParam("jobId") }
            self.jobId = jobId
        }
    }

    public struct JobDetails: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The unique system-generated ID of the job.
        public let id: String?
        /// The AWS account ID associated with the job.
        public let accountId: String?
        public let data: JobData?

        public init(id: String? = nil, accountId: String? = nil, data: JobData? = nil) {
            self.id = id
            self.accountId = accountId
            self.data = data
        }

        public init(dictionary: [String: Any]) throws {
            self.id = dictionary["id"] as? String
            self.accountId = dictionary["accountId"] as? String
            if let data = dictionary["data"] as? [String: Any] { self.data = try Codepipeline.JobData(dictionary: data) } else { self.data = nil }
        }
    }

    public struct S3ArtifactLocation: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the Amazon S3 bucket.
        public let bucketName: String
        /// The key of the object in the Amazon S3 bucket, which uniquely identifies the object in the bucket.
        public let objectKey: String

        public init(bucketName: String, objectKey: String) {
            self.bucketName = bucketName
            self.objectKey = objectKey
        }

        public init(dictionary: [String: Any]) throws {
            guard let bucketName = dictionary["bucketName"] as? String else { throw InitializableError.missingRequiredParam("bucketName") }
            self.bucketName = bucketName
            guard let objectKey = dictionary["objectKey"] as? String else { throw InitializableError.missingRequiredParam("objectKey") }
            self.objectKey = objectKey
        }
    }

    public struct CreateCustomActionTypeOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let actionType: ActionType

        public init(actionType: ActionType) {
            self.actionType = actionType
        }

        public init(dictionary: [String: Any]) throws {
            guard let actionType = dictionary["actionType"] as? [String: Any] else { throw InitializableError.missingRequiredParam("actionType") }
            self.actionType = try Codepipeline.ActionType(dictionary: actionType)
        }
    }

    public struct ActionTypeId: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The creator of the action being called.
        public let owner: ActionOwner
        /// A string that identifies the action type.
        public let version: String
        /// The provider of the service being called by the action. Valid providers are determined by the action category. For example, an action in the Deploy category type might have a provider of AWS CodeDeploy, which would be specified as CodeDeploy.
        public let provider: String
        /// A category defines what kind of action can be taken in the stage, and constrains the provider type for the action. Valid categories are limited to one of the values below.
        public let category: ActionCategory

        public init(owner: ActionOwner, version: String, provider: String, category: ActionCategory) {
            self.owner = owner
            self.version = version
            self.provider = provider
            self.category = category
        }

        public init(dictionary: [String: Any]) throws {
            guard let rawowner = dictionary["owner"] as? String, let owner = ActionOwner(rawValue: rawowner) else { throw InitializableError.missingRequiredParam("owner") }
            self.owner = owner
            guard let version = dictionary["version"] as? String else { throw InitializableError.missingRequiredParam("version") }
            self.version = version
            guard let provider = dictionary["provider"] as? String else { throw InitializableError.missingRequiredParam("provider") }
            self.provider = provider
            guard let rawcategory = dictionary["category"] as? String, let category = ActionCategory(rawValue: rawcategory) else { throw InitializableError.missingRequiredParam("category") }
            self.category = category
        }
    }

    public enum StageExecutionStatus: String, CustomStringConvertible {
        case inprogress = "InProgress"
        case failed = "Failed"
        case succeeded = "Succeeded"
        public var description: String { return self.rawValue }
    }

    public struct GetThirdPartyJobDetailsInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The clientToken portion of the clientId and clientToken pair used to verify that the calling entity is allowed access to the job and its details.
        public let clientToken: String
        /// The unique system-generated ID used for identifying the job.
        public let jobId: String

        public init(clientToken: String, jobId: String) {
            self.clientToken = clientToken
            self.jobId = jobId
        }

        public init(dictionary: [String: Any]) throws {
            guard let clientToken = dictionary["clientToken"] as? String else { throw InitializableError.missingRequiredParam("clientToken") }
            self.clientToken = clientToken
            guard let jobId = dictionary["jobId"] as? String else { throw InitializableError.missingRequiredParam("jobId") }
            self.jobId = jobId
        }
    }

    public struct PutThirdPartyJobSuccessResultInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let executionDetails: ExecutionDetails?
        /// The clientToken portion of the clientId and clientToken pair used to verify that the calling entity is allowed access to the job and its details.
        public let clientToken: String
        /// A token generated by a job worker, such as an AWS CodeDeploy deployment ID, that a successful job provides to identify a partner action in progress. Future jobs will use this token in order to identify the running instance of the action. It can be reused to return additional information about the progress of the partner action. When the action is complete, no continuation token should be supplied.
        public let continuationToken: String?
        public let currentRevision: CurrentRevision?
        /// The ID of the job that successfully completed. This is the same ID returned from PollForThirdPartyJobs.
        public let jobId: String

        public init(executionDetails: ExecutionDetails? = nil, clientToken: String, continuationToken: String? = nil, currentRevision: CurrentRevision? = nil, jobId: String) {
            self.executionDetails = executionDetails
            self.clientToken = clientToken
            self.continuationToken = continuationToken
            self.currentRevision = currentRevision
            self.jobId = jobId
        }

        public init(dictionary: [String: Any]) throws {
            if let executionDetails = dictionary["executionDetails"] as? [String: Any] { self.executionDetails = try Codepipeline.ExecutionDetails(dictionary: executionDetails) } else { self.executionDetails = nil }
            guard let clientToken = dictionary["clientToken"] as? String else { throw InitializableError.missingRequiredParam("clientToken") }
            self.clientToken = clientToken
            self.continuationToken = dictionary["continuationToken"] as? String
            if let currentRevision = dictionary["currentRevision"] as? [String: Any] { self.currentRevision = try Codepipeline.CurrentRevision(dictionary: currentRevision) } else { self.currentRevision = nil }
            guard let jobId = dictionary["jobId"] as? String else { throw InitializableError.missingRequiredParam("jobId") }
            self.jobId = jobId
        }
    }

    public struct DeleteCustomActionTypeInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The provider of the service used in the custom action, such as AWS CodeDeploy.
        public let provider: String
        /// The version of the custom action to delete.
        public let version: String
        /// The category of the custom action that you want to delete, such as source or deploy.
        public let category: ActionCategory

        public init(provider: String, version: String, category: ActionCategory) {
            self.provider = provider
            self.version = version
            self.category = category
        }

        public init(dictionary: [String: Any]) throws {
            guard let provider = dictionary["provider"] as? String else { throw InitializableError.missingRequiredParam("provider") }
            self.provider = provider
            guard let version = dictionary["version"] as? String else { throw InitializableError.missingRequiredParam("version") }
            self.version = version
            guard let rawcategory = dictionary["category"] as? String, let category = ActionCategory(rawValue: rawcategory) else { throw InitializableError.missingRequiredParam("category") }
            self.category = category
        }
    }

    public struct StageDeclaration: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Reserved for future use.
        public let blockers: [BlockerDeclaration]?
        /// The name of the stage.
        public let name: String
        /// The actions included in a stage.
        public let actions: [ActionDeclaration]

        public init(blockers: [BlockerDeclaration]? = nil, name: String, actions: [ActionDeclaration]) {
            self.blockers = blockers
            self.name = name
            self.actions = actions
        }

        public init(dictionary: [String: Any]) throws {
            if let blockers = dictionary["blockers"] as? [[String: Any]] {
                self.blockers = try blockers.map({ try BlockerDeclaration(dictionary: $0) })
            } else { 
                self.blockers = nil
            }
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
            guard let actions = dictionary["actions"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("actions") }
            self.actions = try actions.map({ try ActionDeclaration(dictionary: $0) })
        }
    }

    public struct AWSSessionCredentials: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The token for the session.
        public let sessionToken: String
        /// The access key for the session.
        public let accessKeyId: String
        /// The secret access key for the session.
        public let secretAccessKey: String

        public init(sessionToken: String, accessKeyId: String, secretAccessKey: String) {
            self.sessionToken = sessionToken
            self.accessKeyId = accessKeyId
            self.secretAccessKey = secretAccessKey
        }

        public init(dictionary: [String: Any]) throws {
            guard let sessionToken = dictionary["sessionToken"] as? String else { throw InitializableError.missingRequiredParam("sessionToken") }
            self.sessionToken = sessionToken
            guard let accessKeyId = dictionary["accessKeyId"] as? String else { throw InitializableError.missingRequiredParam("accessKeyId") }
            self.accessKeyId = accessKeyId
            guard let secretAccessKey = dictionary["secretAccessKey"] as? String else { throw InitializableError.missingRequiredParam("secretAccessKey") }
            self.secretAccessKey = secretAccessKey
        }
    }

    public struct EncryptionKey: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID used to identify the key. For an AWS KMS key, this is the key ID or key ARN.
        public let id: String
        /// The type of encryption key, such as an AWS Key Management Service (AWS KMS) key. When creating or updating a pipeline, the value must be set to 'KMS'.
        public let `type`: EncryptionKeyType

        public init(id: String, type: EncryptionKeyType) {
            self.id = id
            self.`type` = `type`
        }

        public init(dictionary: [String: Any]) throws {
            guard let id = dictionary["id"] as? String else { throw InitializableError.missingRequiredParam("id") }
            self.id = id
            guard let rawtype = dictionary["type"] as? String, let `type` = EncryptionKeyType(rawValue: rawtype) else { throw InitializableError.missingRequiredParam("type") }
            self.`type` = `type`
        }
    }

    public struct EnableStageTransitionInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the pipeline in which you want to enable the flow of artifacts from one stage to another.
        public let pipelineName: String
        /// Specifies whether artifacts will be allowed to enter the stage and be processed by the actions in that stage (inbound) or whether already-processed artifacts will be allowed to transition to the next stage (outbound).
        public let transitionType: StageTransitionType
        /// The name of the stage where you want to enable the transition of artifacts, either into the stage (inbound) or from that stage to the next stage (outbound).
        public let stageName: String

        public init(pipelineName: String, transitionType: StageTransitionType, stageName: String) {
            self.pipelineName = pipelineName
            self.transitionType = transitionType
            self.stageName = stageName
        }

        public init(dictionary: [String: Any]) throws {
            guard let pipelineName = dictionary["pipelineName"] as? String else { throw InitializableError.missingRequiredParam("pipelineName") }
            self.pipelineName = pipelineName
            guard let rawtransitionType = dictionary["transitionType"] as? String, let transitionType = StageTransitionType(rawValue: rawtransitionType) else { throw InitializableError.missingRequiredParam("transitionType") }
            self.transitionType = transitionType
            guard let stageName = dictionary["stageName"] as? String else { throw InitializableError.missingRequiredParam("stageName") }
            self.stageName = stageName
        }
    }

    public struct InputArtifact: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the artifact to be worked on, for example, "My App". The input artifact of an action must exactly match the output artifact declared in a preceding action, but the input artifact does not have to be the next action in strict sequence from the action that provided the output artifact. Actions in parallel can declare different output artifacts, which are in turn consumed by different following actions.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
        }
    }

    public enum StageTransitionType: String, CustomStringConvertible {
        case inbound = "Inbound"
        case outbound = "Outbound"
        public var description: String { return self.rawValue }
    }

    public struct PollForJobsOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the jobs to take action on.
        public let jobs: [Job]?

        public init(jobs: [Job]? = nil) {
            self.jobs = jobs
        }

        public init(dictionary: [String: Any]) throws {
            if let jobs = dictionary["jobs"] as? [[String: Any]] {
                self.jobs = try jobs.map({ try Job(dictionary: $0) })
            } else { 
                self.jobs = nil
            }
        }
    }

    public enum BlockerType: String, CustomStringConvertible {
        case schedule = "Schedule"
        public var description: String { return self.rawValue }
    }

    public struct ActionDeclaration: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The configuration information for the action type.
        public let actionTypeId: ActionTypeId
        /// The ARN of the IAM service role that will perform the declared action. This is assumed through the roleArn for the pipeline.
        public let roleArn: String?
        /// The action declaration's name.
        public let name: String
        /// The order in which actions are run.
        public let runOrder: Int32?
        /// The name or ID of the result of the action declaration, such as a test or build artifact.
        public let outputArtifacts: [OutputArtifact]?
        /// The name or ID of the artifact consumed by the action, such as a test or build artifact.
        public let inputArtifacts: [InputArtifact]?
        /// The action declaration's configuration.
        public let configuration: [String: String]?

        public init(actionTypeId: ActionTypeId, roleArn: String? = nil, name: String, runOrder: Int32? = nil, outputArtifacts: [OutputArtifact]? = nil, inputArtifacts: [InputArtifact]? = nil, configuration: [String: String]? = nil) {
            self.actionTypeId = actionTypeId
            self.roleArn = roleArn
            self.name = name
            self.runOrder = runOrder
            self.outputArtifacts = outputArtifacts
            self.inputArtifacts = inputArtifacts
            self.configuration = configuration
        }

        public init(dictionary: [String: Any]) throws {
            guard let actionTypeId = dictionary["actionTypeId"] as? [String: Any] else { throw InitializableError.missingRequiredParam("actionTypeId") }
            self.actionTypeId = try Codepipeline.ActionTypeId(dictionary: actionTypeId)
            self.roleArn = dictionary["roleArn"] as? String
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
            self.runOrder = dictionary["runOrder"] as? Int32
            if let outputArtifacts = dictionary["outputArtifacts"] as? [[String: Any]] {
                self.outputArtifacts = try outputArtifacts.map({ try OutputArtifact(dictionary: $0) })
            } else { 
                self.outputArtifacts = nil
            }
            if let inputArtifacts = dictionary["inputArtifacts"] as? [[String: Any]] {
                self.inputArtifacts = try inputArtifacts.map({ try InputArtifact(dictionary: $0) })
            } else { 
                self.inputArtifacts = nil
            }
            if let configuration = dictionary["configuration"] as? [String: String] {
                self.configuration = configuration
            } else { 
                self.configuration = nil
            }
        }
    }

    public struct GetPipelineStateOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The date and time the pipeline was last updated, in timestamp format.
        public let updated: Date?
        /// The version number of the pipeline.  A newly-created pipeline is always assigned a version number of 1. 
        public let pipelineVersion: Int32?
        /// A list of the pipeline stage output information, including stage name, state, most recent run details, whether the stage is disabled, and other data.
        public let stageStates: [StageState]?
        /// The date and time the pipeline was created, in timestamp format.
        public let created: Date?
        /// The name of the pipeline for which you want to get the state.
        public let pipelineName: String?

        public init(updated: Date? = nil, pipelineVersion: Int32? = nil, stageStates: [StageState]? = nil, created: Date? = nil, pipelineName: String? = nil) {
            self.updated = updated
            self.pipelineVersion = pipelineVersion
            self.stageStates = stageStates
            self.created = created
            self.pipelineName = pipelineName
        }

        public init(dictionary: [String: Any]) throws {
            self.updated = dictionary["updated"] as? Date
            self.pipelineVersion = dictionary["pipelineVersion"] as? Int32
            if let stageStates = dictionary["stageStates"] as? [[String: Any]] {
                self.stageStates = try stageStates.map({ try StageState(dictionary: $0) })
            } else { 
                self.stageStates = nil
            }
            self.created = dictionary["created"] as? Date
            self.pipelineName = dictionary["pipelineName"] as? String
        }
    }

    public struct PutJobSuccessResultInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The execution details of the successful job, such as the actions taken by the job worker.
        public let executionDetails: ExecutionDetails?
        /// A token generated by a job worker, such as an AWS CodeDeploy deployment ID, that a successful job provides to identify a custom action in progress. Future jobs will use this token in order to identify the running instance of the action. It can be reused to return additional information about the progress of the custom action. When the action is complete, no continuation token should be supplied.
        public let continuationToken: String?
        /// The ID of the current revision of the artifact successfully worked upon by the job.
        public let currentRevision: CurrentRevision?
        /// The unique system-generated ID of the job that succeeded. This is the same ID returned from PollForJobs.
        public let jobId: String

        public init(executionDetails: ExecutionDetails? = nil, continuationToken: String? = nil, currentRevision: CurrentRevision? = nil, jobId: String) {
            self.executionDetails = executionDetails
            self.continuationToken = continuationToken
            self.currentRevision = currentRevision
            self.jobId = jobId
        }

        public init(dictionary: [String: Any]) throws {
            if let executionDetails = dictionary["executionDetails"] as? [String: Any] { self.executionDetails = try Codepipeline.ExecutionDetails(dictionary: executionDetails) } else { self.executionDetails = nil }
            self.continuationToken = dictionary["continuationToken"] as? String
            if let currentRevision = dictionary["currentRevision"] as? [String: Any] { self.currentRevision = try Codepipeline.CurrentRevision(dictionary: currentRevision) } else { self.currentRevision = nil }
            guard let jobId = dictionary["jobId"] as? String else { throw InitializableError.missingRequiredParam("jobId") }
            self.jobId = jobId
        }
    }

    public struct OutputArtifact: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the output of an artifact, such as "My App". The input artifact of an action must exactly match the output artifact declared in a preceding action, but the input artifact does not have to be the next action in strict sequence from the action that provided the output artifact. Actions in parallel can declare different output artifacts, which are in turn consumed by different following actions. Output artifact names must be unique within a pipeline.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
        }
    }

    public struct DeletePipelineInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the pipeline to be deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
        }
    }

    public struct PipelineDeclaration: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let artifactStore: ArtifactStore
        /// The name of the action to be performed.
        public let name: String
        /// The stage in which to perform the action.
        public let stages: [StageDeclaration]
        /// The Amazon Resource Name (ARN) for AWS CodePipeline to use to either perform actions with no actionRoleArn, or to use to assume roles for actions with an actionRoleArn.
        public let roleArn: String
        /// The version number of the pipeline. A new pipeline always has a version number of 1. This number is automatically incremented when a pipeline is updated.
        public let version: Int32?

        public init(artifactStore: ArtifactStore, name: String, stages: [StageDeclaration], roleArn: String, version: Int32? = nil) {
            self.artifactStore = artifactStore
            self.name = name
            self.stages = stages
            self.roleArn = roleArn
            self.version = version
        }

        public init(dictionary: [String: Any]) throws {
            guard let artifactStore = dictionary["artifactStore"] as? [String: Any] else { throw InitializableError.missingRequiredParam("artifactStore") }
            self.artifactStore = try Codepipeline.ArtifactStore(dictionary: artifactStore)
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
            guard let stages = dictionary["stages"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("stages") }
            self.stages = try stages.map({ try StageDeclaration(dictionary: $0) })
            guard let roleArn = dictionary["roleArn"] as? String else { throw InitializableError.missingRequiredParam("roleArn") }
            self.roleArn = roleArn
            self.version = dictionary["version"] as? Int32
        }
    }

    public struct ThirdPartyJobDetails: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The identifier used to identify the job details in AWS CodePipeline.
        public let id: String?
        /// A system-generated random number that AWS CodePipeline uses to ensure that the job is being worked on by only one job worker. Use this number in an AcknowledgeThirdPartyJob request.
        public let nonce: String?
        /// The data to be returned by the third party job worker.
        public let data: ThirdPartyJobData?

        public init(id: String? = nil, nonce: String? = nil, data: ThirdPartyJobData? = nil) {
            self.id = id
            self.nonce = nonce
            self.data = data
        }

        public init(dictionary: [String: Any]) throws {
            self.id = dictionary["id"] as? String
            self.nonce = dictionary["nonce"] as? String
            if let data = dictionary["data"] as? [String: Any] { self.data = try Codepipeline.ThirdPartyJobData(dictionary: data) } else { self.data = nil }
        }
    }

    public struct ActionState: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A URL link for more information about the state of the action, such as a deployment group details page.
        public let entityUrl: String?
        /// The name of the action.
        public let actionName: String?
        public let currentRevision: ActionRevision?
        /// A URL link for more information about the revision, such as a commit details page.
        public let revisionUrl: String?
        public let latestExecution: ActionExecution?

        public init(entityUrl: String? = nil, actionName: String? = nil, currentRevision: ActionRevision? = nil, revisionUrl: String? = nil, latestExecution: ActionExecution? = nil) {
            self.entityUrl = entityUrl
            self.actionName = actionName
            self.currentRevision = currentRevision
            self.revisionUrl = revisionUrl
            self.latestExecution = latestExecution
        }

        public init(dictionary: [String: Any]) throws {
            self.entityUrl = dictionary["entityUrl"] as? String
            self.actionName = dictionary["actionName"] as? String
            if let currentRevision = dictionary["currentRevision"] as? [String: Any] { self.currentRevision = try Codepipeline.ActionRevision(dictionary: currentRevision) } else { self.currentRevision = nil }
            self.revisionUrl = dictionary["revisionUrl"] as? String
            if let latestExecution = dictionary["latestExecution"] as? [String: Any] { self.latestExecution = try Codepipeline.ActionExecution(dictionary: latestExecution) } else { self.latestExecution = nil }
        }
    }

    public struct PollForJobsInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let actionTypeId: ActionTypeId
        /// A map of property names and values. For an action type with no queryable properties, this value must be null or an empty map. For an action type with a queryable property, you must supply that property as a key in the map. Only jobs whose action configuration matches the mapped value will be returned.
        public let queryParam: [String: String]?
        /// The maximum number of jobs to return in a poll for jobs call.
        public let maxBatchSize: Int32?

        public init(actionTypeId: ActionTypeId, queryParam: [String: String]? = nil, maxBatchSize: Int32? = nil) {
            self.actionTypeId = actionTypeId
            self.queryParam = queryParam
            self.maxBatchSize = maxBatchSize
        }

        public init(dictionary: [String: Any]) throws {
            guard let actionTypeId = dictionary["actionTypeId"] as? [String: Any] else { throw InitializableError.missingRequiredParam("actionTypeId") }
            self.actionTypeId = try Codepipeline.ActionTypeId(dictionary: actionTypeId)
            if let queryParam = dictionary["queryParam"] as? [String: String] {
                self.queryParam = queryParam
            } else { 
                self.queryParam = nil
            }
            self.maxBatchSize = dictionary["maxBatchSize"] as? Int32
        }
    }

    public struct ThirdPartyJob: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The identifier used to identify the job in AWS CodePipeline.
        public let jobId: String?
        /// The clientToken portion of the clientId and clientToken pair used to verify that the calling entity is allowed access to the job and its details.
        public let clientId: String?

        public init(jobId: String? = nil, clientId: String? = nil) {
            self.jobId = jobId
            self.clientId = clientId
        }

        public init(dictionary: [String: Any]) throws {
            self.jobId = dictionary["jobId"] as? String
            self.clientId = dictionary["clientId"] as? String
        }
    }

    public struct ArtifactRevision: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Summary information about the most recent revision of the artifact. For GitHub and AWS CodeCommit repositories, the commit message. For Amazon S3 buckets or actions, the user-provided content of a codepipeline-artifact-revision-summary key specified in the object metadata.
        public let revisionSummary: String?
        /// The name of an artifact. This name might be system-generated, such as "MyApp", or might be defined by the user when an action is created.
        public let name: String?
        /// The date and time when the most recent revision of the artifact was created, in timestamp format.
        public let created: Date?
        /// An additional identifier for a revision, such as a commit date or, for artifacts stored in Amazon S3 buckets, the ETag value.
        public let revisionChangeIdentifier: String?
        /// The revision ID of the artifact.
        public let revisionId: String?
        /// The commit ID for the artifact revision. For artifacts stored in GitHub or AWS CodeCommit repositories, the commit ID is linked to a commit details page.
        public let revisionUrl: String?

        public init(revisionSummary: String? = nil, name: String? = nil, created: Date? = nil, revisionChangeIdentifier: String? = nil, revisionId: String? = nil, revisionUrl: String? = nil) {
            self.revisionSummary = revisionSummary
            self.name = name
            self.created = created
            self.revisionChangeIdentifier = revisionChangeIdentifier
            self.revisionId = revisionId
            self.revisionUrl = revisionUrl
        }

        public init(dictionary: [String: Any]) throws {
            self.revisionSummary = dictionary["revisionSummary"] as? String
            self.name = dictionary["name"] as? String
            self.created = dictionary["created"] as? Date
            self.revisionChangeIdentifier = dictionary["revisionChangeIdentifier"] as? String
            self.revisionId = dictionary["revisionId"] as? String
            self.revisionUrl = dictionary["revisionUrl"] as? String
        }
    }

    public struct ListPipelinesInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous list pipelines call, which can be used to return the next set of pipelines in the list.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct ActionRevision: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The date and time when the most recent version of the action was created, in timestamp format.
        public let created: Date
        /// The unique identifier of the change that set the state to this revision, for example a deployment ID or timestamp.
        public let revisionChangeId: String
        /// The system-generated unique ID that identifies the revision number of the action.
        public let revisionId: String

        public init(created: Date, revisionChangeId: String, revisionId: String) {
            self.created = created
            self.revisionChangeId = revisionChangeId
            self.revisionId = revisionId
        }

        public init(dictionary: [String: Any]) throws {
            guard let created = dictionary["created"] as? Date else { throw InitializableError.missingRequiredParam("created") }
            self.created = created
            guard let revisionChangeId = dictionary["revisionChangeId"] as? String else { throw InitializableError.missingRequiredParam("revisionChangeId") }
            self.revisionChangeId = revisionChangeId
            guard let revisionId = dictionary["revisionId"] as? String else { throw InitializableError.missingRequiredParam("revisionId") }
            self.revisionId = revisionId
        }
    }

    public enum PipelineExecutionStatus: String, CustomStringConvertible {
        case inprogress = "InProgress"
        case succeeded = "Succeeded"
        case superseded = "Superseded"
        case failed = "Failed"
        public var description: String { return self.rawValue }
    }

    public struct RetryStageExecutionInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The scope of the retry attempt. Currently, the only supported value is FAILED_ACTIONS.
        public let retryMode: StageRetryMode
        /// The ID of the pipeline execution in the failed stage to be retried. Use the GetPipelineState action to retrieve the current pipelineExecutionId of the failed stage
        public let pipelineExecutionId: String
        /// The name of the failed stage to be retried.
        public let stageName: String
        /// The name of the pipeline that contains the failed stage.
        public let pipelineName: String

        public init(retryMode: StageRetryMode, pipelineExecutionId: String, stageName: String, pipelineName: String) {
            self.retryMode = retryMode
            self.pipelineExecutionId = pipelineExecutionId
            self.stageName = stageName
            self.pipelineName = pipelineName
        }

        public init(dictionary: [String: Any]) throws {
            guard let rawretryMode = dictionary["retryMode"] as? String, let retryMode = StageRetryMode(rawValue: rawretryMode) else { throw InitializableError.missingRequiredParam("retryMode") }
            self.retryMode = retryMode
            guard let pipelineExecutionId = dictionary["pipelineExecutionId"] as? String else { throw InitializableError.missingRequiredParam("pipelineExecutionId") }
            self.pipelineExecutionId = pipelineExecutionId
            guard let stageName = dictionary["stageName"] as? String else { throw InitializableError.missingRequiredParam("stageName") }
            self.stageName = stageName
            guard let pipelineName = dictionary["pipelineName"] as? String else { throw InitializableError.missingRequiredParam("pipelineName") }
            self.pipelineName = pipelineName
        }
    }

    public struct TransitionState: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Whether the transition between stages is enabled (true) or disabled (false).
        public let enabled: Bool?
        /// The user-specified reason why the transition between two stages of a pipeline was disabled.
        public let disabledReason: String?
        /// The timestamp when the transition state was last changed.
        public let lastChangedAt: Date?
        /// The ID of the user who last changed the transition state.
        public let lastChangedBy: String?

        public init(enabled: Bool? = nil, disabledReason: String? = nil, lastChangedAt: Date? = nil, lastChangedBy: String? = nil) {
            self.enabled = enabled
            self.disabledReason = disabledReason
            self.lastChangedAt = lastChangedAt
            self.lastChangedBy = lastChangedBy
        }

        public init(dictionary: [String: Any]) throws {
            self.enabled = dictionary["enabled"] as? Bool
            self.disabledReason = dictionary["disabledReason"] as? String
            self.lastChangedAt = dictionary["lastChangedAt"] as? Date
            self.lastChangedBy = dictionary["lastChangedBy"] as? String
        }
    }

    public enum ApprovalStatus: String, CustomStringConvertible {
        case approved = "Approved"
        case rejected = "Rejected"
        public var description: String { return self.rawValue }
    }

    public struct PipelineContext: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the pipeline. This is a user-specified value. Pipeline names must be unique across all pipeline names under an Amazon Web Services account.
        public let pipelineName: String?
        public let action: ActionContext?
        /// The stage of the pipeline.
        public let stage: StageContext?

        public init(pipelineName: String? = nil, action: ActionContext? = nil, stage: StageContext? = nil) {
            self.pipelineName = pipelineName
            self.action = action
            self.stage = stage
        }

        public init(dictionary: [String: Any]) throws {
            self.pipelineName = dictionary["pipelineName"] as? String
            if let action = dictionary["action"] as? [String: Any] { self.action = try Codepipeline.ActionContext(dictionary: action) } else { self.action = nil }
            if let stage = dictionary["stage"] as? [String: Any] { self.stage = try Codepipeline.StageContext(dictionary: stage) } else { self.stage = nil }
        }
    }

    public struct PollForThirdPartyJobsInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let actionTypeId: ActionTypeId
        /// The maximum number of jobs to return in a poll for jobs call.
        public let maxBatchSize: Int32?

        public init(actionTypeId: ActionTypeId, maxBatchSize: Int32? = nil) {
            self.actionTypeId = actionTypeId
            self.maxBatchSize = maxBatchSize
        }

        public init(dictionary: [String: Any]) throws {
            guard let actionTypeId = dictionary["actionTypeId"] as? [String: Any] else { throw InitializableError.missingRequiredParam("actionTypeId") }
            self.actionTypeId = try Codepipeline.ActionTypeId(dictionary: actionTypeId)
            self.maxBatchSize = dictionary["maxBatchSize"] as? Int32
        }
    }

    public struct PollForThirdPartyJobsOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the jobs to take action on.
        public let jobs: [ThirdPartyJob]?

        public init(jobs: [ThirdPartyJob]? = nil) {
            self.jobs = jobs
        }

        public init(dictionary: [String: Any]) throws {
            if let jobs = dictionary["jobs"] as? [[String: Any]] {
                self.jobs = try jobs.map({ try ThirdPartyJob(dictionary: $0) })
            } else { 
                self.jobs = nil
            }
        }
    }

    public struct PutJobFailureResultInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The details about the failure of a job.
        public let failureDetails: FailureDetails
        /// The unique system-generated ID of the job that failed. This is the same ID returned from PollForJobs.
        public let jobId: String

        public init(failureDetails: FailureDetails, jobId: String) {
            self.failureDetails = failureDetails
            self.jobId = jobId
        }

        public init(dictionary: [String: Any]) throws {
            guard let failureDetails = dictionary["failureDetails"] as? [String: Any] else { throw InitializableError.missingRequiredParam("failureDetails") }
            self.failureDetails = try Codepipeline.FailureDetails(dictionary: failureDetails)
            guard let jobId = dictionary["jobId"] as? String else { throw InitializableError.missingRequiredParam("jobId") }
            self.jobId = jobId
        }
    }

    public struct ArtifactStore: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The type of the artifact store, such as S3.
        public let `type`: ArtifactStoreType
        /// The location for storing the artifacts for a pipeline, such as an S3 bucket or folder.
        public let location: String
        /// The encryption key used to encrypt the data in the artifact store, such as an AWS Key Management Service (AWS KMS) key. If this is undefined, the default key for Amazon S3 is used.
        public let encryptionKey: EncryptionKey?

        public init(type: ArtifactStoreType, location: String, encryptionKey: EncryptionKey? = nil) {
            self.`type` = `type`
            self.location = location
            self.encryptionKey = encryptionKey
        }

        public init(dictionary: [String: Any]) throws {
            guard let rawtype = dictionary["type"] as? String, let `type` = ArtifactStoreType(rawValue: rawtype) else { throw InitializableError.missingRequiredParam("type") }
            self.`type` = `type`
            guard let location = dictionary["location"] as? String else { throw InitializableError.missingRequiredParam("location") }
            self.location = location
            if let encryptionKey = dictionary["encryptionKey"] as? [String: Any] { self.encryptionKey = try Codepipeline.EncryptionKey(dictionary: encryptionKey) } else { self.encryptionKey = nil }
        }
    }

    public struct PutApprovalResultOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The timestamp showing when the approval or rejection was submitted.
        public let approvedAt: Date?

        public init(approvedAt: Date? = nil) {
            self.approvedAt = approvedAt
        }

        public init(dictionary: [String: Any]) throws {
            self.approvedAt = dictionary["approvedAt"] as? Date
        }
    }

    public enum ActionOwner: String, CustomStringConvertible {
        case aws = "AWS"
        case thirdparty = "ThirdParty"
        case custom = "Custom"
        public var description: String { return self.rawValue }
    }

    public enum FailureType: String, CustomStringConvertible {
        case jobfailed = "JobFailed"
        case configurationerror = "ConfigurationError"
        case permissionerror = "PermissionError"
        case revisionoutofsync = "RevisionOutOfSync"
        case revisionunavailable = "RevisionUnavailable"
        case systemunavailable = "SystemUnavailable"
        public var description: String { return self.rawValue }
    }

    public struct GetPipelineInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the pipeline for which you want to get information. Pipeline names must be unique under an Amazon Web Services (AWS) user account.
        public let name: String
        /// The version number of the pipeline. If you do not specify a version, defaults to the most current version.
        public let version: Int32?

        public init(name: String, version: Int32? = nil) {
            self.name = name
            self.version = version
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
            self.version = dictionary["version"] as? Int32
        }
    }

    public struct ActionType: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The details of the input artifact for the action, such as its commit ID.
        public let inputArtifactDetails: ArtifactDetails
        public let id: ActionTypeId
        /// The configuration properties for the action type.
        public let actionConfigurationProperties: [ActionConfigurationProperty]?
        /// The settings for the action type.
        public let settings: ActionTypeSettings?
        /// The details of the output artifact of the action, such as its commit ID.
        public let outputArtifactDetails: ArtifactDetails

        public init(inputArtifactDetails: ArtifactDetails, id: ActionTypeId, actionConfigurationProperties: [ActionConfigurationProperty]? = nil, settings: ActionTypeSettings? = nil, outputArtifactDetails: ArtifactDetails) {
            self.inputArtifactDetails = inputArtifactDetails
            self.id = id
            self.actionConfigurationProperties = actionConfigurationProperties
            self.settings = settings
            self.outputArtifactDetails = outputArtifactDetails
        }

        public init(dictionary: [String: Any]) throws {
            guard let inputArtifactDetails = dictionary["inputArtifactDetails"] as? [String: Any] else { throw InitializableError.missingRequiredParam("inputArtifactDetails") }
            self.inputArtifactDetails = try Codepipeline.ArtifactDetails(dictionary: inputArtifactDetails)
            guard let id = dictionary["id"] as? [String: Any] else { throw InitializableError.missingRequiredParam("id") }
            self.id = try Codepipeline.ActionTypeId(dictionary: id)
            if let actionConfigurationProperties = dictionary["actionConfigurationProperties"] as? [[String: Any]] {
                self.actionConfigurationProperties = try actionConfigurationProperties.map({ try ActionConfigurationProperty(dictionary: $0) })
            } else { 
                self.actionConfigurationProperties = nil
            }
            if let settings = dictionary["settings"] as? [String: Any] { self.settings = try Codepipeline.ActionTypeSettings(dictionary: settings) } else { self.settings = nil }
            guard let outputArtifactDetails = dictionary["outputArtifactDetails"] as? [String: Any] else { throw InitializableError.missingRequiredParam("outputArtifactDetails") }
            self.outputArtifactDetails = try Codepipeline.ArtifactDetails(dictionary: outputArtifactDetails)
        }
    }

    public enum ArtifactLocationType: String, CustomStringConvertible {
        case s3 = "S3"
        public var description: String { return self.rawValue }
    }

    public struct GetPipelineExecutionOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Represents information about the execution of a pipeline.
        public let pipelineExecution: PipelineExecution?

        public init(pipelineExecution: PipelineExecution? = nil) {
            self.pipelineExecution = pipelineExecution
        }

        public init(dictionary: [String: Any]) throws {
            if let pipelineExecution = dictionary["pipelineExecution"] as? [String: Any] { self.pipelineExecution = try Codepipeline.PipelineExecution(dictionary: pipelineExecution) } else { self.pipelineExecution = nil }
        }
    }

    public struct ThirdPartyJobData: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let actionTypeId: ActionTypeId?
        public let actionConfiguration: ActionConfiguration?
        public let artifactCredentials: AWSSessionCredentials?
        /// The name of the artifact that will be the result of the action, if any. This name might be system-generated, such as "MyBuiltApp", or might be defined by the user when the action is created.
        public let outputArtifacts: [Artifact]?
        /// The encryption key used to encrypt and decrypt data in the artifact store for the pipeline, such as an AWS Key Management Service (AWS KMS) key. This is optional and might not be present.
        public let encryptionKey: EncryptionKey?
        /// A system-generated token, such as a AWS CodeDeploy deployment ID, that a job requires in order to continue the job asynchronously.
        public let continuationToken: String?
        /// The name of the artifact that will be worked upon by the action, if any. This name might be system-generated, such as "MyApp", or might be defined by the user when the action is created. The input artifact name must match the name of an output artifact generated by an action in an earlier action or stage of the pipeline.
        public let inputArtifacts: [Artifact]?
        public let pipelineContext: PipelineContext?

        public init(actionTypeId: ActionTypeId? = nil, actionConfiguration: ActionConfiguration? = nil, artifactCredentials: AWSSessionCredentials? = nil, outputArtifacts: [Artifact]? = nil, encryptionKey: EncryptionKey? = nil, continuationToken: String? = nil, inputArtifacts: [Artifact]? = nil, pipelineContext: PipelineContext? = nil) {
            self.actionTypeId = actionTypeId
            self.actionConfiguration = actionConfiguration
            self.artifactCredentials = artifactCredentials
            self.outputArtifacts = outputArtifacts
            self.encryptionKey = encryptionKey
            self.continuationToken = continuationToken
            self.inputArtifacts = inputArtifacts
            self.pipelineContext = pipelineContext
        }

        public init(dictionary: [String: Any]) throws {
            if let actionTypeId = dictionary["actionTypeId"] as? [String: Any] { self.actionTypeId = try Codepipeline.ActionTypeId(dictionary: actionTypeId) } else { self.actionTypeId = nil }
            if let actionConfiguration = dictionary["actionConfiguration"] as? [String: Any] { self.actionConfiguration = try Codepipeline.ActionConfiguration(dictionary: actionConfiguration) } else { self.actionConfiguration = nil }
            if let artifactCredentials = dictionary["artifactCredentials"] as? [String: Any] { self.artifactCredentials = try Codepipeline.AWSSessionCredentials(dictionary: artifactCredentials) } else { self.artifactCredentials = nil }
            if let outputArtifacts = dictionary["outputArtifacts"] as? [[String: Any]] {
                self.outputArtifacts = try outputArtifacts.map({ try Artifact(dictionary: $0) })
            } else { 
                self.outputArtifacts = nil
            }
            if let encryptionKey = dictionary["encryptionKey"] as? [String: Any] { self.encryptionKey = try Codepipeline.EncryptionKey(dictionary: encryptionKey) } else { self.encryptionKey = nil }
            self.continuationToken = dictionary["continuationToken"] as? String
            if let inputArtifacts = dictionary["inputArtifacts"] as? [[String: Any]] {
                self.inputArtifacts = try inputArtifacts.map({ try Artifact(dictionary: $0) })
            } else { 
                self.inputArtifacts = nil
            }
            if let pipelineContext = dictionary["pipelineContext"] as? [String: Any] { self.pipelineContext = try Codepipeline.PipelineContext(dictionary: pipelineContext) } else { self.pipelineContext = nil }
        }
    }

    public struct GetPipelineOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let pipeline: PipelineDeclaration?

        public init(pipeline: PipelineDeclaration? = nil) {
            self.pipeline = pipeline
        }

        public init(dictionary: [String: Any]) throws {
            if let pipeline = dictionary["pipeline"] as? [String: Any] { self.pipeline = try Codepipeline.PipelineDeclaration(dictionary: pipeline) } else { self.pipeline = nil }
        }
    }

    public struct ActionConfiguration: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The configuration data for the action.
        public let configuration: [String: String]?

        public init(configuration: [String: String]? = nil) {
            self.configuration = configuration
        }

        public init(dictionary: [String: Any]) throws {
            if let configuration = dictionary["configuration"] as? [String: String] {
                self.configuration = configuration
            } else { 
                self.configuration = nil
            }
        }
    }

    public struct CreatePipelineOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let pipeline: PipelineDeclaration?

        public init(pipeline: PipelineDeclaration? = nil) {
            self.pipeline = pipeline
        }

        public init(dictionary: [String: Any]) throws {
            if let pipeline = dictionary["pipeline"] as? [String: Any] { self.pipeline = try Codepipeline.PipelineDeclaration(dictionary: pipeline) } else { self.pipeline = nil }
        }
    }

    public struct StartPipelineExecutionOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The unique system-generated ID of the pipeline execution that was started.
        public let pipelineExecutionId: String?

        public init(pipelineExecutionId: String? = nil) {
            self.pipelineExecutionId = pipelineExecutionId
        }

        public init(dictionary: [String: Any]) throws {
            self.pipelineExecutionId = dictionary["pipelineExecutionId"] as? String
        }
    }

    public enum ActionConfigurationPropertyType: String, CustomStringConvertible {
        case string = "String"
        case number = "Number"
        case boolean = "Boolean"
        public var description: String { return self.rawValue }
    }

    public struct GetPipelineStateInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the pipeline about which you want to get information.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
        }
    }

    public struct ActionTypeSettings: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The URL returned to the AWS CodePipeline console that contains a link to the page where customers can update or change the configuration of the external action.
        public let revisionUrlTemplate: String?
        /// The URL of a sign-up page where users can sign up for an external service and perform initial configuration of the action provided by that service.
        public let thirdPartyConfigurationUrl: String?
        /// The URL returned to the AWS CodePipeline console that contains a link to the top-level landing page for the external system, such as console page for AWS CodeDeploy. This link is shown on the pipeline view page in the AWS CodePipeline console and provides a link to the execution entity of the external action.
        public let executionUrlTemplate: String?
        /// The URL returned to the AWS CodePipeline console that provides a deep link to the resources of the external system, such as the configuration page for an AWS CodeDeploy deployment group. This link is provided as part of the action display within the pipeline.
        public let entityUrlTemplate: String?

        public init(revisionUrlTemplate: String? = nil, thirdPartyConfigurationUrl: String? = nil, executionUrlTemplate: String? = nil, entityUrlTemplate: String? = nil) {
            self.revisionUrlTemplate = revisionUrlTemplate
            self.thirdPartyConfigurationUrl = thirdPartyConfigurationUrl
            self.executionUrlTemplate = executionUrlTemplate
            self.entityUrlTemplate = entityUrlTemplate
        }

        public init(dictionary: [String: Any]) throws {
            self.revisionUrlTemplate = dictionary["revisionUrlTemplate"] as? String
            self.thirdPartyConfigurationUrl = dictionary["thirdPartyConfigurationUrl"] as? String
            self.executionUrlTemplate = dictionary["executionUrlTemplate"] as? String
            self.entityUrlTemplate = dictionary["entityUrlTemplate"] as? String
        }
    }

    public struct AcknowledgeThirdPartyJobOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The status information for the third party job, if any.
        public let status: JobStatus?

        public init(status: JobStatus? = nil) {
            self.status = status
        }

        public init(dictionary: [String: Any]) throws {
            if let status = dictionary["status"] as? String { self.status = JobStatus(rawValue: status) } else { self.status = nil }
        }
    }

    public struct CreateCustomActionTypeInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let inputArtifactDetails: ArtifactDetails
        public let settings: ActionTypeSettings?
        public let outputArtifactDetails: ArtifactDetails
        /// The configuration properties for the custom action.  You can refer to a name in the configuration properties of the custom action within the URL templates by following the format of {Config:name}, as long as the configuration property is both required and not secret. For more information, see Create a Custom Action for a Pipeline. 
        public let configurationProperties: [ActionConfigurationProperty]?
        /// The version identifier of the custom action.
        public let version: String
        /// The provider of the service used in the custom action, such as AWS CodeDeploy.
        public let provider: String
        /// The category of the custom action, such as a build action or a test action.  Although Source and Approval are listed as valid values, they are not currently functional. These values are reserved for future use. 
        public let category: ActionCategory

        public init(inputArtifactDetails: ArtifactDetails, settings: ActionTypeSettings? = nil, outputArtifactDetails: ArtifactDetails, configurationProperties: [ActionConfigurationProperty]? = nil, version: String, provider: String, category: ActionCategory) {
            self.inputArtifactDetails = inputArtifactDetails
            self.settings = settings
            self.outputArtifactDetails = outputArtifactDetails
            self.configurationProperties = configurationProperties
            self.version = version
            self.provider = provider
            self.category = category
        }

        public init(dictionary: [String: Any]) throws {
            guard let inputArtifactDetails = dictionary["inputArtifactDetails"] as? [String: Any] else { throw InitializableError.missingRequiredParam("inputArtifactDetails") }
            self.inputArtifactDetails = try Codepipeline.ArtifactDetails(dictionary: inputArtifactDetails)
            if let settings = dictionary["settings"] as? [String: Any] { self.settings = try Codepipeline.ActionTypeSettings(dictionary: settings) } else { self.settings = nil }
            guard let outputArtifactDetails = dictionary["outputArtifactDetails"] as? [String: Any] else { throw InitializableError.missingRequiredParam("outputArtifactDetails") }
            self.outputArtifactDetails = try Codepipeline.ArtifactDetails(dictionary: outputArtifactDetails)
            if let configurationProperties = dictionary["configurationProperties"] as? [[String: Any]] {
                self.configurationProperties = try configurationProperties.map({ try ActionConfigurationProperty(dictionary: $0) })
            } else { 
                self.configurationProperties = nil
            }
            guard let version = dictionary["version"] as? String else { throw InitializableError.missingRequiredParam("version") }
            self.version = version
            guard let provider = dictionary["provider"] as? String else { throw InitializableError.missingRequiredParam("provider") }
            self.provider = provider
            guard let rawcategory = dictionary["category"] as? String, let category = ActionCategory(rawValue: rawcategory) else { throw InitializableError.missingRequiredParam("category") }
            self.category = category
        }
    }

    public struct ApprovalResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The summary of the current status of the approval request.
        public let summary: String
        /// The response submitted by a reviewer assigned to an approval action request.
        public let status: ApprovalStatus

        public init(summary: String, status: ApprovalStatus) {
            self.summary = summary
            self.status = status
        }

        public init(dictionary: [String: Any]) throws {
            guard let summary = dictionary["summary"] as? String else { throw InitializableError.missingRequiredParam("summary") }
            self.summary = summary
            guard let rawstatus = dictionary["status"] as? String, let status = ApprovalStatus(rawValue: rawstatus) else { throw InitializableError.missingRequiredParam("status") }
            self.status = status
        }
    }

    public struct BlockerDeclaration: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Reserved for future use.
        public let `type`: BlockerType
        /// Reserved for future use.
        public let name: String

        public init(type: BlockerType, name: String) {
            self.`type` = `type`
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            guard let rawtype = dictionary["type"] as? String, let `type` = BlockerType(rawValue: rawtype) else { throw InitializableError.missingRequiredParam("type") }
            self.`type` = `type`
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
        }
    }

    public enum ActionExecutionStatus: String, CustomStringConvertible {
        case inprogress = "InProgress"
        case succeeded = "Succeeded"
        case failed = "Failed"
        public var description: String { return self.rawValue }
    }

    public struct ListActionTypesInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous list action types call, which can be used to return the next set of action types in the list.
        public let nextToken: String?
        /// Filters the list of action types to those created by a specified entity.
        public let actionOwnerFilter: ActionOwner?

        public init(nextToken: String? = nil, actionOwnerFilter: ActionOwner? = nil) {
            self.nextToken = nextToken
            self.actionOwnerFilter = actionOwnerFilter
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            if let actionOwnerFilter = dictionary["actionOwnerFilter"] as? String { self.actionOwnerFilter = ActionOwner(rawValue: actionOwnerFilter) } else { self.actionOwnerFilter = nil }
        }
    }

    public struct CreatePipelineInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let pipeline: PipelineDeclaration

        public init(pipeline: PipelineDeclaration) {
            self.pipeline = pipeline
        }

        public init(dictionary: [String: Any]) throws {
            guard let pipeline = dictionary["pipeline"] as? [String: Any] else { throw InitializableError.missingRequiredParam("pipeline") }
            self.pipeline = try Codepipeline.PipelineDeclaration(dictionary: pipeline)
        }
    }

    public struct UpdatePipelineInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the pipeline to be updated.
        public let pipeline: PipelineDeclaration

        public init(pipeline: PipelineDeclaration) {
            self.pipeline = pipeline
        }

        public init(dictionary: [String: Any]) throws {
            guard let pipeline = dictionary["pipeline"] as? [String: Any] else { throw InitializableError.missingRequiredParam("pipeline") }
            self.pipeline = try Codepipeline.PipelineDeclaration(dictionary: pipeline)
        }
    }

    public struct Job: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the AWS account to use when performing the job.
        public let accountId: String?
        /// Additional data about a job.
        public let data: JobData?
        /// The unique system-generated ID of the job.
        public let id: String?
        /// A system-generated random number that AWS CodePipeline uses to ensure that the job is being worked on by only one job worker. Use this number in an AcknowledgeJob request.
        public let nonce: String?

        public init(accountId: String? = nil, data: JobData? = nil, id: String? = nil, nonce: String? = nil) {
            self.accountId = accountId
            self.data = data
            self.id = id
            self.nonce = nonce
        }

        public init(dictionary: [String: Any]) throws {
            self.accountId = dictionary["accountId"] as? String
            if let data = dictionary["data"] as? [String: Any] { self.data = try Codepipeline.JobData(dictionary: data) } else { self.data = nil }
            self.id = dictionary["id"] as? String
            self.nonce = dictionary["nonce"] as? String
        }
    }

    public struct UpdatePipelineOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The structure of the updated pipeline.
        public let pipeline: PipelineDeclaration?

        public init(pipeline: PipelineDeclaration? = nil) {
            self.pipeline = pipeline
        }

        public init(dictionary: [String: Any]) throws {
            if let pipeline = dictionary["pipeline"] as? [String: Any] { self.pipeline = try Codepipeline.PipelineDeclaration(dictionary: pipeline) } else { self.pipeline = nil }
        }
    }

    public struct ExecutionDetails: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The summary of the current status of the actions.
        public let summary: String?
        /// The percentage of work completed on the action, represented on a scale of zero to one hundred percent.
        public let percentComplete: Int32?
        /// The system-generated unique ID of this action used to identify this job worker in any external systems, such as AWS CodeDeploy.
        public let externalExecutionId: String?

        public init(summary: String? = nil, percentComplete: Int32? = nil, externalExecutionId: String? = nil) {
            self.summary = summary
            self.percentComplete = percentComplete
            self.externalExecutionId = externalExecutionId
        }

        public init(dictionary: [String: Any]) throws {
            self.summary = dictionary["summary"] as? String
            self.percentComplete = dictionary["percentComplete"] as? Int32
            self.externalExecutionId = dictionary["externalExecutionId"] as? String
        }
    }

    public struct GetThirdPartyJobDetailsOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The details of the job, including any protected values defined for the job.
        public let jobDetails: ThirdPartyJobDetails?

        public init(jobDetails: ThirdPartyJobDetails? = nil) {
            self.jobDetails = jobDetails
        }

        public init(dictionary: [String: Any]) throws {
            if let jobDetails = dictionary["jobDetails"] as? [String: Any] { self.jobDetails = try Codepipeline.ThirdPartyJobDetails(dictionary: jobDetails) } else { self.jobDetails = nil }
        }
    }

    public struct AcknowledgeThirdPartyJobInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A system-generated random number that AWS CodePipeline uses to ensure that the job is being worked on by only one job worker. Get this number from the response to a GetThirdPartyJobDetails request.
        public let nonce: String
        /// The unique system-generated ID of the job.
        public let jobId: String
        /// The clientToken portion of the clientId and clientToken pair used to verify that the calling entity is allowed access to the job and its details.
        public let clientToken: String

        public init(nonce: String, jobId: String, clientToken: String) {
            self.nonce = nonce
            self.jobId = jobId
            self.clientToken = clientToken
        }

        public init(dictionary: [String: Any]) throws {
            guard let nonce = dictionary["nonce"] as? String else { throw InitializableError.missingRequiredParam("nonce") }
            self.nonce = nonce
            guard let jobId = dictionary["jobId"] as? String else { throw InitializableError.missingRequiredParam("jobId") }
            self.jobId = jobId
            guard let clientToken = dictionary["clientToken"] as? String else { throw InitializableError.missingRequiredParam("clientToken") }
            self.clientToken = clientToken
        }
    }

    public struct ListPipelinesOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// If the amount of returned information is significantly large, an identifier is also returned which can be used in a subsequent list pipelines call to return the next set of pipelines in the list.
        public let nextToken: String?
        /// The list of pipelines.
        public let pipelines: [PipelineSummary]?

        public init(nextToken: String? = nil, pipelines: [PipelineSummary]? = nil) {
            self.nextToken = nextToken
            self.pipelines = pipelines
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            if let pipelines = dictionary["pipelines"] as? [[String: Any]] {
                self.pipelines = try pipelines.map({ try PipelineSummary(dictionary: $0) })
            } else { 
                self.pipelines = nil
            }
        }
    }

    public enum ArtifactStoreType: String, CustomStringConvertible {
        case s3 = "S3"
        public var description: String { return self.rawValue }
    }

}