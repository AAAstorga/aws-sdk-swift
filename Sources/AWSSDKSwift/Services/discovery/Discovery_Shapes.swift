// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Discovery {

    public struct DisassociateConfigurationItemsFromApplicationRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Configuration ID of an application from which each item will be disassociated.
        public let applicationConfigurationId: String
        /// Configuration ID of each item be be disassociated from an application.
        public let configurationIds: [String]

        public init(applicationConfigurationId: String, configurationIds: [String]) {
            self.applicationConfigurationId = applicationConfigurationId
            self.configurationIds = configurationIds
        }

        public init(dictionary: [String: Any]) throws {
            guard let applicationConfigurationId = dictionary["applicationConfigurationId"] as? String else { throw InitializableError.missingRequiredParam("applicationConfigurationId") }
            self.applicationConfigurationId = applicationConfigurationId
            guard let configurationIds = dictionary["configurationIds"] as? [String] else { throw InitializableError.missingRequiredParam("configurationIds") }
            self.configurationIds = configurationIds
        }
    }

    public struct DescribeTagsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Depending on the input, this is a list of configuration items tagged with a specific tag, or a list of tags for a specific configuration item.
        public let tags: ConfigurationTagSet?
        /// The call returns a token. Use this token to get the next set of results.
        public let nextToken: String?

        public init(tags: ConfigurationTagSet? = nil, nextToken: String? = nil) {
            self.tags = tags
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let tags = dictionary["tags"] as? [String: Any] { self.tags = try Discovery.ConfigurationTagSet(dictionary: tags) } else { self.tags = nil }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct CreateTagsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Tags that you want to associate with one or more configuration items. Specify the tags that you want to create in a key-value format. For example:  {"key": "serverType", "value": "webServer"} 
        public let tags: TagSet
        /// A list of configuration items that you want to tag.
        public let configurationIds: [String]

        public init(tags: TagSet, configurationIds: [String]) {
            self.tags = tags
            self.configurationIds = configurationIds
        }

        public init(dictionary: [String: Any]) throws {
            guard let tags = dictionary["tags"] as? [String: Any] else { throw InitializableError.missingRequiredParam("tags") }
            self.tags = try Discovery.TagSet(dictionary: tags)
            guard let configurationIds = dictionary["configurationIds"] as? [String] else { throw InitializableError.missingRequiredParam("configurationIds") }
            self.configurationIds = configurationIds
        }
    }

    public struct DeleteTagsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct FilterValues: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [String]?

        public init(item: [String]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            self.item = dictionary["Item"] as? [String]
        }
    }

    public struct UpdateApplicationResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ListConfigurationsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A valid configuration identified by the Discovery Service. 
        public let configurationType: ConfigurationItemType
        /// The total number of items to return. The maximum value is 100.
        public let maxResults: Int32?
        /// Token to retrieve the next set of results. For example, if a previous call to ListConfigurations returned 100 items, but you set ListConfigurationsRequest$maxResults to 10, you received a set of 10 results along with a token. Use that token in this query to get the next set of 10.
        public let nextToken: String?
        /// You can filter the request using various logical operators and a key-value format. For example:   {"key": "serverType", "value": "webServer"}  For a complete list of filter options and guidance about using them with this action, see Querying Discovered Configuration Items. 
        public let filters: [Filter]?
        /// Certain filter criteria return output that can be sorted in ascending or descending order. For a list of output characteristics for each filter, see Querying Discovered Configuration Items.
        public let orderBy: [OrderByElement]?

        public init(configurationType: ConfigurationItemType, maxResults: Int32? = nil, nextToken: String? = nil, filters: [Filter]? = nil, orderBy: [OrderByElement]? = nil) {
            self.configurationType = configurationType
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.filters = filters
            self.orderBy = orderBy
        }

        public init(dictionary: [String: Any]) throws {
            guard let rawconfigurationType = dictionary["configurationType"] as? String, let configurationType = ConfigurationItemType(rawValue: rawconfigurationType) else { throw InitializableError.missingRequiredParam("configurationType") }
            self.configurationType = configurationType
            self.maxResults = dictionary["maxResults"] as? Int32
            self.nextToken = dictionary["nextToken"] as? String
            if let filters = dictionary["filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            } else { 
                self.filters = nil
            }
            if let orderBy = dictionary["orderBy"] as? [[String: Any]] {
                self.orderBy = try orderBy.map({ try OrderByElement(dictionary: $0) })
            } else { 
                self.orderBy = nil
            }
        }
    }

    public struct TagSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [Tag]?

        public init(item: [Tag]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try Tag(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct OrderByElement: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Field to order on.
        public let fieldName: String
        /// Ordering direction.
        public let sortOrder: OrderString?

        public init(fieldName: String, sortOrder: OrderString? = nil) {
            self.fieldName = fieldName
            self.sortOrder = sortOrder
        }

        public init(dictionary: [String: Any]) throws {
            guard let fieldName = dictionary["fieldName"] as? String else { throw InitializableError.missingRequiredParam("fieldName") }
            self.fieldName = fieldName
            if let sortOrder = dictionary["sortOrder"] as? String { self.sortOrder = OrderString(rawValue: sortOrder) } else { self.sortOrder = nil }
        }
    }

    public struct AgentInfo: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The health of the agent or connector.
        public let health: AgentStatus?
        /// Network details about the host where the agent or connector resides.
        public let agentNetworkInfoList: [AgentNetworkInfo]?
        /// Time since agent or connector health was reported.
        public let lastHealthPingTime: String?
        /// Type of agent.
        public let agentType: String?
        /// Status of the collection process for an agent or connector.
        public let collectionStatus: String?
        /// The agent or connector version.
        public let version: String?
        /// The ID of the connector.
        public let connectorId: String?
        /// The agent or connector ID.
        public let agentId: String?
        /// Agent's first registration time stamp in UTC.
        public let registeredTime: String?
        /// The name of the host where the agent or connector resides. The host can be a server or virtual machine.
        public let hostName: String?

        public init(health: AgentStatus? = nil, agentNetworkInfoList: [AgentNetworkInfo]? = nil, lastHealthPingTime: String? = nil, agentType: String? = nil, collectionStatus: String? = nil, version: String? = nil, connectorId: String? = nil, agentId: String? = nil, registeredTime: String? = nil, hostName: String? = nil) {
            self.health = health
            self.agentNetworkInfoList = agentNetworkInfoList
            self.lastHealthPingTime = lastHealthPingTime
            self.agentType = agentType
            self.collectionStatus = collectionStatus
            self.version = version
            self.connectorId = connectorId
            self.agentId = agentId
            self.registeredTime = registeredTime
            self.hostName = hostName
        }

        public init(dictionary: [String: Any]) throws {
            if let health = dictionary["health"] as? String { self.health = AgentStatus(rawValue: health) } else { self.health = nil }
            if let agentNetworkInfoList = dictionary["agentNetworkInfoList"] as? [[String: Any]] {
                self.agentNetworkInfoList = try agentNetworkInfoList.map({ try AgentNetworkInfo(dictionary: $0) })
            } else { 
                self.agentNetworkInfoList = nil
            }
            self.lastHealthPingTime = dictionary["lastHealthPingTime"] as? String
            self.agentType = dictionary["agentType"] as? String
            self.collectionStatus = dictionary["collectionStatus"] as? String
            self.version = dictionary["version"] as? String
            self.connectorId = dictionary["connectorId"] as? String
            self.agentId = dictionary["agentId"] as? String
            self.registeredTime = dictionary["registeredTime"] as? String
            self.hostName = dictionary["hostName"] as? String
        }
    }

    public enum ExportStatus: String, CustomStringConvertible {
        case failed = "FAILED"
        case succeeded = "SUCCEEDED"
        case in_progress = "IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public struct GetDiscoverySummaryResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Number of servers mapped to tags.
        public let serversMappedtoTags: Int64?
        /// Number of applications discovered.
        public let applications: Int64?
        /// Details about discovered connectors, including connector status and health.
        public let connectorSummary: CustomerConnectorInfo?
        /// Details about discovered agents, including agent status and health.
        public let agentSummary: CustomerAgentInfo?
        /// Number of servers discovered.
        public let servers: Int64?
        /// Number of servers mapped to applications.
        public let serversMappedToApplications: Int64?

        public init(serversMappedtoTags: Int64? = nil, applications: Int64? = nil, connectorSummary: CustomerConnectorInfo? = nil, agentSummary: CustomerAgentInfo? = nil, servers: Int64? = nil, serversMappedToApplications: Int64? = nil) {
            self.serversMappedtoTags = serversMappedtoTags
            self.applications = applications
            self.connectorSummary = connectorSummary
            self.agentSummary = agentSummary
            self.servers = servers
            self.serversMappedToApplications = serversMappedToApplications
        }

        public init(dictionary: [String: Any]) throws {
            self.serversMappedtoTags = dictionary["serversMappedtoTags"] as? Int64
            self.applications = dictionary["applications"] as? Int64
            if let connectorSummary = dictionary["connectorSummary"] as? [String: Any] { self.connectorSummary = try Discovery.CustomerConnectorInfo(dictionary: connectorSummary) } else { self.connectorSummary = nil }
            if let agentSummary = dictionary["agentSummary"] as? [String: Any] { self.agentSummary = try Discovery.CustomerAgentInfo(dictionary: agentSummary) } else { self.agentSummary = nil }
            self.servers = dictionary["servers"] as? Int64
            self.serversMappedToApplications = dictionary["serversMappedToApplications"] as? Int64
        }
    }

    public struct DescribeExportConfigurationsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A unique identifier that you can use to query the export status.
        public let exportIds: [String]?
        /// A token to get the next set of results. For example, if you specified 100 IDs for DescribeExportConfigurationsRequest$exportIds but set DescribeExportConfigurationsRequest$maxResults to 10, you will get results in a set of 10. Use the token in the query to get the next set of 10.
        public let nextToken: String?
        /// The maximum number of results that you want to display as a part of the query.
        public let maxResults: Int32?

        public init(exportIds: [String]? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.exportIds = exportIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.exportIds = dictionary["exportIds"] as? [String]
            self.nextToken = dictionary["nextToken"] as? String
            self.maxResults = dictionary["maxResults"] as? Int32
        }
    }

    public struct ConfigurationTag: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The time the configuration tag was created in Coordinated Universal Time (UTC).
        public let timeOfCreation: Date?
        /// A type of IT asset that you want to tag.
        public let configurationType: ConfigurationItemType?
        /// A value to filter on. For example key = serverType and value = web server.
        public let value: String?
        /// A type of tag to filter on. For example, serverType.
        public let key: String?
        /// The configuration ID for the item you want to tag. You can specify a list of keys and values.
        public let configurationId: String?

        public init(timeOfCreation: Date? = nil, configurationType: ConfigurationItemType? = nil, value: String? = nil, key: String? = nil, configurationId: String? = nil) {
            self.timeOfCreation = timeOfCreation
            self.configurationType = configurationType
            self.value = value
            self.key = key
            self.configurationId = configurationId
        }

        public init(dictionary: [String: Any]) throws {
            self.timeOfCreation = dictionary["timeOfCreation"] as? Date
            if let configurationType = dictionary["configurationType"] as? String { self.configurationType = ConfigurationItemType(rawValue: configurationType) } else { self.configurationType = nil }
            self.value = dictionary["value"] as? String
            self.key = dictionary["key"] as? String
            self.configurationId = dictionary["configurationId"] as? String
        }
    }

    public struct ListConfigurationsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Returns configuration details, including the configuration ID, attribute names, and attribute values.
        public let configurations: [[String: String]]?
        /// Token to retrieve the next set of results. For example, if your call to ListConfigurations returned 100 items, but you set ListConfigurationsRequest$maxResults to 10, you received a set of 10 results along with this token. Use this token in the next query to retrieve the next set of 10.
        public let nextToken: String?

        public init(configurations: [[String: String]]? = nil, nextToken: String? = nil) {
            self.configurations = configurations
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            self.configurations = dictionary["configurations"] as? [[String: String]]
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct AgentConfigurationStatus: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A description of the operation performed.
        public let description: String?
        /// The agent/Connector ID.
        public let agentId: String?
        /// Information about the status of the StartDataCollection and StopDataCollection operations. The system has recorded the data collection operation. The agent/Connector receives this command the next time it polls for a new command. 
        public let operationSucceeded: Bool?

        public init(description: String? = nil, agentId: String? = nil, operationSucceeded: Bool? = nil) {
            self.description = description
            self.agentId = agentId
            self.operationSucceeded = operationSucceeded
        }

        public init(dictionary: [String: Any]) throws {
            self.description = dictionary["description"] as? String
            self.agentId = dictionary["agentId"] as? String
            self.operationSucceeded = dictionary["operationSucceeded"] as? Bool
        }
    }

    public struct DeleteApplicationsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Configuration ID of an application to be deleted.
        public let configurationIds: [String]

        public init(configurationIds: [String]) {
            self.configurationIds = configurationIds
        }

        public init(dictionary: [String: Any]) throws {
            guard let configurationIds = dictionary["configurationIds"] as? [String] else { throw InitializableError.missingRequiredParam("configurationIds") }
            self.configurationIds = configurationIds
        }
    }

    public struct CustomerConnectorInfo: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Number of unhealthy discovery connectors.
        public let unhealthyConnectors: Int32
        /// Number of healthy discovery connectors.
        public let healthyConnectors: Int32
        /// Number of active discovery connectors.
        public let activeConnectors: Int32
        /// Total number of discovery connectors.
        public let totalConnectors: Int32
        /// Number of discovery connectors with status SHUTDOWN,
        public let shutdownConnectors: Int32
        /// Number of unknown discovery connectors.
        public let unknownConnectors: Int32
        /// Number of blacklisted discovery connectors.
        public let blackListedConnectors: Int32

        public init(unhealthyConnectors: Int32, healthyConnectors: Int32, activeConnectors: Int32, totalConnectors: Int32, shutdownConnectors: Int32, unknownConnectors: Int32, blackListedConnectors: Int32) {
            self.unhealthyConnectors = unhealthyConnectors
            self.healthyConnectors = healthyConnectors
            self.activeConnectors = activeConnectors
            self.totalConnectors = totalConnectors
            self.shutdownConnectors = shutdownConnectors
            self.unknownConnectors = unknownConnectors
            self.blackListedConnectors = blackListedConnectors
        }

        public init(dictionary: [String: Any]) throws {
            guard let unhealthyConnectors = dictionary["unhealthyConnectors"] as? Int32 else { throw InitializableError.missingRequiredParam("unhealthyConnectors") }
            self.unhealthyConnectors = unhealthyConnectors
            guard let healthyConnectors = dictionary["healthyConnectors"] as? Int32 else { throw InitializableError.missingRequiredParam("healthyConnectors") }
            self.healthyConnectors = healthyConnectors
            guard let activeConnectors = dictionary["activeConnectors"] as? Int32 else { throw InitializableError.missingRequiredParam("activeConnectors") }
            self.activeConnectors = activeConnectors
            guard let totalConnectors = dictionary["totalConnectors"] as? Int32 else { throw InitializableError.missingRequiredParam("totalConnectors") }
            self.totalConnectors = totalConnectors
            guard let shutdownConnectors = dictionary["shutdownConnectors"] as? Int32 else { throw InitializableError.missingRequiredParam("shutdownConnectors") }
            self.shutdownConnectors = shutdownConnectors
            guard let unknownConnectors = dictionary["unknownConnectors"] as? Int32 else { throw InitializableError.missingRequiredParam("unknownConnectors") }
            self.unknownConnectors = unknownConnectors
            guard let blackListedConnectors = dictionary["blackListedConnectors"] as? Int32 else { throw InitializableError.missingRequiredParam("blackListedConnectors") }
            self.blackListedConnectors = blackListedConnectors
        }
    }

    public struct NeighborConnectionDetail: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// ID of the server that accepted the networker connection.
        public let destinationServerId: String
        /// Network protocol used for the connection.
        public let transportProtocol: String?
        /// Number of open network connections with the neighboring server.
        public let connectionsCount: Int64
        /// Destination network port for the connection.
        public let destinationPort: Int32?
        /// ID of server that opened the network connection.
        public let sourceServerId: String

        public init(destinationServerId: String, transportProtocol: String? = nil, connectionsCount: Int64, destinationPort: Int32? = nil, sourceServerId: String) {
            self.destinationServerId = destinationServerId
            self.transportProtocol = transportProtocol
            self.connectionsCount = connectionsCount
            self.destinationPort = destinationPort
            self.sourceServerId = sourceServerId
        }

        public init(dictionary: [String: Any]) throws {
            guard let destinationServerId = dictionary["destinationServerId"] as? String else { throw InitializableError.missingRequiredParam("destinationServerId") }
            self.destinationServerId = destinationServerId
            self.transportProtocol = dictionary["transportProtocol"] as? String
            guard let connectionsCount = dictionary["connectionsCount"] as? Int64 else { throw InitializableError.missingRequiredParam("connectionsCount") }
            self.connectionsCount = connectionsCount
            self.destinationPort = dictionary["destinationPort"] as? Int32
            guard let sourceServerId = dictionary["sourceServerId"] as? String else { throw InitializableError.missingRequiredParam("sourceServerId") }
            self.sourceServerId = sourceServerId
        }
    }

    public struct StopDataCollectionByAgentIdsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IDs of the agents or Connectors that you want to stop collecting data.
        public let agentIds: [String]

        public init(agentIds: [String]) {
            self.agentIds = agentIds
        }

        public init(dictionary: [String: Any]) throws {
            guard let agentIds = dictionary["agentIds"] as? [String] else { throw InitializableError.missingRequiredParam("agentIds") }
            self.agentIds = agentIds
        }
    }

    public enum ConfigurationItemType: String, CustomStringConvertible {
        case server = "SERVER"
        case process = "PROCESS"
        case connection = "CONNECTION"
        case application = "APPLICATION"
        public var description: String { return self.rawValue }
    }

    public struct DescribeTagsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// You can filter the list using a key-value format. You can separate these items by using logical operators. Allowed filters include tagKey, tagValue, and configurationId.  For a complete list of filter options and guidance about using them with this action, see Managing AWS Application Discovery Service Agents and the AWS Application Discovery Connector .
        public let filters: [TagFilter]?
        /// The total number of items to return in a single page of output. The maximum value is 100.
        public let maxResults: Int32?
        /// A token to start the list. Use this token to get the next set of results.
        public let nextToken: String?

        public init(filters: [TagFilter]? = nil, maxResults: Int32? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let filters = dictionary["filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try TagFilter(dictionary: $0) })
            } else { 
                self.filters = nil
            }
            self.maxResults = dictionary["maxResults"] as? Int32
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct DeleteTagsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Tags that you want to delete from one or more configuration items. Specify the tags that you want to delete in a key-value format. For example:  {"key": "serverType", "value": "webServer"} 
        public let tags: TagSet?
        /// A list of configuration items with tags that you want to delete.
        public let configurationIds: [String]

        public init(tags: TagSet? = nil, configurationIds: [String]) {
            self.tags = tags
            self.configurationIds = configurationIds
        }

        public init(dictionary: [String: Any]) throws {
            if let tags = dictionary["tags"] as? [String: Any] { self.tags = try Discovery.TagSet(dictionary: tags) } else { self.tags = nil }
            guard let configurationIds = dictionary["configurationIds"] as? [String] else { throw InitializableError.missingRequiredParam("configurationIds") }
            self.configurationIds = configurationIds
        }
    }

    public struct DescribeConfigurationsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more configuration IDs.
        public let configurationIds: [String]

        public init(configurationIds: [String]) {
            self.configurationIds = configurationIds
        }

        public init(dictionary: [String: Any]) throws {
            guard let configurationIds = dictionary["configurationIds"] as? [String] else { throw InitializableError.missingRequiredParam("configurationIds") }
            self.configurationIds = configurationIds
        }
    }

    public struct ListServerNeighborsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// List of distinct servers that are one hop away from the given server.
        public let neighbors: [NeighborConnectionDetail]
        /// Token to retrieve the next set of results. For example, if you specified 100 IDs for ListServerNeighborsRequest$neighborConfigurationIds but set ListServerNeighborsRequest$maxResults to 10, you received a set of 10 results along with this token. Use this token in the next query to retrieve the next set of 10.
        public let nextToken: String?
        /// Count of distinct servers that are one hop away from the given server.
        public let knownDependencyCount: Int64?

        public init(neighbors: [NeighborConnectionDetail], nextToken: String? = nil, knownDependencyCount: Int64? = nil) {
            self.neighbors = neighbors
            self.nextToken = nextToken
            self.knownDependencyCount = knownDependencyCount
        }

        public init(dictionary: [String: Any]) throws {
            guard let neighbors = dictionary["neighbors"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("neighbors") }
            self.neighbors = try neighbors.map({ try NeighborConnectionDetail(dictionary: $0) })
            self.nextToken = dictionary["nextToken"] as? String
            self.knownDependencyCount = dictionary["knownDependencyCount"] as? Int64
        }
    }

    public enum AgentStatus: String, CustomStringConvertible {
        case healthy = "HEALTHY"
        case unhealthy = "UNHEALTHY"
        case running = "RUNNING"
        case unknown = "UNKNOWN"
        case blacklisted = "BLACKLISTED"
        case shutdown = "SHUTDOWN"
        public var description: String { return self.rawValue }
    }

    public struct AssociateConfigurationItemsToApplicationResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct DescribeExportConfigurationsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A token to get the next set of results. For example, if you specified 100 IDs for DescribeExportConfigurationsRequest$exportIds but set DescribeExportConfigurationsRequest$maxResults to 10, you will get results in a set of 10. Use the token in the query to get the next set of 10.
        public let nextToken: String?
        /// Returns export details. When the status is complete, the response includes a URL for an Amazon S3 bucket where you can view the data in a CSV file.
        public let exportsInfo: [ExportInfo]?

        public init(nextToken: String? = nil, exportsInfo: [ExportInfo]? = nil) {
            self.nextToken = nextToken
            self.exportsInfo = exportsInfo
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            if let exportsInfo = dictionary["exportsInfo"] as? [[String: Any]] {
                self.exportsInfo = try exportsInfo.map({ try ExportInfo(dictionary: $0) })
            } else { 
                self.exportsInfo = nil
            }
        }
    }

    public struct StopDataCollectionByAgentIdsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about agents or the Connector that were instructed to stop collecting data. Information includes the agent/Connector ID, a description of the operation performed, and whether or not the agent/Connector configuration was updated.
        public let agentsConfigurationStatus: [AgentConfigurationStatus]?

        public init(agentsConfigurationStatus: [AgentConfigurationStatus]? = nil) {
            self.agentsConfigurationStatus = agentsConfigurationStatus
        }

        public init(dictionary: [String: Any]) throws {
            if let agentsConfigurationStatus = dictionary["agentsConfigurationStatus"] as? [[String: Any]] {
                self.agentsConfigurationStatus = try agentsConfigurationStatus.map({ try AgentConfigurationStatus(dictionary: $0) })
            } else { 
                self.agentsConfigurationStatus = nil
            }
        }
    }

    public struct StartDataCollectionByAgentIdsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about agents or the Connector that were instructed to start collecting data. Information includes the agent/Connector ID, a description of the operation performed, and whether or not the agent/Connector configuration was updated.
        public let agentsConfigurationStatus: [AgentConfigurationStatus]?

        public init(agentsConfigurationStatus: [AgentConfigurationStatus]? = nil) {
            self.agentsConfigurationStatus = agentsConfigurationStatus
        }

        public init(dictionary: [String: Any]) throws {
            if let agentsConfigurationStatus = dictionary["agentsConfigurationStatus"] as? [[String: Any]] {
                self.agentsConfigurationStatus = try agentsConfigurationStatus.map({ try AgentConfigurationStatus(dictionary: $0) })
            } else { 
                self.agentsConfigurationStatus = nil
            }
        }
    }

    public struct CreateApplicationResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Configuration ID of an application to be created.
        public let configurationId: String?

        public init(configurationId: String? = nil) {
            self.configurationId = configurationId
        }

        public init(dictionary: [String: Any]) throws {
            self.configurationId = dictionary["configurationId"] as? String
        }
    }

    public enum OrderString: String, CustomStringConvertible {
        case asc = "ASC"
        case desc = "DESC"
        public var description: String { return self.rawValue }
    }

    public struct TagFilter: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A name of a tag filter.
        public let name: String
        /// Values of a tag filter.
        public let values: FilterValues

        public init(name: String, values: FilterValues) {
            self.name = name
            self.values = values
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
            guard let values = dictionary["values"] as? [String: Any] else { throw InitializableError.missingRequiredParam("values") }
            self.values = try Discovery.FilterValues(dictionary: values)
        }
    }

    public struct AssociateConfigurationItemsToApplicationRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The configuration ID of an application with which items are to be associated.
        public let applicationConfigurationId: String
        /// The ID of each configuration item to be associated with an application.
        public let configurationIds: [String]

        public init(applicationConfigurationId: String, configurationIds: [String]) {
            self.applicationConfigurationId = applicationConfigurationId
            self.configurationIds = configurationIds
        }

        public init(dictionary: [String: Any]) throws {
            guard let applicationConfigurationId = dictionary["applicationConfigurationId"] as? String else { throw InitializableError.missingRequiredParam("applicationConfigurationId") }
            self.applicationConfigurationId = applicationConfigurationId
            guard let configurationIds = dictionary["configurationIds"] as? [String] else { throw InitializableError.missingRequiredParam("configurationIds") }
            self.configurationIds = configurationIds
        }
    }

    public struct Tag: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A type of tag to filter on.
        public let key: String
        /// A value for a tag key to filter on.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public init(dictionary: [String: Any]) throws {
            guard let key = dictionary["key"] as? String else { throw InitializableError.missingRequiredParam("key") }
            self.key = key
            guard let value = dictionary["value"] as? String else { throw InitializableError.missingRequiredParam("value") }
            self.value = value
        }
    }

    public struct DeleteApplicationsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ExportInfo: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A unique identifier that you can use to query the export.
        public let exportId: String
        /// The status of the configuration data export. The status can succeed, fail, or be in-progress.
        public let exportStatus: ExportStatus
        /// A URL for an Amazon S3 bucket where you can review the configuration data. The URL is displayed only if the export succeeded.
        public let configurationsDownloadUrl: String?
        /// Helpful status messages for API callers. For example: Too many exports in the last 6 hours. Export in progress. Export was successful.
        public let statusMessage: String
        /// The time the configuration data export was initiated.
        public let exportRequestTime: Date

        public init(exportId: String, exportStatus: ExportStatus, configurationsDownloadUrl: String? = nil, statusMessage: String, exportRequestTime: Date) {
            self.exportId = exportId
            self.exportStatus = exportStatus
            self.configurationsDownloadUrl = configurationsDownloadUrl
            self.statusMessage = statusMessage
            self.exportRequestTime = exportRequestTime
        }

        public init(dictionary: [String: Any]) throws {
            guard let exportId = dictionary["exportId"] as? String else { throw InitializableError.missingRequiredParam("exportId") }
            self.exportId = exportId
            guard let rawexportStatus = dictionary["exportStatus"] as? String, let exportStatus = ExportStatus(rawValue: rawexportStatus) else { throw InitializableError.missingRequiredParam("exportStatus") }
            self.exportStatus = exportStatus
            self.configurationsDownloadUrl = dictionary["configurationsDownloadUrl"] as? String
            guard let statusMessage = dictionary["statusMessage"] as? String else { throw InitializableError.missingRequiredParam("statusMessage") }
            self.statusMessage = statusMessage
            guard let exportRequestTime = dictionary["exportRequestTime"] as? Date else { throw InitializableError.missingRequiredParam("exportRequestTime") }
            self.exportRequestTime = exportRequestTime
        }
    }

    public struct DescribeAgentsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Lists agents or the Connector by ID or lists all agents/Connectors associated with your user account if you did not specify an agent/Connector ID. The output includes agent/Connector IDs, IP addresses, media access control (MAC) addresses, agent/Connector health, host name where the agent/Connector resides, and the version number of each agent/Connector.
        public let agentsInfo: [AgentInfo]?
        /// Token to retrieve the next set of results. For example, if you specified 100 IDs for DescribeAgentsRequest$agentIds but set DescribeAgentsRequest$maxResults to 10, you received a set of 10 results along with this token. Use this token in the next query to retrieve the next set of 10.
        public let nextToken: String?

        public init(agentsInfo: [AgentInfo]? = nil, nextToken: String? = nil) {
            self.agentsInfo = agentsInfo
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let agentsInfo = dictionary["agentsInfo"] as? [[String: Any]] {
                self.agentsInfo = try agentsInfo.map({ try AgentInfo(dictionary: $0) })
            } else { 
                self.agentsInfo = nil
            }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct GetDiscoverySummaryRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct DescribeConfigurationsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A key in the response map. The value is an array of data.
        public let configurations: [[String: String]]?

        public init(configurations: [[String: String]]? = nil) {
            self.configurations = configurations
        }

        public init(dictionary: [String: Any]) throws {
            self.configurations = dictionary["configurations"] as? [[String: String]]
        }
    }

    public struct ConfigurationTagSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [ConfigurationTag]?

        public init(item: [ConfigurationTag]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try ConfigurationTag(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct DescribeAgentsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The total number of agents/Connectors to return in a single page of output. The maximum value is 100.
        public let maxResults: Int32?
        /// Token to retrieve the next set of results. For example, if you previously specified 100 IDs for DescribeAgentsRequest$agentIds but set DescribeAgentsRequest$maxResults to 10, you received a set of 10 results along with a token. Use that token in this query to get the next set of 10.
        public let nextToken: String?
        /// You can filter the request using various logical operators and a key-value format. For example:   {"key": "collectionStatus", "value": "STARTED"}  For a complete list of filter options and guidance about using them with this action, see Managing AWS Application Discovery Service Agents and the AWS Application Discovery Connector .
        public let filters: [Filter]?
        /// The agent or the Connector IDs for which you want information. If you specify no IDs, the system returns information about all agents/Connectors associated with your AWS user account.
        public let agentIds: [String]?

        public init(maxResults: Int32? = nil, nextToken: String? = nil, filters: [Filter]? = nil, agentIds: [String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.filters = filters
            self.agentIds = agentIds
        }

        public init(dictionary: [String: Any]) throws {
            self.maxResults = dictionary["maxResults"] as? Int32
            self.nextToken = dictionary["nextToken"] as? String
            if let filters = dictionary["filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            } else { 
                self.filters = nil
            }
            self.agentIds = dictionary["agentIds"] as? [String]
        }
    }

    public struct ExportConfigurationsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A unique identifier that you can use to query the export status.
        public let exportId: String?

        public init(exportId: String? = nil) {
            self.exportId = exportId
        }

        public init(dictionary: [String: Any]) throws {
            self.exportId = dictionary["exportId"] as? String
        }
    }

    public struct CreateApplicationRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Description of the application to be created.
        public let description: String?
        /// Name of the application to be created.
        public let name: String

        public init(description: String? = nil, name: String) {
            self.description = description
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            self.description = dictionary["description"] as? String
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
        }
    }

    public struct DisassociateConfigurationItemsFromApplicationResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct CustomerAgentInfo: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Number of unhealthy discovery agents.
        public let unhealthyAgents: Int32
        /// Number of blacklisted discovery agents.
        public let blackListedAgents: Int32
        /// Total number of discovery agents.
        public let totalAgents: Int32
        /// Number of unknown discovery agents.
        public let unknownAgents: Int32
        /// Number of healthy discovery agents
        public let healthyAgents: Int32
        /// Number of active discovery agents.
        public let activeAgents: Int32
        /// Number of discovery agents with status SHUTDOWN.
        public let shutdownAgents: Int32

        public init(unhealthyAgents: Int32, blackListedAgents: Int32, totalAgents: Int32, unknownAgents: Int32, healthyAgents: Int32, activeAgents: Int32, shutdownAgents: Int32) {
            self.unhealthyAgents = unhealthyAgents
            self.blackListedAgents = blackListedAgents
            self.totalAgents = totalAgents
            self.unknownAgents = unknownAgents
            self.healthyAgents = healthyAgents
            self.activeAgents = activeAgents
            self.shutdownAgents = shutdownAgents
        }

        public init(dictionary: [String: Any]) throws {
            guard let unhealthyAgents = dictionary["unhealthyAgents"] as? Int32 else { throw InitializableError.missingRequiredParam("unhealthyAgents") }
            self.unhealthyAgents = unhealthyAgents
            guard let blackListedAgents = dictionary["blackListedAgents"] as? Int32 else { throw InitializableError.missingRequiredParam("blackListedAgents") }
            self.blackListedAgents = blackListedAgents
            guard let totalAgents = dictionary["totalAgents"] as? Int32 else { throw InitializableError.missingRequiredParam("totalAgents") }
            self.totalAgents = totalAgents
            guard let unknownAgents = dictionary["unknownAgents"] as? Int32 else { throw InitializableError.missingRequiredParam("unknownAgents") }
            self.unknownAgents = unknownAgents
            guard let healthyAgents = dictionary["healthyAgents"] as? Int32 else { throw InitializableError.missingRequiredParam("healthyAgents") }
            self.healthyAgents = healthyAgents
            guard let activeAgents = dictionary["activeAgents"] as? Int32 else { throw InitializableError.missingRequiredParam("activeAgents") }
            self.activeAgents = activeAgents
            guard let shutdownAgents = dictionary["shutdownAgents"] as? Int32 else { throw InitializableError.missingRequiredParam("shutdownAgents") }
            self.shutdownAgents = shutdownAgents
        }
    }

    public struct StartDataCollectionByAgentIdsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IDs of the agents or Connectors that you want to start collecting data. If you send a request to an agent/Connector ID that you do not have permission to contact, according to your AWS account, the service does not throw an exception. Instead, it returns the error in the Description field. If you send a request to multiple agents/Connectors and you do not have permission to contact some of those agents/Connectors, the system does not throw an exception. Instead, the system shows Failed in the Description field.
        public let agentIds: [String]

        public init(agentIds: [String]) {
            self.agentIds = agentIds
        }

        public init(dictionary: [String: Any]) throws {
            guard let agentIds = dictionary["agentIds"] as? [String] else { throw InitializableError.missingRequiredParam("agentIds") }
            self.agentIds = agentIds
        }
    }

    public struct ListServerNeighborsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Maximum number of results to return in a single page of output.
        public let maxResults: Int32?
        /// Flag to indicate if port and protocol information is needed as part of the response.
        public let portInformationNeeded: Bool?
        /// Token to retrieve the next set of results. For example, if you previously specified 100 IDs for ListServerNeighborsRequest$neighborConfigurationIds but set ListServerNeighborsRequest$maxResults to 10, you received a set of 10 results along with a token. Use that token in this query to get the next set of 10.
        public let nextToken: String?
        /// List of configuration IDs to test for one-hop-away.
        public let neighborConfigurationIds: [String]?
        /// Configuration ID of the server for which neighbors are being listed.
        public let configurationId: String

        public init(maxResults: Int32? = nil, portInformationNeeded: Bool? = nil, nextToken: String? = nil, neighborConfigurationIds: [String]? = nil, configurationId: String) {
            self.maxResults = maxResults
            self.portInformationNeeded = portInformationNeeded
            self.nextToken = nextToken
            self.neighborConfigurationIds = neighborConfigurationIds
            self.configurationId = configurationId
        }

        public init(dictionary: [String: Any]) throws {
            self.maxResults = dictionary["maxResults"] as? Int32
            self.portInformationNeeded = dictionary["portInformationNeeded"] as? Bool
            self.nextToken = dictionary["nextToken"] as? String
            self.neighborConfigurationIds = dictionary["neighborConfigurationIds"] as? [String]
            guard let configurationId = dictionary["configurationId"] as? String else { throw InitializableError.missingRequiredParam("configurationId") }
            self.configurationId = configurationId
        }
    }

    public struct UpdateApplicationRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// New description of the application to be updated.
        public let description: String?
        /// New name of the application to be updated.
        public let name: String?
        /// Configuration ID of the application to be updated.
        public let configurationId: String

        public init(description: String? = nil, name: String? = nil, configurationId: String) {
            self.description = description
            self.name = name
            self.configurationId = configurationId
        }

        public init(dictionary: [String: Any]) throws {
            self.description = dictionary["description"] as? String
            self.name = dictionary["name"] as? String
            guard let configurationId = dictionary["configurationId"] as? String else { throw InitializableError.missingRequiredParam("configurationId") }
            self.configurationId = configurationId
        }
    }

    public struct Filter: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the filter.
        public let name: String
        /// A string value that you want to filter on. For example, if you choose the destinationServer.osVersion filter name, you could specify Ubuntu for the value.
        public let values: FilterValues
        /// A conditional operator. The following operators are valid: EQUALS, NOT_EQUALS, CONTAINS, NOT_CONTAINS. If you specify multiple filters, the system utilizes all filters as though concatenated by AND. If you specify multiple values for a particular filter, the system differentiates the values using OR. Calling either DescribeConfigurations or ListConfigurations returns attributes of matching configuration items.
        public let condition: String

        public init(name: String, values: FilterValues, condition: String) {
            self.name = name
            self.values = values
            self.condition = condition
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
            guard let values = dictionary["values"] as? [String: Any] else { throw InitializableError.missingRequiredParam("values") }
            self.values = try Discovery.FilterValues(dictionary: values)
            guard let condition = dictionary["condition"] as? String else { throw InitializableError.missingRequiredParam("condition") }
            self.condition = condition
        }
    }

    public struct AgentNetworkInfo: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The MAC address for the host where the agent/Connector resides.
        public let macAddress: String?
        /// The IP address for the host where the agent/Connector resides.
        public let ipAddress: String?

        public init(macAddress: String? = nil, ipAddress: String? = nil) {
            self.macAddress = macAddress
            self.ipAddress = ipAddress
        }

        public init(dictionary: [String: Any]) throws {
            self.macAddress = dictionary["macAddress"] as? String
            self.ipAddress = dictionary["ipAddress"] as? String
        }
    }

    public struct CreateTagsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

}