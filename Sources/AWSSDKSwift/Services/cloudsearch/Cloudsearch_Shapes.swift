// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Cloudsearch {

    public struct DescribeScalingParametersRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public struct IntOptions: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// Whether facet information can be returned for the field.
        public let facetEnabled: Bool?
        /// The name of the source field to map to the field. 
        public let sourceField: String?
        /// Whether the contents of the field are searchable.
        public let searchEnabled: Bool?
        /// Whether the field can be used to sort the search results.
        public let sortEnabled: Bool?
        /// A value to use for the field if the field isn't specified for a document. This can be important if you are using the field in an expression and that field is not present in every document.
        public let defaultValue: Int64?

        public init(returnEnabled: Bool? = nil, facetEnabled: Bool? = nil, sourceField: String? = nil, searchEnabled: Bool? = nil, sortEnabled: Bool? = nil, defaultValue: Int64? = nil) {
            self.returnEnabled = returnEnabled
            self.facetEnabled = facetEnabled
            self.sourceField = sourceField
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.defaultValue = defaultValue
        }

        public init(dictionary: [String: Any]) throws {
            self.returnEnabled = dictionary["ReturnEnabled"] as? Bool
            self.facetEnabled = dictionary["FacetEnabled"] as? Bool
            self.sourceField = dictionary["SourceField"] as? String
            self.searchEnabled = dictionary["SearchEnabled"] as? Bool
            self.sortEnabled = dictionary["SortEnabled"] as? Bool
            self.defaultValue = dictionary["DefaultValue"] as? Int64
        }
    }

    public struct ExpressionStatus: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The expression that is evaluated for sorting while processing a search request.
        public let options: Expression
        public let status: OptionStatus

        public init(options: Expression, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        public init(dictionary: [String: Any]) throws {
            guard let options = dictionary["Options"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Options") }
            self.options = try Cloudsearch.Expression(dictionary: options)
            guard let status = dictionary["Status"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Status") }
            self.status = try Cloudsearch.OptionStatus(dictionary: status)
        }
    }

    public struct DescribeScalingParametersResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let scalingParameters: ScalingParametersStatus

        public init(scalingParameters: ScalingParametersStatus) {
            self.scalingParameters = scalingParameters
        }

        public init(dictionary: [String: Any]) throws {
            guard let scalingParameters = dictionary["ScalingParameters"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ScalingParameters") }
            self.scalingParameters = try Cloudsearch.ScalingParametersStatus(dictionary: scalingParameters)
        }
    }

    public struct AnalysisScheme: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let analysisSchemeLanguage: AnalysisSchemeLanguage
        public let analysisSchemeName: String
        public let analysisOptions: AnalysisOptions?

        public init(analysisSchemeLanguage: AnalysisSchemeLanguage, analysisSchemeName: String, analysisOptions: AnalysisOptions? = nil) {
            self.analysisSchemeLanguage = analysisSchemeLanguage
            self.analysisSchemeName = analysisSchemeName
            self.analysisOptions = analysisOptions
        }

        public init(dictionary: [String: Any]) throws {
            guard let rawAnalysisSchemeLanguage = dictionary["AnalysisSchemeLanguage"] as? String, let analysisSchemeLanguage = AnalysisSchemeLanguage(rawValue: rawAnalysisSchemeLanguage) else { throw InitializableError.missingRequiredParam("AnalysisSchemeLanguage") }
            self.analysisSchemeLanguage = analysisSchemeLanguage
            guard let analysisSchemeName = dictionary["AnalysisSchemeName"] as? String else { throw InitializableError.missingRequiredParam("AnalysisSchemeName") }
            self.analysisSchemeName = analysisSchemeName
            if let analysisOptions = dictionary["AnalysisOptions"] as? [String: Any] { self.analysisOptions = try Cloudsearch.AnalysisOptions(dictionary: analysisOptions) } else { self.analysisOptions = nil }
        }
    }

    public struct DeleteIndexFieldRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the index field your want to remove from the domain's indexing options.
        public let indexFieldName: String
        public let domainName: String

        public init(indexFieldName: String, domainName: String) {
            self.indexFieldName = indexFieldName
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            guard let indexFieldName = dictionary["IndexFieldName"] as? String else { throw InitializableError.missingRequiredParam("IndexFieldName") }
            self.indexFieldName = indexFieldName
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public struct DeleteExpressionResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The status of the expression being deleted.
        public let expression: ExpressionStatus

        public init(expression: ExpressionStatus) {
            self.expression = expression
        }

        public init(dictionary: [String: Any]) throws {
            guard let expression = dictionary["Expression"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Expression") }
            self.expression = try Cloudsearch.ExpressionStatus(dictionary: expression)
        }
    }

    public struct LiteralOptions: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// Whether facet information can be returned for the field.
        public let facetEnabled: Bool?
        public let sourceField: String?
        /// Whether the contents of the field are searchable.
        public let searchEnabled: Bool?
        /// Whether the field can be used to sort the search results.
        public let sortEnabled: Bool?
        /// A value to use for the field if the field isn't specified for a document.
        public let defaultValue: String?

        public init(returnEnabled: Bool? = nil, facetEnabled: Bool? = nil, sourceField: String? = nil, searchEnabled: Bool? = nil, sortEnabled: Bool? = nil, defaultValue: String? = nil) {
            self.returnEnabled = returnEnabled
            self.facetEnabled = facetEnabled
            self.sourceField = sourceField
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.defaultValue = defaultValue
        }

        public init(dictionary: [String: Any]) throws {
            self.returnEnabled = dictionary["ReturnEnabled"] as? Bool
            self.facetEnabled = dictionary["FacetEnabled"] as? Bool
            self.sourceField = dictionary["SourceField"] as? String
            self.searchEnabled = dictionary["SearchEnabled"] as? Bool
            self.sortEnabled = dictionary["SortEnabled"] as? Bool
            self.defaultValue = dictionary["DefaultValue"] as? String
        }
    }

    public struct DescribeAnalysisSchemesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The analysis schemes you want to describe.
        public let analysisSchemeNames: [String]?
        /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
        public let deployed: Bool?
        /// The name of the domain you want to describe.
        public let domainName: String

        public init(analysisSchemeNames: [String]? = nil, deployed: Bool? = nil, domainName: String) {
            self.analysisSchemeNames = analysisSchemeNames
            self.deployed = deployed
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            self.analysisSchemeNames = dictionary["AnalysisSchemeNames"] as? [String]
            self.deployed = dictionary["Deployed"] as? Bool
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public struct OptionStatus: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A unique integer that indicates when this option was last updated.
        public let updateVersion: Int32?
        /// Indicates that the option will be deleted once processing is complete.
        public let pendingDeletion: Bool?
        /// A timestamp for when this option was created.
        public let creationDate: Date
        /// The state of processing a change to an option. Possible values:   RequiresIndexDocuments: the option's latest value will not be deployed until IndexDocuments has been called and indexing is complete.  Processing: the option's latest value is in the process of being activated.   Active: the option's latest value is completely deployed.  FailedToValidate: the option value is not compatible with the domain's data and cannot be used to index the data. You must either modify the option value or update or remove the incompatible documents. 
        public let state: OptionState
        /// A timestamp for when this option was last updated.
        public let updateDate: Date

        public init(updateVersion: Int32? = nil, pendingDeletion: Bool? = nil, creationDate: Date, state: OptionState, updateDate: Date) {
            self.updateVersion = updateVersion
            self.pendingDeletion = pendingDeletion
            self.creationDate = creationDate
            self.state = state
            self.updateDate = updateDate
        }

        public init(dictionary: [String: Any]) throws {
            self.updateVersion = dictionary["UpdateVersion"] as? Int32
            self.pendingDeletion = dictionary["PendingDeletion"] as? Bool
            guard let creationDate = dictionary["CreationDate"] as? Date else { throw InitializableError.missingRequiredParam("CreationDate") }
            self.creationDate = creationDate
            guard let rawState = dictionary["State"] as? String, let state = OptionState(rawValue: rawState) else { throw InitializableError.missingRequiredParam("State") }
            self.state = state
            guard let updateDate = dictionary["UpdateDate"] as? Date else { throw InitializableError.missingRequiredParam("UpdateDate") }
            self.updateDate = updateDate
        }
    }

    public struct DescribeDomainsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The names of the domains you want to include in the response.
        public let domainNames: [String]?

        public init(domainNames: [String]? = nil) {
            self.domainNames = domainNames
        }

        public init(dictionary: [String: Any]) throws {
            self.domainNames = dictionary["DomainNames"] as? [String]
        }
    }

    public struct UpdateServiceAccessPoliciesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The access rules configured for the domain.
        public let accessPolicies: AccessPoliciesStatus

        public init(accessPolicies: AccessPoliciesStatus) {
            self.accessPolicies = accessPolicies
        }

        public init(dictionary: [String: Any]) throws {
            guard let accessPolicies = dictionary["AccessPolicies"] as? [String: Any] else { throw InitializableError.missingRequiredParam("AccessPolicies") }
            self.accessPolicies = try Cloudsearch.AccessPoliciesStatus(dictionary: accessPolicies)
        }
    }

    public struct DoubleArrayOptions: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// A list of source fields to map to the field. 
        public let sourceFields: String?
        /// Whether facet information can be returned for the field.
        public let facetEnabled: Bool?
        /// Whether the contents of the field are searchable.
        public let searchEnabled: Bool?
        /// A value to use for the field if the field isn't specified for a document.
        public let defaultValue: Double?

        public init(returnEnabled: Bool? = nil, sourceFields: String? = nil, facetEnabled: Bool? = nil, searchEnabled: Bool? = nil, defaultValue: Double? = nil) {
            self.returnEnabled = returnEnabled
            self.sourceFields = sourceFields
            self.facetEnabled = facetEnabled
            self.searchEnabled = searchEnabled
            self.defaultValue = defaultValue
        }

        public init(dictionary: [String: Any]) throws {
            self.returnEnabled = dictionary["ReturnEnabled"] as? Bool
            self.sourceFields = dictionary["SourceFields"] as? String
            self.facetEnabled = dictionary["FacetEnabled"] as? Bool
            self.searchEnabled = dictionary["SearchEnabled"] as? Bool
            self.defaultValue = dictionary["DefaultValue"] as? Double
        }
    }

    public struct DomainStatus: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let limits: Limits?
        /// True if processing is being done to activate the current domain configuration.
        public let processing: Bool?
        /// True if the search domain is created. It can take several minutes to initialize a domain when CreateDomain is called. Newly created search domains are returned from DescribeDomains with a false value for Created until domain creation is complete.
        public let created: Bool?
        public let aRN: String?
        /// The service endpoint for updating documents in a search domain.
        public let docService: ServiceEndpoint?
        /// True if IndexDocuments needs to be called to activate the current domain configuration.
        public let requiresIndexDocuments: Bool
        /// The service endpoint for requesting search results from a search domain.
        public let searchService: ServiceEndpoint?
        /// The number of partitions across which the search index is spread.
        public let searchPartitionCount: Int32?
        /// The instance type that is being used to process search requests.
        public let searchInstanceType: String?
        public let domainName: String
        /// The number of search instances that are available to process search requests.
        public let searchInstanceCount: Int32?
        /// True if the search domain has been deleted. The system must clean up resources dedicated to the search domain when DeleteDomain is called. Newly deleted search domains are returned from DescribeDomains with a true value for IsDeleted for several minutes until resource cleanup is complete.
        public let deleted: Bool?
        public let domainId: String

        public init(limits: Limits? = nil, processing: Bool? = nil, created: Bool? = nil, aRN: String? = nil, docService: ServiceEndpoint? = nil, requiresIndexDocuments: Bool, searchService: ServiceEndpoint? = nil, searchPartitionCount: Int32? = nil, searchInstanceType: String? = nil, domainName: String, searchInstanceCount: Int32? = nil, deleted: Bool? = nil, domainId: String) {
            self.limits = limits
            self.processing = processing
            self.created = created
            self.aRN = aRN
            self.docService = docService
            self.requiresIndexDocuments = requiresIndexDocuments
            self.searchService = searchService
            self.searchPartitionCount = searchPartitionCount
            self.searchInstanceType = searchInstanceType
            self.domainName = domainName
            self.searchInstanceCount = searchInstanceCount
            self.deleted = deleted
            self.domainId = domainId
        }

        public init(dictionary: [String: Any]) throws {
            if let limits = dictionary["Limits"] as? [String: Any] { self.limits = try Cloudsearch.Limits(dictionary: limits) } else { self.limits = nil }
            self.processing = dictionary["Processing"] as? Bool
            self.created = dictionary["Created"] as? Bool
            self.aRN = dictionary["ARN"] as? String
            if let docService = dictionary["DocService"] as? [String: Any] { self.docService = try Cloudsearch.ServiceEndpoint(dictionary: docService) } else { self.docService = nil }
            guard let requiresIndexDocuments = dictionary["RequiresIndexDocuments"] as? Bool else { throw InitializableError.missingRequiredParam("RequiresIndexDocuments") }
            self.requiresIndexDocuments = requiresIndexDocuments
            if let searchService = dictionary["SearchService"] as? [String: Any] { self.searchService = try Cloudsearch.ServiceEndpoint(dictionary: searchService) } else { self.searchService = nil }
            self.searchPartitionCount = dictionary["SearchPartitionCount"] as? Int32
            self.searchInstanceType = dictionary["SearchInstanceType"] as? String
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
            self.searchInstanceCount = dictionary["SearchInstanceCount"] as? Int32
            self.deleted = dictionary["Deleted"] as? Bool
            guard let domainId = dictionary["DomainId"] as? String else { throw InitializableError.missingRequiredParam("DomainId") }
            self.domainId = domainId
        }
    }

    public enum AlgorithmicStemming: String, CustomStringConvertible {
        case none = "none"
        case minimal = "minimal"
        case light = "light"
        case full = "full"
        public var description: String { return self.rawValue }
    }

    public struct UpdateScalingParametersResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let scalingParameters: ScalingParametersStatus

        public init(scalingParameters: ScalingParametersStatus) {
            self.scalingParameters = scalingParameters
        }

        public init(dictionary: [String: Any]) throws {
            guard let scalingParameters = dictionary["ScalingParameters"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ScalingParameters") }
            self.scalingParameters = try Cloudsearch.ScalingParametersStatus(dictionary: scalingParameters)
        }
    }

    public struct ListDomainNamesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The names of the search domains owned by an account.
        public let domainNames: [String: String]?

        public init(domainNames: [String: String]? = nil) {
            self.domainNames = domainNames
        }

        public init(dictionary: [String: Any]) throws {
            if let domainNames = dictionary["DomainNames"] as? [String: String] {
                self.domainNames = domainNames
            } else { 
                self.domainNames = nil
            }
        }
    }

    public struct DescribeAvailabilityOptionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
        public let deployed: Bool?
        /// The name of the domain you want to describe.
        public let domainName: String

        public init(deployed: Bool? = nil, domainName: String) {
            self.deployed = deployed
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            self.deployed = dictionary["Deployed"] as? Bool
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public struct DeleteIndexFieldResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The status of the index field being deleted.
        public let indexField: IndexFieldStatus

        public init(indexField: IndexFieldStatus) {
            self.indexField = indexField
        }

        public init(dictionary: [String: Any]) throws {
            guard let indexField = dictionary["IndexField"] as? [String: Any] else { throw InitializableError.missingRequiredParam("IndexField") }
            self.indexField = try Cloudsearch.IndexFieldStatus(dictionary: indexField)
        }
    }

    public struct DefineSuggesterRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let suggester: Suggester
        public let domainName: String

        public init(suggester: Suggester, domainName: String) {
            self.suggester = suggester
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            guard let suggester = dictionary["Suggester"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Suggester") }
            self.suggester = try Cloudsearch.Suggester(dictionary: suggester)
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public struct DescribeIndexFieldsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
        public let deployed: Bool?
        /// A list of the index fields you want to describe. If not specified, information is returned for all configured index fields.
        public let fieldNames: [String]?
        /// The name of the domain you want to describe.
        public let domainName: String

        public init(deployed: Bool? = nil, fieldNames: [String]? = nil, domainName: String) {
            self.deployed = deployed
            self.fieldNames = fieldNames
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            self.deployed = dictionary["Deployed"] as? Bool
            self.fieldNames = dictionary["FieldNames"] as? [String]
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public enum PartitionInstanceType: String, CustomStringConvertible {
        case search_m1_small = "search.m1.small"
        case search_m1_large = "search.m1.large"
        case search_m2_xlarge = "search.m2.xlarge"
        case search_m2_2xlarge = "search.m2.2xlarge"
        case search_m3_medium = "search.m3.medium"
        case search_m3_large = "search.m3.large"
        case search_m3_xlarge = "search.m3.xlarge"
        case search_m3_2xlarge = "search.m3.2xlarge"
        public var description: String { return self.rawValue }
    }

    public struct DeleteDomainResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let domainStatus: DomainStatus?

        public init(domainStatus: DomainStatus? = nil) {
            self.domainStatus = domainStatus
        }

        public init(dictionary: [String: Any]) throws {
            if let domainStatus = dictionary["DomainStatus"] as? [String: Any] { self.domainStatus = try Cloudsearch.DomainStatus(dictionary: domainStatus) } else { self.domainStatus = nil }
        }
    }

    public enum SuggesterFuzzyMatching: String, CustomStringConvertible {
        case none = "none"
        case low = "low"
        case high = "high"
        public var description: String { return self.rawValue }
    }

    public struct Suggester: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let suggesterName: String
        public let documentSuggesterOptions: DocumentSuggesterOptions

        public init(suggesterName: String, documentSuggesterOptions: DocumentSuggesterOptions) {
            self.suggesterName = suggesterName
            self.documentSuggesterOptions = documentSuggesterOptions
        }

        public init(dictionary: [String: Any]) throws {
            guard let suggesterName = dictionary["SuggesterName"] as? String else { throw InitializableError.missingRequiredParam("SuggesterName") }
            self.suggesterName = suggesterName
            guard let documentSuggesterOptions = dictionary["DocumentSuggesterOptions"] as? [String: Any] else { throw InitializableError.missingRequiredParam("DocumentSuggesterOptions") }
            self.documentSuggesterOptions = try Cloudsearch.DocumentSuggesterOptions(dictionary: documentSuggesterOptions)
        }
    }

    public struct ScalingParameters: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The number of replicas you want to preconfigure for each index partition.
        public let desiredReplicationCount: Int32?
        /// The instance type that you want to preconfigure for your domain. For example, search.m1.small.
        public let desiredInstanceType: PartitionInstanceType?
        /// The number of partitions you want to preconfigure for your domain. Only valid when you select m2.2xlarge as the desired instance type.
        public let desiredPartitionCount: Int32?

        public init(desiredReplicationCount: Int32? = nil, desiredInstanceType: PartitionInstanceType? = nil, desiredPartitionCount: Int32? = nil) {
            self.desiredReplicationCount = desiredReplicationCount
            self.desiredInstanceType = desiredInstanceType
            self.desiredPartitionCount = desiredPartitionCount
        }

        public init(dictionary: [String: Any]) throws {
            self.desiredReplicationCount = dictionary["DesiredReplicationCount"] as? Int32
            if let desiredInstanceType = dictionary["DesiredInstanceType"] as? String { self.desiredInstanceType = PartitionInstanceType(rawValue: desiredInstanceType) } else { self.desiredInstanceType = nil }
            self.desiredPartitionCount = dictionary["DesiredPartitionCount"] as? Int32
        }
    }

    public struct DescribeServiceAccessPoliciesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
        public let deployed: Bool?
        /// The name of the domain you want to describe.
        public let domainName: String

        public init(deployed: Bool? = nil, domainName: String) {
            self.deployed = deployed
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            self.deployed = dictionary["Deployed"] as? Bool
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public struct CreateDomainResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let domainStatus: DomainStatus?

        public init(domainStatus: DomainStatus? = nil) {
            self.domainStatus = domainStatus
        }

        public init(dictionary: [String: Any]) throws {
            if let domainStatus = dictionary["DomainStatus"] as? [String: Any] { self.domainStatus = try Cloudsearch.DomainStatus(dictionary: domainStatus) } else { self.domainStatus = nil }
        }
    }

    public struct DocumentSuggesterOptions: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An expression that computes a score for each suggestion to control how they are sorted. The scores are rounded to the nearest integer, with a floor of 0 and a ceiling of 2^31-1. A document's relevance score is not computed for suggestions, so sort expressions cannot reference the _score value. To sort suggestions using a numeric field or existing expression, simply specify the name of the field or expression. If no expression is configured for the suggester, the suggestions are sorted with the closest matches listed first.
        public let sortExpression: String?
        /// The level of fuzziness allowed when suggesting matches for a string: none, low, or high. With none, the specified string is treated as an exact prefix. With low, suggestions must differ from the specified string by no more than one character. With high, suggestions can differ by up to two characters. The default is none. 
        public let fuzzyMatching: SuggesterFuzzyMatching?
        /// The name of the index field you want to use for suggestions. 
        public let sourceField: String

        public init(sortExpression: String? = nil, fuzzyMatching: SuggesterFuzzyMatching? = nil, sourceField: String) {
            self.sortExpression = sortExpression
            self.fuzzyMatching = fuzzyMatching
            self.sourceField = sourceField
        }

        public init(dictionary: [String: Any]) throws {
            self.sortExpression = dictionary["SortExpression"] as? String
            if let fuzzyMatching = dictionary["FuzzyMatching"] as? String { self.fuzzyMatching = SuggesterFuzzyMatching(rawValue: fuzzyMatching) } else { self.fuzzyMatching = nil }
            guard let sourceField = dictionary["SourceField"] as? String else { throw InitializableError.missingRequiredParam("SourceField") }
            self.sourceField = sourceField
        }
    }

    public struct DefineExpressionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let domainName: String
        public let expression: Expression

        public init(domainName: String, expression: Expression) {
            self.domainName = domainName
            self.expression = expression
        }

        public init(dictionary: [String: Any]) throws {
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
            guard let expression = dictionary["Expression"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Expression") }
            self.expression = try Cloudsearch.Expression(dictionary: expression)
        }
    }

    public struct TextArrayOptions: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of an analysis scheme for a text-array field.
        public let analysisScheme: String?
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// A list of source fields to map to the field. 
        public let sourceFields: String?
        /// Whether highlights can be returned for the field.
        public let highlightEnabled: Bool?
        /// A value to use for the field if the field isn't specified for a document.
        public let defaultValue: String?

        public init(analysisScheme: String? = nil, returnEnabled: Bool? = nil, sourceFields: String? = nil, highlightEnabled: Bool? = nil, defaultValue: String? = nil) {
            self.analysisScheme = analysisScheme
            self.returnEnabled = returnEnabled
            self.sourceFields = sourceFields
            self.highlightEnabled = highlightEnabled
            self.defaultValue = defaultValue
        }

        public init(dictionary: [String: Any]) throws {
            self.analysisScheme = dictionary["AnalysisScheme"] as? String
            self.returnEnabled = dictionary["ReturnEnabled"] as? Bool
            self.sourceFields = dictionary["SourceFields"] as? String
            self.highlightEnabled = dictionary["HighlightEnabled"] as? Bool
            self.defaultValue = dictionary["DefaultValue"] as? String
        }
    }

    public struct DescribeDomainsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let domainStatusList: [DomainStatus]

        public init(domainStatusList: [DomainStatus]) {
            self.domainStatusList = domainStatusList
        }

        public init(dictionary: [String: Any]) throws {
            guard let domainStatusList = dictionary["DomainStatusList"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("DomainStatusList") }
            self.domainStatusList = try domainStatusList.map({ try DomainStatus(dictionary: $0) })
        }
    }

    public struct DeleteSuggesterResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The status of the suggester being deleted.
        public let suggester: SuggesterStatus

        public init(suggester: SuggesterStatus) {
            self.suggester = suggester
        }

        public init(dictionary: [String: Any]) throws {
            guard let suggester = dictionary["Suggester"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Suggester") }
            self.suggester = try Cloudsearch.SuggesterStatus(dictionary: suggester)
        }
    }

    public struct DefineIndexFieldRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The index field and field options you want to configure. 
        public let indexField: IndexField
        public let domainName: String

        public init(indexField: IndexField, domainName: String) {
            self.indexField = indexField
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            guard let indexField = dictionary["IndexField"] as? [String: Any] else { throw InitializableError.missingRequiredParam("IndexField") }
            self.indexField = try Cloudsearch.IndexField(dictionary: indexField)
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public enum IndexFieldType: String, CustomStringConvertible {
        case int = "int"
        case double = "double"
        case literal = "literal"
        case text = "text"
        case date = "date"
        case latlon = "latlon"
        case int_array = "int-array"
        case double_array = "double-array"
        case literal_array = "literal-array"
        case text_array = "text-array"
        case date_array = "date-array"
        public var description: String { return self.rawValue }
    }

    public struct DefineAnalysisSchemeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let analysisScheme: AnalysisScheme
        public let domainName: String

        public init(analysisScheme: AnalysisScheme, domainName: String) {
            self.analysisScheme = analysisScheme
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            guard let analysisScheme = dictionary["AnalysisScheme"] as? [String: Any] else { throw InitializableError.missingRequiredParam("AnalysisScheme") }
            self.analysisScheme = try Cloudsearch.AnalysisScheme(dictionary: analysisScheme)
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public struct DeleteDomainRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the domain you want to permanently delete.
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public struct IndexDocumentsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public struct DeleteExpressionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the Expression to delete.
        public let expressionName: String
        public let domainName: String

        public init(expressionName: String, domainName: String) {
            self.expressionName = expressionName
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            guard let expressionName = dictionary["ExpressionName"] as? String else { throw InitializableError.missingRequiredParam("ExpressionName") }
            self.expressionName = expressionName
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public struct IndexFieldStatus: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let options: IndexField
        public let status: OptionStatus

        public init(options: IndexField, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        public init(dictionary: [String: Any]) throws {
            guard let options = dictionary["Options"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Options") }
            self.options = try Cloudsearch.IndexField(dictionary: options)
            guard let status = dictionary["Status"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Status") }
            self.status = try Cloudsearch.OptionStatus(dictionary: status)
        }
    }

    public struct DeleteAnalysisSchemeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the analysis scheme you want to delete.
        public let analysisSchemeName: String
        public let domainName: String

        public init(analysisSchemeName: String, domainName: String) {
            self.analysisSchemeName = analysisSchemeName
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            guard let analysisSchemeName = dictionary["AnalysisSchemeName"] as? String else { throw InitializableError.missingRequiredParam("AnalysisSchemeName") }
            self.analysisSchemeName = analysisSchemeName
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public struct ScalingParametersStatus: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let options: ScalingParameters
        public let status: OptionStatus

        public init(options: ScalingParameters, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        public init(dictionary: [String: Any]) throws {
            guard let options = dictionary["Options"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Options") }
            self.options = try Cloudsearch.ScalingParameters(dictionary: options)
            guard let status = dictionary["Status"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Status") }
            self.status = try Cloudsearch.OptionStatus(dictionary: status)
        }
    }

    public struct AnalysisOptions: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A JSON object that contains a collection of string:value pairs that each map a term to its stem. For example, {"term1": "stem1", "term2": "stem2", "term3": "stem3"}. The stemming dictionary is applied in addition to any algorithmic stemming. This enables you to override the results of the algorithmic stemming to correct specific cases of overstemming or understemming. The maximum size of a stemming dictionary is 500 KB.
        public let stemmingDictionary: String?
        /// A JSON array that contains a collection of terms, tokens, readings and part of speech for Japanese Tokenizaiton. The Japanese tokenization dictionary enables you to override the default tokenization for selected terms. This is only valid for Japanese language fields.
        public let japaneseTokenizationDictionary: String?
        /// A JSON array of terms to ignore during indexing and searching. For example, ["a", "an", "the", "of"]. The stopwords dictionary must explicitly list each word you want to ignore. Wildcards and regular expressions are not supported. 
        public let stopwords: String?
        /// The level of algorithmic stemming to perform: none, minimal, light, or full. The available levels vary depending on the language. For more information, see Language Specific Text Processing Settings in the Amazon CloudSearch Developer Guide 
        public let algorithmicStemming: AlgorithmicStemming?
        /// A JSON object that defines synonym groups and aliases. A synonym group is an array of arrays, where each sub-array is a group of terms where each term in the group is considered a synonym of every other term in the group. The aliases value is an object that contains a collection of string:value pairs where the string specifies a term and the array of values specifies each of the aliases for that term. An alias is considered a synonym of the specified term, but the term is not considered a synonym of the alias. For more information about specifying synonyms, see Synonyms in the Amazon CloudSearch Developer Guide.
        public let synonyms: String?

        public init(stemmingDictionary: String? = nil, japaneseTokenizationDictionary: String? = nil, stopwords: String? = nil, algorithmicStemming: AlgorithmicStemming? = nil, synonyms: String? = nil) {
            self.stemmingDictionary = stemmingDictionary
            self.japaneseTokenizationDictionary = japaneseTokenizationDictionary
            self.stopwords = stopwords
            self.algorithmicStemming = algorithmicStemming
            self.synonyms = synonyms
        }

        public init(dictionary: [String: Any]) throws {
            self.stemmingDictionary = dictionary["StemmingDictionary"] as? String
            self.japaneseTokenizationDictionary = dictionary["JapaneseTokenizationDictionary"] as? String
            self.stopwords = dictionary["Stopwords"] as? String
            if let algorithmicStemming = dictionary["AlgorithmicStemming"] as? String { self.algorithmicStemming = AlgorithmicStemming(rawValue: algorithmicStemming) } else { self.algorithmicStemming = nil }
            self.synonyms = dictionary["Synonyms"] as? String
        }
    }

    public struct UpdateServiceAccessPoliciesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The access rules you want to configure. These rules replace any existing rules. 
        public let accessPolicies: String
        public let domainName: String

        public init(accessPolicies: String, domainName: String) {
            self.accessPolicies = accessPolicies
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            guard let accessPolicies = dictionary["AccessPolicies"] as? String else { throw InitializableError.missingRequiredParam("AccessPolicies") }
            self.accessPolicies = accessPolicies
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public struct DateArrayOptions: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// A list of source fields to map to the field. 
        public let sourceFields: String?
        /// Whether facet information can be returned for the field.
        public let facetEnabled: Bool?
        /// Whether the contents of the field are searchable.
        public let searchEnabled: Bool?
        /// A value to use for the field if the field isn't specified for a document.
        public let defaultValue: String?

        public init(returnEnabled: Bool? = nil, sourceFields: String? = nil, facetEnabled: Bool? = nil, searchEnabled: Bool? = nil, defaultValue: String? = nil) {
            self.returnEnabled = returnEnabled
            self.sourceFields = sourceFields
            self.facetEnabled = facetEnabled
            self.searchEnabled = searchEnabled
            self.defaultValue = defaultValue
        }

        public init(dictionary: [String: Any]) throws {
            self.returnEnabled = dictionary["ReturnEnabled"] as? Bool
            self.sourceFields = dictionary["SourceFields"] as? String
            self.facetEnabled = dictionary["FacetEnabled"] as? Bool
            self.searchEnabled = dictionary["SearchEnabled"] as? Bool
            self.defaultValue = dictionary["DefaultValue"] as? String
        }
    }

    public struct DeleteAnalysisSchemeResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The status of the analysis scheme being deleted.
        public let analysisScheme: AnalysisSchemeStatus

        public init(analysisScheme: AnalysisSchemeStatus) {
            self.analysisScheme = analysisScheme
        }

        public init(dictionary: [String: Any]) throws {
            guard let analysisScheme = dictionary["AnalysisScheme"] as? [String: Any] else { throw InitializableError.missingRequiredParam("AnalysisScheme") }
            self.analysisScheme = try Cloudsearch.AnalysisSchemeStatus(dictionary: analysisScheme)
        }
    }

    public struct BuildSuggestersResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let fieldNames: [String]?

        public init(fieldNames: [String]? = nil) {
            self.fieldNames = fieldNames
        }

        public init(dictionary: [String: Any]) throws {
            self.fieldNames = dictionary["FieldNames"] as? [String]
        }
    }

    public struct AnalysisSchemeStatus: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let options: AnalysisScheme
        public let status: OptionStatus

        public init(options: AnalysisScheme, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        public init(dictionary: [String: Any]) throws {
            guard let options = dictionary["Options"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Options") }
            self.options = try Cloudsearch.AnalysisScheme(dictionary: options)
            guard let status = dictionary["Status"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Status") }
            self.status = try Cloudsearch.OptionStatus(dictionary: status)
        }
    }

    public struct AccessPoliciesStatus: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let options: String
        public let status: OptionStatus

        public init(options: String, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        public init(dictionary: [String: Any]) throws {
            guard let options = dictionary["Options"] as? String else { throw InitializableError.missingRequiredParam("Options") }
            self.options = options
            guard let status = dictionary["Status"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Status") }
            self.status = try Cloudsearch.OptionStatus(dictionary: status)
        }
    }

    public struct TextOptions: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of an analysis scheme for a text field.
        public let analysisScheme: String?
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        public let sourceField: String?
        /// Whether highlights can be returned for the field.
        public let highlightEnabled: Bool?
        /// Whether the field can be used to sort the search results.
        public let sortEnabled: Bool?
        /// A value to use for the field if the field isn't specified for a document.
        public let defaultValue: String?

        public init(analysisScheme: String? = nil, returnEnabled: Bool? = nil, sourceField: String? = nil, highlightEnabled: Bool? = nil, sortEnabled: Bool? = nil, defaultValue: String? = nil) {
            self.analysisScheme = analysisScheme
            self.returnEnabled = returnEnabled
            self.sourceField = sourceField
            self.highlightEnabled = highlightEnabled
            self.sortEnabled = sortEnabled
            self.defaultValue = defaultValue
        }

        public init(dictionary: [String: Any]) throws {
            self.analysisScheme = dictionary["AnalysisScheme"] as? String
            self.returnEnabled = dictionary["ReturnEnabled"] as? Bool
            self.sourceField = dictionary["SourceField"] as? String
            self.highlightEnabled = dictionary["HighlightEnabled"] as? Bool
            self.sortEnabled = dictionary["SortEnabled"] as? Bool
            self.defaultValue = dictionary["DefaultValue"] as? String
        }
    }

    public struct IndexDocumentsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The names of the fields that are currently being indexed.
        public let fieldNames: [String]?

        public init(fieldNames: [String]? = nil) {
            self.fieldNames = fieldNames
        }

        public init(dictionary: [String: Any]) throws {
            self.fieldNames = dictionary["FieldNames"] as? [String]
        }
    }

    public struct DefineExpressionResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let expression: ExpressionStatus

        public init(expression: ExpressionStatus) {
            self.expression = expression
        }

        public init(dictionary: [String: Any]) throws {
            guard let expression = dictionary["Expression"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Expression") }
            self.expression = try Cloudsearch.ExpressionStatus(dictionary: expression)
        }
    }

    public struct UpdateAvailabilityOptionsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The newly-configured availability options. Indicates whether Multi-AZ is enabled for the domain. 
        public let availabilityOptions: AvailabilityOptionsStatus?

        public init(availabilityOptions: AvailabilityOptionsStatus? = nil) {
            self.availabilityOptions = availabilityOptions
        }

        public init(dictionary: [String: Any]) throws {
            if let availabilityOptions = dictionary["AvailabilityOptions"] as? [String: Any] { self.availabilityOptions = try Cloudsearch.AvailabilityOptionsStatus(dictionary: availabilityOptions) } else { self.availabilityOptions = nil }
        }
    }

    public struct LiteralArrayOptions: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// A list of source fields to map to the field. 
        public let sourceFields: String?
        /// Whether facet information can be returned for the field.
        public let facetEnabled: Bool?
        /// Whether the contents of the field are searchable.
        public let searchEnabled: Bool?
        /// A value to use for the field if the field isn't specified for a document.
        public let defaultValue: String?

        public init(returnEnabled: Bool? = nil, sourceFields: String? = nil, facetEnabled: Bool? = nil, searchEnabled: Bool? = nil, defaultValue: String? = nil) {
            self.returnEnabled = returnEnabled
            self.sourceFields = sourceFields
            self.facetEnabled = facetEnabled
            self.searchEnabled = searchEnabled
            self.defaultValue = defaultValue
        }

        public init(dictionary: [String: Any]) throws {
            self.returnEnabled = dictionary["ReturnEnabled"] as? Bool
            self.sourceFields = dictionary["SourceFields"] as? String
            self.facetEnabled = dictionary["FacetEnabled"] as? Bool
            self.searchEnabled = dictionary["SearchEnabled"] as? Bool
            self.defaultValue = dictionary["DefaultValue"] as? String
        }
    }

    public struct IntArrayOptions: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// A list of source fields to map to the field. 
        public let sourceFields: String?
        /// Whether facet information can be returned for the field.
        public let facetEnabled: Bool?
        /// Whether the contents of the field are searchable.
        public let searchEnabled: Bool?
        /// A value to use for the field if the field isn't specified for a document.
        public let defaultValue: Int64?

        public init(returnEnabled: Bool? = nil, sourceFields: String? = nil, facetEnabled: Bool? = nil, searchEnabled: Bool? = nil, defaultValue: Int64? = nil) {
            self.returnEnabled = returnEnabled
            self.sourceFields = sourceFields
            self.facetEnabled = facetEnabled
            self.searchEnabled = searchEnabled
            self.defaultValue = defaultValue
        }

        public init(dictionary: [String: Any]) throws {
            self.returnEnabled = dictionary["ReturnEnabled"] as? Bool
            self.sourceFields = dictionary["SourceFields"] as? String
            self.facetEnabled = dictionary["FacetEnabled"] as? Bool
            self.searchEnabled = dictionary["SearchEnabled"] as? Bool
            self.defaultValue = dictionary["DefaultValue"] as? Int64
        }
    }

    public struct DescribeAnalysisSchemesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The analysis scheme descriptions.
        public let analysisSchemes: [AnalysisSchemeStatus]

        public init(analysisSchemes: [AnalysisSchemeStatus]) {
            self.analysisSchemes = analysisSchemes
        }

        public init(dictionary: [String: Any]) throws {
            guard let analysisSchemes = dictionary["AnalysisSchemes"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("AnalysisSchemes") }
            self.analysisSchemes = try analysisSchemes.map({ try AnalysisSchemeStatus(dictionary: $0) })
        }
    }

    public struct DescribeExpressionsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The expressions configured for the domain.
        public let expressions: [ExpressionStatus]

        public init(expressions: [ExpressionStatus]) {
            self.expressions = expressions
        }

        public init(dictionary: [String: Any]) throws {
            guard let expressions = dictionary["Expressions"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("Expressions") }
            self.expressions = try expressions.map({ try ExpressionStatus(dictionary: $0) })
        }
    }

    public struct Expression: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let expressionValue: String
        public let expressionName: String

        public init(expressionValue: String, expressionName: String) {
            self.expressionValue = expressionValue
            self.expressionName = expressionName
        }

        public init(dictionary: [String: Any]) throws {
            guard let expressionValue = dictionary["ExpressionValue"] as? String else { throw InitializableError.missingRequiredParam("ExpressionValue") }
            self.expressionValue = expressionValue
            guard let expressionName = dictionary["ExpressionName"] as? String else { throw InitializableError.missingRequiredParam("ExpressionName") }
            self.expressionName = expressionName
        }
    }

    public struct SuggesterStatus: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let options: Suggester
        public let status: OptionStatus

        public init(options: Suggester, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        public init(dictionary: [String: Any]) throws {
            guard let options = dictionary["Options"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Options") }
            self.options = try Cloudsearch.Suggester(dictionary: options)
            guard let status = dictionary["Status"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Status") }
            self.status = try Cloudsearch.OptionStatus(dictionary: status)
        }
    }

    public struct DescribeSuggestersRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
        public let deployed: Bool?
        /// The suggesters you want to describe.
        public let suggesterNames: [String]?
        /// The name of the domain you want to describe.
        public let domainName: String

        public init(deployed: Bool? = nil, suggesterNames: [String]? = nil, domainName: String) {
            self.deployed = deployed
            self.suggesterNames = suggesterNames
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            self.deployed = dictionary["Deployed"] as? Bool
            self.suggesterNames = dictionary["SuggesterNames"] as? [String]
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public struct IndexField: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let intOptions: IntOptions?
        public let dateOptions: DateOptions?
        public let textArrayOptions: TextArrayOptions?
        public let doubleOptions: DoubleOptions?
        public let literalArrayOptions: LiteralArrayOptions?
        public let intArrayOptions: IntArrayOptions?
        public let indexFieldType: IndexFieldType
        /// A string that represents the name of an index field. CloudSearch supports regular index fields as well as dynamic fields. A dynamic field's name defines a pattern that begins or ends with a wildcard. Any document fields that don't map to a regular index field but do match a dynamic field's pattern are configured with the dynamic field's indexing options.  Regular field names begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore). Dynamic field names must begin or end with a wildcard (*). The wildcard can also be the only character in a dynamic field name. Multiple wildcards, and wildcards embedded within a string are not supported.  The name score is reserved and cannot be used as a field name. To reference a document's ID, you can use the name _id. 
        public let indexFieldName: String
        public let dateArrayOptions: DateArrayOptions?
        public let literalOptions: LiteralOptions?
        public let latLonOptions: LatLonOptions?
        public let textOptions: TextOptions?
        public let doubleArrayOptions: DoubleArrayOptions?

        public init(intOptions: IntOptions? = nil, dateOptions: DateOptions? = nil, textArrayOptions: TextArrayOptions? = nil, doubleOptions: DoubleOptions? = nil, literalArrayOptions: LiteralArrayOptions? = nil, intArrayOptions: IntArrayOptions? = nil, indexFieldType: IndexFieldType, indexFieldName: String, dateArrayOptions: DateArrayOptions? = nil, literalOptions: LiteralOptions? = nil, latLonOptions: LatLonOptions? = nil, textOptions: TextOptions? = nil, doubleArrayOptions: DoubleArrayOptions? = nil) {
            self.intOptions = intOptions
            self.dateOptions = dateOptions
            self.textArrayOptions = textArrayOptions
            self.doubleOptions = doubleOptions
            self.literalArrayOptions = literalArrayOptions
            self.intArrayOptions = intArrayOptions
            self.indexFieldType = indexFieldType
            self.indexFieldName = indexFieldName
            self.dateArrayOptions = dateArrayOptions
            self.literalOptions = literalOptions
            self.latLonOptions = latLonOptions
            self.textOptions = textOptions
            self.doubleArrayOptions = doubleArrayOptions
        }

        public init(dictionary: [String: Any]) throws {
            if let intOptions = dictionary["IntOptions"] as? [String: Any] { self.intOptions = try Cloudsearch.IntOptions(dictionary: intOptions) } else { self.intOptions = nil }
            if let dateOptions = dictionary["DateOptions"] as? [String: Any] { self.dateOptions = try Cloudsearch.DateOptions(dictionary: dateOptions) } else { self.dateOptions = nil }
            if let textArrayOptions = dictionary["TextArrayOptions"] as? [String: Any] { self.textArrayOptions = try Cloudsearch.TextArrayOptions(dictionary: textArrayOptions) } else { self.textArrayOptions = nil }
            if let doubleOptions = dictionary["DoubleOptions"] as? [String: Any] { self.doubleOptions = try Cloudsearch.DoubleOptions(dictionary: doubleOptions) } else { self.doubleOptions = nil }
            if let literalArrayOptions = dictionary["LiteralArrayOptions"] as? [String: Any] { self.literalArrayOptions = try Cloudsearch.LiteralArrayOptions(dictionary: literalArrayOptions) } else { self.literalArrayOptions = nil }
            if let intArrayOptions = dictionary["IntArrayOptions"] as? [String: Any] { self.intArrayOptions = try Cloudsearch.IntArrayOptions(dictionary: intArrayOptions) } else { self.intArrayOptions = nil }
            guard let rawIndexFieldType = dictionary["IndexFieldType"] as? String, let indexFieldType = IndexFieldType(rawValue: rawIndexFieldType) else { throw InitializableError.missingRequiredParam("IndexFieldType") }
            self.indexFieldType = indexFieldType
            guard let indexFieldName = dictionary["IndexFieldName"] as? String else { throw InitializableError.missingRequiredParam("IndexFieldName") }
            self.indexFieldName = indexFieldName
            if let dateArrayOptions = dictionary["DateArrayOptions"] as? [String: Any] { self.dateArrayOptions = try Cloudsearch.DateArrayOptions(dictionary: dateArrayOptions) } else { self.dateArrayOptions = nil }
            if let literalOptions = dictionary["LiteralOptions"] as? [String: Any] { self.literalOptions = try Cloudsearch.LiteralOptions(dictionary: literalOptions) } else { self.literalOptions = nil }
            if let latLonOptions = dictionary["LatLonOptions"] as? [String: Any] { self.latLonOptions = try Cloudsearch.LatLonOptions(dictionary: latLonOptions) } else { self.latLonOptions = nil }
            if let textOptions = dictionary["TextOptions"] as? [String: Any] { self.textOptions = try Cloudsearch.TextOptions(dictionary: textOptions) } else { self.textOptions = nil }
            if let doubleArrayOptions = dictionary["DoubleArrayOptions"] as? [String: Any] { self.doubleArrayOptions = try Cloudsearch.DoubleArrayOptions(dictionary: doubleArrayOptions) } else { self.doubleArrayOptions = nil }
        }
    }

    public struct LatLonOptions: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// Whether facet information can be returned for the field.
        public let facetEnabled: Bool?
        public let sourceField: String?
        /// Whether the contents of the field are searchable.
        public let searchEnabled: Bool?
        /// Whether the field can be used to sort the search results.
        public let sortEnabled: Bool?
        /// A value to use for the field if the field isn't specified for a document.
        public let defaultValue: String?

        public init(returnEnabled: Bool? = nil, facetEnabled: Bool? = nil, sourceField: String? = nil, searchEnabled: Bool? = nil, sortEnabled: Bool? = nil, defaultValue: String? = nil) {
            self.returnEnabled = returnEnabled
            self.facetEnabled = facetEnabled
            self.sourceField = sourceField
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.defaultValue = defaultValue
        }

        public init(dictionary: [String: Any]) throws {
            self.returnEnabled = dictionary["ReturnEnabled"] as? Bool
            self.facetEnabled = dictionary["FacetEnabled"] as? Bool
            self.sourceField = dictionary["SourceField"] as? String
            self.searchEnabled = dictionary["SearchEnabled"] as? Bool
            self.sortEnabled = dictionary["SortEnabled"] as? Bool
            self.defaultValue = dictionary["DefaultValue"] as? String
        }
    }

    public enum AnalysisSchemeLanguage: String, CustomStringConvertible {
        case ar = "ar"
        case bg = "bg"
        case ca = "ca"
        case cs = "cs"
        case da = "da"
        case de = "de"
        case el = "el"
        case en = "en"
        case es = "es"
        case eu = "eu"
        case fa = "fa"
        case fi = "fi"
        case fr = "fr"
        case ga = "ga"
        case gl = "gl"
        case he = "he"
        case hi = "hi"
        case hu = "hu"
        case hy = "hy"
        case id = "id"
        case it = "it"
        case ja = "ja"
        case ko = "ko"
        case lv = "lv"
        case mul = "mul"
        case nl = "nl"
        case no = "no"
        case pt = "pt"
        case ro = "ro"
        case ru = "ru"
        case sv = "sv"
        case th = "th"
        case tr = "tr"
        case zh_hans = "zh-Hans"
        case zh_hant = "zh-Hant"
        public var description: String { return self.rawValue }
    }

    public struct DescribeExpressionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
        public let deployed: Bool?
        /// Limits the DescribeExpressions response to the specified expressions. If not specified, all expressions are shown.
        public let expressionNames: [String]?
        /// The name of the domain you want to describe.
        public let domainName: String

        public init(deployed: Bool? = nil, expressionNames: [String]? = nil, domainName: String) {
            self.deployed = deployed
            self.expressionNames = expressionNames
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            self.deployed = dictionary["Deployed"] as? Bool
            self.expressionNames = dictionary["ExpressionNames"] as? [String]
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public struct DoubleOptions: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// Whether facet information can be returned for the field.
        public let facetEnabled: Bool?
        /// The name of the source field to map to the field. 
        public let sourceField: String?
        /// Whether the contents of the field are searchable.
        public let searchEnabled: Bool?
        /// Whether the field can be used to sort the search results.
        public let sortEnabled: Bool?
        /// A value to use for the field if the field isn't specified for a document. This can be important if you are using the field in an expression and that field is not present in every document.
        public let defaultValue: Double?

        public init(returnEnabled: Bool? = nil, facetEnabled: Bool? = nil, sourceField: String? = nil, searchEnabled: Bool? = nil, sortEnabled: Bool? = nil, defaultValue: Double? = nil) {
            self.returnEnabled = returnEnabled
            self.facetEnabled = facetEnabled
            self.sourceField = sourceField
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.defaultValue = defaultValue
        }

        public init(dictionary: [String: Any]) throws {
            self.returnEnabled = dictionary["ReturnEnabled"] as? Bool
            self.facetEnabled = dictionary["FacetEnabled"] as? Bool
            self.sourceField = dictionary["SourceField"] as? String
            self.searchEnabled = dictionary["SearchEnabled"] as? Bool
            self.sortEnabled = dictionary["SortEnabled"] as? Bool
            self.defaultValue = dictionary["DefaultValue"] as? Double
        }
    }

    public struct DateOptions: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// Whether facet information can be returned for the field.
        public let facetEnabled: Bool?
        public let sourceField: String?
        /// Whether the contents of the field are searchable.
        public let searchEnabled: Bool?
        /// Whether the field can be used to sort the search results.
        public let sortEnabled: Bool?
        /// A value to use for the field if the field isn't specified for a document.
        public let defaultValue: String?

        public init(returnEnabled: Bool? = nil, facetEnabled: Bool? = nil, sourceField: String? = nil, searchEnabled: Bool? = nil, sortEnabled: Bool? = nil, defaultValue: String? = nil) {
            self.returnEnabled = returnEnabled
            self.facetEnabled = facetEnabled
            self.sourceField = sourceField
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.defaultValue = defaultValue
        }

        public init(dictionary: [String: Any]) throws {
            self.returnEnabled = dictionary["ReturnEnabled"] as? Bool
            self.facetEnabled = dictionary["FacetEnabled"] as? Bool
            self.sourceField = dictionary["SourceField"] as? String
            self.searchEnabled = dictionary["SearchEnabled"] as? Bool
            self.sortEnabled = dictionary["SortEnabled"] as? Bool
            self.defaultValue = dictionary["DefaultValue"] as? String
        }
    }

    public struct UpdateAvailabilityOptionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// You expand an existing search domain to a second Availability Zone by setting the Multi-AZ option to true. Similarly, you can turn off the Multi-AZ option to downgrade the domain to a single Availability Zone by setting the Multi-AZ option to false. 
        public let multiAZ: Bool
        public let domainName: String

        public init(multiAZ: Bool, domainName: String) {
            self.multiAZ = multiAZ
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            guard let multiAZ = dictionary["MultiAZ"] as? Bool else { throw InitializableError.missingRequiredParam("MultiAZ") }
            self.multiAZ = multiAZ
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public struct DescribeServiceAccessPoliciesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The access rules configured for the domain specified in the request.
        public let accessPolicies: AccessPoliciesStatus

        public init(accessPolicies: AccessPoliciesStatus) {
            self.accessPolicies = accessPolicies
        }

        public init(dictionary: [String: Any]) throws {
            guard let accessPolicies = dictionary["AccessPolicies"] as? [String: Any] else { throw InitializableError.missingRequiredParam("AccessPolicies") }
            self.accessPolicies = try Cloudsearch.AccessPoliciesStatus(dictionary: accessPolicies)
        }
    }

    public struct BuildSuggestersRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public struct AvailabilityOptionsStatus: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The availability options configured for the domain.
        public let options: Bool
        public let status: OptionStatus

        public init(options: Bool, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        public init(dictionary: [String: Any]) throws {
            guard let options = dictionary["Options"] as? Bool else { throw InitializableError.missingRequiredParam("Options") }
            self.options = options
            guard let status = dictionary["Status"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Status") }
            self.status = try Cloudsearch.OptionStatus(dictionary: status)
        }
    }

    public struct ServiceEndpoint: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let endpoint: String?

        public init(endpoint: String? = nil) {
            self.endpoint = endpoint
        }

        public init(dictionary: [String: Any]) throws {
            self.endpoint = dictionary["Endpoint"] as? String
        }
    }

    public struct DeleteSuggesterRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Specifies the name of the suggester you want to delete.
        public let suggesterName: String
        public let domainName: String

        public init(suggesterName: String, domainName: String) {
            self.suggesterName = suggesterName
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            guard let suggesterName = dictionary["SuggesterName"] as? String else { throw InitializableError.missingRequiredParam("SuggesterName") }
            self.suggesterName = suggesterName
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public struct Limits: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let maximumReplicationCount: Int32
        public let maximumPartitionCount: Int32

        public init(maximumReplicationCount: Int32, maximumPartitionCount: Int32) {
            self.maximumReplicationCount = maximumReplicationCount
            self.maximumPartitionCount = maximumPartitionCount
        }

        public init(dictionary: [String: Any]) throws {
            guard let maximumReplicationCount = dictionary["MaximumReplicationCount"] as? Int32 else { throw InitializableError.missingRequiredParam("MaximumReplicationCount") }
            self.maximumReplicationCount = maximumReplicationCount
            guard let maximumPartitionCount = dictionary["MaximumPartitionCount"] as? Int32 else { throw InitializableError.missingRequiredParam("MaximumPartitionCount") }
            self.maximumPartitionCount = maximumPartitionCount
        }
    }

    public struct DescribeIndexFieldsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The index fields configured for the domain.
        public let indexFields: [IndexFieldStatus]

        public init(indexFields: [IndexFieldStatus]) {
            self.indexFields = indexFields
        }

        public init(dictionary: [String: Any]) throws {
            guard let indexFields = dictionary["IndexFields"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("IndexFields") }
            self.indexFields = try indexFields.map({ try IndexFieldStatus(dictionary: $0) })
        }
    }

    public struct UpdateScalingParametersRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let scalingParameters: ScalingParameters
        public let domainName: String

        public init(scalingParameters: ScalingParameters, domainName: String) {
            self.scalingParameters = scalingParameters
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            guard let scalingParameters = dictionary["ScalingParameters"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ScalingParameters") }
            self.scalingParameters = try Cloudsearch.ScalingParameters(dictionary: scalingParameters)
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public struct DefineAnalysisSchemeResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let analysisScheme: AnalysisSchemeStatus

        public init(analysisScheme: AnalysisSchemeStatus) {
            self.analysisScheme = analysisScheme
        }

        public init(dictionary: [String: Any]) throws {
            guard let analysisScheme = dictionary["AnalysisScheme"] as? [String: Any] else { throw InitializableError.missingRequiredParam("AnalysisScheme") }
            self.analysisScheme = try Cloudsearch.AnalysisSchemeStatus(dictionary: analysisScheme)
        }
    }

    public struct DefineSuggesterResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let suggester: SuggesterStatus

        public init(suggester: SuggesterStatus) {
            self.suggester = suggester
        }

        public init(dictionary: [String: Any]) throws {
            guard let suggester = dictionary["Suggester"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Suggester") }
            self.suggester = try Cloudsearch.SuggesterStatus(dictionary: suggester)
        }
    }

    public struct DefineIndexFieldResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let indexField: IndexFieldStatus

        public init(indexField: IndexFieldStatus) {
            self.indexField = indexField
        }

        public init(dictionary: [String: Any]) throws {
            guard let indexField = dictionary["IndexField"] as? [String: Any] else { throw InitializableError.missingRequiredParam("IndexField") }
            self.indexField = try Cloudsearch.IndexFieldStatus(dictionary: indexField)
        }
    }

    public struct DescribeSuggestersResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The suggesters configured for the domain specified in the request.
        public let suggesters: [SuggesterStatus]

        public init(suggesters: [SuggesterStatus]) {
            self.suggesters = suggesters
        }

        public init(dictionary: [String: Any]) throws {
            guard let suggesters = dictionary["Suggesters"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("Suggesters") }
            self.suggesters = try suggesters.map({ try SuggesterStatus(dictionary: $0) })
        }
    }

    public enum OptionState: String, CustomStringConvertible {
        case requiresindexdocuments = "RequiresIndexDocuments"
        case processing = "Processing"
        case active = "Active"
        case failedtovalidate = "FailedToValidate"
        public var description: String { return self.rawValue }
    }

    public struct DescribeAvailabilityOptionsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The availability options configured for the domain. Indicates whether Multi-AZ is enabled for the domain. 
        public let availabilityOptions: AvailabilityOptionsStatus?

        public init(availabilityOptions: AvailabilityOptionsStatus? = nil) {
            self.availabilityOptions = availabilityOptions
        }

        public init(dictionary: [String: Any]) throws {
            if let availabilityOptions = dictionary["AvailabilityOptions"] as? [String: Any] { self.availabilityOptions = try Cloudsearch.AvailabilityOptionsStatus(dictionary: availabilityOptions) } else { self.availabilityOptions = nil }
        }
    }

    public struct CreateDomainRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A name for the domain you are creating. Allowed characters are a-z (lower-case letters), 0-9, and hyphen (-). Domain names must start with a letter or number and be at least 3 and no more than 28 characters long.
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

}