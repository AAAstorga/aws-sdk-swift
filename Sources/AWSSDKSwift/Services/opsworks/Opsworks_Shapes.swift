// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Opsworks {

    public struct DeregisterVolumeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The AWS OpsWorks volume ID, which is the GUID that AWS OpsWorks assigned to the instance when you registered the volume with the stack, not the Amazon EC2 volume ID.
        public let volumeId: String

        public init(volumeId: String) {
            self.volumeId = volumeId
        }

        public init(dictionary: [String: Any]) throws {
            guard let volumeId = dictionary["VolumeId"] as? String else { throw InitializableError.missingRequiredParam("VolumeId") }
            self.volumeId = volumeId
        }
    }

    public struct CreateUserProfileRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The user's IAM ARN; this can also be a federated user's ARN.
        public let iamUserArn: String
        /// The user's public SSH key.
        public let sshPublicKey: String?
        /// The user's SSH user name. The allowable characters are [a-z], [A-Z], [0-9], '-', and '_'. If the specified name includes other punctuation marks, AWS OpsWorks removes them. For example, my.name will be changed to myname. If you do not specify an SSH user name, AWS OpsWorks generates one from the IAM user name. 
        public let sshUsername: String?
        /// Whether users can specify their own SSH public key through the My Settings page. For more information, see Setting an IAM User's Public SSH Key.
        public let allowSelfManagement: Bool?

        public init(iamUserArn: String, sshPublicKey: String? = nil, sshUsername: String? = nil, allowSelfManagement: Bool? = nil) {
            self.iamUserArn = iamUserArn
            self.sshPublicKey = sshPublicKey
            self.sshUsername = sshUsername
            self.allowSelfManagement = allowSelfManagement
        }

        public init(dictionary: [String: Any]) throws {
            guard let iamUserArn = dictionary["IamUserArn"] as? String else { throw InitializableError.missingRequiredParam("IamUserArn") }
            self.iamUserArn = iamUserArn
            self.sshPublicKey = dictionary["SshPublicKey"] as? String
            self.sshUsername = dictionary["SshUsername"] as? String
            self.allowSelfManagement = dictionary["AllowSelfManagement"] as? Bool
        }
    }

    public struct DescribeRdsDbInstancesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The stack ID that the instances are registered with. The operation returns descriptions of all registered Amazon RDS instances.
        public let stackId: String
        /// An array containing the ARNs of the instances to be described.
        public let rdsDbInstanceArns: [String]?

        public init(stackId: String, rdsDbInstanceArns: [String]? = nil) {
            self.stackId = stackId
            self.rdsDbInstanceArns = rdsDbInstanceArns
        }

        public init(dictionary: [String: Any]) throws {
            guard let stackId = dictionary["StackId"] as? String else { throw InitializableError.missingRequiredParam("StackId") }
            self.stackId = stackId
            self.rdsDbInstanceArns = dictionary["RdsDbInstanceArns"] as? [String]
        }
    }

    public struct Layer: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The layer short name.
        public let shortname: String?
        /// An array of Package objects that describe the layer's packages.
        public let packages: [String]?
        /// A LifeCycleEventConfiguration object that specifies the Shutdown event configuration.
        public let lifecycleEventConfiguration: LifecycleEventConfiguration?
        /// A LayerCustomRecipes object that specifies the layer's custom recipes.
        public let customRecipes: Recipes?
        /// Whether to automatically assign an Elastic IP address to the layer's instances. For more information, see How to Edit a Layer.
        public let autoAssignElasticIps: Bool?
        /// Whether to install operating system and package updates when the instance boots. The default value is true. If this value is set to false, you must then update your instances manually by using CreateDeployment to run the update_dependencies stack command or manually running yum (Amazon Linux) or apt-get (Ubuntu) on the instances.   We strongly recommend using the default value of true, to ensure that your instances have the latest security updates. 
        public let installUpdatesOnBoot: Bool?
        /// A JSON formatted string containing the layer's custom stack configuration and deployment attributes.
        public let customJson: String?
        /// Date when the layer was created.
        public let createdAt: String?
        /// An array containing the layer's custom security group IDs.
        public let customSecurityGroupIds: [String]?
        /// The layer stack ID.
        public let stackId: String?
        /// The layer name.
        public let name: String?
        /// The layer ID.
        public let layerId: String?
        /// Whether auto healing is disabled for the layer.
        public let enableAutoHealing: Bool?
        /// A VolumeConfigurations object that describes the layer's Amazon EBS volumes.
        public let volumeConfigurations: [VolumeConfiguration]?
        /// An array containing the layer's security group names.
        public let defaultSecurityGroupNames: [String]?
        /// The layer attributes. For the HaproxyStatsPassword, MysqlRootPassword, and GangliaPassword attributes, AWS OpsWorks returns *****FILTERED***** instead of the actual value For an ECS Cluster layer, AWS OpsWorks the EcsClusterArn attribute is set to the cluster's ARN.
        public let attributes: [LayerAttributesKeys: String]?
        /// Whether the layer uses Amazon EBS-optimized instances.
        public let useEbsOptimizedInstances: Bool?
        public let defaultRecipes: Recipes?
        /// The layer type.
        public let `type`: LayerType?
        /// For stacks that are running in a VPC, whether to automatically assign a public IP address to the layer's instances. For more information, see How to Edit a Layer.
        public let autoAssignPublicIps: Bool?
        /// The ARN of the default IAM profile to be used for the layer's EC2 instances. For more information about IAM ARNs, see Using Identifiers.
        public let customInstanceProfileArn: String?

        public init(shortname: String? = nil, packages: [String]? = nil, lifecycleEventConfiguration: LifecycleEventConfiguration? = nil, customRecipes: Recipes? = nil, autoAssignElasticIps: Bool? = nil, installUpdatesOnBoot: Bool? = nil, customJson: String? = nil, createdAt: String? = nil, customSecurityGroupIds: [String]? = nil, stackId: String? = nil, name: String? = nil, layerId: String? = nil, enableAutoHealing: Bool? = nil, volumeConfigurations: [VolumeConfiguration]? = nil, defaultSecurityGroupNames: [String]? = nil, attributes: [LayerAttributesKeys: String]? = nil, useEbsOptimizedInstances: Bool? = nil, defaultRecipes: Recipes? = nil, type: LayerType? = nil, autoAssignPublicIps: Bool? = nil, customInstanceProfileArn: String? = nil) {
            self.shortname = shortname
            self.packages = packages
            self.lifecycleEventConfiguration = lifecycleEventConfiguration
            self.customRecipes = customRecipes
            self.autoAssignElasticIps = autoAssignElasticIps
            self.installUpdatesOnBoot = installUpdatesOnBoot
            self.customJson = customJson
            self.createdAt = createdAt
            self.customSecurityGroupIds = customSecurityGroupIds
            self.stackId = stackId
            self.name = name
            self.layerId = layerId
            self.enableAutoHealing = enableAutoHealing
            self.volumeConfigurations = volumeConfigurations
            self.defaultSecurityGroupNames = defaultSecurityGroupNames
            self.attributes = attributes
            self.useEbsOptimizedInstances = useEbsOptimizedInstances
            self.defaultRecipes = defaultRecipes
            self.`type` = `type`
            self.autoAssignPublicIps = autoAssignPublicIps
            self.customInstanceProfileArn = customInstanceProfileArn
        }

        public init(dictionary: [String: Any]) throws {
            self.shortname = dictionary["Shortname"] as? String
            self.packages = dictionary["Packages"] as? [String]
            if let lifecycleEventConfiguration = dictionary["LifecycleEventConfiguration"] as? [String: Any] { self.lifecycleEventConfiguration = try Opsworks.LifecycleEventConfiguration(dictionary: lifecycleEventConfiguration) } else { self.lifecycleEventConfiguration = nil }
            if let customRecipes = dictionary["CustomRecipes"] as? [String: Any] { self.customRecipes = try Opsworks.Recipes(dictionary: customRecipes) } else { self.customRecipes = nil }
            self.autoAssignElasticIps = dictionary["AutoAssignElasticIps"] as? Bool
            self.installUpdatesOnBoot = dictionary["InstallUpdatesOnBoot"] as? Bool
            self.customJson = dictionary["CustomJson"] as? String
            self.createdAt = dictionary["CreatedAt"] as? String
            self.customSecurityGroupIds = dictionary["CustomSecurityGroupIds"] as? [String]
            self.stackId = dictionary["StackId"] as? String
            self.name = dictionary["Name"] as? String
            self.layerId = dictionary["LayerId"] as? String
            self.enableAutoHealing = dictionary["EnableAutoHealing"] as? Bool
            if let volumeConfigurations = dictionary["VolumeConfigurations"] as? [[String: Any]] {
                self.volumeConfigurations = try volumeConfigurations.map({ try VolumeConfiguration(dictionary: $0) })
            } else { 
                self.volumeConfigurations = nil
            }
            self.defaultSecurityGroupNames = dictionary["DefaultSecurityGroupNames"] as? [String]
            if let attributes = dictionary["Attributes"] as? [LayerAttributesKeys: String] {
                self.attributes = attributes
            } else { 
                self.attributes = nil
            }
            self.useEbsOptimizedInstances = dictionary["UseEbsOptimizedInstances"] as? Bool
            if let defaultRecipes = dictionary["DefaultRecipes"] as? [String: Any] { self.defaultRecipes = try Opsworks.Recipes(dictionary: defaultRecipes) } else { self.defaultRecipes = nil }
            if let `type` = dictionary["Type"] as? String { self.`type` = LayerType(rawValue: `type`) } else { self.`type` = nil }
            self.autoAssignPublicIps = dictionary["AutoAssignPublicIps"] as? Bool
            self.customInstanceProfileArn = dictionary["CustomInstanceProfileArn"] as? String
        }
    }

    public struct SetTimeBasedAutoScalingRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The instance ID.
        public let instanceId: String
        /// An AutoScalingSchedule with the instance schedule.
        public let autoScalingSchedule: WeeklyAutoScalingSchedule?

        public init(instanceId: String, autoScalingSchedule: WeeklyAutoScalingSchedule? = nil) {
            self.instanceId = instanceId
            self.autoScalingSchedule = autoScalingSchedule
        }

        public init(dictionary: [String: Any]) throws {
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            if let autoScalingSchedule = dictionary["AutoScalingSchedule"] as? [String: Any] { self.autoScalingSchedule = try Opsworks.WeeklyAutoScalingSchedule(dictionary: autoScalingSchedule) } else { self.autoScalingSchedule = nil }
        }
    }

    public struct DescribeRaidArraysRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The stack ID.
        public let stackId: String?
        /// An array of RAID array IDs. If you use this parameter, DescribeRaidArrays returns descriptions of the specified arrays. Otherwise, it returns a description of every array.
        public let raidArrayIds: [String]?
        /// The instance ID. If you use this parameter, DescribeRaidArrays returns descriptions of the RAID arrays associated with the specified instance. 
        public let instanceId: String?

        public init(stackId: String? = nil, raidArrayIds: [String]? = nil, instanceId: String? = nil) {
            self.stackId = stackId
            self.raidArrayIds = raidArrayIds
            self.instanceId = instanceId
        }

        public init(dictionary: [String: Any]) throws {
            self.stackId = dictionary["StackId"] as? String
            self.raidArrayIds = dictionary["RaidArrayIds"] as? [String]
            self.instanceId = dictionary["InstanceId"] as? String
        }
    }

    public struct StackSummary: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An InstancesCount object with the number of instances in each status.
        public let instancesCount: InstancesCount?
        /// The number of layers.
        public let layersCount: Int32?
        /// The stack's ARN.
        public let arn: String?
        /// The stack ID.
        public let stackId: String?
        /// The stack name.
        public let name: String?
        /// The number of apps.
        public let appsCount: Int32?

        public init(instancesCount: InstancesCount? = nil, layersCount: Int32? = nil, arn: String? = nil, stackId: String? = nil, name: String? = nil, appsCount: Int32? = nil) {
            self.instancesCount = instancesCount
            self.layersCount = layersCount
            self.arn = arn
            self.stackId = stackId
            self.name = name
            self.appsCount = appsCount
        }

        public init(dictionary: [String: Any]) throws {
            if let instancesCount = dictionary["InstancesCount"] as? [String: Any] { self.instancesCount = try Opsworks.InstancesCount(dictionary: instancesCount) } else { self.instancesCount = nil }
            self.layersCount = dictionary["LayersCount"] as? Int32
            self.arn = dictionary["Arn"] as? String
            self.stackId = dictionary["StackId"] as? String
            self.name = dictionary["Name"] as? String
            self.appsCount = dictionary["AppsCount"] as? Int32
        }
    }

    public struct DescribeCommandsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of Command objects that describe each of the specified commands.
        public let commands: [Command]?

        public init(commands: [Command]? = nil) {
            self.commands = commands
        }

        public init(dictionary: [String: Any]) throws {
            if let commands = dictionary["Commands"] as? [[String: Any]] {
                self.commands = try commands.map({ try Command(dictionary: $0) })
            } else { 
                self.commands = nil
            }
        }
    }

    public struct DeregisterEcsClusterRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The cluster's ARN.
        public let ecsClusterArn: String

        public init(ecsClusterArn: String) {
            self.ecsClusterArn = ecsClusterArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let ecsClusterArn = dictionary["EcsClusterArn"] as? String else { throw InitializableError.missingRequiredParam("EcsClusterArn") }
            self.ecsClusterArn = ecsClusterArn
        }
    }

    public struct DescribeEcsClustersResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of EcsCluster objects containing the cluster descriptions.
        public let ecsClusters: [EcsCluster]?
        /// If a paginated request does not return all of the remaining results, this parameter is set to a token that you can assign to the request object's NextToken parameter to retrieve the next set of results. If the previous paginated request returned all of the remaining results, this parameter is set to null.
        public let nextToken: String?

        public init(ecsClusters: [EcsCluster]? = nil, nextToken: String? = nil) {
            self.ecsClusters = ecsClusters
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let ecsClusters = dictionary["EcsClusters"] as? [[String: Any]] {
                self.ecsClusters = try ecsClusters.map({ try EcsCluster(dictionary: $0) })
            } else { 
                self.ecsClusters = nil
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct UpdateUserProfileRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The user IAM ARN. This can also be a federated user's ARN.
        public let iamUserArn: String
        /// The user's new SSH public key.
        public let sshPublicKey: String?
        /// The user's SSH user name. The allowable characters are [a-z], [A-Z], [0-9], '-', and '_'. If the specified name includes other punctuation marks, AWS OpsWorks removes them. For example, my.name will be changed to myname. If you do not specify an SSH user name, AWS OpsWorks generates one from the IAM user name. 
        public let sshUsername: String?
        /// Whether users can specify their own SSH public key through the My Settings page. For more information, see Managing User Permissions.
        public let allowSelfManagement: Bool?

        public init(iamUserArn: String, sshPublicKey: String? = nil, sshUsername: String? = nil, allowSelfManagement: Bool? = nil) {
            self.iamUserArn = iamUserArn
            self.sshPublicKey = sshPublicKey
            self.sshUsername = sshUsername
            self.allowSelfManagement = allowSelfManagement
        }

        public init(dictionary: [String: Any]) throws {
            guard let iamUserArn = dictionary["IamUserArn"] as? String else { throw InitializableError.missingRequiredParam("IamUserArn") }
            self.iamUserArn = iamUserArn
            self.sshPublicKey = dictionary["SshPublicKey"] as? String
            self.sshUsername = dictionary["SshUsername"] as? String
            self.allowSelfManagement = dictionary["AllowSelfManagement"] as? Bool
        }
    }

    public struct DescribeStacksRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of stack IDs that specify the stacks to be described. If you omit this parameter, DescribeStacks returns a description of every stack.
        public let stackIds: [String]?

        public init(stackIds: [String]? = nil) {
            self.stackIds = stackIds
        }

        public init(dictionary: [String: Any]) throws {
            self.stackIds = dictionary["StackIds"] as? [String]
        }
    }

    public struct SslConfiguration: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The contents of the certificate's domain.crt file.
        public let certificate: String
        /// Optional. Can be used to specify an intermediate certificate authority key or client authentication.
        public let chain: String?
        /// The private key; the contents of the certificate's domain.kex file.
        public let privateKey: String

        public init(certificate: String, chain: String? = nil, privateKey: String) {
            self.certificate = certificate
            self.chain = chain
            self.privateKey = privateKey
        }

        public init(dictionary: [String: Any]) throws {
            guard let certificate = dictionary["Certificate"] as? String else { throw InitializableError.missingRequiredParam("Certificate") }
            self.certificate = certificate
            self.chain = dictionary["Chain"] as? String
            guard let privateKey = dictionary["PrivateKey"] as? String else { throw InitializableError.missingRequiredParam("PrivateKey") }
            self.privateKey = privateKey
        }
    }

    public struct DescribeElasticIpsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A stack ID. If you include this parameter, DescribeElasticIps returns a description of the Elastic IP addresses that are registered with the specified stack.
        public let stackId: String?
        /// An array of Elastic IP addresses to be described. If you include this parameter, DescribeElasticIps returns a description of the specified Elastic IP addresses. Otherwise, it returns a description of every Elastic IP address.
        public let ips: [String]?
        /// The instance ID. If you include this parameter, DescribeElasticIps returns a description of the Elastic IP addresses associated with the specified instance.
        public let instanceId: String?

        public init(stackId: String? = nil, ips: [String]? = nil, instanceId: String? = nil) {
            self.stackId = stackId
            self.ips = ips
            self.instanceId = instanceId
        }

        public init(dictionary: [String: Any]) throws {
            self.stackId = dictionary["StackId"] as? String
            self.ips = dictionary["Ips"] as? [String]
            self.instanceId = dictionary["InstanceId"] as? String
        }
    }

    public struct StackConfigurationManager: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name. This parameter must be set to "Chef".
        public let name: String?
        /// The Chef version. This parameter must be set to 12, 11.10, or 11.4 for Linux stacks, and to 12.2 for Windows stacks. The default value for Linux stacks is 11.4.
        public let version: String?

        public init(name: String? = nil, version: String? = nil) {
            self.name = name
            self.version = version
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["Name"] as? String
            self.version = dictionary["Version"] as? String
        }
    }

    public struct UpdateAppRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The app ID.
        public let appId: String
        /// The app name.
        public let name: String?
        /// The app's data sources.
        public let dataSources: [DataSource]?
        /// An array of EnvironmentVariable objects that specify environment variables to be associated with the app. After you deploy the app, these variables are defined on the associated app server instances.For more information, see  Environment Variables. There is no specific limit on the number of environment variables. However, the size of the associated data structure - which includes the variables' names, values, and protected flag values - cannot exceed 10 KB (10240 Bytes). This limit should accommodate most if not all use cases. Exceeding it will cause an exception with the message, "Environment: is too large (maximum is 10KB)."  This parameter is supported only by Chef 11.10 stacks. If you have specified one or more environment variables, you cannot modify the stack's Chef version. 
        public let environment: [EnvironmentVariable]?
        /// A Source object that specifies the app repository.
        public let appSource: Source?
        /// An SslConfiguration object with the SSL configuration.
        public let sslConfiguration: SslConfiguration?
        /// One or more user-defined key/value pairs to be added to the stack attributes.
        public let attributes: [AppAttributesKeys: String]?
        /// Whether SSL is enabled for the app.
        public let enableSsl: Bool?
        /// The app type.
        public let `type`: AppType?
        /// The app's virtual host settings, with multiple domains separated by commas. For example: 'www.example.com, example.com' 
        public let domains: [String]?
        /// A description of the app.
        public let description: String?

        public init(appId: String, name: String? = nil, dataSources: [DataSource]? = nil, environment: [EnvironmentVariable]? = nil, appSource: Source? = nil, sslConfiguration: SslConfiguration? = nil, attributes: [AppAttributesKeys: String]? = nil, enableSsl: Bool? = nil, type: AppType? = nil, domains: [String]? = nil, description: String? = nil) {
            self.appId = appId
            self.name = name
            self.dataSources = dataSources
            self.environment = environment
            self.appSource = appSource
            self.sslConfiguration = sslConfiguration
            self.attributes = attributes
            self.enableSsl = enableSsl
            self.`type` = `type`
            self.domains = domains
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            guard let appId = dictionary["AppId"] as? String else { throw InitializableError.missingRequiredParam("AppId") }
            self.appId = appId
            self.name = dictionary["Name"] as? String
            if let dataSources = dictionary["DataSources"] as? [[String: Any]] {
                self.dataSources = try dataSources.map({ try DataSource(dictionary: $0) })
            } else { 
                self.dataSources = nil
            }
            if let environment = dictionary["Environment"] as? [[String: Any]] {
                self.environment = try environment.map({ try EnvironmentVariable(dictionary: $0) })
            } else { 
                self.environment = nil
            }
            if let appSource = dictionary["AppSource"] as? [String: Any] { self.appSource = try Opsworks.Source(dictionary: appSource) } else { self.appSource = nil }
            if let sslConfiguration = dictionary["SslConfiguration"] as? [String: Any] { self.sslConfiguration = try Opsworks.SslConfiguration(dictionary: sslConfiguration) } else { self.sslConfiguration = nil }
            if let attributes = dictionary["Attributes"] as? [AppAttributesKeys: String] {
                self.attributes = attributes
            } else { 
                self.attributes = nil
            }
            self.enableSsl = dictionary["EnableSsl"] as? Bool
            if let `type` = dictionary["Type"] as? String { self.`type` = AppType(rawValue: `type`) } else { self.`type` = nil }
            self.domains = dictionary["Domains"] as? [String]
            self.description = dictionary["Description"] as? String
        }
    }

    public struct Instance: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// For container instances, the instance's ARN.
        public let ecsContainerInstanceArn: String?
        /// The instance host name.
        public let hostname: String?
        /// Whether this is an Amazon EBS-optimized instance.
        public let ebsOptimized: Bool?
        /// Whether to install operating system and package updates when the instance boots. The default value is true. If this value is set to false, you must then update your instances manually by using CreateDeployment to run the update_dependencies stack command or by manually running yum (Amazon Linux) or apt-get (Ubuntu) on the instances.   We strongly recommend using the default value of true, to ensure that your instances have the latest security updates. 
        public let installUpdatesOnBoot: Bool?
        /// The instance public IP address.
        public let publicIp: String?
        /// The instance type, such as t2.micro.
        public let instanceType: String?
        /// The instance Availability Zone. For more information, see Regions and Endpoints.
        public let availabilityZone: String?
        /// The ID of the associated Amazon EC2 instance.
        public let ec2InstanceId: String?
        /// The instance status:    booting     connection_lost     online     pending     rebooting     requested     running_setup     setup_failed     shutting_down     start_failed     stop_failed     stopped     stopping     terminated     terminating   
        public let status: String?
        /// The instance's reported AWS OpsWorks agent version.
        public let reportedAgentVersion: String?
        /// The stack ID.
        public let stackId: String?
        /// The instance Elastic IP address .
        public let elasticIp: String?
        /// The instance ID.
        public let instanceId: String?
        /// The instance's Amazon EC2 key-pair name.
        public let sshKeyName: String?
        /// The instance's root device type. For more information, see Storage for the Root Device.
        public let rootDeviceType: RootDeviceType?
        /// The ID of the last service error. For more information, call DescribeServiceErrors.
        public let lastServiceErrorId: String?
        /// The instance public DNS name.
        public let publicDns: String?
        /// An array containing the instance layer IDs.
        public let layerIds: [String]?
        /// The instance's subnet ID; applicable only if the stack is running in a VPC.
        public let subnetId: String?
        /// An array of BlockDeviceMapping objects that specify the instance's block device mappings.
        public let blockDeviceMappings: [BlockDeviceMapping]?
        /// The instance's platform.
        public let platform: String?
        /// For container instances, the Amazon ECS cluster's ARN.
        public let ecsClusterArn: String?
        /// The instance's private IP address.
        public let privateIp: String?
        /// For registered instances, the infrastructure class: ec2 or on-premises.
        public let infrastructureClass: String?
        /// An array containing the instance security group IDs.
        public let securityGroupIds: [String]?
        /// A custom AMI ID to be used to create the instance. For more information, see Instances 
        public let amiId: String?
        /// The The instance's private DNS name.
        public let privateDns: String?
        /// The root device volume ID.
        public let rootDeviceVolumeId: String?
        /// The instance's tenancy option, such as dedicated or host.
        public let tenancy: String?
        /// The SSH key's RSA fingerprint.
        public let sshHostRsaKeyFingerprint: String?
        /// For registered instances, who performed the registration.
        public let registeredBy: String?
        /// The time that the instance was created.
        public let createdAt: String?
        /// For registered instances, the reported operating system.
        public let reportedOs: ReportedOs?
        /// The agent version. This parameter is set to INHERIT if the instance inherits the default stack setting or to a a version number for a fixed agent version.
        public let agentVersion: String?
        /// The SSH key's Deep Security Agent (DSA) fingerprint.
        public let sshHostDsaKeyFingerprint: String?
        /// The instance architecture: "i386" or "x86_64".
        public let architecture: Architecture?
        /// The ARN of the instance's IAM profile. For more information about IAM ARNs, see Using Identifiers.
        public let instanceProfileArn: String?
        /// The instance's operating system.
        public let os: String?
        /// For load-based or time-based instances, the type.
        public let autoScalingType: AutoScalingType?
        /// The instance's virtualization type: paravirtual or hvm.
        public let virtualizationType: VirtualizationType?

        public init(ecsContainerInstanceArn: String? = nil, hostname: String? = nil, ebsOptimized: Bool? = nil, installUpdatesOnBoot: Bool? = nil, publicIp: String? = nil, instanceType: String? = nil, availabilityZone: String? = nil, ec2InstanceId: String? = nil, status: String? = nil, reportedAgentVersion: String? = nil, stackId: String? = nil, elasticIp: String? = nil, instanceId: String? = nil, sshKeyName: String? = nil, rootDeviceType: RootDeviceType? = nil, lastServiceErrorId: String? = nil, publicDns: String? = nil, layerIds: [String]? = nil, subnetId: String? = nil, blockDeviceMappings: [BlockDeviceMapping]? = nil, platform: String? = nil, ecsClusterArn: String? = nil, privateIp: String? = nil, infrastructureClass: String? = nil, securityGroupIds: [String]? = nil, amiId: String? = nil, privateDns: String? = nil, rootDeviceVolumeId: String? = nil, tenancy: String? = nil, sshHostRsaKeyFingerprint: String? = nil, registeredBy: String? = nil, createdAt: String? = nil, reportedOs: ReportedOs? = nil, agentVersion: String? = nil, sshHostDsaKeyFingerprint: String? = nil, architecture: Architecture? = nil, instanceProfileArn: String? = nil, os: String? = nil, autoScalingType: AutoScalingType? = nil, virtualizationType: VirtualizationType? = nil) {
            self.ecsContainerInstanceArn = ecsContainerInstanceArn
            self.hostname = hostname
            self.ebsOptimized = ebsOptimized
            self.installUpdatesOnBoot = installUpdatesOnBoot
            self.publicIp = publicIp
            self.instanceType = instanceType
            self.availabilityZone = availabilityZone
            self.ec2InstanceId = ec2InstanceId
            self.status = status
            self.reportedAgentVersion = reportedAgentVersion
            self.stackId = stackId
            self.elasticIp = elasticIp
            self.instanceId = instanceId
            self.sshKeyName = sshKeyName
            self.rootDeviceType = rootDeviceType
            self.lastServiceErrorId = lastServiceErrorId
            self.publicDns = publicDns
            self.layerIds = layerIds
            self.subnetId = subnetId
            self.blockDeviceMappings = blockDeviceMappings
            self.platform = platform
            self.ecsClusterArn = ecsClusterArn
            self.privateIp = privateIp
            self.infrastructureClass = infrastructureClass
            self.securityGroupIds = securityGroupIds
            self.amiId = amiId
            self.privateDns = privateDns
            self.rootDeviceVolumeId = rootDeviceVolumeId
            self.tenancy = tenancy
            self.sshHostRsaKeyFingerprint = sshHostRsaKeyFingerprint
            self.registeredBy = registeredBy
            self.createdAt = createdAt
            self.reportedOs = reportedOs
            self.agentVersion = agentVersion
            self.sshHostDsaKeyFingerprint = sshHostDsaKeyFingerprint
            self.architecture = architecture
            self.instanceProfileArn = instanceProfileArn
            self.os = os
            self.autoScalingType = autoScalingType
            self.virtualizationType = virtualizationType
        }

        public init(dictionary: [String: Any]) throws {
            self.ecsContainerInstanceArn = dictionary["EcsContainerInstanceArn"] as? String
            self.hostname = dictionary["Hostname"] as? String
            self.ebsOptimized = dictionary["EbsOptimized"] as? Bool
            self.installUpdatesOnBoot = dictionary["InstallUpdatesOnBoot"] as? Bool
            self.publicIp = dictionary["PublicIp"] as? String
            self.instanceType = dictionary["InstanceType"] as? String
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.ec2InstanceId = dictionary["Ec2InstanceId"] as? String
            self.status = dictionary["Status"] as? String
            self.reportedAgentVersion = dictionary["ReportedAgentVersion"] as? String
            self.stackId = dictionary["StackId"] as? String
            self.elasticIp = dictionary["ElasticIp"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            self.sshKeyName = dictionary["SshKeyName"] as? String
            if let rootDeviceType = dictionary["RootDeviceType"] as? String { self.rootDeviceType = RootDeviceType(rawValue: rootDeviceType) } else { self.rootDeviceType = nil }
            self.lastServiceErrorId = dictionary["LastServiceErrorId"] as? String
            self.publicDns = dictionary["PublicDns"] as? String
            self.layerIds = dictionary["LayerIds"] as? [String]
            self.subnetId = dictionary["SubnetId"] as? String
            if let blockDeviceMappings = dictionary["BlockDeviceMappings"] as? [[String: Any]] {
                self.blockDeviceMappings = try blockDeviceMappings.map({ try BlockDeviceMapping(dictionary: $0) })
            } else { 
                self.blockDeviceMappings = nil
            }
            self.platform = dictionary["Platform"] as? String
            self.ecsClusterArn = dictionary["EcsClusterArn"] as? String
            self.privateIp = dictionary["PrivateIp"] as? String
            self.infrastructureClass = dictionary["InfrastructureClass"] as? String
            self.securityGroupIds = dictionary["SecurityGroupIds"] as? [String]
            self.amiId = dictionary["AmiId"] as? String
            self.privateDns = dictionary["PrivateDns"] as? String
            self.rootDeviceVolumeId = dictionary["RootDeviceVolumeId"] as? String
            self.tenancy = dictionary["Tenancy"] as? String
            self.sshHostRsaKeyFingerprint = dictionary["SshHostRsaKeyFingerprint"] as? String
            self.registeredBy = dictionary["RegisteredBy"] as? String
            self.createdAt = dictionary["CreatedAt"] as? String
            if let reportedOs = dictionary["ReportedOs"] as? [String: Any] { self.reportedOs = try Opsworks.ReportedOs(dictionary: reportedOs) } else { self.reportedOs = nil }
            self.agentVersion = dictionary["AgentVersion"] as? String
            self.sshHostDsaKeyFingerprint = dictionary["SshHostDsaKeyFingerprint"] as? String
            if let architecture = dictionary["Architecture"] as? String { self.architecture = Architecture(rawValue: architecture) } else { self.architecture = nil }
            self.instanceProfileArn = dictionary["InstanceProfileArn"] as? String
            self.os = dictionary["Os"] as? String
            if let autoScalingType = dictionary["AutoScalingType"] as? String { self.autoScalingType = AutoScalingType(rawValue: autoScalingType) } else { self.autoScalingType = nil }
            if let virtualizationType = dictionary["VirtualizationType"] as? String { self.virtualizationType = VirtualizationType(rawValue: virtualizationType) } else { self.virtualizationType = nil }
        }
    }

    public struct DescribeUserProfilesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of IAM or federated user ARNs that identify the users to be described.
        public let iamUserArns: [String]?

        public init(iamUserArns: [String]? = nil) {
            self.iamUserArns = iamUserArns
        }

        public init(dictionary: [String: Any]) throws {
            self.iamUserArns = dictionary["IamUserArns"] as? [String]
        }
    }

    public struct DeleteInstanceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Whether to delete the instance's Amazon EBS volumes.
        public let deleteVolumes: Bool?
        /// The instance ID.
        public let instanceId: String
        /// Whether to delete the instance Elastic IP address.
        public let deleteElasticIp: Bool?

        public init(deleteVolumes: Bool? = nil, instanceId: String, deleteElasticIp: Bool? = nil) {
            self.deleteVolumes = deleteVolumes
            self.instanceId = instanceId
            self.deleteElasticIp = deleteElasticIp
        }

        public init(dictionary: [String: Any]) throws {
            self.deleteVolumes = dictionary["DeleteVolumes"] as? Bool
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            self.deleteElasticIp = dictionary["DeleteElasticIp"] as? Bool
        }
    }

    public struct InstancesCount: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The number of instances with pending status.
        public let pending: Int32?
        /// The number of instances with stopping status.
        public let stopping: Int32?
        /// The number of instances with booting status.
        public let booting: Int32?
        /// The number of instances with online status.
        public let online: Int32?
        /// The number of instances with running_setup status.
        public let runningSetup: Int32?
        /// The number of instances with terminated status.
        public let terminated: Int32?
        /// The number of instances with setup_failed status.
        public let setupFailed: Int32?
        /// The number of instances in the Assigning state.
        public let assigning: Int32?
        /// The number of instances with connection_lost status.
        public let connectionLost: Int32?
        /// The number of instances with terminating status.
        public let terminating: Int32?
        /// The number of instances with shutting_down status.
        public let shuttingDown: Int32?
        /// The number of instances in the Registering state.
        public let registering: Int32?
        /// The number of instances with rebooting status.
        public let rebooting: Int32?
        /// The number of instances in the Unassigning state.
        public let unassigning: Int32?
        /// The number of instances with stopped status.
        public let stopped: Int32?
        /// The number of instances with start_failed status.
        public let startFailed: Int32?
        /// The number of instances in the Registered state.
        public let registered: Int32?
        /// The number of instances in the Deregistering state.
        public let deregistering: Int32?
        /// The number of instances with requested status.
        public let requested: Int32?

        public init(pending: Int32? = nil, stopping: Int32? = nil, booting: Int32? = nil, online: Int32? = nil, runningSetup: Int32? = nil, terminated: Int32? = nil, setupFailed: Int32? = nil, assigning: Int32? = nil, connectionLost: Int32? = nil, terminating: Int32? = nil, shuttingDown: Int32? = nil, registering: Int32? = nil, rebooting: Int32? = nil, unassigning: Int32? = nil, stopped: Int32? = nil, startFailed: Int32? = nil, registered: Int32? = nil, deregistering: Int32? = nil, requested: Int32? = nil) {
            self.pending = pending
            self.stopping = stopping
            self.booting = booting
            self.online = online
            self.runningSetup = runningSetup
            self.terminated = terminated
            self.setupFailed = setupFailed
            self.assigning = assigning
            self.connectionLost = connectionLost
            self.terminating = terminating
            self.shuttingDown = shuttingDown
            self.registering = registering
            self.rebooting = rebooting
            self.unassigning = unassigning
            self.stopped = stopped
            self.startFailed = startFailed
            self.registered = registered
            self.deregistering = deregistering
            self.requested = requested
        }

        public init(dictionary: [String: Any]) throws {
            self.pending = dictionary["Pending"] as? Int32
            self.stopping = dictionary["Stopping"] as? Int32
            self.booting = dictionary["Booting"] as? Int32
            self.online = dictionary["Online"] as? Int32
            self.runningSetup = dictionary["RunningSetup"] as? Int32
            self.terminated = dictionary["Terminated"] as? Int32
            self.setupFailed = dictionary["SetupFailed"] as? Int32
            self.assigning = dictionary["Assigning"] as? Int32
            self.connectionLost = dictionary["ConnectionLost"] as? Int32
            self.terminating = dictionary["Terminating"] as? Int32
            self.shuttingDown = dictionary["ShuttingDown"] as? Int32
            self.registering = dictionary["Registering"] as? Int32
            self.rebooting = dictionary["Rebooting"] as? Int32
            self.unassigning = dictionary["Unassigning"] as? Int32
            self.stopped = dictionary["Stopped"] as? Int32
            self.startFailed = dictionary["StartFailed"] as? Int32
            self.registered = dictionary["Registered"] as? Int32
            self.deregistering = dictionary["Deregistering"] as? Int32
            self.requested = dictionary["Requested"] as? Int32
        }
    }

    public struct CreateLayerRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// For custom layers only, use this parameter to specify the layer's short name, which is used internally by AWS OpsWorks and by Chef recipes. The short name is also used as the name for the directory where your app files are installed. It can have a maximum of 200 characters, which are limited to the alphanumeric characters, '-', '_', and '.'. The built-in layers' short names are defined by AWS OpsWorks. For more information, see the Layer Reference.
        public let shortname: String
        /// An array of Package objects that describes the layer packages.
        public let packages: [String]?
        /// A LifeCycleEventConfiguration object that you can use to configure the Shutdown event to specify an execution timeout and enable or disable Elastic Load Balancer connection draining.
        public let lifecycleEventConfiguration: LifecycleEventConfiguration?
        /// A LayerCustomRecipes object that specifies the layer custom recipes.
        public let customRecipes: Recipes?
        /// Whether to automatically assign an Elastic IP address to the layer's instances. For more information, see How to Edit a Layer.
        public let autoAssignElasticIps: Bool?
        /// Whether to install operating system and package updates when the instance boots. The default value is true. To control when updates are installed, set this value to false. You must then update your instances manually by using CreateDeployment to run the update_dependencies stack command or by manually running yum (Amazon Linux) or apt-get (Ubuntu) on the instances.   To ensure that your instances have the latest security updates, we strongly recommend using the default value of true. 
        public let installUpdatesOnBoot: Bool?
        /// A JSON-formatted string containing custom stack configuration and deployment attributes to be installed on the layer's instances. For more information, see  Using Custom JSON. This feature is supported as of version 1.7.42 of the AWS CLI. 
        public let customJson: String?
        /// An array containing the layer custom security group IDs.
        public let customSecurityGroupIds: [String]?
        /// The layer stack ID.
        public let stackId: String
        /// The layer name, which is used by the console.
        public let name: String
        /// The ARN of an IAM profile to be used for the layer's EC2 instances. For more information about IAM ARNs, see Using Identifiers.
        public let customInstanceProfileArn: String?
        /// Whether to disable auto healing for the layer.
        public let enableAutoHealing: Bool?
        /// A VolumeConfigurations object that describes the layer's Amazon EBS volumes.
        public let volumeConfigurations: [VolumeConfiguration]?
        /// One or more user-defined key-value pairs to be added to the stack attributes. To create a cluster layer, set the EcsClusterArn attribute to the cluster's ARN.
        public let attributes: [LayerAttributesKeys: String]?
        /// Whether to use Amazon EBS-optimized instances.
        public let useEbsOptimizedInstances: Bool?
        /// For stacks that are running in a VPC, whether to automatically assign a public IP address to the layer's instances. For more information, see How to Edit a Layer.
        public let autoAssignPublicIps: Bool?
        /// The layer type. A stack cannot have more than one built-in layer of the same type. It can have any number of custom layers. Built-in layers are not available in Chef 12 stacks.
        public let `type`: LayerType

        public init(shortname: String, packages: [String]? = nil, lifecycleEventConfiguration: LifecycleEventConfiguration? = nil, customRecipes: Recipes? = nil, autoAssignElasticIps: Bool? = nil, installUpdatesOnBoot: Bool? = nil, customJson: String? = nil, customSecurityGroupIds: [String]? = nil, stackId: String, name: String, customInstanceProfileArn: String? = nil, enableAutoHealing: Bool? = nil, volumeConfigurations: [VolumeConfiguration]? = nil, attributes: [LayerAttributesKeys: String]? = nil, useEbsOptimizedInstances: Bool? = nil, autoAssignPublicIps: Bool? = nil, type: LayerType) {
            self.shortname = shortname
            self.packages = packages
            self.lifecycleEventConfiguration = lifecycleEventConfiguration
            self.customRecipes = customRecipes
            self.autoAssignElasticIps = autoAssignElasticIps
            self.installUpdatesOnBoot = installUpdatesOnBoot
            self.customJson = customJson
            self.customSecurityGroupIds = customSecurityGroupIds
            self.stackId = stackId
            self.name = name
            self.customInstanceProfileArn = customInstanceProfileArn
            self.enableAutoHealing = enableAutoHealing
            self.volumeConfigurations = volumeConfigurations
            self.attributes = attributes
            self.useEbsOptimizedInstances = useEbsOptimizedInstances
            self.autoAssignPublicIps = autoAssignPublicIps
            self.`type` = `type`
        }

        public init(dictionary: [String: Any]) throws {
            guard let shortname = dictionary["Shortname"] as? String else { throw InitializableError.missingRequiredParam("Shortname") }
            self.shortname = shortname
            self.packages = dictionary["Packages"] as? [String]
            if let lifecycleEventConfiguration = dictionary["LifecycleEventConfiguration"] as? [String: Any] { self.lifecycleEventConfiguration = try Opsworks.LifecycleEventConfiguration(dictionary: lifecycleEventConfiguration) } else { self.lifecycleEventConfiguration = nil }
            if let customRecipes = dictionary["CustomRecipes"] as? [String: Any] { self.customRecipes = try Opsworks.Recipes(dictionary: customRecipes) } else { self.customRecipes = nil }
            self.autoAssignElasticIps = dictionary["AutoAssignElasticIps"] as? Bool
            self.installUpdatesOnBoot = dictionary["InstallUpdatesOnBoot"] as? Bool
            self.customJson = dictionary["CustomJson"] as? String
            self.customSecurityGroupIds = dictionary["CustomSecurityGroupIds"] as? [String]
            guard let stackId = dictionary["StackId"] as? String else { throw InitializableError.missingRequiredParam("StackId") }
            self.stackId = stackId
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            self.customInstanceProfileArn = dictionary["CustomInstanceProfileArn"] as? String
            self.enableAutoHealing = dictionary["EnableAutoHealing"] as? Bool
            if let volumeConfigurations = dictionary["VolumeConfigurations"] as? [[String: Any]] {
                self.volumeConfigurations = try volumeConfigurations.map({ try VolumeConfiguration(dictionary: $0) })
            } else { 
                self.volumeConfigurations = nil
            }
            if let attributes = dictionary["Attributes"] as? [LayerAttributesKeys: String] {
                self.attributes = attributes
            } else { 
                self.attributes = nil
            }
            self.useEbsOptimizedInstances = dictionary["UseEbsOptimizedInstances"] as? Bool
            self.autoAssignPublicIps = dictionary["AutoAssignPublicIps"] as? Bool
            guard let rawType = dictionary["Type"] as? String, let `type` = LayerType(rawValue: rawType) else { throw InitializableError.missingRequiredParam("Type") }
            self.`type` = `type`
        }
    }

    public struct UpdateInstanceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The instance's layer IDs.
        public let layerIds: [String]?
        /// The instance host name.
        public let hostname: String?
        /// The default AWS OpsWorks agent version. You have the following options:    INHERIT - Use the stack's default agent version setting.    version_number - Use the specified agent version. This value overrides the stack's default setting. To update the agent version, you must edit the instance configuration and specify a new version. AWS OpsWorks then automatically installs that version on the instance.   The default setting is INHERIT. To specify an agent version, you must use the complete version number, not the abbreviated number shown on the console. For a list of available agent version numbers, call DescribeAgentVersions.
        public let agentVersion: String?
        /// This property cannot be updated.
        public let ebsOptimized: Bool?
        /// The instance architecture. Instance types do not necessarily support both architectures. For a list of the architectures that are supported by the different instance types, see Instance Families and Types.
        public let architecture: Architecture?
        /// The ID of the AMI that was used to create the instance. The value of this parameter must be the same AMI ID that the instance is already using. You cannot apply a new AMI to an instance by running UpdateInstance. UpdateInstance does not work on instances that are using custom AMIs. 
        public let amiId: String?
        /// For load-based or time-based instances, the type. Windows stacks can use only time-based instances.
        public let autoScalingType: AutoScalingType?
        /// Whether to install operating system and package updates when the instance boots. The default value is true. To control when updates are installed, set this value to false. You must then update your instances manually by using CreateDeployment to run the update_dependencies stack command or by manually running yum (Amazon Linux) or apt-get (Ubuntu) on the instances.   We strongly recommend using the default value of true, to ensure that your instances have the latest security updates. 
        public let installUpdatesOnBoot: Bool?
        /// The instance ID.
        public let instanceId: String
        /// The instance type, such as t2.micro. For a list of supported instance types, open the stack in the console, choose Instances, and choose + Instance. The Size list contains the currently supported types. For more information, see Instance Families and Types. The parameter values that you use to specify the various types are in the API Name column of the Available Instance Types table.
        public let instanceType: String?
        /// The instance's operating system, which must be set to one of the following. You cannot update an instance that is using a custom AMI.   A supported Linux operating system: An Amazon Linux version, such as Amazon Linux 2016.03, Amazon Linux 2015.09, or Amazon Linux 2015.03.   A supported Ubuntu operating system, such as Ubuntu 16.04 LTS, Ubuntu 14.04 LTS, or Ubuntu 12.04 LTS.    CentOS 7     Red Hat Enterprise Linux 7    A supported Windows operating system, such as Microsoft Windows Server 2012 R2 Base, Microsoft Windows Server 2012 R2 with SQL Server Express, Microsoft Windows Server 2012 R2 with SQL Server Standard, or Microsoft Windows Server 2012 R2 with SQL Server Web.   For more information on the supported operating systems, see AWS OpsWorks Operating Systems. The default option is the current Amazon Linux version. If you set this parameter to Custom, you must use the AmiId parameter to specify the custom AMI that you want to use. For more information on the supported operating systems, see Operating Systems. For more information on how to use custom AMIs with OpsWorks, see Using Custom AMIs.  You can specify a different Linux operating system for the updated stack, but you cannot change from Linux to Windows or Windows to Linux. 
        public let os: String?
        /// The instance's Amazon EC2 key name.
        public let sshKeyName: String?

        public init(layerIds: [String]? = nil, hostname: String? = nil, agentVersion: String? = nil, ebsOptimized: Bool? = nil, architecture: Architecture? = nil, amiId: String? = nil, autoScalingType: AutoScalingType? = nil, installUpdatesOnBoot: Bool? = nil, instanceId: String, instanceType: String? = nil, os: String? = nil, sshKeyName: String? = nil) {
            self.layerIds = layerIds
            self.hostname = hostname
            self.agentVersion = agentVersion
            self.ebsOptimized = ebsOptimized
            self.architecture = architecture
            self.amiId = amiId
            self.autoScalingType = autoScalingType
            self.installUpdatesOnBoot = installUpdatesOnBoot
            self.instanceId = instanceId
            self.instanceType = instanceType
            self.os = os
            self.sshKeyName = sshKeyName
        }

        public init(dictionary: [String: Any]) throws {
            self.layerIds = dictionary["LayerIds"] as? [String]
            self.hostname = dictionary["Hostname"] as? String
            self.agentVersion = dictionary["AgentVersion"] as? String
            self.ebsOptimized = dictionary["EbsOptimized"] as? Bool
            if let architecture = dictionary["Architecture"] as? String { self.architecture = Architecture(rawValue: architecture) } else { self.architecture = nil }
            self.amiId = dictionary["AmiId"] as? String
            if let autoScalingType = dictionary["AutoScalingType"] as? String { self.autoScalingType = AutoScalingType(rawValue: autoScalingType) } else { self.autoScalingType = nil }
            self.installUpdatesOnBoot = dictionary["InstallUpdatesOnBoot"] as? Bool
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            self.instanceType = dictionary["InstanceType"] as? String
            self.os = dictionary["Os"] as? String
            self.sshKeyName = dictionary["SshKeyName"] as? String
        }
    }

    public struct RaidArray: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The array's Linux device. For example /dev/mdadm0.
        public let device: String?
        /// For PIOPS volumes, the IOPS per disk.
        public let iops: Int32?
        /// The array's Availability Zone. For more information, see Regions and Endpoints.
        public let availabilityZone: String?
        /// The RAID level.
        public let raidLevel: Int32?
        /// The array ID.
        public let raidArrayId: String?
        /// When the RAID array was created.
        public let createdAt: String?
        /// The volume type, standard or PIOPS.
        public let volumeType: String?
        /// The stack ID.
        public let stackId: String?
        /// The array's mount point.
        public let mountPoint: String?
        /// The array name.
        public let name: String?
        /// The instance ID.
        public let instanceId: String?
        /// The array's size.
        public let size: Int32?
        /// The number of disks in the array.
        public let numberOfDisks: Int32?

        public init(device: String? = nil, iops: Int32? = nil, availabilityZone: String? = nil, raidLevel: Int32? = nil, raidArrayId: String? = nil, createdAt: String? = nil, volumeType: String? = nil, stackId: String? = nil, mountPoint: String? = nil, name: String? = nil, instanceId: String? = nil, size: Int32? = nil, numberOfDisks: Int32? = nil) {
            self.device = device
            self.iops = iops
            self.availabilityZone = availabilityZone
            self.raidLevel = raidLevel
            self.raidArrayId = raidArrayId
            self.createdAt = createdAt
            self.volumeType = volumeType
            self.stackId = stackId
            self.mountPoint = mountPoint
            self.name = name
            self.instanceId = instanceId
            self.size = size
            self.numberOfDisks = numberOfDisks
        }

        public init(dictionary: [String: Any]) throws {
            self.device = dictionary["Device"] as? String
            self.iops = dictionary["Iops"] as? Int32
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.raidLevel = dictionary["RaidLevel"] as? Int32
            self.raidArrayId = dictionary["RaidArrayId"] as? String
            self.createdAt = dictionary["CreatedAt"] as? String
            self.volumeType = dictionary["VolumeType"] as? String
            self.stackId = dictionary["StackId"] as? String
            self.mountPoint = dictionary["MountPoint"] as? String
            self.name = dictionary["Name"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            self.size = dictionary["Size"] as? Int32
            self.numberOfDisks = dictionary["NumberOfDisks"] as? Int32
        }
    }

    public struct CloneStackResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The cloned stack ID.
        public let stackId: String?

        public init(stackId: String? = nil) {
            self.stackId = stackId
        }

        public init(dictionary: [String: Any]) throws {
            self.stackId = dictionary["StackId"] as? String
        }
    }

    public struct CreateStackResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The stack ID, which is an opaque string that you use to identify the stack when performing actions such as DescribeStacks.
        public let stackId: String?

        public init(stackId: String? = nil) {
            self.stackId = stackId
        }

        public init(dictionary: [String: Any]) throws {
            self.stackId = dictionary["StackId"] as? String
        }
    }

    public enum AutoScalingType: String, CustomStringConvertible {
        case load = "load"
        case timer = "timer"
        public var description: String { return self.rawValue }
    }

    public struct LoadBasedAutoScalingConfiguration: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An AutoScalingThresholds object that describes the downscaling configuration, which defines how and when AWS OpsWorks reduces the number of instances.
        public let downScaling: AutoScalingThresholds?
        /// Whether load-based auto scaling is enabled for the layer.
        public let enable: Bool?
        /// An AutoScalingThresholds object that describes the upscaling configuration, which defines how and when AWS OpsWorks increases the number of instances.
        public let upScaling: AutoScalingThresholds?
        /// The layer ID.
        public let layerId: String?

        public init(downScaling: AutoScalingThresholds? = nil, enable: Bool? = nil, upScaling: AutoScalingThresholds? = nil, layerId: String? = nil) {
            self.downScaling = downScaling
            self.enable = enable
            self.upScaling = upScaling
            self.layerId = layerId
        }

        public init(dictionary: [String: Any]) throws {
            if let downScaling = dictionary["DownScaling"] as? [String: Any] { self.downScaling = try Opsworks.AutoScalingThresholds(dictionary: downScaling) } else { self.downScaling = nil }
            self.enable = dictionary["Enable"] as? Bool
            if let upScaling = dictionary["UpScaling"] as? [String: Any] { self.upScaling = try Opsworks.AutoScalingThresholds(dictionary: upScaling) } else { self.upScaling = nil }
            self.layerId = dictionary["LayerId"] as? String
        }
    }

    public struct App: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The app's short name.
        public let shortname: String?
        /// An SslConfiguration object with the SSL configuration.
        public let sslConfiguration: SslConfiguration?
        /// A Source object that describes the app repository.
        public let appSource: Source?
        /// Whether to enable SSL for the app.
        public let enableSsl: Bool?
        /// The app vhost settings with multiple domains separated by commas. For example: 'www.example.com, example.com' 
        public let domains: [String]?
        /// A description of the app.
        public let description: String?
        /// When the app was created.
        public let createdAt: String?
        /// The app stack ID.
        public let stackId: String?
        /// The app name.
        public let name: String?
        /// The app's data sources.
        public let dataSources: [DataSource]?
        /// An array of EnvironmentVariable objects that specify environment variables to be associated with the app. After you deploy the app, these variables are defined on the associated app server instances. For more information, see  Environment Variables.   There is no specific limit on the number of environment variables. However, the size of the associated data structure - which includes the variable names, values, and protected flag values - cannot exceed 10 KB (10240 Bytes). This limit should accommodate most if not all use cases, but if you do exceed it, you will cause an exception (API) with an "Environment: is too large (maximum is 10KB)" message. 
        public let environment: [EnvironmentVariable]?
        /// The stack attributes.
        public let attributes: [AppAttributesKeys: String]?
        /// The app type.
        public let `type`: AppType?
        /// The app ID.
        public let appId: String?

        public init(shortname: String? = nil, sslConfiguration: SslConfiguration? = nil, appSource: Source? = nil, enableSsl: Bool? = nil, domains: [String]? = nil, description: String? = nil, createdAt: String? = nil, stackId: String? = nil, name: String? = nil, dataSources: [DataSource]? = nil, environment: [EnvironmentVariable]? = nil, attributes: [AppAttributesKeys: String]? = nil, type: AppType? = nil, appId: String? = nil) {
            self.shortname = shortname
            self.sslConfiguration = sslConfiguration
            self.appSource = appSource
            self.enableSsl = enableSsl
            self.domains = domains
            self.description = description
            self.createdAt = createdAt
            self.stackId = stackId
            self.name = name
            self.dataSources = dataSources
            self.environment = environment
            self.attributes = attributes
            self.`type` = `type`
            self.appId = appId
        }

        public init(dictionary: [String: Any]) throws {
            self.shortname = dictionary["Shortname"] as? String
            if let sslConfiguration = dictionary["SslConfiguration"] as? [String: Any] { self.sslConfiguration = try Opsworks.SslConfiguration(dictionary: sslConfiguration) } else { self.sslConfiguration = nil }
            if let appSource = dictionary["AppSource"] as? [String: Any] { self.appSource = try Opsworks.Source(dictionary: appSource) } else { self.appSource = nil }
            self.enableSsl = dictionary["EnableSsl"] as? Bool
            self.domains = dictionary["Domains"] as? [String]
            self.description = dictionary["Description"] as? String
            self.createdAt = dictionary["CreatedAt"] as? String
            self.stackId = dictionary["StackId"] as? String
            self.name = dictionary["Name"] as? String
            if let dataSources = dictionary["DataSources"] as? [[String: Any]] {
                self.dataSources = try dataSources.map({ try DataSource(dictionary: $0) })
            } else { 
                self.dataSources = nil
            }
            if let environment = dictionary["Environment"] as? [[String: Any]] {
                self.environment = try environment.map({ try EnvironmentVariable(dictionary: $0) })
            } else { 
                self.environment = nil
            }
            if let attributes = dictionary["Attributes"] as? [AppAttributesKeys: String] {
                self.attributes = attributes
            } else { 
                self.attributes = nil
            }
            if let `type` = dictionary["Type"] as? String { self.`type` = AppType(rawValue: `type`) } else { self.`type` = nil }
            self.appId = dictionary["AppId"] as? String
        }
    }

    public enum VirtualizationType: String, CustomStringConvertible {
        case paravirtual = "paravirtual"
        case hvm = "hvm"
        public var description: String { return self.rawValue }
    }

    public struct Command: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The URL of the command log.
        public let logUrl: String?
        /// Date and time when the command was acknowledged.
        public let acknowledgedAt: String?
        /// Date and time when the command was run.
        public let createdAt: String?
        /// The command status:   failed   successful   skipped   pending  
        public let status: String?
        /// The ID of the instance where the command was executed.
        public let instanceId: String?
        /// The command deployment ID.
        public let deploymentId: String?
        /// The command exit code.
        public let exitCode: Int32?
        /// The command ID.
        public let commandId: String?
        /// The command type:    deploy     rollback     start     stop     restart     undeploy     update_dependencies     install_dependencies     update_custom_cookbooks     execute_recipes   
        public let `type`: String?
        /// Date when the command completed.
        public let completedAt: String?

        public init(logUrl: String? = nil, acknowledgedAt: String? = nil, createdAt: String? = nil, status: String? = nil, instanceId: String? = nil, deploymentId: String? = nil, exitCode: Int32? = nil, commandId: String? = nil, type: String? = nil, completedAt: String? = nil) {
            self.logUrl = logUrl
            self.acknowledgedAt = acknowledgedAt
            self.createdAt = createdAt
            self.status = status
            self.instanceId = instanceId
            self.deploymentId = deploymentId
            self.exitCode = exitCode
            self.commandId = commandId
            self.`type` = `type`
            self.completedAt = completedAt
        }

        public init(dictionary: [String: Any]) throws {
            self.logUrl = dictionary["LogUrl"] as? String
            self.acknowledgedAt = dictionary["AcknowledgedAt"] as? String
            self.createdAt = dictionary["CreatedAt"] as? String
            self.status = dictionary["Status"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            self.deploymentId = dictionary["DeploymentId"] as? String
            self.exitCode = dictionary["ExitCode"] as? Int32
            self.commandId = dictionary["CommandId"] as? String
            self.`type` = dictionary["Type"] as? String
            self.completedAt = dictionary["CompletedAt"] as? String
        }
    }

    public enum LayerType: String, CustomStringConvertible {
        case aws_flow_ruby = "aws-flow-ruby"
        case ecs_cluster = "ecs-cluster"
        case java_app = "java-app"
        case lb = "lb"
        case web = "web"
        case php_app = "php-app"
        case rails_app = "rails-app"
        case nodejs_app = "nodejs-app"
        case memcached = "memcached"
        case db_master = "db-master"
        case monitoring_master = "monitoring-master"
        case custom = "custom"
        public var description: String { return self.rawValue }
    }

    public struct UserProfile: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The user's IAM ARN.
        public let iamUserArn: String?
        /// The user's SSH public key.
        public let sshPublicKey: String?
        /// The user's SSH user name.
        public let sshUsername: String?
        /// The user's name.
        public let name: String?
        /// Whether users can specify their own SSH public key through the My Settings page. For more information, see Managing User Permissions.
        public let allowSelfManagement: Bool?

        public init(iamUserArn: String? = nil, sshPublicKey: String? = nil, sshUsername: String? = nil, name: String? = nil, allowSelfManagement: Bool? = nil) {
            self.iamUserArn = iamUserArn
            self.sshPublicKey = sshPublicKey
            self.sshUsername = sshUsername
            self.name = name
            self.allowSelfManagement = allowSelfManagement
        }

        public init(dictionary: [String: Any]) throws {
            self.iamUserArn = dictionary["IamUserArn"] as? String
            self.sshPublicKey = dictionary["SshPublicKey"] as? String
            self.sshUsername = dictionary["SshUsername"] as? String
            self.name = dictionary["Name"] as? String
            self.allowSelfManagement = dictionary["AllowSelfManagement"] as? Bool
        }
    }

    public struct WeeklyAutoScalingSchedule: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The schedule for Saturday.
        public let saturday: [String: String]?
        /// The schedule for Tuesday.
        public let tuesday: [String: String]?
        /// The schedule for Sunday.
        public let sunday: [String: String]?
        /// The schedule for Friday.
        public let friday: [String: String]?
        /// The schedule for Monday.
        public let monday: [String: String]?
        /// The schedule for Thursday.
        public let thursday: [String: String]?
        /// The schedule for Wednesday.
        public let wednesday: [String: String]?

        public init(saturday: [String: String]? = nil, tuesday: [String: String]? = nil, sunday: [String: String]? = nil, friday: [String: String]? = nil, monday: [String: String]? = nil, thursday: [String: String]? = nil, wednesday: [String: String]? = nil) {
            self.saturday = saturday
            self.tuesday = tuesday
            self.sunday = sunday
            self.friday = friday
            self.monday = monday
            self.thursday = thursday
            self.wednesday = wednesday
        }

        public init(dictionary: [String: Any]) throws {
            if let saturday = dictionary["Saturday"] as? [String: String] {
                self.saturday = saturday
            } else { 
                self.saturday = nil
            }
            if let tuesday = dictionary["Tuesday"] as? [String: String] {
                self.tuesday = tuesday
            } else { 
                self.tuesday = nil
            }
            if let sunday = dictionary["Sunday"] as? [String: String] {
                self.sunday = sunday
            } else { 
                self.sunday = nil
            }
            if let friday = dictionary["Friday"] as? [String: String] {
                self.friday = friday
            } else { 
                self.friday = nil
            }
            if let monday = dictionary["Monday"] as? [String: String] {
                self.monday = monday
            } else { 
                self.monday = nil
            }
            if let thursday = dictionary["Thursday"] as? [String: String] {
                self.thursday = thursday
            } else { 
                self.thursday = nil
            }
            if let wednesday = dictionary["Wednesday"] as? [String: String] {
                self.wednesday = wednesday
            } else { 
                self.wednesday = nil
            }
        }
    }

    public struct RegisterEcsClusterResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The cluster's ARN.
        public let ecsClusterArn: String?

        public init(ecsClusterArn: String? = nil) {
            self.ecsClusterArn = ecsClusterArn
        }

        public init(dictionary: [String: Any]) throws {
            self.ecsClusterArn = dictionary["EcsClusterArn"] as? String
        }
    }

    public struct RegisterElasticIpResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Elastic IP address.
        public let elasticIp: String?

        public init(elasticIp: String? = nil) {
            self.elasticIp = elasticIp
        }

        public init(dictionary: [String: Any]) throws {
            self.elasticIp = dictionary["ElasticIp"] as? String
        }
    }

    public struct GetHostnameSuggestionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The layer ID.
        public let layerId: String

        public init(layerId: String) {
            self.layerId = layerId
        }

        public init(dictionary: [String: Any]) throws {
            guard let layerId = dictionary["LayerId"] as? String else { throw InitializableError.missingRequiredParam("LayerId") }
            self.layerId = layerId
        }
    }

    public struct DeregisterInstanceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The instance ID.
        public let instanceId: String

        public init(instanceId: String) {
            self.instanceId = instanceId
        }

        public init(dictionary: [String: Any]) throws {
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
        }
    }

    public struct CreateInstanceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of BlockDeviceMapping objects that specify the instance's block devices. For more information, see Block Device Mapping. Note that block device mappings are not supported for custom AMIs.
        public let blockDeviceMappings: [BlockDeviceMapping]?
        /// The ID of the instance's subnet. If the stack is running in a VPC, you can use this parameter to override the stack's default subnet ID value and direct AWS OpsWorks to launch the instance in a different subnet.
        public let subnetId: String?
        /// An array that contains the instance's layer IDs.
        public let layerIds: [String]
        /// The instance host name.
        public let hostname: String?
        /// Whether to create an Amazon EBS-optimized instance.
        public let ebsOptimized: Bool?
        /// The instance's tenancy option. The default option is no tenancy, or if the instance is running in a VPC, inherit tenancy settings from the VPC. The following are valid values for this parameter: dedicated, default, or host. Because there are costs associated with changes in tenancy options, we recommend that you research tenancy options before choosing them for your instances. For more information about dedicated hosts, see Dedicated Hosts Overview and Amazon EC2 Dedicated Hosts. For more information about dedicated instances, see Dedicated Instances and Amazon EC2 Dedicated Instances.
        public let tenancy: String?
        /// A custom AMI ID to be used to create the instance. The AMI should be based on one of the supported operating systems. For more information, see Using Custom AMIs.  If you specify a custom AMI, you must set Os to Custom. 
        public let amiId: String?
        /// Whether to install operating system and package updates when the instance boots. The default value is true. To control when updates are installed, set this value to false. You must then update your instances manually by using CreateDeployment to run the update_dependencies stack command or by manually running yum (Amazon Linux) or apt-get (Ubuntu) on the instances.   We strongly recommend using the default value of true to ensure that your instances have the latest security updates. 
        public let installUpdatesOnBoot: Bool?
        /// The instance type, such as t2.micro. For a list of supported instance types, open the stack in the console, choose Instances, and choose + Instance. The Size list contains the currently supported types. For more information, see Instance Families and Types. The parameter values that you use to specify the various types are in the API Name column of the Available Instance Types table.
        public let instanceType: String
        /// The instance Availability Zone. For more information, see Regions and Endpoints.
        public let availabilityZone: String?
        /// The default AWS OpsWorks agent version. You have the following options:    INHERIT - Use the stack's default agent version setting.    version_number - Use the specified agent version. This value overrides the stack's default setting. To update the agent version, edit the instance configuration and specify a new version. AWS OpsWorks then automatically installs that version on the instance.   The default setting is INHERIT. To specify an agent version, you must use the complete version number, not the abbreviated number shown on the console. For a list of available agent version numbers, call DescribeAgentVersions.
        public let agentVersion: String?
        /// The stack ID.
        public let stackId: String
        /// The instance architecture. The default option is x86_64. Instance types do not necessarily support both architectures. For a list of the architectures that are supported by the different instance types, see Instance Families and Types.
        public let architecture: Architecture?
        /// The instance root device type. For more information, see Storage for the Root Device.
        public let rootDeviceType: RootDeviceType?
        /// For load-based or time-based instances, the type. Windows stacks can use only time-based instances.
        public let autoScalingType: AutoScalingType?
        /// The instance's operating system, which must be set to one of the following.   A supported Linux operating system: An Amazon Linux version, such as Amazon Linux 2016.03, Amazon Linux 2015.09, or Amazon Linux 2015.03.   A supported Ubuntu operating system, such as Ubuntu 16.04 LTS, Ubuntu 14.04 LTS, or Ubuntu 12.04 LTS.    CentOS 7     Red Hat Enterprise Linux 7    A supported Windows operating system, such as Microsoft Windows Server 2012 R2 Base, Microsoft Windows Server 2012 R2 with SQL Server Express, Microsoft Windows Server 2012 R2 with SQL Server Standard, or Microsoft Windows Server 2012 R2 with SQL Server Web.   A custom AMI: Custom.   For more information on the supported operating systems, see AWS OpsWorks Operating Systems. The default option is the current Amazon Linux version. If you set this parameter to Custom, you must use the CreateInstance action's AmiId parameter to specify the custom AMI that you want to use. Block device mappings are not supported if the value is Custom. For more information on the supported operating systems, see Operating SystemsFor more information on how to use custom AMIs with AWS OpsWorks, see Using Custom AMIs.
        public let os: String?
        /// The instance's Amazon EC2 key-pair name.
        public let sshKeyName: String?
        /// The instance's virtualization type, paravirtual or hvm.
        public let virtualizationType: String?

        public init(blockDeviceMappings: [BlockDeviceMapping]? = nil, subnetId: String? = nil, layerIds: [String], hostname: String? = nil, ebsOptimized: Bool? = nil, tenancy: String? = nil, amiId: String? = nil, installUpdatesOnBoot: Bool? = nil, instanceType: String, availabilityZone: String? = nil, agentVersion: String? = nil, stackId: String, architecture: Architecture? = nil, rootDeviceType: RootDeviceType? = nil, autoScalingType: AutoScalingType? = nil, os: String? = nil, sshKeyName: String? = nil, virtualizationType: String? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.subnetId = subnetId
            self.layerIds = layerIds
            self.hostname = hostname
            self.ebsOptimized = ebsOptimized
            self.tenancy = tenancy
            self.amiId = amiId
            self.installUpdatesOnBoot = installUpdatesOnBoot
            self.instanceType = instanceType
            self.availabilityZone = availabilityZone
            self.agentVersion = agentVersion
            self.stackId = stackId
            self.architecture = architecture
            self.rootDeviceType = rootDeviceType
            self.autoScalingType = autoScalingType
            self.os = os
            self.sshKeyName = sshKeyName
            self.virtualizationType = virtualizationType
        }

        public init(dictionary: [String: Any]) throws {
            if let blockDeviceMappings = dictionary["BlockDeviceMappings"] as? [[String: Any]] {
                self.blockDeviceMappings = try blockDeviceMappings.map({ try BlockDeviceMapping(dictionary: $0) })
            } else { 
                self.blockDeviceMappings = nil
            }
            self.subnetId = dictionary["SubnetId"] as? String
            guard let layerIds = dictionary["LayerIds"] as? [String] else { throw InitializableError.missingRequiredParam("LayerIds") }
            self.layerIds = layerIds
            self.hostname = dictionary["Hostname"] as? String
            self.ebsOptimized = dictionary["EbsOptimized"] as? Bool
            self.tenancy = dictionary["Tenancy"] as? String
            self.amiId = dictionary["AmiId"] as? String
            self.installUpdatesOnBoot = dictionary["InstallUpdatesOnBoot"] as? Bool
            guard let instanceType = dictionary["InstanceType"] as? String else { throw InitializableError.missingRequiredParam("InstanceType") }
            self.instanceType = instanceType
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.agentVersion = dictionary["AgentVersion"] as? String
            guard let stackId = dictionary["StackId"] as? String else { throw InitializableError.missingRequiredParam("StackId") }
            self.stackId = stackId
            if let architecture = dictionary["Architecture"] as? String { self.architecture = Architecture(rawValue: architecture) } else { self.architecture = nil }
            if let rootDeviceType = dictionary["RootDeviceType"] as? String { self.rootDeviceType = RootDeviceType(rawValue: rootDeviceType) } else { self.rootDeviceType = nil }
            if let autoScalingType = dictionary["AutoScalingType"] as? String { self.autoScalingType = AutoScalingType(rawValue: autoScalingType) } else { self.autoScalingType = nil }
            self.os = dictionary["Os"] as? String
            self.sshKeyName = dictionary["SshKeyName"] as? String
            self.virtualizationType = dictionary["VirtualizationType"] as? String
        }
    }

    public struct CreateAppRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The app's short name.
        public let shortname: String?
        /// The stack ID.
        public let stackId: String
        /// The app name.
        public let name: String
        /// The app's data source.
        public let dataSources: [DataSource]?
        /// An SslConfiguration object with the SSL configuration.
        public let sslConfiguration: SslConfiguration?
        /// A Source object that specifies the app repository.
        public let appSource: Source?
        /// One or more user-defined key/value pairs to be added to the stack attributes.
        public let attributes: [AppAttributesKeys: String]?
        /// An array of EnvironmentVariable objects that specify environment variables to be associated with the app. After you deploy the app, these variables are defined on the associated app server instance. For more information, see  Environment Variables. There is no specific limit on the number of environment variables. However, the size of the associated data structure - which includes the variables' names, values, and protected flag values - cannot exceed 10 KB (10240 Bytes). This limit should accommodate most if not all use cases. Exceeding it will cause an exception with the message, "Environment: is too large (maximum is 10KB)."  This parameter is supported only by Chef 11.10 stacks. If you have specified one or more environment variables, you cannot modify the stack's Chef version. 
        public let environment: [EnvironmentVariable]?
        /// Whether to enable SSL for the app.
        public let enableSsl: Bool?
        /// The app virtual host settings, with multiple domains separated by commas. For example: 'www.example.com, example.com' 
        public let domains: [String]?
        /// The app type. Each supported type is associated with a particular layer. For example, PHP applications are associated with a PHP layer. AWS OpsWorks deploys an application to those instances that are members of the corresponding layer. If your app isn't one of the standard types, or you prefer to implement your own Deploy recipes, specify other.
        public let `type`: AppType
        /// A description of the app.
        public let description: String?

        public init(shortname: String? = nil, stackId: String, name: String, dataSources: [DataSource]? = nil, sslConfiguration: SslConfiguration? = nil, appSource: Source? = nil, attributes: [AppAttributesKeys: String]? = nil, environment: [EnvironmentVariable]? = nil, enableSsl: Bool? = nil, domains: [String]? = nil, type: AppType, description: String? = nil) {
            self.shortname = shortname
            self.stackId = stackId
            self.name = name
            self.dataSources = dataSources
            self.sslConfiguration = sslConfiguration
            self.appSource = appSource
            self.attributes = attributes
            self.environment = environment
            self.enableSsl = enableSsl
            self.domains = domains
            self.`type` = `type`
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.shortname = dictionary["Shortname"] as? String
            guard let stackId = dictionary["StackId"] as? String else { throw InitializableError.missingRequiredParam("StackId") }
            self.stackId = stackId
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            if let dataSources = dictionary["DataSources"] as? [[String: Any]] {
                self.dataSources = try dataSources.map({ try DataSource(dictionary: $0) })
            } else { 
                self.dataSources = nil
            }
            if let sslConfiguration = dictionary["SslConfiguration"] as? [String: Any] { self.sslConfiguration = try Opsworks.SslConfiguration(dictionary: sslConfiguration) } else { self.sslConfiguration = nil }
            if let appSource = dictionary["AppSource"] as? [String: Any] { self.appSource = try Opsworks.Source(dictionary: appSource) } else { self.appSource = nil }
            if let attributes = dictionary["Attributes"] as? [AppAttributesKeys: String] {
                self.attributes = attributes
            } else { 
                self.attributes = nil
            }
            if let environment = dictionary["Environment"] as? [[String: Any]] {
                self.environment = try environment.map({ try EnvironmentVariable(dictionary: $0) })
            } else { 
                self.environment = nil
            }
            self.enableSsl = dictionary["EnableSsl"] as? Bool
            self.domains = dictionary["Domains"] as? [String]
            guard let rawType = dictionary["Type"] as? String, let `type` = AppType(rawValue: rawType) else { throw InitializableError.missingRequiredParam("Type") }
            self.`type` = `type`
            self.description = dictionary["Description"] as? String
        }
    }

    public struct ShutdownEventConfiguration: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The time, in seconds, that AWS OpsWorks will wait after triggering a Shutdown event before shutting down an instance.
        public let executionTimeout: Int32?
        /// Whether to enable Elastic Load Balancing connection draining. For more information, see Connection Draining 
        public let delayUntilElbConnectionsDrained: Bool?

        public init(executionTimeout: Int32? = nil, delayUntilElbConnectionsDrained: Bool? = nil) {
            self.executionTimeout = executionTimeout
            self.delayUntilElbConnectionsDrained = delayUntilElbConnectionsDrained
        }

        public init(dictionary: [String: Any]) throws {
            self.executionTimeout = dictionary["ExecutionTimeout"] as? Int32
            self.delayUntilElbConnectionsDrained = dictionary["DelayUntilElbConnectionsDrained"] as? Bool
        }
    }

    public struct CreateUserProfileResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The user's IAM ARN.
        public let iamUserArn: String?

        public init(iamUserArn: String? = nil) {
            self.iamUserArn = iamUserArn
        }

        public init(dictionary: [String: Any]) throws {
            self.iamUserArn = dictionary["IamUserArn"] as? String
        }
    }

    public struct CloneStackRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The stack's operating system, which must be set to one of the following.   A supported Linux operating system: An Amazon Linux version, such as Amazon Linux 2016.03, Amazon Linux 2015.09, or Amazon Linux 2015.03.   A supported Ubuntu operating system, such as Ubuntu 16.04 LTS, Ubuntu 14.04 LTS, or Ubuntu 12.04 LTS.    CentOS 7     Red Hat Enterprise Linux 7     Microsoft Windows Server 2012 R2 Base, Microsoft Windows Server 2012 R2 with SQL Server Express, Microsoft Windows Server 2012 R2 with SQL Server Standard, or Microsoft Windows Server 2012 R2 with SQL Server Web.   A custom AMI: Custom. You specify the custom AMI you want to use when you create instances. For more information on how to use custom AMIs with OpsWorks, see Using Custom AMIs.   The default option is the parent stack's operating system. For more information on the supported operating systems, see AWS OpsWorks Operating Systems.  You can specify a different Linux operating system for the cloned stack, but you cannot change from Linux to Windows or Windows to Linux. 
        public let defaultOs: String?
        /// Whether to clone the source stack's permissions.
        public let clonePermissions: Bool?
        /// The stack AWS Identity and Access Management (IAM) role, which allows AWS OpsWorks to work with AWS resources on your behalf. You must set this parameter to the Amazon Resource Name (ARN) for an existing IAM role. If you create a stack by using the AWS OpsWorks console, it creates the role for you. You can obtain an existing stack's IAM ARN programmatically by calling DescribePermissions. For more information about IAM ARNs, see Using Identifiers.  You must set this parameter to a valid service role ARN or the action will fail; there is no default value. You can specify the source stack's service role ARN, if you prefer, but you must do so explicitly. 
        public let serviceRoleArn: String
        /// The default root device type. This value is used by default for all instances in the cloned stack, but you can override it when you create an instance. For more information, see Storage for the Root Device.
        public let defaultRootDeviceType: RootDeviceType?
        /// The Amazon Resource Name (ARN) of an IAM profile that is the default profile for all of the stack's EC2 instances. For more information about IAM ARNs, see Using Identifiers.
        public let defaultInstanceProfileArn: String?
        /// A ChefConfiguration object that specifies whether to enable Berkshelf and the Berkshelf version on Chef 11.10 stacks. For more information, see Create a New Stack.
        public let chefConfiguration: ChefConfiguration?
        /// The cloned stack AWS region, such as "ap-northeast-2". For more information about AWS regions, see Regions and Endpoints.
        public let region: String?
        /// The source stack ID.
        public let sourceStackId: String
        /// A string that contains user-defined, custom JSON. It is used to override the corresponding default stack configuration JSON values. The string should be in the following format:  "{\"key1\": \"value1\", \"key2\": \"value2\",...}"  For more information on custom JSON, see Use Custom JSON to Modify the Stack Configuration Attributes 
        public let customJson: String?
        /// Whether to use custom cookbooks.
        public let useCustomCookbooks: Bool?
        public let customCookbooksSource: Source?
        /// A default Amazon EC2 key pair name. The default value is none. If you specify a key pair name, AWS OpsWorks installs the public key on the instance and you can use the private key with an SSH client to log in to the instance. For more information, see  Using SSH to Communicate with an Instance and  Managing SSH Access. You can override this setting by specifying a different key pair, or no key pair, when you  create an instance. 
        public let defaultSshKeyName: String?
        /// The default AWS OpsWorks agent version. You have the following options:   Auto-update - Set this parameter to LATEST. AWS OpsWorks automatically installs new agent versions on the stack's instances as soon as they are available.   Fixed version - Set this parameter to your preferred agent version. To update the agent version, you must edit the stack configuration and specify a new version. AWS OpsWorks then automatically installs that version on the stack's instances.   The default setting is LATEST. To specify an agent version, you must use the complete version number, not the abbreviated number shown on the console. For a list of available agent version numbers, call DescribeAgentVersions.  You can also specify an agent version when you create or update an instance, which overrides the stack's default setting. 
        public let agentVersion: String?
        /// The ID of the VPC that the cloned stack is to be launched into. It must be in the specified region. All instances are launched into this VPC, and you cannot change the ID later.   If your account supports EC2 Classic, the default value is no VPC.   If your account does not support EC2 Classic, the default value is the default VPC for the specified region.   If the VPC ID corresponds to a default VPC and you have specified either the DefaultAvailabilityZone or the DefaultSubnetId parameter only, AWS OpsWorks infers the value of the other parameter. If you specify neither parameter, AWS OpsWorks sets these parameters to the first valid Availability Zone for the specified region and the corresponding default VPC subnet ID, respectively.  If you specify a nondefault VPC ID, note the following:   It must belong to a VPC in your account that is in the specified region.   You must specify a value for DefaultSubnetId.   For more information on how to use AWS OpsWorks with a VPC, see Running a Stack in a VPC. For more information on default VPC and EC2 Classic, see Supported Platforms. 
        public let vpcId: String?
        /// The cloned stack name.
        public let name: String?
        /// A list of source stack app IDs to be included in the cloned stack.
        public let cloneAppIds: [String]?
        /// A list of stack attributes and values as key/value pairs to be added to the cloned stack.
        public let attributes: [StackAttributesKeys: String]?
        /// The stack's default VPC subnet ID. This parameter is required if you specify a value for the VpcId parameter. All instances are launched into this subnet unless you specify otherwise when you create the instance. If you also specify a value for DefaultAvailabilityZone, the subnet must be in that zone. For information on default values and when this parameter is required, see the VpcId parameter description. 
        public let defaultSubnetId: String?
        /// The cloned stack's default Availability Zone, which must be in the specified region. For more information, see Regions and Endpoints. If you also specify a value for DefaultSubnetId, the subnet must be in the same zone. For more information, see the VpcId parameter description. 
        public let defaultAvailabilityZone: String?
        /// The stack's host name theme, with spaces are replaced by underscores. The theme is used to generate host names for the stack's instances. By default, HostnameTheme is set to Layer_Dependent, which creates host names by appending integers to the layer's short name. The other themes are:    Baked_Goods     Clouds     Europe_Cities     Fruits     Greek_Deities     Legendary_creatures_from_Japan     Planets_and_Moons     Roman_Deities     Scottish_Islands     US_Cities     Wild_Cats    To obtain a generated host name, call GetHostNameSuggestion, which returns a host name based on the current theme.
        public let hostnameTheme: String?
        /// The configuration manager. When you clone a stack we recommend that you use the configuration manager to specify the Chef version: 12, 11.10, or 11.4 for Linux stacks, or 12.2 for Windows stacks. The default value for Linux stacks is currently 12.
        public let configurationManager: StackConfigurationManager?
        /// Whether to associate the AWS OpsWorks built-in security groups with the stack's layers. AWS OpsWorks provides a standard set of built-in security groups, one for each layer, which are associated with layers by default. With UseOpsworksSecurityGroups you can instead provide your own custom security groups. UseOpsworksSecurityGroups has the following settings:    True - AWS OpsWorks automatically associates the appropriate built-in security group with each layer (default setting). You can associate additional security groups with a layer after you create it but you cannot delete the built-in security group.   False - AWS OpsWorks does not associate built-in security groups with layers. You must create appropriate Amazon Elastic Compute Cloud (Amazon EC2) security groups and associate a security group with each layer that you create. However, you can still manually associate a built-in security group with a layer on creation; custom security groups are required only for those layers that need custom settings.   For more information, see Create a New Stack.
        public let useOpsworksSecurityGroups: Bool?

        public init(defaultOs: String? = nil, clonePermissions: Bool? = nil, serviceRoleArn: String, defaultRootDeviceType: RootDeviceType? = nil, defaultInstanceProfileArn: String? = nil, chefConfiguration: ChefConfiguration? = nil, region: String? = nil, sourceStackId: String, customJson: String? = nil, useCustomCookbooks: Bool? = nil, customCookbooksSource: Source? = nil, defaultSshKeyName: String? = nil, agentVersion: String? = nil, vpcId: String? = nil, name: String? = nil, cloneAppIds: [String]? = nil, attributes: [StackAttributesKeys: String]? = nil, defaultSubnetId: String? = nil, defaultAvailabilityZone: String? = nil, hostnameTheme: String? = nil, configurationManager: StackConfigurationManager? = nil, useOpsworksSecurityGroups: Bool? = nil) {
            self.defaultOs = defaultOs
            self.clonePermissions = clonePermissions
            self.serviceRoleArn = serviceRoleArn
            self.defaultRootDeviceType = defaultRootDeviceType
            self.defaultInstanceProfileArn = defaultInstanceProfileArn
            self.chefConfiguration = chefConfiguration
            self.region = region
            self.sourceStackId = sourceStackId
            self.customJson = customJson
            self.useCustomCookbooks = useCustomCookbooks
            self.customCookbooksSource = customCookbooksSource
            self.defaultSshKeyName = defaultSshKeyName
            self.agentVersion = agentVersion
            self.vpcId = vpcId
            self.name = name
            self.cloneAppIds = cloneAppIds
            self.attributes = attributes
            self.defaultSubnetId = defaultSubnetId
            self.defaultAvailabilityZone = defaultAvailabilityZone
            self.hostnameTheme = hostnameTheme
            self.configurationManager = configurationManager
            self.useOpsworksSecurityGroups = useOpsworksSecurityGroups
        }

        public init(dictionary: [String: Any]) throws {
            self.defaultOs = dictionary["DefaultOs"] as? String
            self.clonePermissions = dictionary["ClonePermissions"] as? Bool
            guard let serviceRoleArn = dictionary["ServiceRoleArn"] as? String else { throw InitializableError.missingRequiredParam("ServiceRoleArn") }
            self.serviceRoleArn = serviceRoleArn
            if let defaultRootDeviceType = dictionary["DefaultRootDeviceType"] as? String { self.defaultRootDeviceType = RootDeviceType(rawValue: defaultRootDeviceType) } else { self.defaultRootDeviceType = nil }
            self.defaultInstanceProfileArn = dictionary["DefaultInstanceProfileArn"] as? String
            if let chefConfiguration = dictionary["ChefConfiguration"] as? [String: Any] { self.chefConfiguration = try Opsworks.ChefConfiguration(dictionary: chefConfiguration) } else { self.chefConfiguration = nil }
            self.region = dictionary["Region"] as? String
            guard let sourceStackId = dictionary["SourceStackId"] as? String else { throw InitializableError.missingRequiredParam("SourceStackId") }
            self.sourceStackId = sourceStackId
            self.customJson = dictionary["CustomJson"] as? String
            self.useCustomCookbooks = dictionary["UseCustomCookbooks"] as? Bool
            if let customCookbooksSource = dictionary["CustomCookbooksSource"] as? [String: Any] { self.customCookbooksSource = try Opsworks.Source(dictionary: customCookbooksSource) } else { self.customCookbooksSource = nil }
            self.defaultSshKeyName = dictionary["DefaultSshKeyName"] as? String
            self.agentVersion = dictionary["AgentVersion"] as? String
            self.vpcId = dictionary["VpcId"] as? String
            self.name = dictionary["Name"] as? String
            self.cloneAppIds = dictionary["CloneAppIds"] as? [String]
            if let attributes = dictionary["Attributes"] as? [StackAttributesKeys: String] {
                self.attributes = attributes
            } else { 
                self.attributes = nil
            }
            self.defaultSubnetId = dictionary["DefaultSubnetId"] as? String
            self.defaultAvailabilityZone = dictionary["DefaultAvailabilityZone"] as? String
            self.hostnameTheme = dictionary["HostnameTheme"] as? String
            if let configurationManager = dictionary["ConfigurationManager"] as? [String: Any] { self.configurationManager = try Opsworks.StackConfigurationManager(dictionary: configurationManager) } else { self.configurationManager = nil }
            self.useOpsworksSecurityGroups = dictionary["UseOpsworksSecurityGroups"] as? Bool
        }
    }

    public struct DescribeLayersRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The stack ID.
        public let stackId: String?
        /// An array of layer IDs that specify the layers to be described. If you omit this parameter, DescribeLayers returns a description of every layer in the specified stack.
        public let layerIds: [String]?

        public init(stackId: String? = nil, layerIds: [String]? = nil) {
            self.stackId = stackId
            self.layerIds = layerIds
        }

        public init(dictionary: [String: Any]) throws {
            self.stackId = dictionary["StackId"] as? String
            self.layerIds = dictionary["LayerIds"] as? [String]
        }
    }

    public struct DescribeAgentVersionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The stack ID.
        public let stackId: String?
        /// The configuration manager.
        public let configurationManager: StackConfigurationManager?

        public init(stackId: String? = nil, configurationManager: StackConfigurationManager? = nil) {
            self.stackId = stackId
            self.configurationManager = configurationManager
        }

        public init(dictionary: [String: Any]) throws {
            self.stackId = dictionary["StackId"] as? String
            if let configurationManager = dictionary["ConfigurationManager"] as? [String: Any] { self.configurationManager = try Opsworks.StackConfigurationManager(dictionary: configurationManager) } else { self.configurationManager = nil }
        }
    }

    public struct DescribeDeploymentsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The stack ID. If you include this parameter, DescribeDeployments returns a description of the commands associated with the specified stack.
        public let stackId: String?
        /// An array of deployment IDs to be described. If you include this parameter, DescribeDeployments returns a description of the specified deployments. Otherwise, it returns a description of every deployment.
        public let deploymentIds: [String]?
        /// The app ID. If you include this parameter, DescribeDeployments returns a description of the commands associated with the specified app.
        public let appId: String?

        public init(stackId: String? = nil, deploymentIds: [String]? = nil, appId: String? = nil) {
            self.stackId = stackId
            self.deploymentIds = deploymentIds
            self.appId = appId
        }

        public init(dictionary: [String: Any]) throws {
            self.stackId = dictionary["StackId"] as? String
            self.deploymentIds = dictionary["DeploymentIds"] as? [String]
            self.appId = dictionary["AppId"] as? String
        }
    }

    public struct DescribeAppsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of App objects that describe the specified apps. 
        public let apps: [App]?

        public init(apps: [App]? = nil) {
            self.apps = apps
        }

        public init(dictionary: [String: Any]) throws {
            if let apps = dictionary["Apps"] as? [[String: Any]] {
                self.apps = try apps.map({ try App(dictionary: $0) })
            } else { 
                self.apps = nil
            }
        }
    }

    public struct DescribeVolumesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of volume IDs.
        public let volumes: [Volume]?

        public init(volumes: [Volume]? = nil) {
            self.volumes = volumes
        }

        public init(dictionary: [String: Any]) throws {
            if let volumes = dictionary["Volumes"] as? [[String: Any]] {
                self.volumes = try volumes.map({ try Volume(dictionary: $0) })
            } else { 
                self.volumes = nil
            }
        }
    }

    public struct GrantAccessRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The length of time (in minutes) that the grant is valid. When the grant expires at the end of this period, the user will no longer be able to use the credentials to log in. If the user is logged in at the time, he or she automatically will be logged out.
        public let validForInMinutes: Int32?
        /// The instance's AWS OpsWorks ID.
        public let instanceId: String

        public init(validForInMinutes: Int32? = nil, instanceId: String) {
            self.validForInMinutes = validForInMinutes
            self.instanceId = instanceId
        }

        public init(dictionary: [String: Any]) throws {
            self.validForInMinutes = dictionary["ValidForInMinutes"] as? Int32
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
        }
    }

    public struct DescribeLayersResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of Layer objects that describe the layers.
        public let layers: [Layer]?

        public init(layers: [Layer]? = nil) {
            self.layers = layers
        }

        public init(dictionary: [String: Any]) throws {
            if let layers = dictionary["Layers"] as? [[String: Any]] {
                self.layers = try layers.map({ try Layer(dictionary: $0) })
            } else { 
                self.layers = nil
            }
        }
    }

    public struct DetachElasticLoadBalancerRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the layer that the Elastic Load Balancing instance is attached to.
        public let layerId: String
        /// The Elastic Load Balancing instance's name.
        public let elasticLoadBalancerName: String

        public init(layerId: String, elasticLoadBalancerName: String) {
            self.layerId = layerId
            self.elasticLoadBalancerName = elasticLoadBalancerName
        }

        public init(dictionary: [String: Any]) throws {
            guard let layerId = dictionary["LayerId"] as? String else { throw InitializableError.missingRequiredParam("LayerId") }
            self.layerId = layerId
            guard let elasticLoadBalancerName = dictionary["ElasticLoadBalancerName"] as? String else { throw InitializableError.missingRequiredParam("ElasticLoadBalancerName") }
            self.elasticLoadBalancerName = elasticLoadBalancerName
        }
    }

    public struct RegisterInstanceResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The registered instance's AWS OpsWorks ID.
        public let instanceId: String?

        public init(instanceId: String? = nil) {
            self.instanceId = instanceId
        }

        public init(dictionary: [String: Any]) throws {
            self.instanceId = dictionary["InstanceId"] as? String
        }
    }

    public struct ElasticIp: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The domain.
        public let domain: String?
        /// The IP address.
        public let ip: String?
        /// The ID of the instance that the address is attached to.
        public let instanceId: String?
        /// The AWS region. For more information, see Regions and Endpoints.
        public let region: String?
        /// The name.
        public let name: String?

        public init(domain: String? = nil, ip: String? = nil, instanceId: String? = nil, region: String? = nil, name: String? = nil) {
            self.domain = domain
            self.ip = ip
            self.instanceId = instanceId
            self.region = region
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            self.domain = dictionary["Domain"] as? String
            self.ip = dictionary["Ip"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            self.region = dictionary["Region"] as? String
            self.name = dictionary["Name"] as? String
        }
    }

    public struct GrantAccessResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A TemporaryCredential object that contains the data needed to log in to the instance by RDP clients, such as the Microsoft Remote Desktop Connection.
        public let temporaryCredential: TemporaryCredential?

        public init(temporaryCredential: TemporaryCredential? = nil) {
            self.temporaryCredential = temporaryCredential
        }

        public init(dictionary: [String: Any]) throws {
            if let temporaryCredential = dictionary["TemporaryCredential"] as? [String: Any] { self.temporaryCredential = try Opsworks.TemporaryCredential(dictionary: temporaryCredential) } else { self.temporaryCredential = nil }
        }
    }

    public enum RootDeviceType: String, CustomStringConvertible {
        case ebs = "ebs"
        case instance_store = "instance-store"
        public var description: String { return self.rawValue }
    }

    public struct AssignInstanceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The layer ID, which must correspond to a custom layer. You cannot assign a registered instance to a built-in layer.
        public let layerIds: [String]
        /// The instance ID.
        public let instanceId: String

        public init(layerIds: [String], instanceId: String) {
            self.layerIds = layerIds
            self.instanceId = instanceId
        }

        public init(dictionary: [String: Any]) throws {
            guard let layerIds = dictionary["LayerIds"] as? [String] else { throw InitializableError.missingRequiredParam("LayerIds") }
            self.layerIds = layerIds
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
        }
    }

    public struct AssociateElasticIpRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Elastic IP address.
        public let elasticIp: String
        /// The instance ID.
        public let instanceId: String?

        public init(elasticIp: String, instanceId: String? = nil) {
            self.elasticIp = elasticIp
            self.instanceId = instanceId
        }

        public init(dictionary: [String: Any]) throws {
            guard let elasticIp = dictionary["ElasticIp"] as? String else { throw InitializableError.missingRequiredParam("ElasticIp") }
            self.elasticIp = elasticIp
            self.instanceId = dictionary["InstanceId"] as? String
        }
    }

    public struct UnassignVolumeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The volume ID.
        public let volumeId: String

        public init(volumeId: String) {
            self.volumeId = volumeId
        }

        public init(dictionary: [String: Any]) throws {
            guard let volumeId = dictionary["VolumeId"] as? String else { throw InitializableError.missingRequiredParam("VolumeId") }
            self.volumeId = volumeId
        }
    }

    public struct VolumeConfiguration: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The number of disks in the volume.
        public let numberOfDisks: Int32
        /// The volume type:    standard - Magnetic    io1 - Provisioned IOPS (SSD)    gp2 - General Purpose (SSD)  
        public let volumeType: String?
        /// For PIOPS volumes, the IOPS per disk.
        public let iops: Int32?
        /// The volume mount point. For example "/dev/sdh".
        public let mountPoint: String
        /// The volume size.
        public let size: Int32
        /// The volume RAID level.
        public let raidLevel: Int32?

        public init(numberOfDisks: Int32, volumeType: String? = nil, iops: Int32? = nil, mountPoint: String, size: Int32, raidLevel: Int32? = nil) {
            self.numberOfDisks = numberOfDisks
            self.volumeType = volumeType
            self.iops = iops
            self.mountPoint = mountPoint
            self.size = size
            self.raidLevel = raidLevel
        }

        public init(dictionary: [String: Any]) throws {
            guard let numberOfDisks = dictionary["NumberOfDisks"] as? Int32 else { throw InitializableError.missingRequiredParam("NumberOfDisks") }
            self.numberOfDisks = numberOfDisks
            self.volumeType = dictionary["VolumeType"] as? String
            self.iops = dictionary["Iops"] as? Int32
            guard let mountPoint = dictionary["MountPoint"] as? String else { throw InitializableError.missingRequiredParam("MountPoint") }
            self.mountPoint = mountPoint
            guard let size = dictionary["Size"] as? Int32 else { throw InitializableError.missingRequiredParam("Size") }
            self.size = size
            self.raidLevel = dictionary["RaidLevel"] as? Int32
        }
    }

    public struct CreateAppResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The app ID.
        public let appId: String?

        public init(appId: String? = nil) {
            self.appId = appId
        }

        public init(dictionary: [String: Any]) throws {
            self.appId = dictionary["AppId"] as? String
        }
    }

    public struct DescribeUserProfilesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A Users object that describes the specified users.
        public let userProfiles: [UserProfile]?

        public init(userProfiles: [UserProfile]? = nil) {
            self.userProfiles = userProfiles
        }

        public init(dictionary: [String: Any]) throws {
            if let userProfiles = dictionary["UserProfiles"] as? [[String: Any]] {
                self.userProfiles = try userProfiles.map({ try UserProfile(dictionary: $0) })
            } else { 
                self.userProfiles = nil
            }
        }
    }

    public struct SetLoadBasedAutoScalingRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An AutoScalingThresholds object with the downscaling threshold configuration. If the load falls below these thresholds for a specified amount of time, AWS OpsWorks stops a specified number of instances.
        public let downScaling: AutoScalingThresholds?
        /// Enables load-based auto scaling for the layer.
        public let enable: Bool?
        /// An AutoScalingThresholds object with the upscaling threshold configuration. If the load exceeds these thresholds for a specified amount of time, AWS OpsWorks starts a specified number of instances.
        public let upScaling: AutoScalingThresholds?
        /// The layer ID.
        public let layerId: String

        public init(downScaling: AutoScalingThresholds? = nil, enable: Bool? = nil, upScaling: AutoScalingThresholds? = nil, layerId: String) {
            self.downScaling = downScaling
            self.enable = enable
            self.upScaling = upScaling
            self.layerId = layerId
        }

        public init(dictionary: [String: Any]) throws {
            if let downScaling = dictionary["DownScaling"] as? [String: Any] { self.downScaling = try Opsworks.AutoScalingThresholds(dictionary: downScaling) } else { self.downScaling = nil }
            self.enable = dictionary["Enable"] as? Bool
            if let upScaling = dictionary["UpScaling"] as? [String: Any] { self.upScaling = try Opsworks.AutoScalingThresholds(dictionary: upScaling) } else { self.upScaling = nil }
            guard let layerId = dictionary["LayerId"] as? String else { throw InitializableError.missingRequiredParam("LayerId") }
            self.layerId = layerId
        }
    }

    public struct DeleteStackRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The stack ID.
        public let stackId: String

        public init(stackId: String) {
            self.stackId = stackId
        }

        public init(dictionary: [String: Any]) throws {
            guard let stackId = dictionary["StackId"] as? String else { throw InitializableError.missingRequiredParam("StackId") }
            self.stackId = stackId
        }
    }

    public struct UpdateMyUserProfileRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The user's SSH public key.
        public let sshPublicKey: String?

        public init(sshPublicKey: String? = nil) {
            self.sshPublicKey = sshPublicKey
        }

        public init(dictionary: [String: Any]) throws {
            self.sshPublicKey = dictionary["SshPublicKey"] as? String
        }
    }

    public enum StackAttributesKeys: String, CustomStringConvertible {
        case color = "Color"
        public var description: String { return self.rawValue }
    }

    public struct StopInstanceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The instance ID.
        public let instanceId: String

        public init(instanceId: String) {
            self.instanceId = instanceId
        }

        public init(dictionary: [String: Any]) throws {
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
        }
    }

    public struct DescribeInstancesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A stack ID. If you use this parameter, DescribeInstances returns descriptions of the instances associated with the specified stack.
        public let stackId: String?
        /// An array of instance IDs to be described. If you use this parameter, DescribeInstances returns a description of the specified instances. Otherwise, it returns a description of every instance.
        public let instanceIds: [String]?
        /// A layer ID. If you use this parameter, DescribeInstances returns descriptions of the instances associated with the specified layer.
        public let layerId: String?

        public init(stackId: String? = nil, instanceIds: [String]? = nil, layerId: String? = nil) {
            self.stackId = stackId
            self.instanceIds = instanceIds
            self.layerId = layerId
        }

        public init(dictionary: [String: Any]) throws {
            self.stackId = dictionary["StackId"] as? String
            self.instanceIds = dictionary["InstanceIds"] as? [String]
            self.layerId = dictionary["LayerId"] as? String
        }
    }

    public struct DescribeLoadBasedAutoScalingResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of LoadBasedAutoScalingConfiguration objects that describe each layer's configuration.
        public let loadBasedAutoScalingConfigurations: [LoadBasedAutoScalingConfiguration]?

        public init(loadBasedAutoScalingConfigurations: [LoadBasedAutoScalingConfiguration]? = nil) {
            self.loadBasedAutoScalingConfigurations = loadBasedAutoScalingConfigurations
        }

        public init(dictionary: [String: Any]) throws {
            if let loadBasedAutoScalingConfigurations = dictionary["LoadBasedAutoScalingConfigurations"] as? [[String: Any]] {
                self.loadBasedAutoScalingConfigurations = try loadBasedAutoScalingConfigurations.map({ try LoadBasedAutoScalingConfiguration(dictionary: $0) })
            } else { 
                self.loadBasedAutoScalingConfigurations = nil
            }
        }
    }

    public struct DeploymentCommand: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Specifies the operation. You can specify only one command. For stacks, the following commands are available:    execute_recipes: Execute one or more recipes. To specify the recipes, set an Args parameter named recipes to the list of recipes to be executed. For example, to execute phpapp::appsetup, set Args to {"recipes":["phpapp::appsetup"]}.    install_dependencies: Install the stack's dependencies.    update_custom_cookbooks: Update the stack's custom cookbooks.    update_dependencies: Update the stack's dependencies.    The update_dependencies and install_dependencies commands are supported only for Linux instances. You can run the commands successfully on Windows instances, but they do nothing.  For apps, the following commands are available:    deploy: Deploy an app. Ruby on Rails apps have an optional Args parameter named migrate. Set Args to {"migrate":["true"]} to migrate the database. The default setting is {"migrate":["false"]}.    rollback Roll the app back to the previous version. When you update an app, AWS OpsWorks stores the previous version, up to a maximum of five versions. You can use this command to roll an app back as many as four versions.    start: Start the app's web or application server.    stop: Stop the app's web or application server.    restart: Restart the app's web or application server.    undeploy: Undeploy the app.  
        public let name: DeploymentCommandName
        /// The arguments of those commands that take arguments. It should be set to a JSON object with the following format:  {"arg_name1" : ["value1", "value2", ...], "arg_name2" : ["value1", "value2", ...], ...}  The update_dependencies command takes two arguments:    upgrade_os_to - Specifies the desired Amazon Linux version for instances whose OS you want to upgrade, such as Amazon Linux 2014.09. You must also set the allow_reboot argument to true.    allow_reboot - Specifies whether to allow AWS OpsWorks to reboot the instances if necessary, after installing the updates. This argument can be set to either true or false. The default value is false.   For example, to upgrade an instance to Amazon Linux 2014.09, set Args to the following.   { "upgrade_os_to":["Amazon Linux 2014.09"], "allow_reboot":["true"] }  
        public let args: [String: [String]]?

        public init(name: DeploymentCommandName, args: [String: [String]]? = nil) {
            self.name = name
            self.args = args
        }

        public init(dictionary: [String: Any]) throws {
            guard let rawName = dictionary["Name"] as? String, let name = DeploymentCommandName(rawValue: rawName) else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            if let args = dictionary["Args"] as? [String: Any] {
                var argsDict: [String: [String]] = [:]
                for (key, value) in args {
                    guard let strings = value as? [String] else { throw InitializableError.convertingError }
                    argsDict[key] = strings
                }
                self.args = argsDict
            } else { 
                self.args = nil
            }
        }
    }

    public struct RegisterRdsDbInstanceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The stack ID.
        public let stackId: String
        /// The Amazon RDS instance's ARN.
        public let rdsDbInstanceArn: String
        /// The database password.
        public let dbPassword: String
        /// The database's master user name.
        public let dbUser: String

        public init(stackId: String, rdsDbInstanceArn: String, dbPassword: String, dbUser: String) {
            self.stackId = stackId
            self.rdsDbInstanceArn = rdsDbInstanceArn
            self.dbPassword = dbPassword
            self.dbUser = dbUser
        }

        public init(dictionary: [String: Any]) throws {
            guard let stackId = dictionary["StackId"] as? String else { throw InitializableError.missingRequiredParam("StackId") }
            self.stackId = stackId
            guard let rdsDbInstanceArn = dictionary["RdsDbInstanceArn"] as? String else { throw InitializableError.missingRequiredParam("RdsDbInstanceArn") }
            self.rdsDbInstanceArn = rdsDbInstanceArn
            guard let dbPassword = dictionary["DbPassword"] as? String else { throw InitializableError.missingRequiredParam("DbPassword") }
            self.dbPassword = dbPassword
            guard let dbUser = dictionary["DbUser"] as? String else { throw InitializableError.missingRequiredParam("DbUser") }
            self.dbUser = dbUser
        }
    }

    public struct CreateInstanceResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The instance ID.
        public let instanceId: String?

        public init(instanceId: String? = nil) {
            self.instanceId = instanceId
        }

        public init(dictionary: [String: Any]) throws {
            self.instanceId = dictionary["InstanceId"] as? String
        }
    }

    public struct Deployment: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Date when the deployment completed.
        public let completedAt: String?
        /// The deployment status:   running   successful   failed  
        public let status: String?
        /// Date when the deployment was created.
        public let createdAt: String?
        /// The stack ID.
        public let stackId: String?
        /// A user-defined comment.
        public let comment: String?
        /// The deployment ID.
        public let deploymentId: String?
        /// The user's IAM ARN.
        public let iamUserArn: String?
        /// A string that contains user-defined custom JSON. It can be used to override the corresponding default stack configuration attribute values for stack or to pass data to recipes. The string should be in the following format:  "{\"key1\": \"value1\", \"key2\": \"value2\",...}"  For more information on custom JSON, see Use Custom JSON to Modify the Stack Configuration Attributes.
        public let customJson: String?
        /// The deployment duration.
        public let duration: Int32?
        /// The IDs of the target instances.
        public let instanceIds: [String]?
        public let command: DeploymentCommand?
        /// The app ID.
        public let appId: String?

        public init(completedAt: String? = nil, status: String? = nil, createdAt: String? = nil, stackId: String? = nil, comment: String? = nil, deploymentId: String? = nil, iamUserArn: String? = nil, customJson: String? = nil, duration: Int32? = nil, instanceIds: [String]? = nil, command: DeploymentCommand? = nil, appId: String? = nil) {
            self.completedAt = completedAt
            self.status = status
            self.createdAt = createdAt
            self.stackId = stackId
            self.comment = comment
            self.deploymentId = deploymentId
            self.iamUserArn = iamUserArn
            self.customJson = customJson
            self.duration = duration
            self.instanceIds = instanceIds
            self.command = command
            self.appId = appId
        }

        public init(dictionary: [String: Any]) throws {
            self.completedAt = dictionary["CompletedAt"] as? String
            self.status = dictionary["Status"] as? String
            self.createdAt = dictionary["CreatedAt"] as? String
            self.stackId = dictionary["StackId"] as? String
            self.comment = dictionary["Comment"] as? String
            self.deploymentId = dictionary["DeploymentId"] as? String
            self.iamUserArn = dictionary["IamUserArn"] as? String
            self.customJson = dictionary["CustomJson"] as? String
            self.duration = dictionary["Duration"] as? Int32
            self.instanceIds = dictionary["InstanceIds"] as? [String]
            if let command = dictionary["Command"] as? [String: Any] { self.command = try Opsworks.DeploymentCommand(dictionary: command) } else { self.command = nil }
            self.appId = dictionary["AppId"] as? String
        }
    }

    public struct RegisterInstanceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An InstanceIdentity object that contains the instance's identity.
        public let instanceIdentity: InstanceIdentity?
        /// The instance's hostname.
        public let hostname: String?
        /// The ID of the stack that the instance is to be registered with.
        public let stackId: String
        /// The instance's private IP address.
        public let privateIp: String?
        /// The instances public RSA key fingerprint.
        public let rsaPublicKeyFingerprint: String?
        /// The instance's public IP address.
        public let publicIp: String?
        /// The instances public RSA key. This key is used to encrypt communication between the instance and the service.
        public let rsaPublicKey: String?

        public init(instanceIdentity: InstanceIdentity? = nil, hostname: String? = nil, stackId: String, privateIp: String? = nil, rsaPublicKeyFingerprint: String? = nil, publicIp: String? = nil, rsaPublicKey: String? = nil) {
            self.instanceIdentity = instanceIdentity
            self.hostname = hostname
            self.stackId = stackId
            self.privateIp = privateIp
            self.rsaPublicKeyFingerprint = rsaPublicKeyFingerprint
            self.publicIp = publicIp
            self.rsaPublicKey = rsaPublicKey
        }

        public init(dictionary: [String: Any]) throws {
            if let instanceIdentity = dictionary["InstanceIdentity"] as? [String: Any] { self.instanceIdentity = try Opsworks.InstanceIdentity(dictionary: instanceIdentity) } else { self.instanceIdentity = nil }
            self.hostname = dictionary["Hostname"] as? String
            guard let stackId = dictionary["StackId"] as? String else { throw InitializableError.missingRequiredParam("StackId") }
            self.stackId = stackId
            self.privateIp = dictionary["PrivateIp"] as? String
            self.rsaPublicKeyFingerprint = dictionary["RsaPublicKeyFingerprint"] as? String
            self.publicIp = dictionary["PublicIp"] as? String
            self.rsaPublicKey = dictionary["RsaPublicKey"] as? String
        }
    }

    public struct DescribeAppsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The app stack ID. If you use this parameter, DescribeApps returns a description of the apps in the specified stack.
        public let stackId: String?
        /// An array of app IDs for the apps to be described. If you use this parameter, DescribeApps returns a description of the specified apps. Otherwise, it returns a description of every app.
        public let appIds: [String]?

        public init(stackId: String? = nil, appIds: [String]? = nil) {
            self.stackId = stackId
            self.appIds = appIds
        }

        public init(dictionary: [String: Any]) throws {
            self.stackId = dictionary["StackId"] as? String
            self.appIds = dictionary["AppIds"] as? [String]
        }
    }

    public struct Source: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// In requests, the repository's SSH key. In responses, AWS OpsWorks returns *****FILTERED***** instead of the actual value.
        public let sshKey: String?
        /// This parameter depends on the repository type.   For Amazon S3 bundles, set Username to the appropriate IAM access key ID.   For HTTP bundles, Git repositories, and Subversion repositories, set Username to the user name.  
        public let username: String?
        /// When included in a request, the parameter depends on the repository type.   For Amazon S3 bundles, set Password to the appropriate IAM secret access key.   For HTTP bundles and Subversion repositories, set Password to the password.   For more information on how to safely handle IAM credentials, see http://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html. In responses, AWS OpsWorks returns *****FILTERED***** instead of the actual value.
        public let password: String?
        /// The repository type.
        public let `type`: SourceType?
        /// The source URL.
        public let url: String?
        /// The application's version. AWS OpsWorks enables you to easily deploy new versions of an application. One of the simplest approaches is to have branches or revisions in your repository that represent different versions that can potentially be deployed.
        public let revision: String?

        public init(sshKey: String? = nil, username: String? = nil, password: String? = nil, type: SourceType? = nil, url: String? = nil, revision: String? = nil) {
            self.sshKey = sshKey
            self.username = username
            self.password = password
            self.`type` = `type`
            self.url = url
            self.revision = revision
        }

        public init(dictionary: [String: Any]) throws {
            self.sshKey = dictionary["SshKey"] as? String
            self.username = dictionary["Username"] as? String
            self.password = dictionary["Password"] as? String
            if let `type` = dictionary["Type"] as? String { self.`type` = SourceType(rawValue: `type`) } else { self.`type` = nil }
            self.url = dictionary["Url"] as? String
            self.revision = dictionary["Revision"] as? String
        }
    }

    public struct DescribeRaidArraysResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A RaidArrays object that describes the specified RAID arrays.
        public let raidArrays: [RaidArray]?

        public init(raidArrays: [RaidArray]? = nil) {
            self.raidArrays = raidArrays
        }

        public init(dictionary: [String: Any]) throws {
            if let raidArrays = dictionary["RaidArrays"] as? [[String: Any]] {
                self.raidArrays = try raidArrays.map({ try RaidArray(dictionary: $0) })
            } else { 
                self.raidArrays = nil
            }
        }
    }

    public struct DescribeStacksResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of Stack objects that describe the stacks.
        public let stacks: [Stack]?

        public init(stacks: [Stack]? = nil) {
            self.stacks = stacks
        }

        public init(dictionary: [String: Any]) throws {
            if let stacks = dictionary["Stacks"] as? [[String: Any]] {
                self.stacks = try stacks.map({ try Stack(dictionary: $0) })
            } else { 
                self.stacks = nil
            }
        }
    }

    public struct DescribeServiceErrorsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The stack ID. If you use this parameter, DescribeServiceErrors returns descriptions of the errors associated with the specified stack.
        public let stackId: String?
        /// The instance ID. If you use this parameter, DescribeServiceErrors returns descriptions of the errors associated with the specified instance.
        public let instanceId: String?
        /// An array of service error IDs. If you use this parameter, DescribeServiceErrors returns descriptions of the specified errors. Otherwise, it returns a description of every error.
        public let serviceErrorIds: [String]?

        public init(stackId: String? = nil, instanceId: String? = nil, serviceErrorIds: [String]? = nil) {
            self.stackId = stackId
            self.instanceId = instanceId
            self.serviceErrorIds = serviceErrorIds
        }

        public init(dictionary: [String: Any]) throws {
            self.stackId = dictionary["StackId"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            self.serviceErrorIds = dictionary["ServiceErrorIds"] as? [String]
        }
    }

    public struct DescribeVolumesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The RAID array ID. If you use this parameter, DescribeVolumes returns descriptions of the volumes associated with the specified RAID array.
        public let raidArrayId: String?
        /// Am array of volume IDs. If you use this parameter, DescribeVolumes returns descriptions of the specified volumes. Otherwise, it returns a description of every volume.
        public let volumeIds: [String]?
        /// A stack ID. The action describes the stack's registered Amazon EBS volumes.
        public let stackId: String?
        /// The instance ID. If you use this parameter, DescribeVolumes returns descriptions of the volumes associated with the specified instance.
        public let instanceId: String?

        public init(raidArrayId: String? = nil, volumeIds: [String]? = nil, stackId: String? = nil, instanceId: String? = nil) {
            self.raidArrayId = raidArrayId
            self.volumeIds = volumeIds
            self.stackId = stackId
            self.instanceId = instanceId
        }

        public init(dictionary: [String: Any]) throws {
            self.raidArrayId = dictionary["RaidArrayId"] as? String
            self.volumeIds = dictionary["VolumeIds"] as? [String]
            self.stackId = dictionary["StackId"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
        }
    }

    public struct AutoScalingThresholds: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The memory utilization threshold, as a percent of the available memory. A value of -1 disables the threshold.
        public let memoryThreshold: Double?
        /// The CPU utilization threshold, as a percent of the available CPU. A value of -1 disables the threshold.
        public let cpuThreshold: Double?
        /// The amount of time (in minutes) after a scaling event occurs that AWS OpsWorks should ignore metrics and suppress additional scaling events. For example, AWS OpsWorks adds new instances following an upscaling event but the instances won't start reducing the load until they have been booted and configured. There is no point in raising additional scaling events during that operation, which typically takes several minutes. IgnoreMetricsTime allows you to direct AWS OpsWorks to suppress scaling events long enough to get the new instances online.
        public let ignoreMetricsTime: Int32?
        /// The load threshold. A value of -1 disables the threshold. For more information about how load is computed, see Load (computing).
        public let loadThreshold: Double?
        /// The number of instances to add or remove when the load exceeds a threshold.
        public let instanceCount: Int32?
        /// Custom Cloudwatch auto scaling alarms, to be used as thresholds. This parameter takes a list of up to five alarm names, which are case sensitive and must be in the same region as the stack.  To use custom alarms, you must update your service role to allow cloudwatch:DescribeAlarms. You can either have AWS OpsWorks update the role for you when you first use this feature or you can edit the role manually. For more information, see Allowing AWS OpsWorks to Act on Your Behalf. 
        public let alarms: [String]?
        /// The amount of time, in minutes, that the load must exceed a threshold before more instances are added or removed.
        public let thresholdsWaitTime: Int32?

        public init(memoryThreshold: Double? = nil, cpuThreshold: Double? = nil, ignoreMetricsTime: Int32? = nil, loadThreshold: Double? = nil, instanceCount: Int32? = nil, alarms: [String]? = nil, thresholdsWaitTime: Int32? = nil) {
            self.memoryThreshold = memoryThreshold
            self.cpuThreshold = cpuThreshold
            self.ignoreMetricsTime = ignoreMetricsTime
            self.loadThreshold = loadThreshold
            self.instanceCount = instanceCount
            self.alarms = alarms
            self.thresholdsWaitTime = thresholdsWaitTime
        }

        public init(dictionary: [String: Any]) throws {
            self.memoryThreshold = dictionary["MemoryThreshold"] as? Double
            self.cpuThreshold = dictionary["CpuThreshold"] as? Double
            self.ignoreMetricsTime = dictionary["IgnoreMetricsTime"] as? Int32
            self.loadThreshold = dictionary["LoadThreshold"] as? Double
            self.instanceCount = dictionary["InstanceCount"] as? Int32
            self.alarms = dictionary["Alarms"] as? [String]
            self.thresholdsWaitTime = dictionary["ThresholdsWaitTime"] as? Int32
        }
    }

    public enum LayerAttributesKeys: String, CustomStringConvertible {
        case ecsclusterarn = "EcsClusterArn"
        case enablehaproxystats = "EnableHaproxyStats"
        case haproxystatsurl = "HaproxyStatsUrl"
        case haproxystatsuser = "HaproxyStatsUser"
        case haproxystatspassword = "HaproxyStatsPassword"
        case haproxyhealthcheckurl = "HaproxyHealthCheckUrl"
        case haproxyhealthcheckmethod = "HaproxyHealthCheckMethod"
        case mysqlrootpassword = "MysqlRootPassword"
        case mysqlrootpasswordubiquitous = "MysqlRootPasswordUbiquitous"
        case gangliaurl = "GangliaUrl"
        case gangliauser = "GangliaUser"
        case gangliapassword = "GangliaPassword"
        case memcachedmemory = "MemcachedMemory"
        case nodejsversion = "NodejsVersion"
        case rubyversion = "RubyVersion"
        case rubygemsversion = "RubygemsVersion"
        case managebundler = "ManageBundler"
        case bundlerversion = "BundlerVersion"
        case railsstack = "RailsStack"
        case passengerversion = "PassengerVersion"
        case jvm = "Jvm"
        case jvmversion = "JvmVersion"
        case jvmoptions = "JvmOptions"
        case javaappserver = "JavaAppServer"
        case javaappserverversion = "JavaAppServerVersion"
        public var description: String { return self.rawValue }
    }

    public struct DescribeEcsClustersRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of ARNs, one for each cluster to be described.
        public let ecsClusterArns: [String]?
        /// A stack ID. DescribeEcsClusters returns a description of the cluster that is registered with the stack.
        public let stackId: String?
        /// If the previous paginated request did not return all of the remaining results, the response object'sNextToken parameter value is set to a token. To retrieve the next set of results, call DescribeEcsClusters again and assign that token to the request object's NextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
        public let nextToken: String?
        /// To receive a paginated response, use this parameter to specify the maximum number of results to be returned with a single call. If the number of available results exceeds this maximum, the response includes a NextToken value that you can assign to the NextToken request parameter to get the next set of results.
        public let maxResults: Int32?

        public init(ecsClusterArns: [String]? = nil, stackId: String? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.ecsClusterArns = ecsClusterArns
            self.stackId = stackId
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.ecsClusterArns = dictionary["EcsClusterArns"] as? [String]
            self.stackId = dictionary["StackId"] as? String
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct UpdateLayerRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// For custom layers only, use this parameter to specify the layer's short name, which is used internally by AWS OpsWorksand by Chef. The short name is also used as the name for the directory where your app files are installed. It can have a maximum of 200 characters and must be in the following format: /\A[a-z0-9\-\_\.]+\Z/. The built-in layers' short names are defined by AWS OpsWorks. For more information, see the Layer Reference 
        public let shortname: String?
        /// An array of Package objects that describe the layer's packages.
        public let packages: [String]?
        public let lifecycleEventConfiguration: LifecycleEventConfiguration?
        /// A LayerCustomRecipes object that specifies the layer's custom recipes.
        public let customRecipes: Recipes?
        /// Whether to automatically assign an Elastic IP address to the layer's instances. For more information, see How to Edit a Layer.
        public let autoAssignElasticIps: Bool?
        /// Whether to install operating system and package updates when the instance boots. The default value is true. To control when updates are installed, set this value to false. You must then update your instances manually by using CreateDeployment to run the update_dependencies stack command or manually running yum (Amazon Linux) or apt-get (Ubuntu) on the instances.   We strongly recommend using the default value of true, to ensure that your instances have the latest security updates. 
        public let installUpdatesOnBoot: Bool?
        /// A JSON-formatted string containing custom stack configuration and deployment attributes to be installed on the layer's instances. For more information, see  Using Custom JSON. 
        public let customJson: String?
        /// An array containing the layer's custom security group IDs.
        public let customSecurityGroupIds: [String]?
        /// The layer name, which is used by the console.
        public let name: String?
        /// The layer ID.
        public let layerId: String
        /// The ARN of an IAM profile to be used for all of the layer's EC2 instances. For more information about IAM ARNs, see Using Identifiers.
        public let customInstanceProfileArn: String?
        /// Whether to disable auto healing for the layer.
        public let enableAutoHealing: Bool?
        /// A VolumeConfigurations object that describes the layer's Amazon EBS volumes.
        public let volumeConfigurations: [VolumeConfiguration]?
        /// One or more user-defined key/value pairs to be added to the stack attributes.
        public let attributes: [LayerAttributesKeys: String]?
        /// Whether to use Amazon EBS-optimized instances.
        public let useEbsOptimizedInstances: Bool?
        /// For stacks that are running in a VPC, whether to automatically assign a public IP address to the layer's instances. For more information, see How to Edit a Layer.
        public let autoAssignPublicIps: Bool?

        public init(shortname: String? = nil, packages: [String]? = nil, lifecycleEventConfiguration: LifecycleEventConfiguration? = nil, customRecipes: Recipes? = nil, autoAssignElasticIps: Bool? = nil, installUpdatesOnBoot: Bool? = nil, customJson: String? = nil, customSecurityGroupIds: [String]? = nil, name: String? = nil, layerId: String, customInstanceProfileArn: String? = nil, enableAutoHealing: Bool? = nil, volumeConfigurations: [VolumeConfiguration]? = nil, attributes: [LayerAttributesKeys: String]? = nil, useEbsOptimizedInstances: Bool? = nil, autoAssignPublicIps: Bool? = nil) {
            self.shortname = shortname
            self.packages = packages
            self.lifecycleEventConfiguration = lifecycleEventConfiguration
            self.customRecipes = customRecipes
            self.autoAssignElasticIps = autoAssignElasticIps
            self.installUpdatesOnBoot = installUpdatesOnBoot
            self.customJson = customJson
            self.customSecurityGroupIds = customSecurityGroupIds
            self.name = name
            self.layerId = layerId
            self.customInstanceProfileArn = customInstanceProfileArn
            self.enableAutoHealing = enableAutoHealing
            self.volumeConfigurations = volumeConfigurations
            self.attributes = attributes
            self.useEbsOptimizedInstances = useEbsOptimizedInstances
            self.autoAssignPublicIps = autoAssignPublicIps
        }

        public init(dictionary: [String: Any]) throws {
            self.shortname = dictionary["Shortname"] as? String
            self.packages = dictionary["Packages"] as? [String]
            if let lifecycleEventConfiguration = dictionary["LifecycleEventConfiguration"] as? [String: Any] { self.lifecycleEventConfiguration = try Opsworks.LifecycleEventConfiguration(dictionary: lifecycleEventConfiguration) } else { self.lifecycleEventConfiguration = nil }
            if let customRecipes = dictionary["CustomRecipes"] as? [String: Any] { self.customRecipes = try Opsworks.Recipes(dictionary: customRecipes) } else { self.customRecipes = nil }
            self.autoAssignElasticIps = dictionary["AutoAssignElasticIps"] as? Bool
            self.installUpdatesOnBoot = dictionary["InstallUpdatesOnBoot"] as? Bool
            self.customJson = dictionary["CustomJson"] as? String
            self.customSecurityGroupIds = dictionary["CustomSecurityGroupIds"] as? [String]
            self.name = dictionary["Name"] as? String
            guard let layerId = dictionary["LayerId"] as? String else { throw InitializableError.missingRequiredParam("LayerId") }
            self.layerId = layerId
            self.customInstanceProfileArn = dictionary["CustomInstanceProfileArn"] as? String
            self.enableAutoHealing = dictionary["EnableAutoHealing"] as? Bool
            if let volumeConfigurations = dictionary["VolumeConfigurations"] as? [[String: Any]] {
                self.volumeConfigurations = try volumeConfigurations.map({ try VolumeConfiguration(dictionary: $0) })
            } else { 
                self.volumeConfigurations = nil
            }
            if let attributes = dictionary["Attributes"] as? [LayerAttributesKeys: String] {
                self.attributes = attributes
            } else { 
                self.attributes = nil
            }
            self.useEbsOptimizedInstances = dictionary["UseEbsOptimizedInstances"] as? Bool
            self.autoAssignPublicIps = dictionary["AutoAssignPublicIps"] as? Bool
        }
    }

    public struct DescribeStackProvisioningParametersResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An embedded object that contains the provisioning parameters.
        public let parameters: [String: String]?
        /// The AWS OpsWorks agent installer's URL.
        public let agentInstallerUrl: String?

        public init(parameters: [String: String]? = nil, agentInstallerUrl: String? = nil) {
            self.parameters = parameters
            self.agentInstallerUrl = agentInstallerUrl
        }

        public init(dictionary: [String: Any]) throws {
            if let parameters = dictionary["Parameters"] as? [String: String] {
                self.parameters = parameters
            } else { 
                self.parameters = nil
            }
            self.agentInstallerUrl = dictionary["AgentInstallerUrl"] as? String
        }
    }

    public struct UnassignInstanceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The instance ID.
        public let instanceId: String

        public init(instanceId: String) {
            self.instanceId = instanceId
        }

        public init(dictionary: [String: Any]) throws {
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
        }
    }

    public enum AppType: String, CustomStringConvertible {
        case aws_flow_ruby = "aws-flow-ruby"
        case java = "java"
        case rails = "rails"
        case php = "php"
        case nodejs = "nodejs"
        case `static` = "static"
        case other = "other"
        public var description: String { return self.rawValue }
    }

    public struct Stack: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The stack's default operating system.
        public let defaultOs: String?
        /// Whether the stack automatically associates the AWS OpsWorks built-in security groups with the stack's layers.
        public let useOpsworksSecurityGroups: Bool?
        /// The stack's ARN.
        public let arn: String?
        /// The default root device type. This value is used by default for all instances in the stack, but you can override it when you create an instance. For more information, see Storage for the Root Device.
        public let defaultRootDeviceType: RootDeviceType?
        /// The ARN of an IAM profile that is the default profile for all of the stack's EC2 instances. For more information about IAM ARNs, see Using Identifiers.
        public let defaultInstanceProfileArn: String?
        /// The stack AWS Identity and Access Management (IAM) role.
        public let serviceRoleArn: String?
        /// The stack AWS region, such as "ap-northeast-2". For more information about AWS regions, see Regions and Endpoints.
        public let region: String?
        /// Whether the stack uses custom cookbooks.
        public let useCustomCookbooks: Bool?
        /// A JSON object that contains user-defined attributes to be added to the stack configuration and deployment attributes. You can use custom JSON to override the corresponding default stack configuration attribute values or to pass data to recipes. The string should be in the following format:  "{\"key1\": \"value1\", \"key2\": \"value2\",...}"  For more information on custom JSON, see Use Custom JSON to Modify the Stack Configuration Attributes.
        public let customJson: String?
        public let customCookbooksSource: Source?
        /// A default Amazon EC2 key pair for the stack's instances. You can override this value when you create or update an instance.
        public let defaultSshKeyName: String?
        /// The date when the stack was created.
        public let createdAt: String?
        /// The VPC ID; applicable only if the stack is running in a VPC.
        public let vpcId: String?
        /// The stack ID.
        public let stackId: String?
        /// The stack name.
        public let name: String?
        /// The agent version. This parameter is set to LATEST for auto-update. or a version number for a fixed agent version.
        public let agentVersion: String?
        /// The stack's attributes.
        public let attributes: [StackAttributesKeys: String]?
        /// The default subnet ID; applicable only if the stack is running in a VPC.
        public let defaultSubnetId: String?
        /// The stack's default Availability Zone. For more information, see Regions and Endpoints.
        public let defaultAvailabilityZone: String?
        /// The stack host name theme, with spaces replaced by underscores.
        public let hostnameTheme: String?
        /// The configuration manager.
        public let configurationManager: StackConfigurationManager?
        /// A ChefConfiguration object that specifies whether to enable Berkshelf and the Berkshelf version. For more information, see Create a New Stack.
        public let chefConfiguration: ChefConfiguration?

        public init(defaultOs: String? = nil, useOpsworksSecurityGroups: Bool? = nil, arn: String? = nil, defaultRootDeviceType: RootDeviceType? = nil, defaultInstanceProfileArn: String? = nil, serviceRoleArn: String? = nil, region: String? = nil, useCustomCookbooks: Bool? = nil, customJson: String? = nil, customCookbooksSource: Source? = nil, defaultSshKeyName: String? = nil, createdAt: String? = nil, vpcId: String? = nil, stackId: String? = nil, name: String? = nil, agentVersion: String? = nil, attributes: [StackAttributesKeys: String]? = nil, defaultSubnetId: String? = nil, defaultAvailabilityZone: String? = nil, hostnameTheme: String? = nil, configurationManager: StackConfigurationManager? = nil, chefConfiguration: ChefConfiguration? = nil) {
            self.defaultOs = defaultOs
            self.useOpsworksSecurityGroups = useOpsworksSecurityGroups
            self.arn = arn
            self.defaultRootDeviceType = defaultRootDeviceType
            self.defaultInstanceProfileArn = defaultInstanceProfileArn
            self.serviceRoleArn = serviceRoleArn
            self.region = region
            self.useCustomCookbooks = useCustomCookbooks
            self.customJson = customJson
            self.customCookbooksSource = customCookbooksSource
            self.defaultSshKeyName = defaultSshKeyName
            self.createdAt = createdAt
            self.vpcId = vpcId
            self.stackId = stackId
            self.name = name
            self.agentVersion = agentVersion
            self.attributes = attributes
            self.defaultSubnetId = defaultSubnetId
            self.defaultAvailabilityZone = defaultAvailabilityZone
            self.hostnameTheme = hostnameTheme
            self.configurationManager = configurationManager
            self.chefConfiguration = chefConfiguration
        }

        public init(dictionary: [String: Any]) throws {
            self.defaultOs = dictionary["DefaultOs"] as? String
            self.useOpsworksSecurityGroups = dictionary["UseOpsworksSecurityGroups"] as? Bool
            self.arn = dictionary["Arn"] as? String
            if let defaultRootDeviceType = dictionary["DefaultRootDeviceType"] as? String { self.defaultRootDeviceType = RootDeviceType(rawValue: defaultRootDeviceType) } else { self.defaultRootDeviceType = nil }
            self.defaultInstanceProfileArn = dictionary["DefaultInstanceProfileArn"] as? String
            self.serviceRoleArn = dictionary["ServiceRoleArn"] as? String
            self.region = dictionary["Region"] as? String
            self.useCustomCookbooks = dictionary["UseCustomCookbooks"] as? Bool
            self.customJson = dictionary["CustomJson"] as? String
            if let customCookbooksSource = dictionary["CustomCookbooksSource"] as? [String: Any] { self.customCookbooksSource = try Opsworks.Source(dictionary: customCookbooksSource) } else { self.customCookbooksSource = nil }
            self.defaultSshKeyName = dictionary["DefaultSshKeyName"] as? String
            self.createdAt = dictionary["CreatedAt"] as? String
            self.vpcId = dictionary["VpcId"] as? String
            self.stackId = dictionary["StackId"] as? String
            self.name = dictionary["Name"] as? String
            self.agentVersion = dictionary["AgentVersion"] as? String
            if let attributes = dictionary["Attributes"] as? [StackAttributesKeys: String] {
                self.attributes = attributes
            } else { 
                self.attributes = nil
            }
            self.defaultSubnetId = dictionary["DefaultSubnetId"] as? String
            self.defaultAvailabilityZone = dictionary["DefaultAvailabilityZone"] as? String
            self.hostnameTheme = dictionary["HostnameTheme"] as? String
            if let configurationManager = dictionary["ConfigurationManager"] as? [String: Any] { self.configurationManager = try Opsworks.StackConfigurationManager(dictionary: configurationManager) } else { self.configurationManager = nil }
            if let chefConfiguration = dictionary["ChefConfiguration"] as? [String: Any] { self.chefConfiguration = try Opsworks.ChefConfiguration(dictionary: chefConfiguration) } else { self.chefConfiguration = nil }
        }
    }

    public struct StartStackRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The stack ID.
        public let stackId: String

        public init(stackId: String) {
            self.stackId = stackId
        }

        public init(dictionary: [String: Any]) throws {
            guard let stackId = dictionary["StackId"] as? String else { throw InitializableError.missingRequiredParam("StackId") }
            self.stackId = stackId
        }
    }

    public struct ReportedOs: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The operating system family.
        public let family: String?
        /// The operating system name.
        public let name: String?
        /// The operating system version.
        public let version: String?

        public init(family: String? = nil, name: String? = nil, version: String? = nil) {
            self.family = family
            self.name = name
            self.version = version
        }

        public init(dictionary: [String: Any]) throws {
            self.family = dictionary["Family"] as? String
            self.name = dictionary["Name"] as? String
            self.version = dictionary["Version"] as? String
        }
    }

    public struct Recipes: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of custom recipe names to be run following a undeploy event.
        public let undeploy: [String]?
        /// An array of custom recipe names to be run following a configure event.
        public let configure: [String]?
        /// An array of custom recipe names to be run following a setup event.
        public let setup: [String]?
        /// An array of custom recipe names to be run following a shutdown event.
        public let shutdown: [String]?
        /// An array of custom recipe names to be run following a deploy event.
        public let deploy: [String]?

        public init(undeploy: [String]? = nil, configure: [String]? = nil, setup: [String]? = nil, shutdown: [String]? = nil, deploy: [String]? = nil) {
            self.undeploy = undeploy
            self.configure = configure
            self.setup = setup
            self.shutdown = shutdown
            self.deploy = deploy
        }

        public init(dictionary: [String: Any]) throws {
            self.undeploy = dictionary["Undeploy"] as? [String]
            self.configure = dictionary["Configure"] as? [String]
            self.setup = dictionary["Setup"] as? [String]
            self.shutdown = dictionary["Shutdown"] as? [String]
            self.deploy = dictionary["Deploy"] as? [String]
        }
    }

    public enum Architecture: String, CustomStringConvertible {
        case x86_64 = "x86_64"
        case i386 = "i386"
        public var description: String { return self.rawValue }
    }

    public struct SetPermissionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The user's permission level, which must be set to one of the following strings. You cannot set your own permissions level.    deny     show     deploy     manage     iam_only    For more information on the permissions associated with these levels, see Managing User Permissions.
        public let level: String?
        /// The user's IAM ARN. This can also be a federated user's ARN.
        public let iamUserArn: String
        /// The user is allowed to use SSH to communicate with the instance.
        public let allowSsh: Bool?
        /// The stack ID.
        public let stackId: String
        /// The user is allowed to use sudo to elevate privileges.
        public let allowSudo: Bool?

        public init(level: String? = nil, iamUserArn: String, allowSsh: Bool? = nil, stackId: String, allowSudo: Bool? = nil) {
            self.level = level
            self.iamUserArn = iamUserArn
            self.allowSsh = allowSsh
            self.stackId = stackId
            self.allowSudo = allowSudo
        }

        public init(dictionary: [String: Any]) throws {
            self.level = dictionary["Level"] as? String
            guard let iamUserArn = dictionary["IamUserArn"] as? String else { throw InitializableError.missingRequiredParam("IamUserArn") }
            self.iamUserArn = iamUserArn
            self.allowSsh = dictionary["AllowSsh"] as? Bool
            guard let stackId = dictionary["StackId"] as? String else { throw InitializableError.missingRequiredParam("StackId") }
            self.stackId = stackId
            self.allowSudo = dictionary["AllowSudo"] as? Bool
        }
    }

    public struct DescribeTimeBasedAutoScalingResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of TimeBasedAutoScalingConfiguration objects that describe the configuration for the specified instances.
        public let timeBasedAutoScalingConfigurations: [TimeBasedAutoScalingConfiguration]?

        public init(timeBasedAutoScalingConfigurations: [TimeBasedAutoScalingConfiguration]? = nil) {
            self.timeBasedAutoScalingConfigurations = timeBasedAutoScalingConfigurations
        }

        public init(dictionary: [String: Any]) throws {
            if let timeBasedAutoScalingConfigurations = dictionary["TimeBasedAutoScalingConfigurations"] as? [[String: Any]] {
                self.timeBasedAutoScalingConfigurations = try timeBasedAutoScalingConfigurations.map({ try TimeBasedAutoScalingConfiguration(dictionary: $0) })
            } else { 
                self.timeBasedAutoScalingConfigurations = nil
            }
        }
    }

    public struct DescribeElasticLoadBalancersRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A stack ID. The action describes the stack's Elastic Load Balancing instances.
        public let stackId: String?
        /// A list of layer IDs. The action describes the Elastic Load Balancing instances for the specified layers.
        public let layerIds: [String]?

        public init(stackId: String? = nil, layerIds: [String]? = nil) {
            self.stackId = stackId
            self.layerIds = layerIds
        }

        public init(dictionary: [String: Any]) throws {
            self.stackId = dictionary["StackId"] as? String
            self.layerIds = dictionary["LayerIds"] as? [String]
        }
    }

    public struct UpdateVolumeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The new mount point.
        public let mountPoint: String?
        /// The volume ID.
        public let volumeId: String
        /// The new name.
        public let name: String?

        public init(mountPoint: String? = nil, volumeId: String, name: String? = nil) {
            self.mountPoint = mountPoint
            self.volumeId = volumeId
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            self.mountPoint = dictionary["MountPoint"] as? String
            guard let volumeId = dictionary["VolumeId"] as? String else { throw InitializableError.missingRequiredParam("VolumeId") }
            self.volumeId = volumeId
            self.name = dictionary["Name"] as? String
        }
    }

    public struct RegisterVolumeResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The volume ID.
        public let volumeId: String?

        public init(volumeId: String? = nil) {
            self.volumeId = volumeId
        }

        public init(dictionary: [String: Any]) throws {
            self.volumeId = dictionary["VolumeId"] as? String
        }
    }

    public struct DescribeMyUserProfileResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A UserProfile object that describes the user's SSH information.
        public let userProfile: SelfUserProfile?

        public init(userProfile: SelfUserProfile? = nil) {
            self.userProfile = userProfile
        }

        public init(dictionary: [String: Any]) throws {
            if let userProfile = dictionary["UserProfile"] as? [String: Any] { self.userProfile = try Opsworks.SelfUserProfile(dictionary: userProfile) } else { self.userProfile = nil }
        }
    }

    public struct RegisterElasticIpRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Elastic IP address.
        public let elasticIp: String
        /// The stack ID.
        public let stackId: String

        public init(elasticIp: String, stackId: String) {
            self.elasticIp = elasticIp
            self.stackId = stackId
        }

        public init(dictionary: [String: Any]) throws {
            guard let elasticIp = dictionary["ElasticIp"] as? String else { throw InitializableError.missingRequiredParam("ElasticIp") }
            self.elasticIp = elasticIp
            guard let stackId = dictionary["StackId"] as? String else { throw InitializableError.missingRequiredParam("StackId") }
            self.stackId = stackId
        }
    }

    public struct DescribeCommandsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of command IDs. If you include this parameter, DescribeCommands returns a description of the specified commands. Otherwise, it returns a description of every command.
        public let commandIds: [String]?
        /// The deployment ID. If you include this parameter, DescribeCommands returns a description of the commands associated with the specified deployment.
        public let deploymentId: String?
        /// The instance ID. If you include this parameter, DescribeCommands returns a description of the commands associated with the specified instance.
        public let instanceId: String?

        public init(commandIds: [String]? = nil, deploymentId: String? = nil, instanceId: String? = nil) {
            self.commandIds = commandIds
            self.deploymentId = deploymentId
            self.instanceId = instanceId
        }

        public init(dictionary: [String: Any]) throws {
            self.commandIds = dictionary["CommandIds"] as? [String]
            self.deploymentId = dictionary["DeploymentId"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
        }
    }

    public struct DescribeAgentVersionsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The agent versions for the specified stack or configuration manager. Note that this value is the complete version number, not the abbreviated number used by the console.
        public let agentVersions: [AgentVersion]?

        public init(agentVersions: [AgentVersion]? = nil) {
            self.agentVersions = agentVersions
        }

        public init(dictionary: [String: Any]) throws {
            if let agentVersions = dictionary["AgentVersions"] as? [[String: Any]] {
                self.agentVersions = try agentVersions.map({ try AgentVersion(dictionary: $0) })
            } else { 
                self.agentVersions = nil
            }
        }
    }

    public enum SourceType: String, CustomStringConvertible {
        case git = "git"
        case svn = "svn"
        case archive = "archive"
        case s3 = "s3"
        public var description: String { return self.rawValue }
    }

    public struct CreateStackRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The stack's default operating system, which is installed on every instance unless you specify a different operating system when you create the instance. You can specify one of the following.   A supported Linux operating system: An Amazon Linux version, such as Amazon Linux 2016.03, Amazon Linux 2015.09, or Amazon Linux 2015.03.   A supported Ubuntu operating system, such as Ubuntu 16.04 LTS, Ubuntu 14.04 LTS, or Ubuntu 12.04 LTS.    CentOS 7     Red Hat Enterprise Linux 7    A supported Windows operating system, such as Microsoft Windows Server 2012 R2 Base, Microsoft Windows Server 2012 R2 with SQL Server Express, Microsoft Windows Server 2012 R2 with SQL Server Standard, or Microsoft Windows Server 2012 R2 with SQL Server Web.   A custom AMI: Custom. You specify the custom AMI you want to use when you create instances. For more information, see  Using Custom AMIs.   The default option is the current Amazon Linux version. For more information on the supported operating systems, see AWS OpsWorks Operating Systems.
        public let defaultOs: String?
        /// A ChefConfiguration object that specifies whether to enable Berkshelf and the Berkshelf version on Chef 11.10 stacks. For more information, see Create a New Stack.
        public let chefConfiguration: ChefConfiguration?
        /// The stack's AWS Identity and Access Management (IAM) role, which allows AWS OpsWorks to work with AWS resources on your behalf. You must set this parameter to the Amazon Resource Name (ARN) for an existing IAM role. For more information about IAM ARNs, see Using Identifiers.
        public let serviceRoleArn: String
        /// The default root device type. This value is the default for all instances in the stack, but you can override it when you create an instance. The default option is instance-store. For more information, see Storage for the Root Device.
        public let defaultRootDeviceType: RootDeviceType?
        /// The Amazon Resource Name (ARN) of an IAM profile that is the default profile for all of the stack's EC2 instances. For more information about IAM ARNs, see Using Identifiers.
        public let defaultInstanceProfileArn: String
        /// The stack's AWS region, such as "ap-south-1". For more information about Amazon regions, see Regions and Endpoints.
        public let region: String
        public let customCookbooksSource: Source?
        /// A string that contains user-defined, custom JSON. It can be used to override the corresponding default stack configuration attribute values or to pass data to recipes. The string should be in the following format:  "{\"key1\": \"value1\", \"key2\": \"value2\",...}"  For more information on custom JSON, see Use Custom JSON to Modify the Stack Configuration Attributes.
        public let customJson: String?
        /// Whether the stack uses custom cookbooks.
        public let useCustomCookbooks: Bool?
        /// A default Amazon EC2 key pair name. The default value is none. If you specify a key pair name, AWS OpsWorks installs the public key on the instance and you can use the private key with an SSH client to log in to the instance. For more information, see  Using SSH to Communicate with an Instance and  Managing SSH Access. You can override this setting by specifying a different key pair, or no key pair, when you  create an instance. 
        public let defaultSshKeyName: String?
        /// The default AWS OpsWorks agent version. You have the following options:   Auto-update - Set this parameter to LATEST. AWS OpsWorks automatically installs new agent versions on the stack's instances as soon as they are available.   Fixed version - Set this parameter to your preferred agent version. To update the agent version, you must edit the stack configuration and specify a new version. AWS OpsWorks then automatically installs that version on the stack's instances.   The default setting is the most recent release of the agent. To specify an agent version, you must use the complete version number, not the abbreviated number shown on the console. For a list of available agent version numbers, call DescribeAgentVersions.  You can also specify an agent version when you create or update an instance, which overrides the stack's default setting. 
        public let agentVersion: String?
        /// The stack name.
        public let name: String
        /// The ID of the VPC that the stack is to be launched into. The VPC must be in the stack's region. All instances are launched into this VPC. You cannot change the ID later.   If your account supports EC2-Classic, the default value is no VPC.   If your account does not support EC2-Classic, the default value is the default VPC for the specified region.   If the VPC ID corresponds to a default VPC and you have specified either the DefaultAvailabilityZone or the DefaultSubnetId parameter only, AWS OpsWorks infers the value of the other parameter. If you specify neither parameter, AWS OpsWorks sets these parameters to the first valid Availability Zone for the specified region and the corresponding default VPC subnet ID, respectively. If you specify a nondefault VPC ID, note the following:   It must belong to a VPC in your account that is in the specified region.   You must specify a value for DefaultSubnetId.   For more information on how to use AWS OpsWorks with a VPC, see Running a Stack in a VPC. For more information on default VPC and EC2-Classic, see Supported Platforms. 
        public let vpcId: String?
        /// One or more user-defined key-value pairs to be added to the stack attributes.
        public let attributes: [StackAttributesKeys: String]?
        /// The stack's default VPC subnet ID. This parameter is required if you specify a value for the VpcId parameter. All instances are launched into this subnet unless you specify otherwise when you create the instance. If you also specify a value for DefaultAvailabilityZone, the subnet must be in that zone. For information on default values and when this parameter is required, see the VpcId parameter description. 
        public let defaultSubnetId: String?
        /// The configuration manager. When you create a stack we recommend that you use the configuration manager to specify the Chef version: 12, 11.10, or 11.4 for Linux stacks, or 12.2 for Windows stacks. The default value for Linux stacks is currently 11.4.
        public let configurationManager: StackConfigurationManager?
        /// The stack's default Availability Zone, which must be in the specified region. For more information, see Regions and Endpoints. If you also specify a value for DefaultSubnetId, the subnet must be in the same zone. For more information, see the VpcId parameter description. 
        public let defaultAvailabilityZone: String?
        /// The stack's host name theme, with spaces replaced by underscores. The theme is used to generate host names for the stack's instances. By default, HostnameTheme is set to Layer_Dependent, which creates host names by appending integers to the layer's short name. The other themes are:    Baked_Goods     Clouds     Europe_Cities     Fruits     Greek_Deities     Legendary_creatures_from_Japan     Planets_and_Moons     Roman_Deities     Scottish_Islands     US_Cities     Wild_Cats    To obtain a generated host name, call GetHostNameSuggestion, which returns a host name based on the current theme.
        public let hostnameTheme: String?
        /// Whether to associate the AWS OpsWorks built-in security groups with the stack's layers. AWS OpsWorks provides a standard set of built-in security groups, one for each layer, which are associated with layers by default. With UseOpsworksSecurityGroups you can instead provide your own custom security groups. UseOpsworksSecurityGroups has the following settings:    True - AWS OpsWorks automatically associates the appropriate built-in security group with each layer (default setting). You can associate additional security groups with a layer after you create it, but you cannot delete the built-in security group.   False - AWS OpsWorks does not associate built-in security groups with layers. You must create appropriate EC2 security groups and associate a security group with each layer that you create. However, you can still manually associate a built-in security group with a layer on creation; custom security groups are required only for those layers that need custom settings.   For more information, see Create a New Stack.
        public let useOpsworksSecurityGroups: Bool?

        public init(defaultOs: String? = nil, chefConfiguration: ChefConfiguration? = nil, serviceRoleArn: String, defaultRootDeviceType: RootDeviceType? = nil, defaultInstanceProfileArn: String, region: String, customCookbooksSource: Source? = nil, customJson: String? = nil, useCustomCookbooks: Bool? = nil, defaultSshKeyName: String? = nil, agentVersion: String? = nil, name: String, vpcId: String? = nil, attributes: [StackAttributesKeys: String]? = nil, defaultSubnetId: String? = nil, configurationManager: StackConfigurationManager? = nil, defaultAvailabilityZone: String? = nil, hostnameTheme: String? = nil, useOpsworksSecurityGroups: Bool? = nil) {
            self.defaultOs = defaultOs
            self.chefConfiguration = chefConfiguration
            self.serviceRoleArn = serviceRoleArn
            self.defaultRootDeviceType = defaultRootDeviceType
            self.defaultInstanceProfileArn = defaultInstanceProfileArn
            self.region = region
            self.customCookbooksSource = customCookbooksSource
            self.customJson = customJson
            self.useCustomCookbooks = useCustomCookbooks
            self.defaultSshKeyName = defaultSshKeyName
            self.agentVersion = agentVersion
            self.name = name
            self.vpcId = vpcId
            self.attributes = attributes
            self.defaultSubnetId = defaultSubnetId
            self.configurationManager = configurationManager
            self.defaultAvailabilityZone = defaultAvailabilityZone
            self.hostnameTheme = hostnameTheme
            self.useOpsworksSecurityGroups = useOpsworksSecurityGroups
        }

        public init(dictionary: [String: Any]) throws {
            self.defaultOs = dictionary["DefaultOs"] as? String
            if let chefConfiguration = dictionary["ChefConfiguration"] as? [String: Any] { self.chefConfiguration = try Opsworks.ChefConfiguration(dictionary: chefConfiguration) } else { self.chefConfiguration = nil }
            guard let serviceRoleArn = dictionary["ServiceRoleArn"] as? String else { throw InitializableError.missingRequiredParam("ServiceRoleArn") }
            self.serviceRoleArn = serviceRoleArn
            if let defaultRootDeviceType = dictionary["DefaultRootDeviceType"] as? String { self.defaultRootDeviceType = RootDeviceType(rawValue: defaultRootDeviceType) } else { self.defaultRootDeviceType = nil }
            guard let defaultInstanceProfileArn = dictionary["DefaultInstanceProfileArn"] as? String else { throw InitializableError.missingRequiredParam("DefaultInstanceProfileArn") }
            self.defaultInstanceProfileArn = defaultInstanceProfileArn
            guard let region = dictionary["Region"] as? String else { throw InitializableError.missingRequiredParam("Region") }
            self.region = region
            if let customCookbooksSource = dictionary["CustomCookbooksSource"] as? [String: Any] { self.customCookbooksSource = try Opsworks.Source(dictionary: customCookbooksSource) } else { self.customCookbooksSource = nil }
            self.customJson = dictionary["CustomJson"] as? String
            self.useCustomCookbooks = dictionary["UseCustomCookbooks"] as? Bool
            self.defaultSshKeyName = dictionary["DefaultSshKeyName"] as? String
            self.agentVersion = dictionary["AgentVersion"] as? String
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            self.vpcId = dictionary["VpcId"] as? String
            if let attributes = dictionary["Attributes"] as? [StackAttributesKeys: String] {
                self.attributes = attributes
            } else { 
                self.attributes = nil
            }
            self.defaultSubnetId = dictionary["DefaultSubnetId"] as? String
            if let configurationManager = dictionary["ConfigurationManager"] as? [String: Any] { self.configurationManager = try Opsworks.StackConfigurationManager(dictionary: configurationManager) } else { self.configurationManager = nil }
            self.defaultAvailabilityZone = dictionary["DefaultAvailabilityZone"] as? String
            self.hostnameTheme = dictionary["HostnameTheme"] as? String
            self.useOpsworksSecurityGroups = dictionary["UseOpsworksSecurityGroups"] as? Bool
        }
    }

    public struct DeleteLayerRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The layer ID.
        public let layerId: String

        public init(layerId: String) {
            self.layerId = layerId
        }

        public init(dictionary: [String: Any]) throws {
            guard let layerId = dictionary["LayerId"] as? String else { throw InitializableError.missingRequiredParam("LayerId") }
            self.layerId = layerId
        }
    }

    public struct RegisterEcsClusterRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The stack ID.
        public let stackId: String
        /// The cluster's ARN.
        public let ecsClusterArn: String

        public init(stackId: String, ecsClusterArn: String) {
            self.stackId = stackId
            self.ecsClusterArn = ecsClusterArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let stackId = dictionary["StackId"] as? String else { throw InitializableError.missingRequiredParam("StackId") }
            self.stackId = stackId
            guard let ecsClusterArn = dictionary["EcsClusterArn"] as? String else { throw InitializableError.missingRequiredParam("EcsClusterArn") }
            self.ecsClusterArn = ecsClusterArn
        }
    }

    public struct UpdateRdsDbInstanceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The database password.
        public let dbPassword: String?
        /// The master user name.
        public let dbUser: String?
        /// The Amazon RDS instance's ARN.
        public let rdsDbInstanceArn: String

        public init(dbPassword: String? = nil, dbUser: String? = nil, rdsDbInstanceArn: String) {
            self.dbPassword = dbPassword
            self.dbUser = dbUser
            self.rdsDbInstanceArn = rdsDbInstanceArn
        }

        public init(dictionary: [String: Any]) throws {
            self.dbPassword = dictionary["DbPassword"] as? String
            self.dbUser = dictionary["DbUser"] as? String
            guard let rdsDbInstanceArn = dictionary["RdsDbInstanceArn"] as? String else { throw InitializableError.missingRequiredParam("RdsDbInstanceArn") }
            self.rdsDbInstanceArn = rdsDbInstanceArn
        }
    }

    public struct ChefConfiguration: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Whether to enable Berkshelf.
        public let manageBerkshelf: Bool?
        /// The Berkshelf version.
        public let berkshelfVersion: String?

        public init(manageBerkshelf: Bool? = nil, berkshelfVersion: String? = nil) {
            self.manageBerkshelf = manageBerkshelf
            self.berkshelfVersion = berkshelfVersion
        }

        public init(dictionary: [String: Any]) throws {
            self.manageBerkshelf = dictionary["ManageBerkshelf"] as? Bool
            self.berkshelfVersion = dictionary["BerkshelfVersion"] as? String
        }
    }

    public struct DisassociateElasticIpRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Elastic IP address.
        public let elasticIp: String

        public init(elasticIp: String) {
            self.elasticIp = elasticIp
        }

        public init(dictionary: [String: Any]) throws {
            guard let elasticIp = dictionary["ElasticIp"] as? String else { throw InitializableError.missingRequiredParam("ElasticIp") }
            self.elasticIp = elasticIp
        }
    }

    public struct AttachElasticLoadBalancerRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the layer that the Elastic Load Balancing instance is to be attached to.
        public let layerId: String
        /// The Elastic Load Balancing instance's name.
        public let elasticLoadBalancerName: String

        public init(layerId: String, elasticLoadBalancerName: String) {
            self.layerId = layerId
            self.elasticLoadBalancerName = elasticLoadBalancerName
        }

        public init(dictionary: [String: Any]) throws {
            guard let layerId = dictionary["LayerId"] as? String else { throw InitializableError.missingRequiredParam("LayerId") }
            self.layerId = layerId
            guard let elasticLoadBalancerName = dictionary["ElasticLoadBalancerName"] as? String else { throw InitializableError.missingRequiredParam("ElasticLoadBalancerName") }
            self.elasticLoadBalancerName = elasticLoadBalancerName
        }
    }

    public struct EnvironmentVariable: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// (Optional) The environment variable's value, which can be left empty. If you specify a value, it can contain up to 256 characters, which must all be printable.
        public let value: String
        /// (Required) The environment variable's name, which can consist of up to 64 characters and must be specified. The name can contain upper- and lowercase letters, numbers, and underscores (_), but it must start with a letter or underscore.
        public let key: String
        /// (Optional) Whether the variable's value will be returned by the DescribeApps action. To conceal an environment variable's value, set Secure to true. DescribeApps then returns *****FILTERED***** instead of the actual value. The default value for Secure is false. 
        public let secure: Bool?

        public init(value: String, key: String, secure: Bool? = nil) {
            self.value = value
            self.key = key
            self.secure = secure
        }

        public init(dictionary: [String: Any]) throws {
            guard let value = dictionary["Value"] as? String else { throw InitializableError.missingRequiredParam("Value") }
            self.value = value
            guard let key = dictionary["Key"] as? String else { throw InitializableError.missingRequiredParam("Key") }
            self.key = key
            self.secure = dictionary["Secure"] as? Bool
        }
    }

    public struct DescribeLoadBasedAutoScalingRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of layer IDs.
        public let layerIds: [String]

        public init(layerIds: [String]) {
            self.layerIds = layerIds
        }

        public init(dictionary: [String: Any]) throws {
            guard let layerIds = dictionary["LayerIds"] as? [String] else { throw InitializableError.missingRequiredParam("LayerIds") }
            self.layerIds = layerIds
        }
    }

    public enum VolumeType: String, CustomStringConvertible {
        case gp2 = "gp2"
        case io1 = "io1"
        case standard = "standard"
        public var description: String { return self.rawValue }
    }

    public struct RdsDbInstance: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the stack that the instance is registered with.
        public let stackId: String?
        /// The instance's address.
        public let address: String?
        /// The master user name.
        public let dbUser: String?
        /// The instance's AWS region.
        public let region: String?
        /// The instance's database engine.
        public let engine: String?
        /// Set to true if AWS OpsWorks was unable to discover the Amazon RDS instance. AWS OpsWorks attempts to discover the instance only once. If this value is set to true, you must deregister the instance and then register it again.
        public let missingOnRds: Bool?
        /// The instance's ARN.
        public let rdsDbInstanceArn: String?
        /// AWS OpsWorks returns *****FILTERED***** instead of the actual value.
        public let dbPassword: String?
        /// The DB instance identifier.
        public let dbInstanceIdentifier: String?

        public init(stackId: String? = nil, address: String? = nil, dbUser: String? = nil, region: String? = nil, engine: String? = nil, missingOnRds: Bool? = nil, rdsDbInstanceArn: String? = nil, dbPassword: String? = nil, dbInstanceIdentifier: String? = nil) {
            self.stackId = stackId
            self.address = address
            self.dbUser = dbUser
            self.region = region
            self.engine = engine
            self.missingOnRds = missingOnRds
            self.rdsDbInstanceArn = rdsDbInstanceArn
            self.dbPassword = dbPassword
            self.dbInstanceIdentifier = dbInstanceIdentifier
        }

        public init(dictionary: [String: Any]) throws {
            self.stackId = dictionary["StackId"] as? String
            self.address = dictionary["Address"] as? String
            self.dbUser = dictionary["DbUser"] as? String
            self.region = dictionary["Region"] as? String
            self.engine = dictionary["Engine"] as? String
            self.missingOnRds = dictionary["MissingOnRds"] as? Bool
            self.rdsDbInstanceArn = dictionary["RdsDbInstanceArn"] as? String
            self.dbPassword = dictionary["DbPassword"] as? String
            self.dbInstanceIdentifier = dictionary["DbInstanceIdentifier"] as? String
        }
    }

    public struct DescribeStackSummaryResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A StackSummary object that contains the results.
        public let stackSummary: StackSummary?

        public init(stackSummary: StackSummary? = nil) {
            self.stackSummary = stackSummary
        }

        public init(dictionary: [String: Any]) throws {
            if let stackSummary = dictionary["StackSummary"] as? [String: Any] { self.stackSummary = try Opsworks.StackSummary(dictionary: stackSummary) } else { self.stackSummary = nil }
        }
    }

    public struct Volume: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The device name.
        public let device: String?
        /// The volume ID.
        public let volumeId: String?
        /// The AWS region. For more information about AWS regions, see Regions and Endpoints.
        public let region: String?
        /// The Amazon EC2 volume ID.
        public let ec2VolumeId: String?
        /// For PIOPS volumes, the IOPS per disk.
        public let iops: Int32?
        /// The volume Availability Zone. For more information, see Regions and Endpoints.
        public let availabilityZone: String?
        /// The RAID array ID.
        public let raidArrayId: String?
        /// The value returned by DescribeVolumes.
        public let status: String?
        /// The volume type, standard or PIOPS.
        public let volumeType: String?
        /// The volume mount point. For example, "/mnt/disk1".
        public let mountPoint: String?
        /// The volume name.
        public let name: String?
        /// The instance ID.
        public let instanceId: String?
        /// The volume size.
        public let size: Int32?

        public init(device: String? = nil, volumeId: String? = nil, region: String? = nil, ec2VolumeId: String? = nil, iops: Int32? = nil, availabilityZone: String? = nil, raidArrayId: String? = nil, status: String? = nil, volumeType: String? = nil, mountPoint: String? = nil, name: String? = nil, instanceId: String? = nil, size: Int32? = nil) {
            self.device = device
            self.volumeId = volumeId
            self.region = region
            self.ec2VolumeId = ec2VolumeId
            self.iops = iops
            self.availabilityZone = availabilityZone
            self.raidArrayId = raidArrayId
            self.status = status
            self.volumeType = volumeType
            self.mountPoint = mountPoint
            self.name = name
            self.instanceId = instanceId
            self.size = size
        }

        public init(dictionary: [String: Any]) throws {
            self.device = dictionary["Device"] as? String
            self.volumeId = dictionary["VolumeId"] as? String
            self.region = dictionary["Region"] as? String
            self.ec2VolumeId = dictionary["Ec2VolumeId"] as? String
            self.iops = dictionary["Iops"] as? Int32
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.raidArrayId = dictionary["RaidArrayId"] as? String
            self.status = dictionary["Status"] as? String
            self.volumeType = dictionary["VolumeType"] as? String
            self.mountPoint = dictionary["MountPoint"] as? String
            self.name = dictionary["Name"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            self.size = dictionary["Size"] as? Int32
        }
    }

    public struct SelfUserProfile: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The user's IAM ARN.
        public let iamUserArn: String?
        /// The user's SSH public key.
        public let sshPublicKey: String?
        /// The user's SSH user name.
        public let sshUsername: String?
        /// The user's name.
        public let name: String?

        public init(iamUserArn: String? = nil, sshPublicKey: String? = nil, sshUsername: String? = nil, name: String? = nil) {
            self.iamUserArn = iamUserArn
            self.sshPublicKey = sshPublicKey
            self.sshUsername = sshUsername
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            self.iamUserArn = dictionary["IamUserArn"] as? String
            self.sshPublicKey = dictionary["SshPublicKey"] as? String
            self.sshUsername = dictionary["SshUsername"] as? String
            self.name = dictionary["Name"] as? String
        }
    }

    public struct EcsCluster: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The cluster name.
        public let ecsClusterName: String?
        /// The time and date that the cluster was registered with the stack.
        public let registeredAt: String?
        /// The stack ID.
        public let stackId: String?
        /// The cluster's ARN.
        public let ecsClusterArn: String?

        public init(ecsClusterName: String? = nil, registeredAt: String? = nil, stackId: String? = nil, ecsClusterArn: String? = nil) {
            self.ecsClusterName = ecsClusterName
            self.registeredAt = registeredAt
            self.stackId = stackId
            self.ecsClusterArn = ecsClusterArn
        }

        public init(dictionary: [String: Any]) throws {
            self.ecsClusterName = dictionary["EcsClusterName"] as? String
            self.registeredAt = dictionary["RegisteredAt"] as? String
            self.stackId = dictionary["StackId"] as? String
            self.ecsClusterArn = dictionary["EcsClusterArn"] as? String
        }
    }

    public struct DescribeStackSummaryRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The stack ID.
        public let stackId: String

        public init(stackId: String) {
            self.stackId = stackId
        }

        public init(dictionary: [String: Any]) throws {
            guard let stackId = dictionary["StackId"] as? String else { throw InitializableError.missingRequiredParam("StackId") }
            self.stackId = stackId
        }
    }

    public struct CreateLayerResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The layer ID.
        public let layerId: String?

        public init(layerId: String? = nil) {
            self.layerId = layerId
        }

        public init(dictionary: [String: Any]) throws {
            self.layerId = dictionary["LayerId"] as? String
        }
    }

    public struct TemporaryCredential: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The length of time (in minutes) that the grant is valid. When the grant expires, at the end of this period, the user will no longer be able to use the credentials to log in. If they are logged in at the time, they will be automatically logged out.
        public let validForInMinutes: Int32?
        /// The password.
        public let password: String?
        /// The instance's AWS OpsWorks ID.
        public let instanceId: String?
        /// The user name.
        public let username: String?

        public init(validForInMinutes: Int32? = nil, password: String? = nil, instanceId: String? = nil, username: String? = nil) {
            self.validForInMinutes = validForInMinutes
            self.password = password
            self.instanceId = instanceId
            self.username = username
        }

        public init(dictionary: [String: Any]) throws {
            self.validForInMinutes = dictionary["ValidForInMinutes"] as? Int32
            self.password = dictionary["Password"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            self.username = dictionary["Username"] as? String
        }
    }

    public struct DeregisterElasticIpRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Elastic IP address.
        public let elasticIp: String

        public init(elasticIp: String) {
            self.elasticIp = elasticIp
        }

        public init(dictionary: [String: Any]) throws {
            guard let elasticIp = dictionary["ElasticIp"] as? String else { throw InitializableError.missingRequiredParam("ElasticIp") }
            self.elasticIp = elasticIp
        }
    }

    public struct CreateDeploymentRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The layer IDs for the deployment targets.
        public let layerIds: [String]?
        /// The stack ID.
        public let stackId: String
        /// A user-defined comment.
        public let comment: String?
        /// A string that contains user-defined, custom JSON. It is used to override the corresponding default stack configuration JSON values. The string should be in the following format:  "{\"key1\": \"value1\", \"key2\": \"value2\",...}"  For more information on custom JSON, see Use Custom JSON to Modify the Stack Configuration Attributes.
        public let customJson: String?
        /// A DeploymentCommand object that specifies the deployment command and any associated arguments.
        public let command: DeploymentCommand
        /// The instance IDs for the deployment targets.
        public let instanceIds: [String]?
        /// The app ID. This parameter is required for app deployments, but not for other deployment commands.
        public let appId: String?

        public init(layerIds: [String]? = nil, stackId: String, comment: String? = nil, customJson: String? = nil, command: DeploymentCommand, instanceIds: [String]? = nil, appId: String? = nil) {
            self.layerIds = layerIds
            self.stackId = stackId
            self.comment = comment
            self.customJson = customJson
            self.command = command
            self.instanceIds = instanceIds
            self.appId = appId
        }

        public init(dictionary: [String: Any]) throws {
            self.layerIds = dictionary["LayerIds"] as? [String]
            guard let stackId = dictionary["StackId"] as? String else { throw InitializableError.missingRequiredParam("StackId") }
            self.stackId = stackId
            self.comment = dictionary["Comment"] as? String
            self.customJson = dictionary["CustomJson"] as? String
            guard let command = dictionary["Command"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Command") }
            self.command = try Opsworks.DeploymentCommand(dictionary: command)
            self.instanceIds = dictionary["InstanceIds"] as? [String]
            self.appId = dictionary["AppId"] as? String
        }
    }

    public struct DescribeTimeBasedAutoScalingRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of instance IDs.
        public let instanceIds: [String]

        public init(instanceIds: [String]) {
            self.instanceIds = instanceIds
        }

        public init(dictionary: [String: Any]) throws {
            guard let instanceIds = dictionary["InstanceIds"] as? [String] else { throw InitializableError.missingRequiredParam("InstanceIds") }
            self.instanceIds = instanceIds
        }
    }

    public struct StopStackRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The stack ID.
        public let stackId: String

        public init(stackId: String) {
            self.stackId = stackId
        }

        public init(dictionary: [String: Any]) throws {
            guard let stackId = dictionary["StackId"] as? String else { throw InitializableError.missingRequiredParam("StackId") }
            self.stackId = stackId
        }
    }

    public struct DescribeRdsDbInstancesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An a array of RdsDbInstance objects that describe the instances.
        public let rdsDbInstances: [RdsDbInstance]?

        public init(rdsDbInstances: [RdsDbInstance]? = nil) {
            self.rdsDbInstances = rdsDbInstances
        }

        public init(dictionary: [String: Any]) throws {
            if let rdsDbInstances = dictionary["RdsDbInstances"] as? [[String: Any]] {
                self.rdsDbInstances = try rdsDbInstances.map({ try RdsDbInstance(dictionary: $0) })
            } else { 
                self.rdsDbInstances = nil
            }
        }
    }

    public struct ServiceError: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// When the error occurred.
        public let createdAt: String?
        /// A message that describes the error.
        public let message: String?
        /// The stack ID.
        public let stackId: String?
        /// The error type.
        public let `type`: String?
        /// The instance ID.
        public let instanceId: String?
        /// The error ID.
        public let serviceErrorId: String?

        public init(createdAt: String? = nil, message: String? = nil, stackId: String? = nil, type: String? = nil, instanceId: String? = nil, serviceErrorId: String? = nil) {
            self.createdAt = createdAt
            self.message = message
            self.stackId = stackId
            self.`type` = `type`
            self.instanceId = instanceId
            self.serviceErrorId = serviceErrorId
        }

        public init(dictionary: [String: Any]) throws {
            self.createdAt = dictionary["CreatedAt"] as? String
            self.message = dictionary["Message"] as? String
            self.stackId = dictionary["StackId"] as? String
            self.`type` = dictionary["Type"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            self.serviceErrorId = dictionary["ServiceErrorId"] as? String
        }
    }

    public struct RebootInstanceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The instance ID.
        public let instanceId: String

        public init(instanceId: String) {
            self.instanceId = instanceId
        }

        public init(dictionary: [String: Any]) throws {
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
        }
    }

    public struct CreateDeploymentResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The deployment ID, which can be used with other requests to identify the deployment.
        public let deploymentId: String?

        public init(deploymentId: String? = nil) {
            self.deploymentId = deploymentId
        }

        public init(dictionary: [String: Any]) throws {
            self.deploymentId = dictionary["DeploymentId"] as? String
        }
    }

    public struct DescribeServiceErrorsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of ServiceError objects that describe the specified service errors.
        public let serviceErrors: [ServiceError]?

        public init(serviceErrors: [ServiceError]? = nil) {
            self.serviceErrors = serviceErrors
        }

        public init(dictionary: [String: Any]) throws {
            if let serviceErrors = dictionary["ServiceErrors"] as? [[String: Any]] {
                self.serviceErrors = try serviceErrors.map({ try ServiceError(dictionary: $0) })
            } else { 
                self.serviceErrors = nil
            }
        }
    }

    public struct DescribePermissionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The stack ID.
        public let stackId: String?
        /// The user's IAM ARN. This can also be a federated user's ARN. For more information about IAM ARNs, see Using Identifiers.
        public let iamUserArn: String?

        public init(stackId: String? = nil, iamUserArn: String? = nil) {
            self.stackId = stackId
            self.iamUserArn = iamUserArn
        }

        public init(dictionary: [String: Any]) throws {
            self.stackId = dictionary["StackId"] as? String
            self.iamUserArn = dictionary["IamUserArn"] as? String
        }
    }

    public struct AgentVersion: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The configuration manager.
        public let configurationManager: StackConfigurationManager?
        /// The agent version.
        public let version: String?

        public init(configurationManager: StackConfigurationManager? = nil, version: String? = nil) {
            self.configurationManager = configurationManager
            self.version = version
        }

        public init(dictionary: [String: Any]) throws {
            if let configurationManager = dictionary["ConfigurationManager"] as? [String: Any] { self.configurationManager = try Opsworks.StackConfigurationManager(dictionary: configurationManager) } else { self.configurationManager = nil }
            self.version = dictionary["Version"] as? String
        }
    }

    public struct DataSource: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The data source's type, AutoSelectOpsworksMysqlInstance, OpsworksMysqlInstance, or RdsDbInstance.
        public let `type`: String?
        /// The data source's ARN.
        public let arn: String?
        /// The database name.
        public let databaseName: String?

        public init(type: String? = nil, arn: String? = nil, databaseName: String? = nil) {
            self.`type` = `type`
            self.arn = arn
            self.databaseName = databaseName
        }

        public init(dictionary: [String: Any]) throws {
            self.`type` = dictionary["Type"] as? String
            self.arn = dictionary["Arn"] as? String
            self.databaseName = dictionary["DatabaseName"] as? String
        }
    }

    public struct DescribeElasticLoadBalancersResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of ElasticLoadBalancer objects that describe the specified Elastic Load Balancing instances.
        public let elasticLoadBalancers: [ElasticLoadBalancer]?

        public init(elasticLoadBalancers: [ElasticLoadBalancer]? = nil) {
            self.elasticLoadBalancers = elasticLoadBalancers
        }

        public init(dictionary: [String: Any]) throws {
            if let elasticLoadBalancers = dictionary["ElasticLoadBalancers"] as? [[String: Any]] {
                self.elasticLoadBalancers = try elasticLoadBalancers.map({ try ElasticLoadBalancer(dictionary: $0) })
            } else { 
                self.elasticLoadBalancers = nil
            }
        }
    }

    public struct TimeBasedAutoScalingConfiguration: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The instance ID.
        public let instanceId: String?
        /// A WeeklyAutoScalingSchedule object with the instance schedule.
        public let autoScalingSchedule: WeeklyAutoScalingSchedule?

        public init(instanceId: String? = nil, autoScalingSchedule: WeeklyAutoScalingSchedule? = nil) {
            self.instanceId = instanceId
            self.autoScalingSchedule = autoScalingSchedule
        }

        public init(dictionary: [String: Any]) throws {
            self.instanceId = dictionary["InstanceId"] as? String
            if let autoScalingSchedule = dictionary["AutoScalingSchedule"] as? [String: Any] { self.autoScalingSchedule = try Opsworks.WeeklyAutoScalingSchedule(dictionary: autoScalingSchedule) } else { self.autoScalingSchedule = nil }
        }
    }

    public enum AppAttributesKeys: String, CustomStringConvertible {
        case documentroot = "DocumentRoot"
        case railsenv = "RailsEnv"
        case autobundleondeploy = "AutoBundleOnDeploy"
        case awsflowrubysettings = "AwsFlowRubySettings"
        public var description: String { return self.rawValue }
    }

    public struct GetHostnameSuggestionResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The generated host name.
        public let hostname: String?
        /// The layer ID.
        public let layerId: String?

        public init(hostname: String? = nil, layerId: String? = nil) {
            self.hostname = hostname
            self.layerId = layerId
        }

        public init(dictionary: [String: Any]) throws {
            self.hostname = dictionary["Hostname"] as? String
            self.layerId = dictionary["LayerId"] as? String
        }
    }

    public enum DeploymentCommandName: String, CustomStringConvertible {
        case install_dependencies = "install_dependencies"
        case update_dependencies = "update_dependencies"
        case update_custom_cookbooks = "update_custom_cookbooks"
        case execute_recipes = "execute_recipes"
        case configure = "configure"
        case setup = "setup"
        case deploy = "deploy"
        case rollback = "rollback"
        case start = "start"
        case stop = "stop"
        case restart = "restart"
        case undeploy = "undeploy"
        public var description: String { return self.rawValue }
    }

    public struct EbsBlockDevice: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The snapshot ID.
        public let snapshotId: String?
        /// The volume size, in GiB. For more information, see EbsBlockDevice.
        public let volumeSize: Int32?
        /// Whether the volume is deleted on instance termination.
        public let deleteOnTermination: Bool?
        /// The volume type. gp2 for General Purpose (SSD) volumes, io1 for Provisioned IOPS (SSD) volumes, and standard for Magnetic volumes.
        public let volumeType: VolumeType?
        /// The number of I/O operations per second (IOPS) that the volume supports. For more information, see EbsBlockDevice.
        public let iops: Int32?

        public init(snapshotId: String? = nil, volumeSize: Int32? = nil, deleteOnTermination: Bool? = nil, volumeType: VolumeType? = nil, iops: Int32? = nil) {
            self.snapshotId = snapshotId
            self.volumeSize = volumeSize
            self.deleteOnTermination = deleteOnTermination
            self.volumeType = volumeType
            self.iops = iops
        }

        public init(dictionary: [String: Any]) throws {
            self.snapshotId = dictionary["SnapshotId"] as? String
            self.volumeSize = dictionary["VolumeSize"] as? Int32
            self.deleteOnTermination = dictionary["DeleteOnTermination"] as? Bool
            if let volumeType = dictionary["VolumeType"] as? String { self.volumeType = VolumeType(rawValue: volumeType) } else { self.volumeType = nil }
            self.iops = dictionary["Iops"] as? Int32
        }
    }

    public struct BlockDeviceMapping: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Suppresses the specified device included in the AMI's block device mapping.
        public let noDevice: String?
        /// The virtual device name. For more information, see BlockDeviceMapping.
        public let virtualName: String?
        /// The device name that is exposed to the instance, such as /dev/sdh. For the root device, you can use the explicit device name or you can set this parameter to ROOT_DEVICE and AWS OpsWorks will provide the correct device name.
        public let deviceName: String?
        /// An EBSBlockDevice that defines how to configure an Amazon EBS volume when the instance is launched.
        public let ebs: EbsBlockDevice?

        public init(noDevice: String? = nil, virtualName: String? = nil, deviceName: String? = nil, ebs: EbsBlockDevice? = nil) {
            self.noDevice = noDevice
            self.virtualName = virtualName
            self.deviceName = deviceName
            self.ebs = ebs
        }

        public init(dictionary: [String: Any]) throws {
            self.noDevice = dictionary["NoDevice"] as? String
            self.virtualName = dictionary["VirtualName"] as? String
            self.deviceName = dictionary["DeviceName"] as? String
            if let ebs = dictionary["Ebs"] as? [String: Any] { self.ebs = try Opsworks.EbsBlockDevice(dictionary: ebs) } else { self.ebs = nil }
        }
    }

    public struct DeregisterRdsDbInstanceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Amazon RDS instance's ARN.
        public let rdsDbInstanceArn: String

        public init(rdsDbInstanceArn: String) {
            self.rdsDbInstanceArn = rdsDbInstanceArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let rdsDbInstanceArn = dictionary["RdsDbInstanceArn"] as? String else { throw InitializableError.missingRequiredParam("RdsDbInstanceArn") }
            self.rdsDbInstanceArn = rdsDbInstanceArn
        }
    }

    public struct UpdateStackRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The stack's operating system, which must be set to one of the following:   A supported Linux operating system: An Amazon Linux version, such as Amazon Linux 2016.03, Amazon Linux 2015.09, or Amazon Linux 2015.03.   A supported Ubuntu operating system, such as Ubuntu 16.04 LTS, Ubuntu 14.04 LTS, or Ubuntu 12.04 LTS.    CentOS 7     Red Hat Enterprise Linux 7    A supported Windows operating system, such as Microsoft Windows Server 2012 R2 Base, Microsoft Windows Server 2012 R2 with SQL Server Express, Microsoft Windows Server 2012 R2 with SQL Server Standard, or Microsoft Windows Server 2012 R2 with SQL Server Web.   A custom AMI: Custom. You specify the custom AMI you want to use when you create instances. For more information on how to use custom AMIs with OpsWorks, see Using Custom AMIs.   The default option is the stack's current operating system. For more information on the supported operating systems, see AWS OpsWorks Operating Systems.
        public let defaultOs: String?
        /// A ChefConfiguration object that specifies whether to enable Berkshelf and the Berkshelf version on Chef 11.10 stacks. For more information, see Create a New Stack.
        public let chefConfiguration: ChefConfiguration?
        /// Do not use this parameter. You cannot update a stack's service role.
        public let serviceRoleArn: String?
        /// The default root device type. This value is used by default for all instances in the stack, but you can override it when you create an instance. For more information, see Storage for the Root Device.
        public let defaultRootDeviceType: RootDeviceType?
        /// The ARN of an IAM profile that is the default profile for all of the stack's EC2 instances. For more information about IAM ARNs, see Using Identifiers.
        public let defaultInstanceProfileArn: String?
        public let customCookbooksSource: Source?
        /// A string that contains user-defined, custom JSON. It can be used to override the corresponding default stack configuration JSON values or to pass data to recipes. The string should be in the following format:  "{\"key1\": \"value1\", \"key2\": \"value2\",...}"  For more information on custom JSON, see Use Custom JSON to Modify the Stack Configuration Attributes.
        public let customJson: String?
        /// Whether the stack uses custom cookbooks.
        public let useCustomCookbooks: Bool?
        /// A default Amazon EC2 key-pair name. The default value is none. If you specify a key-pair name, AWS OpsWorks installs the public key on the instance and you can use the private key with an SSH client to log in to the instance. For more information, see  Using SSH to Communicate with an Instance and  Managing SSH Access. You can override this setting by specifying a different key pair, or no key pair, when you  create an instance. 
        public let defaultSshKeyName: String?
        /// The default AWS OpsWorks agent version. You have the following options:   Auto-update - Set this parameter to LATEST. AWS OpsWorks automatically installs new agent versions on the stack's instances as soon as they are available.   Fixed version - Set this parameter to your preferred agent version. To update the agent version, you must edit the stack configuration and specify a new version. AWS OpsWorks then automatically installs that version on the stack's instances.   The default setting is LATEST. To specify an agent version, you must use the complete version number, not the abbreviated number shown on the console. For a list of available agent version numbers, call DescribeAgentVersions.  You can also specify an agent version when you create or update an instance, which overrides the stack's default setting. 
        public let agentVersion: String?
        /// The stack's new name.
        public let name: String?
        /// The stack ID.
        public let stackId: String
        /// The configuration manager. When you update a stack, we recommend that you use the configuration manager to specify the Chef version: 12, 11.10, or 11.4 for Linux stacks, or 12.2 for Windows stacks. The default value for Linux stacks is currently 11.4.
        public let configurationManager: StackConfigurationManager?
        /// One or more user-defined key-value pairs to be added to the stack attributes.
        public let attributes: [StackAttributesKeys: String]?
        /// The stack's default VPC subnet ID. This parameter is required if you specify a value for the VpcId parameter. All instances are launched into this subnet unless you specify otherwise when you create the instance. If you also specify a value for DefaultAvailabilityZone, the subnet must be in that zone. For information on default values and when this parameter is required, see the VpcId parameter description. 
        public let defaultSubnetId: String?
        /// The stack's new host name theme, with spaces replaced by underscores. The theme is used to generate host names for the stack's instances. By default, HostnameTheme is set to Layer_Dependent, which creates host names by appending integers to the layer's short name. The other themes are:    Baked_Goods     Clouds     Europe_Cities     Fruits     Greek_Deities     Legendary_creatures_from_Japan     Planets_and_Moons     Roman_Deities     Scottish_Islands     US_Cities     Wild_Cats    To obtain a generated host name, call GetHostNameSuggestion, which returns a host name based on the current theme.
        public let hostnameTheme: String?
        /// The stack's default Availability Zone, which must be in the stack's region. For more information, see Regions and Endpoints. If you also specify a value for DefaultSubnetId, the subnet must be in the same zone. For more information, see CreateStack. 
        public let defaultAvailabilityZone: String?
        /// Whether to associate the AWS OpsWorks built-in security groups with the stack's layers. AWS OpsWorks provides a standard set of built-in security groups, one for each layer, which are associated with layers by default. UseOpsworksSecurityGroups allows you to provide your own custom security groups instead of using the built-in groups. UseOpsworksSecurityGroups has the following settings:    True - AWS OpsWorks automatically associates the appropriate built-in security group with each layer (default setting). You can associate additional security groups with a layer after you create it, but you cannot delete the built-in security group.   False - AWS OpsWorks does not associate built-in security groups with layers. You must create appropriate EC2 security groups and associate a security group with each layer that you create. However, you can still manually associate a built-in security group with a layer on. Custom security groups are required only for those layers that need custom settings.   For more information, see Create a New Stack.
        public let useOpsworksSecurityGroups: Bool?

        public init(defaultOs: String? = nil, chefConfiguration: ChefConfiguration? = nil, serviceRoleArn: String? = nil, defaultRootDeviceType: RootDeviceType? = nil, defaultInstanceProfileArn: String? = nil, customCookbooksSource: Source? = nil, customJson: String? = nil, useCustomCookbooks: Bool? = nil, defaultSshKeyName: String? = nil, agentVersion: String? = nil, name: String? = nil, stackId: String, configurationManager: StackConfigurationManager? = nil, attributes: [StackAttributesKeys: String]? = nil, defaultSubnetId: String? = nil, hostnameTheme: String? = nil, defaultAvailabilityZone: String? = nil, useOpsworksSecurityGroups: Bool? = nil) {
            self.defaultOs = defaultOs
            self.chefConfiguration = chefConfiguration
            self.serviceRoleArn = serviceRoleArn
            self.defaultRootDeviceType = defaultRootDeviceType
            self.defaultInstanceProfileArn = defaultInstanceProfileArn
            self.customCookbooksSource = customCookbooksSource
            self.customJson = customJson
            self.useCustomCookbooks = useCustomCookbooks
            self.defaultSshKeyName = defaultSshKeyName
            self.agentVersion = agentVersion
            self.name = name
            self.stackId = stackId
            self.configurationManager = configurationManager
            self.attributes = attributes
            self.defaultSubnetId = defaultSubnetId
            self.hostnameTheme = hostnameTheme
            self.defaultAvailabilityZone = defaultAvailabilityZone
            self.useOpsworksSecurityGroups = useOpsworksSecurityGroups
        }

        public init(dictionary: [String: Any]) throws {
            self.defaultOs = dictionary["DefaultOs"] as? String
            if let chefConfiguration = dictionary["ChefConfiguration"] as? [String: Any] { self.chefConfiguration = try Opsworks.ChefConfiguration(dictionary: chefConfiguration) } else { self.chefConfiguration = nil }
            self.serviceRoleArn = dictionary["ServiceRoleArn"] as? String
            if let defaultRootDeviceType = dictionary["DefaultRootDeviceType"] as? String { self.defaultRootDeviceType = RootDeviceType(rawValue: defaultRootDeviceType) } else { self.defaultRootDeviceType = nil }
            self.defaultInstanceProfileArn = dictionary["DefaultInstanceProfileArn"] as? String
            if let customCookbooksSource = dictionary["CustomCookbooksSource"] as? [String: Any] { self.customCookbooksSource = try Opsworks.Source(dictionary: customCookbooksSource) } else { self.customCookbooksSource = nil }
            self.customJson = dictionary["CustomJson"] as? String
            self.useCustomCookbooks = dictionary["UseCustomCookbooks"] as? Bool
            self.defaultSshKeyName = dictionary["DefaultSshKeyName"] as? String
            self.agentVersion = dictionary["AgentVersion"] as? String
            self.name = dictionary["Name"] as? String
            guard let stackId = dictionary["StackId"] as? String else { throw InitializableError.missingRequiredParam("StackId") }
            self.stackId = stackId
            if let configurationManager = dictionary["ConfigurationManager"] as? [String: Any] { self.configurationManager = try Opsworks.StackConfigurationManager(dictionary: configurationManager) } else { self.configurationManager = nil }
            if let attributes = dictionary["Attributes"] as? [StackAttributesKeys: String] {
                self.attributes = attributes
            } else { 
                self.attributes = nil
            }
            self.defaultSubnetId = dictionary["DefaultSubnetId"] as? String
            self.hostnameTheme = dictionary["HostnameTheme"] as? String
            self.defaultAvailabilityZone = dictionary["DefaultAvailabilityZone"] as? String
            self.useOpsworksSecurityGroups = dictionary["UseOpsworksSecurityGroups"] as? Bool
        }
    }

    public struct UpdateElasticIpRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The address.
        public let elasticIp: String
        /// The new name.
        public let name: String?

        public init(elasticIp: String, name: String? = nil) {
            self.elasticIp = elasticIp
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            guard let elasticIp = dictionary["ElasticIp"] as? String else { throw InitializableError.missingRequiredParam("ElasticIp") }
            self.elasticIp = elasticIp
            self.name = dictionary["Name"] as? String
        }
    }

    public struct InstanceIdentity: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A JSON document that contains the metadata.
        public let document: String?
        /// A signature that can be used to verify the document's accuracy and authenticity.
        public let signature: String?

        public init(document: String? = nil, signature: String? = nil) {
            self.document = document
            self.signature = signature
        }

        public init(dictionary: [String: Any]) throws {
            self.document = dictionary["Document"] as? String
            self.signature = dictionary["Signature"] as? String
        }
    }

    public struct DescribeInstancesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of Instance objects that describe the instances.
        public let instances: [Instance]?

        public init(instances: [Instance]? = nil) {
            self.instances = instances
        }

        public init(dictionary: [String: Any]) throws {
            if let instances = dictionary["Instances"] as? [[String: Any]] {
                self.instances = try instances.map({ try Instance(dictionary: $0) })
            } else { 
                self.instances = nil
            }
        }
    }

    public struct LifecycleEventConfiguration: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A ShutdownEventConfiguration object that specifies the Shutdown event configuration.
        public let shutdown: ShutdownEventConfiguration?

        public init(shutdown: ShutdownEventConfiguration? = nil) {
            self.shutdown = shutdown
        }

        public init(dictionary: [String: Any]) throws {
            if let shutdown = dictionary["Shutdown"] as? [String: Any] { self.shutdown = try Opsworks.ShutdownEventConfiguration(dictionary: shutdown) } else { self.shutdown = nil }
        }
    }

    public struct DescribeStackProvisioningParametersRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The stack ID
        public let stackId: String

        public init(stackId: String) {
            self.stackId = stackId
        }

        public init(dictionary: [String: Any]) throws {
            guard let stackId = dictionary["StackId"] as? String else { throw InitializableError.missingRequiredParam("StackId") }
            self.stackId = stackId
        }
    }

    public struct DeleteAppRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The app ID.
        public let appId: String

        public init(appId: String) {
            self.appId = appId
        }

        public init(dictionary: [String: Any]) throws {
            guard let appId = dictionary["AppId"] as? String else { throw InitializableError.missingRequiredParam("AppId") }
            self.appId = appId
        }
    }

    public struct DescribeDeploymentsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of Deployment objects that describe the deployments.
        public let deployments: [Deployment]?

        public init(deployments: [Deployment]? = nil) {
            self.deployments = deployments
        }

        public init(dictionary: [String: Any]) throws {
            if let deployments = dictionary["Deployments"] as? [[String: Any]] {
                self.deployments = try deployments.map({ try Deployment(dictionary: $0) })
            } else { 
                self.deployments = nil
            }
        }
    }

    public struct DescribePermissionsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of Permission objects that describe the stack permissions.   If the request object contains only a stack ID, the array contains a Permission object with permissions for each of the stack IAM ARNs.   If the request object contains only an IAM ARN, the array contains a Permission object with permissions for each of the user's stack IDs.   If the request contains a stack ID and an IAM ARN, the array contains a single Permission object with permissions for the specified stack and IAM ARN.  
        public let permissions: [Permission]?

        public init(permissions: [Permission]? = nil) {
            self.permissions = permissions
        }

        public init(dictionary: [String: Any]) throws {
            if let permissions = dictionary["Permissions"] as? [[String: Any]] {
                self.permissions = try permissions.map({ try Permission(dictionary: $0) })
            } else { 
                self.permissions = nil
            }
        }
    }

    public struct RegisterVolumeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The stack ID.
        public let stackId: String
        /// The Amazon EBS volume ID.
        public let ec2VolumeId: String?

        public init(stackId: String, ec2VolumeId: String? = nil) {
            self.stackId = stackId
            self.ec2VolumeId = ec2VolumeId
        }

        public init(dictionary: [String: Any]) throws {
            guard let stackId = dictionary["StackId"] as? String else { throw InitializableError.missingRequiredParam("StackId") }
            self.stackId = stackId
            self.ec2VolumeId = dictionary["Ec2VolumeId"] as? String
        }
    }

    public struct StartInstanceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The instance ID.
        public let instanceId: String

        public init(instanceId: String) {
            self.instanceId = instanceId
        }

        public init(dictionary: [String: Any]) throws {
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
        }
    }

    public struct Permission: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The user's permission level, which must be the following:    deny     show     deploy     manage     iam_only    For more information on the permissions associated with these levels, see Managing User Permissions 
        public let level: String?
        /// The Amazon Resource Name (ARN) for an AWS Identity and Access Management (IAM) role. For more information about IAM ARNs, see Using Identifiers.
        public let iamUserArn: String?
        /// Whether the user can use SSH.
        public let allowSsh: Bool?
        /// A stack ID.
        public let stackId: String?
        /// Whether the user can use sudo.
        public let allowSudo: Bool?

        public init(level: String? = nil, iamUserArn: String? = nil, allowSsh: Bool? = nil, stackId: String? = nil, allowSudo: Bool? = nil) {
            self.level = level
            self.iamUserArn = iamUserArn
            self.allowSsh = allowSsh
            self.stackId = stackId
            self.allowSudo = allowSudo
        }

        public init(dictionary: [String: Any]) throws {
            self.level = dictionary["Level"] as? String
            self.iamUserArn = dictionary["IamUserArn"] as? String
            self.allowSsh = dictionary["AllowSsh"] as? Bool
            self.stackId = dictionary["StackId"] as? String
            self.allowSudo = dictionary["AllowSudo"] as? Bool
        }
    }

    public struct AssignVolumeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The instance ID.
        public let instanceId: String?
        /// The volume ID.
        public let volumeId: String

        public init(instanceId: String? = nil, volumeId: String) {
            self.instanceId = instanceId
            self.volumeId = volumeId
        }

        public init(dictionary: [String: Any]) throws {
            self.instanceId = dictionary["InstanceId"] as? String
            guard let volumeId = dictionary["VolumeId"] as? String else { throw InitializableError.missingRequiredParam("VolumeId") }
            self.volumeId = volumeId
        }
    }

    public struct DeleteUserProfileRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The user's IAM ARN. This can also be a federated user's ARN.
        public let iamUserArn: String

        public init(iamUserArn: String) {
            self.iamUserArn = iamUserArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let iamUserArn = dictionary["IamUserArn"] as? String else { throw InitializableError.missingRequiredParam("IamUserArn") }
            self.iamUserArn = iamUserArn
        }
    }

    public struct ElasticLoadBalancer: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of subnet IDs, if the stack is running in a VPC.
        public let subnetIds: [String]?
        /// A list of Availability Zones.
        public let availabilityZones: [String]?
        /// The ID of the stack that the instance is associated with.
        public let stackId: String?
        /// A list of the EC2 instances that the Elastic Load Balancing instance is managing traffic for.
        public let ec2InstanceIds: [String]?
        /// The instance's AWS region.
        public let region: String?
        /// The ID of the layer that the instance is attached to.
        public let layerId: String?
        /// The VPC ID.
        public let vpcId: String?
        /// The Elastic Load Balancing instance's name.
        public let elasticLoadBalancerName: String?
        /// The instance's public DNS name.
        public let dnsName: String?

        public init(subnetIds: [String]? = nil, availabilityZones: [String]? = nil, stackId: String? = nil, ec2InstanceIds: [String]? = nil, region: String? = nil, layerId: String? = nil, vpcId: String? = nil, elasticLoadBalancerName: String? = nil, dnsName: String? = nil) {
            self.subnetIds = subnetIds
            self.availabilityZones = availabilityZones
            self.stackId = stackId
            self.ec2InstanceIds = ec2InstanceIds
            self.region = region
            self.layerId = layerId
            self.vpcId = vpcId
            self.elasticLoadBalancerName = elasticLoadBalancerName
            self.dnsName = dnsName
        }

        public init(dictionary: [String: Any]) throws {
            self.subnetIds = dictionary["SubnetIds"] as? [String]
            self.availabilityZones = dictionary["AvailabilityZones"] as? [String]
            self.stackId = dictionary["StackId"] as? String
            self.ec2InstanceIds = dictionary["Ec2InstanceIds"] as? [String]
            self.region = dictionary["Region"] as? String
            self.layerId = dictionary["LayerId"] as? String
            self.vpcId = dictionary["VpcId"] as? String
            self.elasticLoadBalancerName = dictionary["ElasticLoadBalancerName"] as? String
            self.dnsName = dictionary["DnsName"] as? String
        }
    }

    public struct DescribeElasticIpsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An ElasticIps object that describes the specified Elastic IP addresses.
        public let elasticIps: [ElasticIp]?

        public init(elasticIps: [ElasticIp]? = nil) {
            self.elasticIps = elasticIps
        }

        public init(dictionary: [String: Any]) throws {
            if let elasticIps = dictionary["ElasticIps"] as? [[String: Any]] {
                self.elasticIps = try elasticIps.map({ try ElasticIp(dictionary: $0) })
            } else { 
                self.elasticIps = nil
            }
        }
    }

}