// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension Translate {

    public struct ListTerminologiesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "TerminologyPropertiesList", required: false, type: .list)
        ]
        ///  If the response to the ListTerminologies was truncated, the NextToken fetches the next group of custom terminologies. 
        public let nextToken: String?
        /// The properties list of the custom terminologies returned on the list request.
        public let terminologyPropertiesList: [TerminologyProperties]?

        public init(nextToken: String? = nil, terminologyPropertiesList: [TerminologyProperties]? = nil) {
            self.nextToken = nextToken
            self.terminologyPropertiesList = terminologyPropertiesList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case terminologyPropertiesList = "TerminologyPropertiesList"
        }
    }

    public struct DeleteTerminologyRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The name of the custom terminology being deleted. 
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public enum MergeStrategy: String, CustomStringConvertible, Codable {
        case overwrite = "OVERWRITE"
        public var description: String { return self.rawValue }
    }

    public struct GetTerminologyRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "TerminologyDataFormat", required: true, type: .enum)
        ]
        /// The name of the custom terminology being retrieved.
        public let name: String
        /// The data format of the custom terminology being retrieved, either CSV or TMX.
        public let terminologyDataFormat: TerminologyDataFormat

        public init(name: String, terminologyDataFormat: TerminologyDataFormat) {
            self.name = name
            self.terminologyDataFormat = terminologyDataFormat
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case terminologyDataFormat = "TerminologyDataFormat"
        }
    }

    public struct Term: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SourceText", required: false, type: .string), 
            AWSShapeMember(label: "TargetText", required: false, type: .string)
        ]
        /// The source text of the term being translated by the custom terminology.
        public let sourceText: String?
        /// The target text of the term being translated by the custom terminology.
        public let targetText: String?

        public init(sourceText: String? = nil, targetText: String? = nil) {
            self.sourceText = sourceText
            self.targetText = targetText
        }

        private enum CodingKeys: String, CodingKey {
            case sourceText = "SourceText"
            case targetText = "TargetText"
        }
    }

    public struct ListTerminologiesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer)
        ]
        /// If the result of the request to ListTerminologies was truncated, include the NextToken to fetch the next group of custom terminologies. 
        public let nextToken: String?
        /// The maximum number of custom terminologies returned per list request.
        public let maxResults: Int32?

        public init(nextToken: String? = nil, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case maxResults = "MaxResults"
        }
    }

    public struct TerminologyData: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Format", required: true, type: .enum), 
            AWSShapeMember(label: "File", required: true, type: .blob)
        ]
        /// The data format of the custom terminology. Either CSV or TMX.
        public let format: TerminologyDataFormat
        /// The file containing the custom terminology data.
        public let file: Data

        public init(format: TerminologyDataFormat, file: Data) {
            self.format = format
            self.file = file
        }

        private enum CodingKeys: String, CodingKey {
            case format = "Format"
            case file = "File"
        }
    }

    public struct ImportTerminologyResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TerminologyProperties", required: false, type: .structure)
        ]
        /// The properties of the custom terminology being imported.
        public let terminologyProperties: TerminologyProperties?

        public init(terminologyProperties: TerminologyProperties? = nil) {
            self.terminologyProperties = terminologyProperties
        }

        private enum CodingKeys: String, CodingKey {
            case terminologyProperties = "TerminologyProperties"
        }
    }

    public struct TranslateTextResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TargetLanguageCode", required: true, type: .string), 
            AWSShapeMember(label: "SourceLanguageCode", required: true, type: .string), 
            AWSShapeMember(label: "AppliedTerminologies", required: false, type: .list), 
            AWSShapeMember(label: "TranslatedText", required: true, type: .string)
        ]
        /// The language code for the language of the target text. 
        public let targetLanguageCode: String
        /// The language code for the language of the source text. 
        public let sourceLanguageCode: String
        /// The names of the custom terminologies applied to the input text by Amazon Translate for the translated text response.
        public let appliedTerminologies: [AppliedTerminology]?
        /// The the translated text. The maximum length of this text is 5kb.
        public let translatedText: String

        public init(targetLanguageCode: String, sourceLanguageCode: String, appliedTerminologies: [AppliedTerminology]? = nil, translatedText: String) {
            self.targetLanguageCode = targetLanguageCode
            self.sourceLanguageCode = sourceLanguageCode
            self.appliedTerminologies = appliedTerminologies
            self.translatedText = translatedText
        }

        private enum CodingKeys: String, CodingKey {
            case targetLanguageCode = "TargetLanguageCode"
            case sourceLanguageCode = "SourceLanguageCode"
            case appliedTerminologies = "AppliedTerminologies"
            case translatedText = "TranslatedText"
        }
    }

    public struct TerminologyProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreatedAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "SizeBytes", required: false, type: .integer), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "TargetLanguageCodes", required: false, type: .list), 
            AWSShapeMember(label: "LastUpdatedAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "Arn", required: false, type: .string), 
            AWSShapeMember(label: "SourceLanguageCode", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "EncryptionKey", required: false, type: .structure), 
            AWSShapeMember(label: "TermCount", required: false, type: .integer)
        ]
        /// The time at which the custom terminology was created, based on the timestamp.
        public let createdAt: TimeStamp?
        /// The size of the file used when importing a custom terminology.
        public let sizeBytes: Int32?
        /// The description of the custom terminology properties.
        public let description: String?
        /// The language codes for the target languages available with the custom terminology file. All possible target languages are returned in array.
        public let targetLanguageCodes: [String]?
        /// The time at which the custom terminology was last update, based on the timestamp.
        public let lastUpdatedAt: TimeStamp?
        ///  The Amazon Resource Name (ARN) of the custom terminology. 
        public let arn: String?
        /// The language code for the source text of the translation request for which the custom terminology is being used.
        public let sourceLanguageCode: String?
        /// The name of the custom terminology.
        public let name: String?
        /// The encryption key for the custom terminology.
        public let encryptionKey: EncryptionKey?
        /// The number of terms included in the custom terminology.
        public let termCount: Int32?

        public init(createdAt: TimeStamp? = nil, sizeBytes: Int32? = nil, description: String? = nil, targetLanguageCodes: [String]? = nil, lastUpdatedAt: TimeStamp? = nil, arn: String? = nil, sourceLanguageCode: String? = nil, name: String? = nil, encryptionKey: EncryptionKey? = nil, termCount: Int32? = nil) {
            self.createdAt = createdAt
            self.sizeBytes = sizeBytes
            self.description = description
            self.targetLanguageCodes = targetLanguageCodes
            self.lastUpdatedAt = lastUpdatedAt
            self.arn = arn
            self.sourceLanguageCode = sourceLanguageCode
            self.name = name
            self.encryptionKey = encryptionKey
            self.termCount = termCount
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case sizeBytes = "SizeBytes"
            case description = "Description"
            case targetLanguageCodes = "TargetLanguageCodes"
            case lastUpdatedAt = "LastUpdatedAt"
            case arn = "Arn"
            case sourceLanguageCode = "SourceLanguageCode"
            case name = "Name"
            case encryptionKey = "EncryptionKey"
            case termCount = "TermCount"
        }
    }

    public struct TerminologyDataLocation: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "RepositoryType", required: true, type: .string), 
            AWSShapeMember(label: "Location", required: true, type: .string)
        ]
        /// The repository type for the custom terminology data.
        public let repositoryType: String
        /// The location of the custom terminology data.
        public let location: String

        public init(repositoryType: String, location: String) {
            self.repositoryType = repositoryType
            self.location = location
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryType = "RepositoryType"
            case location = "Location"
        }
    }

    public struct AppliedTerminology: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Terms", required: false, type: .list)
        ]
        /// The name of the custom terminology applied to the input text by Amazon Translate for the translated text response.
        public let name: String?
        /// The specific terms of the custom terminology applied to the input text by Amazon Translate for the translated text response. A maximum of 250 terms will be returned, and the specific terms applied will be the first 250 terms in the source text. 
        public let terms: [Term]?

        public init(name: String? = nil, terms: [Term]? = nil) {
            self.name = name
            self.terms = terms
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case terms = "Terms"
        }
    }

    public struct EncryptionKey: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Type", required: true, type: .enum), 
            AWSShapeMember(label: "Id", required: true, type: .string)
        ]
        /// The type of encryption key used by Amazon Translate to encrypt custom terminologies.
        public let `type`: EncryptionKeyType
        /// The Amazon Resource Name (ARN) of the encryption key being used to encrypt the custom terminology.
        public let id: String

        public init(type: EncryptionKeyType, id: String) {
            self.`type` = `type`
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "Type"
            case id = "Id"
        }
    }

    public struct ImportTerminologyRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "EncryptionKey", required: false, type: .structure), 
            AWSShapeMember(label: "MergeStrategy", required: true, type: .enum), 
            AWSShapeMember(label: "TerminologyData", required: true, type: .structure)
        ]
        /// The name of the custom terminology being imported.
        public let name: String
        /// The description of the custom terminology being imported.
        public let description: String?
        /// The encryption key for the custom terminology being imported.
        public let encryptionKey: EncryptionKey?
        /// The merge strategy of the custom terminology being imported. Currently, only the OVERWRITE merge strategy is supported. In this case, the imported terminology will overwrite an existing terminology of the same name.
        public let mergeStrategy: MergeStrategy
        /// The terminology data for the custom terminology being imported.
        public let terminologyData: TerminologyData

        public init(name: String, description: String? = nil, encryptionKey: EncryptionKey? = nil, mergeStrategy: MergeStrategy, terminologyData: TerminologyData) {
            self.name = name
            self.description = description
            self.encryptionKey = encryptionKey
            self.mergeStrategy = mergeStrategy
            self.terminologyData = terminologyData
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case description = "Description"
            case encryptionKey = "EncryptionKey"
            case mergeStrategy = "MergeStrategy"
            case terminologyData = "TerminologyData"
        }
    }

    public struct GetTerminologyResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TerminologyDataLocation", required: false, type: .structure), 
            AWSShapeMember(label: "TerminologyProperties", required: false, type: .structure)
        ]
        /// The data location of the custom terminology being retrieved. The custom terminology file is returned in a presigned url that has a 30 minute expiration.
        public let terminologyDataLocation: TerminologyDataLocation?
        /// The properties of the custom terminology being retrieved.
        public let terminologyProperties: TerminologyProperties?

        public init(terminologyDataLocation: TerminologyDataLocation? = nil, terminologyProperties: TerminologyProperties? = nil) {
            self.terminologyDataLocation = terminologyDataLocation
            self.terminologyProperties = terminologyProperties
        }

        private enum CodingKeys: String, CodingKey {
            case terminologyDataLocation = "TerminologyDataLocation"
            case terminologyProperties = "TerminologyProperties"
        }
    }

    public enum EncryptionKeyType: String, CustomStringConvertible, Codable {
        case kms = "KMS"
        public var description: String { return self.rawValue }
    }

    public enum TerminologyDataFormat: String, CustomStringConvertible, Codable {
        case csv = "CSV"
        case tmx = "TMX"
        public var description: String { return self.rawValue }
    }

    public struct TranslateTextRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SourceLanguageCode", required: true, type: .string), 
            AWSShapeMember(label: "TargetLanguageCode", required: true, type: .string), 
            AWSShapeMember(label: "TerminologyNames", required: false, type: .list), 
            AWSShapeMember(label: "Text", required: true, type: .string)
        ]
        /// The language code for the language of the source text. The language must be a language supported by Amazon Translate.  To have Amazon Translate determine the source language of your text, you can specify auto in the SourceLanguageCode field. If you specify auto, Amazon Translate will call Amazon Comprehend to determine the source language.
        public let sourceLanguageCode: String
        /// The language code requested for the language of the target text. The language must be a language supported by Amazon Translate.
        public let targetLanguageCode: String
        /// The TerminologyNames list that is taken as input to the TranslateText request. This has a minimum length of 0 and a maximum length of 1.
        public let terminologyNames: [String]?
        /// The text to translate. The text string can be a maximum of 5,000 bytes long. Depending on your character set, this may be fewer than 5,000 characters.
        public let text: String

        public init(sourceLanguageCode: String, targetLanguageCode: String, terminologyNames: [String]? = nil, text: String) {
            self.sourceLanguageCode = sourceLanguageCode
            self.targetLanguageCode = targetLanguageCode
            self.terminologyNames = terminologyNames
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case sourceLanguageCode = "SourceLanguageCode"
            case targetLanguageCode = "TargetLanguageCode"
            case terminologyNames = "TerminologyNames"
            case text = "Text"
        }
    }

}