// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Sqs {

    public struct ReceiveMessageRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the message attribute, where N is the index.   The name can contain alphanumeric characters and the underscore (_), hyphen (-), and period (.).   The name is case-sensitive and must be unique among all attribute names for the message.   The name must not start with AWS-reserved prefixes such as AWS. or Amazon. (or any casing variants).   The name must not start or end with a period (.), and it should not have periods in succession (..).   The name can be up to 256 characters long.   When using ReceiveMessage, you can send a list of attribute names to receive, or you can return all of the attributes by specifying All or .* in your request. You can also use all message attributes starting with a prefix, for example bar.*.
        public let messageAttributeNames: MessageAttributeNameList?
        /// The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved by a ReceiveMessage request.
        public let visibilityTimeout: Int32?
        /// The maximum number of messages to return. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values are 1 to 10. Default is 1.
        public let maxNumberOfMessages: Int32?
        /// The URL of the Amazon SQS queue from which messages are received. Queue URLs are case-sensitive.
        public let queueUrl: String
        /// This parameter applies only to FIFO (first-in-first-out) queues. The token used for deduplication of ReceiveMessage calls. If a networking issue occurs after a ReceiveMessage action, and instead of a response you receive a generic error, you can retry the same action with an identical ReceiveRequestAttemptId to retrieve the same set of messages, even if their visibility timeout has not yet expired.   You can use ReceiveRequestAttemptId only for 5 minutes after a ReceiveMessage action.   When you set FifoQueue, a caller of the ReceiveMessage action can provide a ReceiveRequestAttemptId explicitly.   If a caller of the ReceiveMessage action doesn't provide a ReceiveRequestAttemptId, Amazon SQS generates a ReceiveRequestAttemptId.   You can retry the ReceiveMessage action with the same ReceiveRequestAttemptId if none of the messages have been modified (deleted or had their visibility changes).   During a visibility timeout, subsequent calls with the same ReceiveRequestAttemptId return the same messages and receipt handles. If a retry occurs within the deduplication interval, it resets the visibility timeout. For more information, see Visibility Timeout in the Amazon Simple Queue Service Developer Guide.  If a caller of the ReceiveMessage action is still processing messages when the visibility timeout expires and messages become visible, another worker reading from the same queue can receive the same messages and therefore process duplicates. Also, if a reader whose message processing time is longer than the visibility timeout tries to delete the processed messages, the action fails with an error. To mitigate this effect, ensure that your application observes a safe threshold before the visibility timeout expires and extend the visibility timeout as necessary.    While messages with a particular MessageGroupId are invisible, no more messages belonging to the same MessageGroupId are returned until the visibility timeout expires. You can still receive messages with another MessageGroupId as long as it is also visible.   If a caller of ReceiveMessage can't track the ReceiveRequestAttemptId, no retries work until the original visibility timeout expires. As a result, delays might occur but the messages in the queue remain in a strict order.   The length of ReceiveRequestAttemptId is 128 characters. ReceiveRequestAttemptId can contain alphanumeric characters (a-z, A-Z, 0-9) and punctuation (!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~). For best practices of using ReceiveRequestAttemptId, see Using the ReceiveRequestAttemptId Request Parameter in the Amazon Simple Queue Service Developer Guide.
        public let receiveRequestAttemptId: String?
        /// A list of attributes that need to be returned along with each message. These attributes include:    All - Returns all values.    ApproximateFirstReceiveTimestamp - Returns the time the message was first received from the queue (epoch time in milliseconds).    ApproximateReceiveCount - Returns the number of times a message has been received from the queue but not deleted.    SenderId    For an IAM user, returns the IAM user ID, for example ABCDEFGHI1JKLMNOPQ23R.   For an IAM role, returns the IAM role ID, for example ABCDE1F2GH3I4JK5LMNOP:i-a123b456.      SentTimestamp - Returns the time the message was sent to the queue (epoch time in milliseconds).    MessageDeduplicationId - Returns the value provided by the sender that calls the  SendMessage  action.    MessageGroupId - Returns the value provided by the sender that calls the  SendMessage  action. Messages with the same MessageGroupId are returned in sequence.    SequenceNumber - Returns the value provided by Amazon SQS.   Any other valid special request parameters (such as the following) are ignored:    ApproximateNumberOfMessages     ApproximateNumberOfMessagesDelayed     ApproximateNumberOfMessagesNotVisible     CreatedTimestamp     ContentBasedDeduplication     DelaySeconds     FifoQueue     LastModifiedTimestamp     MaximumMessageSize     MessageRetentionPeriod     Policy     QueueArn,     ReceiveMessageWaitTimeSeconds     RedrivePolicy     VisibilityTimeout   
        public let attributeNames: AttributeNameList?
        /// The duration (in seconds) for which the call waits for a message to arrive in the queue before returning. If a message is available, the call returns sooner than WaitTimeSeconds.
        public let waitTimeSeconds: Int32?

        public init(messageAttributeNames: MessageAttributeNameList? = nil, visibilityTimeout: Int32? = nil, maxNumberOfMessages: Int32? = nil, queueUrl: String, receiveRequestAttemptId: String? = nil, attributeNames: AttributeNameList? = nil, waitTimeSeconds: Int32? = nil) {
            self.messageAttributeNames = messageAttributeNames
            self.visibilityTimeout = visibilityTimeout
            self.maxNumberOfMessages = maxNumberOfMessages
            self.queueUrl = queueUrl
            self.receiveRequestAttemptId = receiveRequestAttemptId
            self.attributeNames = attributeNames
            self.waitTimeSeconds = waitTimeSeconds
        }

        public init(dictionary: [String: Any]) throws {
            if let messageAttributeNames = dictionary["MessageAttributeNames"] as? [String: Any] { self.messageAttributeNames = try Sqs.MessageAttributeNameList(dictionary: messageAttributeNames) } else { self.messageAttributeNames = nil }
            self.visibilityTimeout = dictionary["VisibilityTimeout"] as? Int32
            self.maxNumberOfMessages = dictionary["MaxNumberOfMessages"] as? Int32
            guard let queueUrl = dictionary["QueueUrl"] as? String else { throw InitializableError.missingRequiredParam("QueueUrl") }
            self.queueUrl = queueUrl
            self.receiveRequestAttemptId = dictionary["ReceiveRequestAttemptId"] as? String
            if let attributeNames = dictionary["AttributeNames"] as? [String: Any] { self.attributeNames = try Sqs.AttributeNameList(dictionary: attributeNames) } else { self.attributeNames = nil }
            self.waitTimeSeconds = dictionary["WaitTimeSeconds"] as? Int32
        }
    }

    public struct GetQueueUrlRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the queue whose URL must be fetched. Maximum 80 characters. Valid values: alphanumeric characters, hyphens (-), and underscores (_). Queue names are case-sensitive.
        public let queueName: String
        /// The AWS account ID of the account that created the queue.
        public let queueOwnerAWSAccountId: String?

        public init(queueName: String, queueOwnerAWSAccountId: String? = nil) {
            self.queueName = queueName
            self.queueOwnerAWSAccountId = queueOwnerAWSAccountId
        }

        public init(dictionary: [String: Any]) throws {
            guard let queueName = dictionary["QueueName"] as? String else { throw InitializableError.missingRequiredParam("QueueName") }
            self.queueName = queueName
            self.queueOwnerAWSAccountId = dictionary["QueueOwnerAWSAccountId"] as? String
        }
    }

    public struct SendMessageResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An MD5 digest of the non-URL-encoded message attribute string. You can use this attribute to verify that Amazon SQS received the message correctly. Amazon SQS URL-decodes the message before creating the MD5 digest. For information on MD5, see RFC1321.
        public let mD5OfMessageAttributes: String?
        /// An MD5 digest of the non-URL-encoded message attribute string. You can use this attribute to verify that Amazon SQS received the message correctly. Amazon SQS URL-decodes the message before creating the MD5 digest. For information on MD5, see RFC1321.
        public let mD5OfMessageBody: String?
        /// This parameter applies only to FIFO (first-in-first-out) queues. A large, non-consecutive number that Amazon SQS assigns to each message. The length of SequenceNumber is 128 bits. SequenceNumber continues to increase for a particular MessageGroupId.
        public let sequenceNumber: String?
        /// An attribute containing the MessageId of the message sent to the queue. For more information, see Queue and Message Identifiers in the Amazon SQS Developer Guide. 
        public let messageId: String?

        public init(mD5OfMessageAttributes: String? = nil, mD5OfMessageBody: String? = nil, sequenceNumber: String? = nil, messageId: String? = nil) {
            self.mD5OfMessageAttributes = mD5OfMessageAttributes
            self.mD5OfMessageBody = mD5OfMessageBody
            self.sequenceNumber = sequenceNumber
            self.messageId = messageId
        }

        public init(dictionary: [String: Any]) throws {
            self.mD5OfMessageAttributes = dictionary["MD5OfMessageAttributes"] as? String
            self.mD5OfMessageBody = dictionary["MD5OfMessageBody"] as? String
            self.sequenceNumber = dictionary["SequenceNumber"] as? String
            self.messageId = dictionary["MessageId"] as? String
        }
    }

    public struct BinaryList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let binaryListValue: [Data]?

        public init(binaryListValue: [Data]? = nil) {
            self.binaryListValue = binaryListValue
        }

        public init(dictionary: [String: Any]) throws {
            self.binaryListValue = dictionary["BinaryListValue"] as? [Data]
        }
    }

    public struct MessageAttributeValue: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Not implemented. Reserved for future use.
        public let binaryListValues: BinaryList?
        /// Binary type attributes can store any binary data, such as compressed data, encrypted data, or images.
        public let binaryValue: Data?
        /// Strings are Unicode with UTF-8 binary encoding. For a list of code values, see ASCII Printable Characters.
        public let stringValue: String?
        /// Amazon SQS supports the following logical data types: String, Number, and Binary. For the Number data type, you must use StringValue. You can also append custom labels. For more information, see Message Attribute Data Types and Validation in the Amazon SQS Developer Guide.
        public let dataType: String
        /// Not implemented. Reserved for future use.
        public let stringListValues: StringList?

        public init(binaryListValues: BinaryList? = nil, binaryValue: Data? = nil, stringValue: String? = nil, dataType: String, stringListValues: StringList? = nil) {
            self.binaryListValues = binaryListValues
            self.binaryValue = binaryValue
            self.stringValue = stringValue
            self.dataType = dataType
            self.stringListValues = stringListValues
        }

        public init(dictionary: [String: Any]) throws {
            if let binaryListValues = dictionary["BinaryListValue"] as? [String: Any] { self.binaryListValues = try Sqs.BinaryList(dictionary: binaryListValues) } else { self.binaryListValues = nil }
            self.binaryValue = dictionary["BinaryValue"] as? Data
            self.stringValue = dictionary["StringValue"] as? String
            guard let dataType = dictionary["DataType"] as? String else { throw InitializableError.missingRequiredParam("DataType") }
            self.dataType = dataType
            if let stringListValues = dictionary["StringListValue"] as? [String: Any] { self.stringListValues = try Sqs.StringList(dictionary: stringListValues) } else { self.stringListValues = nil }
        }
    }

    public struct ChangeMessageVisibilityBatchRequestEntry: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The new value (in seconds) for the message's visibility timeout.
        public let visibilityTimeout: Int32?
        /// A receipt handle.
        public let receiptHandle: String
        /// An identifier for this particular receipt handle used to communicate the result.  The Ids of a batch request need to be unique within a request 
        public let id: String

        public init(visibilityTimeout: Int32? = nil, receiptHandle: String, id: String) {
            self.visibilityTimeout = visibilityTimeout
            self.receiptHandle = receiptHandle
            self.id = id
        }

        public init(dictionary: [String: Any]) throws {
            self.visibilityTimeout = dictionary["VisibilityTimeout"] as? Int32
            guard let receiptHandle = dictionary["ReceiptHandle"] as? String else { throw InitializableError.missingRequiredParam("ReceiptHandle") }
            self.receiptHandle = receiptHandle
            guard let id = dictionary["Id"] as? String else { throw InitializableError.missingRequiredParam("Id") }
            self.id = id
        }
    }

    public struct StringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let stringListValue: [String]?

        public init(stringListValue: [String]? = nil) {
            self.stringListValue = stringListValue
        }

        public init(dictionary: [String: Any]) throws {
            self.stringListValue = dictionary["StringListValue"] as? [String]
        }
    }

    public struct GetQueueUrlResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The URL of the queue.
        public let queueUrl: String?

        public init(queueUrl: String? = nil) {
            self.queueUrl = queueUrl
        }

        public init(dictionary: [String: Any]) throws {
            self.queueUrl = dictionary["QueueUrl"] as? String
        }
    }

    public struct ActionNameList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let actionName: [String]?

        public init(actionName: [String]? = nil) {
            self.actionName = actionName
        }

        public init(dictionary: [String: Any]) throws {
            self.actionName = dictionary["ActionName"] as? [String]
        }
    }

    public struct ChangeMessageVisibilityBatchRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of receipt handles of the messages for which the visibility timeout must be changed.
        public let entries: ChangeMessageVisibilityBatchRequestEntryList
        /// The URL of the Amazon SQS queue whose messages' visibility is changed. Queue URLs are case-sensitive.
        public let queueUrl: String

        public init(entries: ChangeMessageVisibilityBatchRequestEntryList, queueUrl: String) {
            self.entries = entries
            self.queueUrl = queueUrl
        }

        public init(dictionary: [String: Any]) throws {
            guard let entries = dictionary["Entries"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Entries") }
            self.entries = try Sqs.ChangeMessageVisibilityBatchRequestEntryList(dictionary: entries)
            guard let queueUrl = dictionary["QueueUrl"] as? String else { throw InitializableError.missingRequiredParam("QueueUrl") }
            self.queueUrl = queueUrl
        }
    }

    public struct Message: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier associated with the act of receiving the message. A new receipt handle is returned every time you receive a message. When deleting a message, you provide the last received receipt handle to delete the message.
        public let receiptHandle: String?
        /// A unique identifier for the message. A MessageIdis considered unique across all AWS accounts for an extended period of time.
        public let messageId: String?
        /// An MD5 digest of the non-URL-encoded message attribute string. You can use this attribute to verify that Amazon SQS received the message correctly. Amazon SQS URL-decodes the message before creating the MD5 digest. For information on MD5, see RFC1321.
        public let mD5OfMessageAttributes: String?
        ///  SenderId, SentTimestamp, ApproximateReceiveCount, and/or ApproximateFirstReceiveTimestamp. SentTimestamp and ApproximateFirstReceiveTimestamp are each returned as an integer representing the epoch time in milliseconds.
        public let attributes: [MessageSystemAttributeName: String]?
        /// The message's contents (not URL-encoded).
        public let body: String?
        /// An MD5 digest of the non-URL-encoded message body string.
        public let mD5OfBody: String?
        /// Each message attribute consists of a Name, Type, and Value. For more information, see Message Attribute Items and Validation in the Amazon SQS Developer Guide.
        public let messageAttributes: [String: MessageAttributeValue]?

        public init(receiptHandle: String? = nil, messageId: String? = nil, mD5OfMessageAttributes: String? = nil, attributes: [MessageSystemAttributeName: String]? = nil, body: String? = nil, mD5OfBody: String? = nil, messageAttributes: [String: MessageAttributeValue]? = nil) {
            self.receiptHandle = receiptHandle
            self.messageId = messageId
            self.mD5OfMessageAttributes = mD5OfMessageAttributes
            self.attributes = attributes
            self.body = body
            self.mD5OfBody = mD5OfBody
            self.messageAttributes = messageAttributes
        }

        public init(dictionary: [String: Any]) throws {
            self.receiptHandle = dictionary["ReceiptHandle"] as? String
            self.messageId = dictionary["MessageId"] as? String
            self.mD5OfMessageAttributes = dictionary["MD5OfMessageAttributes"] as? String
            if let attributes = dictionary["Attribute"] as? [MessageSystemAttributeName: String] {
                self.attributes = attributes
            } else { 
                self.attributes = nil
            }
            self.body = dictionary["Body"] as? String
            self.mD5OfBody = dictionary["MD5OfBody"] as? String
            if let messageAttributes = dictionary["MessageAttribute"] as? [String: Any] {
                var messageAttributesDict: [String: MessageAttributeValue] = [:]
                for (key, value) in messageAttributes {
                    guard let messageAttributeValueDict = value as? [String: Any] else { throw InitializableError.convertingError }
                    messageAttributesDict[key] = try MessageAttributeValue(dictionary: messageAttributeValueDict)
                }
                self.messageAttributes = messageAttributesDict
            } else { 
                self.messageAttributes = nil
            }
        }
    }

    public struct MessageAttributeNameList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let messageAttributeName: [String]?

        public init(messageAttributeName: [String]? = nil) {
            self.messageAttributeName = messageAttributeName
        }

        public init(dictionary: [String: Any]) throws {
            self.messageAttributeName = dictionary["MessageAttributeName"] as? [String]
        }
    }

    public struct DeleteMessageBatchResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of  DeleteMessageBatchResultEntry  items.
        public let successful: DeleteMessageBatchResultEntryList
        /// A list of  BatchResultErrorEntry  items.
        public let failed: BatchResultErrorEntryList

        public init(successful: DeleteMessageBatchResultEntryList, failed: BatchResultErrorEntryList) {
            self.successful = successful
            self.failed = failed
        }

        public init(dictionary: [String: Any]) throws {
            guard let successful = dictionary["Successful"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Successful") }
            self.successful = try Sqs.DeleteMessageBatchResultEntryList(dictionary: successful)
            guard let failed = dictionary["Failed"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Failed") }
            self.failed = try Sqs.BatchResultErrorEntryList(dictionary: failed)
        }
    }

    public struct ReceiveMessageResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of messages.
        public let messages: MessageList?

        public init(messages: MessageList? = nil) {
            self.messages = messages
        }

        public init(dictionary: [String: Any]) throws {
            if let messages = dictionary["Messages"] as? [String: Any] { self.messages = try Sqs.MessageList(dictionary: messages) } else { self.messages = nil }
        }
    }

    public struct SendMessageRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        ///  The number of seconds to delay a specific message. Valid values: 0 to 900. Maximum: 15 minutes. Messages with a positive DelaySeconds value become available for processing after the delay period is finished. If you don't specify a value, the default value for the queue applies.   When you set FifoQueue, you can't set DelaySeconds per message. You can set this parameter only on a queue level. 
        public let delaySeconds: Int32?
        /// The URL of the Amazon SQS queue to which a message is sent. Queue URLs are case-sensitive.
        public let queueUrl: String
        /// This parameter applies only to FIFO (first-in-first-out) queues. The tag that specifies that a message belongs to a specific message group. Messages that belong to the same message group are processed in a FIFO manner (however, messages in different message groups might be processed out of order). To interleave multiple ordered streams within a single queue, use MessageGroupId values (for example, session data for multiple users). In this scenario, multiple readers can process the queue, but the session data of each user is processed in a FIFO fashion.   You must associate a non-empty MessageGroupId with a message. If you don't provide a MessageGroupId, the action fails.    ReceiveMessage might return messages with multiple MessageGroupId values. For each MessageGroupId, the messages are sorted by time sent. The caller can't specify a MessageGroupId.   The length of MessageGroupId is 128 characters. Valid values are alphanumeric characters and punctuation (!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~). For best practices of using MessageGroupId, see Using the MessageGroupId Property in the Amazon Simple Queue Service Developer Guide.
        public let messageGroupId: String?
        /// This parameter applies only to FIFO (first-in-first-out) queues. The token used for deduplication of sent messages. If a message with a particular MessageDeduplicationId is sent successfully, any messages sent with the same MessageDeduplicationId are accepted successfully but aren't delivered during the 5-minute deduplication interval. For more information, see  Exactly-Once Processing in the Amazon SQS Developer Guide.   Every message must have a unique MessageDeduplicationId,   You may provide a MessageDeduplicationId explicitly.   If you aren't able to provide a MessageDeduplicationId and you enable ContentBasedDeduplication for your queue, Amazon SQS uses a SHA-256 hash to generate the MessageDeduplicationId using the body of the message (but not the attributes of the message).    If you don't provide a MessageDeduplicationId and the queue doesn't have ContentBasedDeduplication set, the action fails with an error.   If the queue has ContentBasedDeduplication set, your MessageDeduplicationId overrides the generated one.     When ContentBasedDeduplication is in effect, messages with identical content sent within the deduplication interval are treated as duplicates and only one copy of the message is delivered.   You can also use ContentBasedDeduplication for messages with identical content to be treated as duplicates.   If you send one message with ContentBasedDeduplication enabled and then another message with a MessageDeduplicationId that is the same as the one generated for the first MessageDeduplicationId, the two messages are treated as duplicates and only one copy of the message is delivered.     The MessageDeduplicationId is available to the recipient of the message (this can be useful for troubleshooting delivery issues). If a message is sent successfully but the acknowledgement is lost and the message is resent with the same MessageDeduplicationId after the deduplication interval, Amazon SQS can't detect duplicate messages.  The length of MessageDeduplicationId is 128 characters. MessageDeduplicationId can contain alphanumeric characters (a-z, A-Z, 0-9) and punctuation (!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~). For best practices of using MessageDeduplicationId, see Using the MessageDeduplicationId Property in the Amazon Simple Queue Service Developer Guide.
        public let messageDeduplicationId: String?
        /// The message to send. The maximum string size is 256 KB.  The following list shows the characters (in Unicode) that are allowed in your message, according to the W3C XML specification:    #x9     #xA     #xD     #x20 to #xD7FF     #xE000 to #xFFFD     #x10000 to #x10FFFF    For more information, see RFC1321. If you send any characters that aren't included in this list, your request is rejected. 
        public let messageBody: String
        /// Each message attribute consists of a Name, Type, and Value. For more information, see Message Attribute Items and Validation in the Amazon SQS Developer Guide.
        public let messageAttributes: [String: MessageAttributeValue]?

        public init(delaySeconds: Int32? = nil, queueUrl: String, messageGroupId: String? = nil, messageDeduplicationId: String? = nil, messageBody: String, messageAttributes: [String: MessageAttributeValue]? = nil) {
            self.delaySeconds = delaySeconds
            self.queueUrl = queueUrl
            self.messageGroupId = messageGroupId
            self.messageDeduplicationId = messageDeduplicationId
            self.messageBody = messageBody
            self.messageAttributes = messageAttributes
        }

        public init(dictionary: [String: Any]) throws {
            self.delaySeconds = dictionary["DelaySeconds"] as? Int32
            guard let queueUrl = dictionary["QueueUrl"] as? String else { throw InitializableError.missingRequiredParam("QueueUrl") }
            self.queueUrl = queueUrl
            self.messageGroupId = dictionary["MessageGroupId"] as? String
            self.messageDeduplicationId = dictionary["MessageDeduplicationId"] as? String
            guard let messageBody = dictionary["MessageBody"] as? String else { throw InitializableError.missingRequiredParam("MessageBody") }
            self.messageBody = messageBody
            if let messageAttributes = dictionary["MessageAttribute"] as? [String: Any] {
                var messageAttributesDict: [String: MessageAttributeValue] = [:]
                for (key, value) in messageAttributes {
                    guard let messageAttributeValueDict = value as? [String: Any] else { throw InitializableError.convertingError }
                    messageAttributesDict[key] = try MessageAttributeValue(dictionary: messageAttributeValueDict)
                }
                self.messageAttributes = messageAttributesDict
            } else { 
                self.messageAttributes = nil
            }
        }
    }

    public struct AddPermissionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The unique identification of the permission you're setting (for example, AliceSendMessage). Maximum 80 characters. Allowed characters include alphanumeric characters, hyphens (-), and underscores (_).
        public let label: String
        /// The AWS account number of the principal who is given permission. The principal must have an AWS account, but does not need to be signed up for Amazon SQS. For information about locating the AWS account identification, see Your AWS Identifiers in the Amazon SQS Developer Guide.
        public let aWSAccountIds: AWSAccountIdList
        /// The action the client wants to allow for the specified principal. The following values are valid:    *     ChangeMessageVisibility     DeleteMessage     GetQueueAttributes     GetQueueUrl     ReceiveMessage     SendMessage    For more information about these actions, see Understanding Permissions in the Amazon SQS Developer Guide. Specifying SendMessage, DeleteMessage, or ChangeMessageVisibility for ActionName.n also grants permissions for the corresponding batch versions of those actions: SendMessageBatch, DeleteMessageBatch, and ChangeMessageVisibilityBatch.
        public let actions: ActionNameList
        /// The URL of the Amazon SQS queue to which permissions are added. Queue URLs are case-sensitive.
        public let queueUrl: String

        public init(label: String, aWSAccountIds: AWSAccountIdList, actions: ActionNameList, queueUrl: String) {
            self.label = label
            self.aWSAccountIds = aWSAccountIds
            self.actions = actions
            self.queueUrl = queueUrl
        }

        public init(dictionary: [String: Any]) throws {
            guard let label = dictionary["Label"] as? String else { throw InitializableError.missingRequiredParam("Label") }
            self.label = label
            guard let aWSAccountIds = dictionary["AWSAccountIds"] as? [String: Any] else { throw InitializableError.missingRequiredParam("AWSAccountIds") }
            self.aWSAccountIds = try Sqs.AWSAccountIdList(dictionary: aWSAccountIds)
            guard let actions = dictionary["Actions"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Actions") }
            self.actions = try Sqs.ActionNameList(dictionary: actions)
            guard let queueUrl = dictionary["QueueUrl"] as? String else { throw InitializableError.missingRequiredParam("QueueUrl") }
            self.queueUrl = queueUrl
        }
    }

    public struct CreateQueueRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the new queue. The following limits apply to this name:   A queue name can have up to 80 characters.   Valid values: alphanumeric characters, hyphens (-), and underscores (_).   A FIFO queue name must end with the .fifo suffix.   Queue names are case-sensitive.
        public let queueName: String
        /// A map of attributes with their corresponding values. The following lists the names, descriptions, and values of the special request parameters that the CreateQueue action uses:    DelaySeconds - The number of seconds for which the delivery of all messages in the queue is delayed. Valid values: An integer from 0 to 900 seconds (15 minutes). The default is 0 (zero).     MaximumMessageSize - The limit of how many bytes a message can contain before Amazon SQS rejects it. Valid values: An integer from 1,024 bytes (1 KiB) to 262,144 bytes (256 KiB). The default is 262,144 (256 KiB).     MessageRetentionPeriod - The number of seconds for which Amazon SQS retains a message. Valid values: An integer from 60 seconds (1 minute) to 1,209,600 seconds (14 days). The default is 345,600 (4 days).     Policy - The queue's policy. A valid AWS policy. For more information about policy structure, see Overview of AWS IAM Policies in the Amazon IAM User Guide.     ReceiveMessageWaitTimeSeconds - The number of seconds for which a  ReceiveMessage  action waits for a message to arrive. Valid values: An integer from 0 to 20 (seconds). The default is 0 (zero).     RedrivePolicy - The parameters for the dead letter queue functionality of the source queue. For more information about the redrive policy and dead letter queues, see Using Amazon SQS Dead Letter Queues in the Amazon SQS Developer Guide.   The dead letter queue of a FIFO queue must also be a FIFO queue. Similarly, the dead letter queue of a standard queue must also be a standard queue.     VisibilityTimeout - The visibility timeout for the queue. Valid values: An integer from 0 to 43,200 (12 hours). The default is 30. For more information about the visibility timeout, see Visibility Timeout in the Amazon SQS Developer Guide.   The following attributes apply only to FIFO (first-in-first-out) queues:    FifoQueue - Designates a queue as FIFO. You can provide this attribute only during queue creation. You can't change it for an existing queue. When you set this attribute, you must provide a MessageGroupId explicitly. For more information, see FIFO Queue Logic in the Amazon SQS Developer Guide.    ContentBasedDeduplication - Enables content-based deduplication. For more information, see Exactly-Once Processing in the Amazon SQS Developer Guide.    Every message must have a unique MessageDeduplicationId,   You may provide a MessageDeduplicationId explicitly.   If you aren't able to provide a MessageDeduplicationId and you enable ContentBasedDeduplication for your queue, Amazon SQS uses a SHA-256 hash to generate the MessageDeduplicationId using the body of the message (but not the attributes of the message).    If you don't provide a MessageDeduplicationId and the queue doesn't have ContentBasedDeduplication set, the action fails with an error.   If the queue has ContentBasedDeduplication set, your MessageDeduplicationId overrides the generated one.     When ContentBasedDeduplication is in effect, messages with identical content sent within the deduplication interval are treated as duplicates and only one copy of the message is delivered.   You can also use ContentBasedDeduplication for messages with identical content to be treated as duplicates.   If you send one message with ContentBasedDeduplication enabled and then another message with a MessageDeduplicationId that is the same as the one generated for the first MessageDeduplicationId, the two messages are treated as duplicates and only one copy of the message is delivered.      Any other valid special request parameters (such as the following) are ignored:    ApproximateNumberOfMessages     ApproximateNumberOfMessagesDelayed     ApproximateNumberOfMessagesNotVisible     CreatedTimestamp     LastModifiedTimestamp     QueueArn   
        public let attributes: [QueueAttributeName: String]?

        public init(queueName: String, attributes: [QueueAttributeName: String]? = nil) {
            self.queueName = queueName
            self.attributes = attributes
        }

        public init(dictionary: [String: Any]) throws {
            guard let queueName = dictionary["QueueName"] as? String else { throw InitializableError.missingRequiredParam("QueueName") }
            self.queueName = queueName
            if let attributes = dictionary["Attribute"] as? [QueueAttributeName: String] {
                self.attributes = attributes
            } else { 
                self.attributes = nil
            }
        }
    }

    public struct ListDeadLetterSourceQueuesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of source queue URLs that have the RedrivePolicy queue attribute configured with a dead letter queue.
        public let queueUrls: QueueUrlList

        public init(queueUrls: QueueUrlList) {
            self.queueUrls = queueUrls
        }

        public init(dictionary: [String: Any]) throws {
            guard let queueUrls = dictionary["queueUrls"] as? [String: Any] else { throw InitializableError.missingRequiredParam("queueUrls") }
            self.queueUrls = try Sqs.QueueUrlList(dictionary: queueUrls)
        }
    }

    public struct AWSAccountIdList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let aWSAccountId: [String]?

        public init(aWSAccountId: [String]? = nil) {
            self.aWSAccountId = aWSAccountId
        }

        public init(dictionary: [String: Any]) throws {
            self.aWSAccountId = dictionary["AWSAccountId"] as? [String]
        }
    }

    public struct QueueUrlList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let queueUrl: [String]?

        public init(queueUrl: [String]? = nil) {
            self.queueUrl = queueUrl
        }

        public init(dictionary: [String: Any]) throws {
            self.queueUrl = dictionary["QueueUrl"] as? [String]
        }
    }

    public enum QueueAttributeName: String, CustomStringConvertible {
        case all = "All"
        case policy = "Policy"
        case visibilitytimeout = "VisibilityTimeout"
        case maximummessagesize = "MaximumMessageSize"
        case messageretentionperiod = "MessageRetentionPeriod"
        case approximatenumberofmessages = "ApproximateNumberOfMessages"
        case approximatenumberofmessagesnotvisible = "ApproximateNumberOfMessagesNotVisible"
        case createdtimestamp = "CreatedTimestamp"
        case lastmodifiedtimestamp = "LastModifiedTimestamp"
        case queuearn = "QueueArn"
        case approximatenumberofmessagesdelayed = "ApproximateNumberOfMessagesDelayed"
        case delayseconds = "DelaySeconds"
        case receivemessagewaittimeseconds = "ReceiveMessageWaitTimeSeconds"
        case redrivepolicy = "RedrivePolicy"
        case fifoqueue = "FifoQueue"
        case contentbaseddeduplication = "ContentBasedDeduplication"
        public var description: String { return self.rawValue }
    }

    public struct ListQueuesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A string to use for filtering the list results. Only those queues whose name begins with the specified string are returned. Queue names are case-sensitive.
        public let queueNamePrefix: String?

        public init(queueNamePrefix: String? = nil) {
            self.queueNamePrefix = queueNamePrefix
        }

        public init(dictionary: [String: Any]) throws {
            self.queueNamePrefix = dictionary["QueueNamePrefix"] as? String
        }
    }

    public struct RemovePermissionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The URL of the Amazon SQS queue from which permissions are removed. Queue URLs are case-sensitive.
        public let queueUrl: String
        /// The identification of the permission to remove. This is the label added using the  AddPermission  action.
        public let label: String

        public init(queueUrl: String, label: String) {
            self.queueUrl = queueUrl
            self.label = label
        }

        public init(dictionary: [String: Any]) throws {
            guard let queueUrl = dictionary["QueueUrl"] as? String else { throw InitializableError.missingRequiredParam("QueueUrl") }
            self.queueUrl = queueUrl
            guard let label = dictionary["Label"] as? String else { throw InitializableError.missingRequiredParam("Label") }
            self.label = label
        }
    }

    public struct SendMessageBatchResultEntryList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let sendMessageBatchResultEntry: [SendMessageBatchResultEntry]?

        public init(sendMessageBatchResultEntry: [SendMessageBatchResultEntry]? = nil) {
            self.sendMessageBatchResultEntry = sendMessageBatchResultEntry
        }

        public init(dictionary: [String: Any]) throws {
            if let sendMessageBatchResultEntry = dictionary["SendMessageBatchResultEntry"] as? [[String: Any]] {
                self.sendMessageBatchResultEntry = try sendMessageBatchResultEntry.map({ try SendMessageBatchResultEntry(dictionary: $0) })
            } else { 
                self.sendMessageBatchResultEntry = nil
            }
        }
    }

    public struct ChangeMessageVisibilityBatchResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of  ChangeMessageVisibilityBatchResultEntry  items.
        public let successful: ChangeMessageVisibilityBatchResultEntryList
        /// A list of  BatchResultErrorEntry  items.
        public let failed: BatchResultErrorEntryList

        public init(successful: ChangeMessageVisibilityBatchResultEntryList, failed: BatchResultErrorEntryList) {
            self.successful = successful
            self.failed = failed
        }

        public init(dictionary: [String: Any]) throws {
            guard let successful = dictionary["Successful"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Successful") }
            self.successful = try Sqs.ChangeMessageVisibilityBatchResultEntryList(dictionary: successful)
            guard let failed = dictionary["Failed"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Failed") }
            self.failed = try Sqs.BatchResultErrorEntryList(dictionary: failed)
        }
    }

    public struct DeleteMessageBatchResultEntryList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let deleteMessageBatchResultEntry: [DeleteMessageBatchResultEntry]?

        public init(deleteMessageBatchResultEntry: [DeleteMessageBatchResultEntry]? = nil) {
            self.deleteMessageBatchResultEntry = deleteMessageBatchResultEntry
        }

        public init(dictionary: [String: Any]) throws {
            if let deleteMessageBatchResultEntry = dictionary["DeleteMessageBatchResultEntry"] as? [[String: Any]] {
                self.deleteMessageBatchResultEntry = try deleteMessageBatchResultEntry.map({ try DeleteMessageBatchResultEntry(dictionary: $0) })
            } else { 
                self.deleteMessageBatchResultEntry = nil
            }
        }
    }

    public struct MessageList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let message: [Message]?

        public init(message: [Message]? = nil) {
            self.message = message
        }

        public init(dictionary: [String: Any]) throws {
            if let message = dictionary["Message"] as? [[String: Any]] {
                self.message = try message.map({ try Message(dictionary: $0) })
            } else { 
                self.message = nil
            }
        }
    }

    public struct ListDeadLetterSourceQueuesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The URL of a dead letter queue. Queue URLs are case-sensitive.
        public let queueUrl: String

        public init(queueUrl: String) {
            self.queueUrl = queueUrl
        }

        public init(dictionary: [String: Any]) throws {
            guard let queueUrl = dictionary["QueueUrl"] as? String else { throw InitializableError.missingRequiredParam("QueueUrl") }
            self.queueUrl = queueUrl
        }
    }

    public struct SendMessageBatchResultEntry: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An MD5 digest of the non-URL-encoded message attribute string. You can use this attribute to verify that Amazon SQS received the message correctly. Amazon SQS URL-decodes the message before creating the MD5 digest. For information on MD5, see RFC1321.
        public let mD5OfMessageAttributes: String?
        /// An MD5 digest of the non-URL-encoded message attribute string. You can use this attribute to verify that Amazon SQS received the message correctly. Amazon SQS URL-decodes the message before creating the MD5 digest. For information on MD5, see RFC1321.
        public let mD5OfMessageBody: String
        /// This parameter applies only to FIFO (first-in-first-out) queues. A large, non-consecutive number that Amazon SQS assigns to each message. The length of SequenceNumber is 128 bits. As SequenceNumber continues to increase for a particular MessageGroupId.
        public let sequenceNumber: String?
        /// An identifier for the message.
        public let messageId: String
        /// An identifier for the message in this batch.
        public let id: String

        public init(mD5OfMessageAttributes: String? = nil, mD5OfMessageBody: String, sequenceNumber: String? = nil, messageId: String, id: String) {
            self.mD5OfMessageAttributes = mD5OfMessageAttributes
            self.mD5OfMessageBody = mD5OfMessageBody
            self.sequenceNumber = sequenceNumber
            self.messageId = messageId
            self.id = id
        }

        public init(dictionary: [String: Any]) throws {
            self.mD5OfMessageAttributes = dictionary["MD5OfMessageAttributes"] as? String
            guard let mD5OfMessageBody = dictionary["MD5OfMessageBody"] as? String else { throw InitializableError.missingRequiredParam("MD5OfMessageBody") }
            self.mD5OfMessageBody = mD5OfMessageBody
            self.sequenceNumber = dictionary["SequenceNumber"] as? String
            guard let messageId = dictionary["MessageId"] as? String else { throw InitializableError.missingRequiredParam("MessageId") }
            self.messageId = messageId
            guard let id = dictionary["Id"] as? String else { throw InitializableError.missingRequiredParam("Id") }
            self.id = id
        }
    }

    public struct SetQueueAttributesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A map of attributes to set. The following lists the names, descriptions, and values of the special request parameters that the SetQueueAttributes action uses:    DelaySeconds - The number of seconds for which the delivery of all messages in the queue is delayed. Valid values: An integer from 0 to 900 (15 minutes). The default is 0 (zero).     MaximumMessageSize - The limit of how many bytes a message can contain before Amazon SQS rejects it. Valid values: An integer from 1,024 bytes (1 KiB) up to 262,144 bytes (256 KiB). The default is 262,144 (256 KiB).     MessageRetentionPeriod - The number of seconds for which Amazon SQS retains a message. Valid values: An integer representing seconds, from 60 (1 minute) to 1,209,600 (14 days). The default is 345,600 (4 days).     Policy - The queue's policy. A valid AWS policy. For more information about policy structure, see Overview of AWS IAM Policies in the Amazon IAM User Guide.     ReceiveMessageWaitTimeSeconds - The number of seconds for which a  ReceiveMessage  action waits for a message to arrive. Valid values: an integer from 0 to 20 (seconds). The default is 0.     RedrivePolicy - The parameters for the dead letter queue functionality of the source queue. For more information about the redrive policy and dead letter queues, see Using Amazon SQS Dead Letter Queues in the Amazon SQS Developer Guide.   The dead letter queue of a FIFO queue must also be a FIFO queue. Similarly, the dead letter queue of a standard queue must also be a standard queue.     VisibilityTimeout - The visibility timeout for the queue. Valid values: an integer from 0 to 43,200 (12 hours). The default is 30. For more information about the visibility timeout, see Visibility Timeout in the Amazon SQS Developer Guide.   The following attribute applies only to FIFO (first-in-first-out) queues:    ContentBasedDeduplication - Enables content-based deduplication. For more information, see Exactly-Once Processing in the Amazon SQS Developer Guide.    Every message must have a unique MessageDeduplicationId,   You may provide a MessageDeduplicationId explicitly.   If you aren't able to provide a MessageDeduplicationId and you enable ContentBasedDeduplication for your queue, Amazon SQS uses a SHA-256 hash to generate the MessageDeduplicationId using the body of the message (but not the attributes of the message).    If you don't provide a MessageDeduplicationId and the queue doesn't have ContentBasedDeduplication set, the action fails with an error.   If the queue has ContentBasedDeduplication set, your MessageDeduplicationId overrides the generated one.     When ContentBasedDeduplication is in effect, messages with identical content sent within the deduplication interval are treated as duplicates and only one copy of the message is delivered.   You can also use ContentBasedDeduplication for messages with identical content to be treated as duplicates.   If you send one message with ContentBasedDeduplication enabled and then another message with a MessageDeduplicationId that is the same as the one generated for the first MessageDeduplicationId, the two messages are treated as duplicates and only one copy of the message is delivered.      Any other valid special request parameters (such as the following) are ignored:    ApproximateNumberOfMessages     ApproximateNumberOfMessagesDelayed     ApproximateNumberOfMessagesNotVisible     CreatedTimestamp     LastModifiedTimestamp     QueueArn   
        public let attributes: [QueueAttributeName: String]
        /// The URL of the Amazon SQS queue whose attributes are set. Queue URLs are case-sensitive.
        public let queueUrl: String

        public init(attributes: [QueueAttributeName: String], queueUrl: String) {
            self.attributes = attributes
            self.queueUrl = queueUrl
        }

        public init(dictionary: [String: Any]) throws {
            guard let attributes = dictionary["Attribute"] as? [QueueAttributeName: String] else { throw InitializableError.missingRequiredParam("Attribute") }
            self.attributes = attributes
            guard let queueUrl = dictionary["QueueUrl"] as? String else { throw InitializableError.missingRequiredParam("QueueUrl") }
            self.queueUrl = queueUrl
        }
    }

    public struct AttributeNameList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let attributeName: [QueueAttributeName]?

        public init(attributeName: [QueueAttributeName]? = nil) {
            self.attributeName = attributeName
        }

        public init(dictionary: [String: Any]) throws {
            if let attributeName = dictionary["AttributeName"] as? [String] { self.attributeName = attributeName.flatMap({ QueueAttributeName(rawValue: $0)}) } else { self.attributeName = nil }
        }
    }

    public struct GetQueueAttributesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A map of attributes to their respective values.
        public let attributes: [QueueAttributeName: String]?

        public init(attributes: [QueueAttributeName: String]? = nil) {
            self.attributes = attributes
        }

        public init(dictionary: [String: Any]) throws {
            if let attributes = dictionary["Attribute"] as? [QueueAttributeName: String] {
                self.attributes = attributes
            } else { 
                self.attributes = nil
            }
        }
    }

    public struct CreateQueueResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The URL of the created Amazon SQS queue.
        public let queueUrl: String?

        public init(queueUrl: String? = nil) {
            self.queueUrl = queueUrl
        }

        public init(dictionary: [String: Any]) throws {
            self.queueUrl = dictionary["QueueUrl"] as? String
        }
    }

    public struct ListQueuesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of queue URLs, up to 1,000 entries.
        public let queueUrls: QueueUrlList?

        public init(queueUrls: QueueUrlList? = nil) {
            self.queueUrls = queueUrls
        }

        public init(dictionary: [String: Any]) throws {
            if let queueUrls = dictionary["QueueUrls"] as? [String: Any] { self.queueUrls = try Sqs.QueueUrlList(dictionary: queueUrls) } else { self.queueUrls = nil }
        }
    }

    public struct ChangeMessageVisibilityRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The new value for the message's visibility timeout (in seconds). Values values: 0 to 43200. Maximum: 12 hours.
        public let visibilityTimeout: Int32
        /// The receipt handle associated with the message whose visibility timeout is changed. This parameter is returned by the  ReceiveMessage  action.
        public let receiptHandle: String
        /// The URL of the Amazon SQS queue whose message's visibility is changed. Queue URLs are case-sensitive.
        public let queueUrl: String

        public init(visibilityTimeout: Int32, receiptHandle: String, queueUrl: String) {
            self.visibilityTimeout = visibilityTimeout
            self.receiptHandle = receiptHandle
            self.queueUrl = queueUrl
        }

        public init(dictionary: [String: Any]) throws {
            guard let visibilityTimeout = dictionary["VisibilityTimeout"] as? Int32 else { throw InitializableError.missingRequiredParam("VisibilityTimeout") }
            self.visibilityTimeout = visibilityTimeout
            guard let receiptHandle = dictionary["ReceiptHandle"] as? String else { throw InitializableError.missingRequiredParam("ReceiptHandle") }
            self.receiptHandle = receiptHandle
            guard let queueUrl = dictionary["QueueUrl"] as? String else { throw InitializableError.missingRequiredParam("QueueUrl") }
            self.queueUrl = queueUrl
        }
    }

    public struct ChangeMessageVisibilityBatchRequestEntryList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let changeMessageVisibilityBatchRequestEntry: [ChangeMessageVisibilityBatchRequestEntry]?

        public init(changeMessageVisibilityBatchRequestEntry: [ChangeMessageVisibilityBatchRequestEntry]? = nil) {
            self.changeMessageVisibilityBatchRequestEntry = changeMessageVisibilityBatchRequestEntry
        }

        public init(dictionary: [String: Any]) throws {
            if let changeMessageVisibilityBatchRequestEntry = dictionary["ChangeMessageVisibilityBatchRequestEntry"] as? [[String: Any]] {
                self.changeMessageVisibilityBatchRequestEntry = try changeMessageVisibilityBatchRequestEntry.map({ try ChangeMessageVisibilityBatchRequestEntry(dictionary: $0) })
            } else { 
                self.changeMessageVisibilityBatchRequestEntry = nil
            }
        }
    }

    public enum MessageSystemAttributeName: String, CustomStringConvertible {
        case senderid = "SenderId"
        case senttimestamp = "SentTimestamp"
        case approximatereceivecount = "ApproximateReceiveCount"
        case approximatefirstreceivetimestamp = "ApproximateFirstReceiveTimestamp"
        case sequencenumber = "SequenceNumber"
        case messagededuplicationid = "MessageDeduplicationId"
        case messagegroupid = "MessageGroupId"
        public var description: String { return self.rawValue }
    }

    public struct DeleteMessageBatchRequestEntry: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A receipt handle.
        public let receiptHandle: String
        /// An identifier for this particular receipt handle. This is used to communicate the result.  The Ids of a batch request need to be unique within a request 
        public let id: String

        public init(receiptHandle: String, id: String) {
            self.receiptHandle = receiptHandle
            self.id = id
        }

        public init(dictionary: [String: Any]) throws {
            guard let receiptHandle = dictionary["ReceiptHandle"] as? String else { throw InitializableError.missingRequiredParam("ReceiptHandle") }
            self.receiptHandle = receiptHandle
            guard let id = dictionary["Id"] as? String else { throw InitializableError.missingRequiredParam("Id") }
            self.id = id
        }
    }

    public struct BatchResultErrorEntry: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An error code representing why the action failed on this entry.
        public let code: String
        /// A message explaining why the action failed on this entry.
        public let message: String?
        /// Specifies whether the error happened due to the sender's fault.
        public let senderFault: Bool
        /// The Id of an entry in a batch request.
        public let id: String

        public init(code: String, message: String? = nil, senderFault: Bool, id: String) {
            self.code = code
            self.message = message
            self.senderFault = senderFault
            self.id = id
        }

        public init(dictionary: [String: Any]) throws {
            guard let code = dictionary["Code"] as? String else { throw InitializableError.missingRequiredParam("Code") }
            self.code = code
            self.message = dictionary["Message"] as? String
            guard let senderFault = dictionary["SenderFault"] as? Bool else { throw InitializableError.missingRequiredParam("SenderFault") }
            self.senderFault = senderFault
            guard let id = dictionary["Id"] as? String else { throw InitializableError.missingRequiredParam("Id") }
            self.id = id
        }
    }

    public struct ChangeMessageVisibilityBatchResultEntryList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let changeMessageVisibilityBatchResultEntry: [ChangeMessageVisibilityBatchResultEntry]?

        public init(changeMessageVisibilityBatchResultEntry: [ChangeMessageVisibilityBatchResultEntry]? = nil) {
            self.changeMessageVisibilityBatchResultEntry = changeMessageVisibilityBatchResultEntry
        }

        public init(dictionary: [String: Any]) throws {
            if let changeMessageVisibilityBatchResultEntry = dictionary["ChangeMessageVisibilityBatchResultEntry"] as? [[String: Any]] {
                self.changeMessageVisibilityBatchResultEntry = try changeMessageVisibilityBatchResultEntry.map({ try ChangeMessageVisibilityBatchResultEntry(dictionary: $0) })
            } else { 
                self.changeMessageVisibilityBatchResultEntry = nil
            }
        }
    }

    public struct DeleteMessageRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The receipt handle associated with the message to delete.
        public let receiptHandle: String
        /// The URL of the Amazon SQS queue from which messages are deleted. Queue URLs are case-sensitive.
        public let queueUrl: String

        public init(receiptHandle: String, queueUrl: String) {
            self.receiptHandle = receiptHandle
            self.queueUrl = queueUrl
        }

        public init(dictionary: [String: Any]) throws {
            guard let receiptHandle = dictionary["ReceiptHandle"] as? String else { throw InitializableError.missingRequiredParam("ReceiptHandle") }
            self.receiptHandle = receiptHandle
            guard let queueUrl = dictionary["QueueUrl"] as? String else { throw InitializableError.missingRequiredParam("QueueUrl") }
            self.queueUrl = queueUrl
        }
    }

    public struct ChangeMessageVisibilityBatchResultEntry: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Represents a message whose visibility timeout has been changed successfully.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public init(dictionary: [String: Any]) throws {
            guard let id = dictionary["Id"] as? String else { throw InitializableError.missingRequiredParam("Id") }
            self.id = id
        }
    }

    public struct SendMessageBatchRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of  SendMessageBatchRequestEntry  items.
        public let entries: SendMessageBatchRequestEntryList
        /// The URL of the Amazon SQS queue to which batched messages are sent. Queue URLs are case-sensitive.
        public let queueUrl: String

        public init(entries: SendMessageBatchRequestEntryList, queueUrl: String) {
            self.entries = entries
            self.queueUrl = queueUrl
        }

        public init(dictionary: [String: Any]) throws {
            guard let entries = dictionary["Entries"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Entries") }
            self.entries = try Sqs.SendMessageBatchRequestEntryList(dictionary: entries)
            guard let queueUrl = dictionary["QueueUrl"] as? String else { throw InitializableError.missingRequiredParam("QueueUrl") }
            self.queueUrl = queueUrl
        }
    }

    public struct PurgeQueueRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The URL of the queue from which the PurgeQueue action deletes messages. Queue URLs are case-sensitive.
        public let queueUrl: String

        public init(queueUrl: String) {
            self.queueUrl = queueUrl
        }

        public init(dictionary: [String: Any]) throws {
            guard let queueUrl = dictionary["QueueUrl"] as? String else { throw InitializableError.missingRequiredParam("QueueUrl") }
            self.queueUrl = queueUrl
        }
    }

    public struct DeleteMessageBatchRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of receipt handles for the messages to be deleted.
        public let entries: DeleteMessageBatchRequestEntryList
        /// The URL of the Amazon SQS queue from which messages are deleted. Queue URLs are case-sensitive.
        public let queueUrl: String

        public init(entries: DeleteMessageBatchRequestEntryList, queueUrl: String) {
            self.entries = entries
            self.queueUrl = queueUrl
        }

        public init(dictionary: [String: Any]) throws {
            guard let entries = dictionary["Entries"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Entries") }
            self.entries = try Sqs.DeleteMessageBatchRequestEntryList(dictionary: entries)
            guard let queueUrl = dictionary["QueueUrl"] as? String else { throw InitializableError.missingRequiredParam("QueueUrl") }
            self.queueUrl = queueUrl
        }
    }

    public struct GetQueueAttributesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of attributes for which to retrieve information.  In the future, new attributes might be added. If you write code that calls this action, we recommend that you structure your code so that it can handle new attributes gracefully.  The following attributes are supported:    All - Returns all values.     ApproximateNumberOfMessages - Returns the approximate number of visible messages in a queue. For more information, see Resources Required to Process Messages in the Amazon SQS Developer Guide.     ApproximateNumberOfMessagesDelayed - Returns the approximate number of messages that are waiting to be added to the queue.     ApproximateNumberOfMessagesNotVisible - Returns the approximate number of messages that have not timed-out and aren't deleted. For more information, see Resources Required to Process Messages in the Amazon SQS Developer Guide.     CreatedTimestamp - Returns the time when the queue was created in seconds (epoch time).    DelaySeconds - Returns the default delay on the queue in seconds.    LastModifiedTimestamp - Returns the time when the queue was last changed in seconds (epoch time).    MaximumMessageSize - Returns the limit of how many bytes a message can contain before Amazon SQS rejects it.    MessageRetentionPeriod - Returns the number of seconds for which Amazon SQS retains a message.    Policy - Returns the policy of the queue.    QueueArn - Returns the Amazon resource name (ARN) of the queue.    ReceiveMessageWaitTimeSeconds - Returns the number of seconds for which the ReceiveMessage action waits for a message to arrive.     RedrivePolicy - Returns the parameters for dead letter queue functionality of the source queue. For more information about the redrive policy and dead letter queues, see Using Amazon SQS Dead Letter Queues in the Amazon SQS Developer Guide.     VisibilityTimeout - Returns the visibility timeout for the queue. For more information about the visibility timeout, see Visibility Timeout in the Amazon SQS Developer Guide.    The following attributes apply only to FIFO (first-in-first-out) queues:    FifoQueue - Returns whether the queue is FIFO. For more information, see FIFO Queue Logic in the Amazon SQS Developer Guide.    ContentBasedDeduplication - Returns whether content-based deduplication is enabled for the queue. For more information, see Exactly-Once Processing in the Amazon SQS Developer Guide.   
        public let attributeNames: AttributeNameList?
        /// The URL of the Amazon SQS queue whose attribute information is retrieved. Queue URLs are case-sensitive.
        public let queueUrl: String

        public init(attributeNames: AttributeNameList? = nil, queueUrl: String) {
            self.attributeNames = attributeNames
            self.queueUrl = queueUrl
        }

        public init(dictionary: [String: Any]) throws {
            if let attributeNames = dictionary["AttributeNames"] as? [String: Any] { self.attributeNames = try Sqs.AttributeNameList(dictionary: attributeNames) } else { self.attributeNames = nil }
            guard let queueUrl = dictionary["QueueUrl"] as? String else { throw InitializableError.missingRequiredParam("QueueUrl") }
            self.queueUrl = queueUrl
        }
    }

    public struct BatchResultErrorEntryList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let batchResultErrorEntry: [BatchResultErrorEntry]?

        public init(batchResultErrorEntry: [BatchResultErrorEntry]? = nil) {
            self.batchResultErrorEntry = batchResultErrorEntry
        }

        public init(dictionary: [String: Any]) throws {
            if let batchResultErrorEntry = dictionary["BatchResultErrorEntry"] as? [[String: Any]] {
                self.batchResultErrorEntry = try batchResultErrorEntry.map({ try BatchResultErrorEntry(dictionary: $0) })
            } else { 
                self.batchResultErrorEntry = nil
            }
        }
    }

    public struct DeleteQueueRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The URL of the Amazon SQS queue to delete. Queue URLs are case-sensitive.
        public let queueUrl: String

        public init(queueUrl: String) {
            self.queueUrl = queueUrl
        }

        public init(dictionary: [String: Any]) throws {
            guard let queueUrl = dictionary["QueueUrl"] as? String else { throw InitializableError.missingRequiredParam("QueueUrl") }
            self.queueUrl = queueUrl
        }
    }

    public struct SendMessageBatchRequestEntryList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let sendMessageBatchRequestEntry: [SendMessageBatchRequestEntry]?

        public init(sendMessageBatchRequestEntry: [SendMessageBatchRequestEntry]? = nil) {
            self.sendMessageBatchRequestEntry = sendMessageBatchRequestEntry
        }

        public init(dictionary: [String: Any]) throws {
            if let sendMessageBatchRequestEntry = dictionary["SendMessageBatchRequestEntry"] as? [[String: Any]] {
                self.sendMessageBatchRequestEntry = try sendMessageBatchRequestEntry.map({ try SendMessageBatchRequestEntry(dictionary: $0) })
            } else { 
                self.sendMessageBatchRequestEntry = nil
            }
        }
    }

    public struct DeleteMessageBatchRequestEntryList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let deleteMessageBatchRequestEntry: [DeleteMessageBatchRequestEntry]?

        public init(deleteMessageBatchRequestEntry: [DeleteMessageBatchRequestEntry]? = nil) {
            self.deleteMessageBatchRequestEntry = deleteMessageBatchRequestEntry
        }

        public init(dictionary: [String: Any]) throws {
            if let deleteMessageBatchRequestEntry = dictionary["DeleteMessageBatchRequestEntry"] as? [[String: Any]] {
                self.deleteMessageBatchRequestEntry = try deleteMessageBatchRequestEntry.map({ try DeleteMessageBatchRequestEntry(dictionary: $0) })
            } else { 
                self.deleteMessageBatchRequestEntry = nil
            }
        }
    }

    public struct SendMessageBatchRequestEntry: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The number of seconds for which a specific message is delayed. Valid values: 0 to 900. Maximum: 15 minutes. Messages with a positive DelaySeconds value become available for processing after the delay period is finished. If you don't specify a value, the default value for the queue is applied.   When you set FifoQueue, you can't set DelaySeconds per message. You can set this parameter only on a queue level. 
        public let delaySeconds: Int32?
        /// Each message attribute consists of a Name, Type, and Value. For more information, see Message Attribute Items and Validation in the Amazon SQS Developer Guide.
        public let messageAttributes: [String: MessageAttributeValue]?
        /// This parameter applies only to FIFO (first-in-first-out) queues. The tag that specifies that a message belongs to a specific message group. Messages that belong to the same message group are processed in a FIFO manner (however, messages in different message groups might be processed out of order). To interleave multiple ordered streams within a single queue, use MessageGroupId values (for example, session data for multiple users). In this scenario, multiple readers can process the queue, but the session data of each user is processed in a FIFO fashion.   You must associate a non-empty MessageGroupId with a message. If you don't provide a MessageGroupId, the action fails.    ReceiveMessage might return messages with multiple MessageGroupId values. For each MessageGroupId, the messages are sorted by time sent. The caller can't specify a MessageGroupId.   The length of MessageGroupId is 128 characters. Valid values are alphanumeric characters and punctuation (!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~). For best practices of using MessageGroupId, see Using the MessageGroupId Property in the Amazon Simple Queue Service Developer Guide.
        public let messageGroupId: String?
        /// This parameter applies only to FIFO (first-in-first-out) queues. The token used for deduplication of messages within a 5-minute minimum deduplication interval. If a message with a particular MessageDeduplicationId is sent successfully, subsequent messages with the same MessageDeduplicationId are accepted successfully but aren't delivered. For more information, see  Exactly-Once Processing in the Amazon SQS Developer Guide.   Every message must have a unique MessageDeduplicationId,   You may provide a MessageDeduplicationId explicitly.   If you aren't able to provide a MessageDeduplicationId and you enable ContentBasedDeduplication for your queue, Amazon SQS uses a SHA-256 hash to generate the MessageDeduplicationId using the body of the message (but not the attributes of the message).    If you don't provide a MessageDeduplicationId and the queue doesn't have ContentBasedDeduplication set, the action fails with an error.   If the queue has ContentBasedDeduplication set, your MessageDeduplicationId overrides the generated one.     When ContentBasedDeduplication is in effect, messages with identical content sent within the deduplication interval are treated as duplicates and only one copy of the message is delivered.   You can also use ContentBasedDeduplication for messages with identical content to be treated as duplicates.   If you send one message with ContentBasedDeduplication enabled and then another message with a MessageDeduplicationId that is the same as the one generated for the first MessageDeduplicationId, the two messages are treated as duplicates and only one copy of the message is delivered.     The MessageDeduplicationId is available to the recipient of the message (this can be useful for troubleshooting delivery issues). If a message is sent successfully but the acknowledgement is lost and the message is resent with the same MessageDeduplicationId after the deduplication interval, Amazon SQS can't detect duplicate messages.  The length of MessageDeduplicationId is 128 characters. MessageDeduplicationId can contain alphanumeric characters (a-z, A-Z, 0-9) and punctuation (!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~). For best practices of using MessageDeduplicationId, see Using the MessageDeduplicationId Property in the Amazon Simple Queue Service Developer Guide.
        public let messageDeduplicationId: String?
        /// The body of the message.
        public let messageBody: String
        /// An identifier for a message in this batch used to communicate the result.  The Ids of a batch request need to be unique within a request 
        public let id: String

        public init(delaySeconds: Int32? = nil, messageAttributes: [String: MessageAttributeValue]? = nil, messageGroupId: String? = nil, messageDeduplicationId: String? = nil, messageBody: String, id: String) {
            self.delaySeconds = delaySeconds
            self.messageAttributes = messageAttributes
            self.messageGroupId = messageGroupId
            self.messageDeduplicationId = messageDeduplicationId
            self.messageBody = messageBody
            self.id = id
        }

        public init(dictionary: [String: Any]) throws {
            self.delaySeconds = dictionary["DelaySeconds"] as? Int32
            if let messageAttributes = dictionary["MessageAttribute"] as? [String: Any] {
                var messageAttributesDict: [String: MessageAttributeValue] = [:]
                for (key, value) in messageAttributes {
                    guard let messageAttributeValueDict = value as? [String: Any] else { throw InitializableError.convertingError }
                    messageAttributesDict[key] = try MessageAttributeValue(dictionary: messageAttributeValueDict)
                }
                self.messageAttributes = messageAttributesDict
            } else { 
                self.messageAttributes = nil
            }
            self.messageGroupId = dictionary["MessageGroupId"] as? String
            self.messageDeduplicationId = dictionary["MessageDeduplicationId"] as? String
            guard let messageBody = dictionary["MessageBody"] as? String else { throw InitializableError.missingRequiredParam("MessageBody") }
            self.messageBody = messageBody
            guard let id = dictionary["Id"] as? String else { throw InitializableError.missingRequiredParam("Id") }
            self.id = id
        }
    }

    public struct DeleteMessageBatchResultEntry: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Represents a successfully deleted message.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public init(dictionary: [String: Any]) throws {
            guard let id = dictionary["Id"] as? String else { throw InitializableError.missingRequiredParam("Id") }
            self.id = id
        }
    }

    public struct SendMessageBatchResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of  SendMessageBatchResultEntry  items.
        public let successful: SendMessageBatchResultEntryList
        /// A list of  BatchResultErrorEntry  items with error details about each message that can't be enqueued.
        public let failed: BatchResultErrorEntryList

        public init(successful: SendMessageBatchResultEntryList, failed: BatchResultErrorEntryList) {
            self.successful = successful
            self.failed = failed
        }

        public init(dictionary: [String: Any]) throws {
            guard let successful = dictionary["Successful"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Successful") }
            self.successful = try Sqs.SendMessageBatchResultEntryList(dictionary: successful)
            guard let failed = dictionary["Failed"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Failed") }
            self.failed = try Sqs.BatchResultErrorEntryList(dictionary: failed)
        }
    }

}