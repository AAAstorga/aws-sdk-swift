// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Route53domains {

    public struct GetOperationDetailRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The identifier for the operation for which you want to get the status. Amazon Route 53 returned the identifier in the response to the original request. Type: String Default: None Required: Yes
        public let operationId: String

        public init(operationId: String) {
            self.operationId = operationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let operationId = dictionary["OperationId"] as? String else { throw InitializableError.missingRequiredParam("OperationId") }
            self.operationId = operationId
        }
    }

    public struct ResendContactReachabilityEmailRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the domain for which you want Amazon Route 53 to resend a confirmation email to the registrant contact. Type: String Default: None Required: Yes
        public let domainName: String?

        public init(domainName: String? = nil) {
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            self.domainName = dictionary["domainName"] as? String
        }
    }

    public struct ListOperationsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// For an initial request for a list of operations, omit this element. If the number of operations that are not yet complete is greater than the value that you specified for MaxItems, you can use Marker to return additional operations. Get the value of NextPageMarker from the previous response, and submit another request that includes the value of NextPageMarker in the Marker element. Type: String Default: None Required: No
        public let marker: String?
        /// Number of domains to be returned. Type: Integer Default: 20 Constraints: A value between 1 and 100. Required: No
        public let maxItems: Int32?

        public init(marker: String? = nil, maxItems: Int32? = nil) {
            self.marker = marker
            self.maxItems = maxItems
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["Marker"] as? String
            self.maxItems = dictionary["MaxItems"] as? Int32
        }
    }

    public struct RenewDomainRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The year when the registration for the domain is set to expire. This value must match the current expiration date for the domain. Type: Integer Default: None Valid values: Integer Required: Yes
        public let currentExpiryYear: Int32
        public let domainName: String
        /// The number of years that you want to renew the domain for. The maximum number of years depends on the top-level domain. For the range of valid values for your domain, see Domains that You Can Register with Amazon Route 53 in the Amazon Route 53 documentation. Type: Integer Default: 1 Valid values: Integer from 1 to 10 Required: No
        public let durationInYears: Int32?

        public init(currentExpiryYear: Int32, domainName: String, durationInYears: Int32? = nil) {
            self.currentExpiryYear = currentExpiryYear
            self.domainName = domainName
            self.durationInYears = durationInYears
        }

        public init(dictionary: [String: Any]) throws {
            guard let currentExpiryYear = dictionary["CurrentExpiryYear"] as? Int32 else { throw InitializableError.missingRequiredParam("CurrentExpiryYear") }
            self.currentExpiryYear = currentExpiryYear
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
            self.durationInYears = dictionary["DurationInYears"] as? Int32
        }
    }

    public enum OperationStatus: String, CustomStringConvertible {
        case submitted = "SUBMITTED"
        case in_progress = "IN_PROGRESS"
        case error = "ERROR"
        case successful = "SUCCESSFUL"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public struct GetDomainSuggestionsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let suggestionsList: [DomainSuggestion]?

        public init(suggestionsList: [DomainSuggestion]? = nil) {
            self.suggestionsList = suggestionsList
        }

        public init(dictionary: [String: Any]) throws {
            if let suggestionsList = dictionary["SuggestionsList"] as? [[String: Any]] {
                self.suggestionsList = try suggestionsList.map({ try DomainSuggestion(dictionary: $0) })
            } else { 
                self.suggestionsList = nil
            }
        }
    }

    public struct ListDomainsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A summary of domains. Type: Complex type containing a list of domain summaries. Children: AutoRenew, DomainName, Expiry, TransferLock
        public let domains: [DomainSummary]
        /// If there are more domains than you specified for MaxItems in the request, submit another request and include the value of NextPageMarker in the value of Marker. Type: String Parent: Operations
        public let nextPageMarker: String?

        public init(domains: [DomainSummary], nextPageMarker: String? = nil) {
            self.domains = domains
            self.nextPageMarker = nextPageMarker
        }

        public init(dictionary: [String: Any]) throws {
            guard let domains = dictionary["Domains"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("Domains") }
            self.domains = try domains.map({ try DomainSummary(dictionary: $0) })
            self.nextPageMarker = dictionary["NextPageMarker"] as? String
        }
    }

    public struct RegisterDomainResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Identifier for tracking the progress of the request. To use this ID to query the operation status, use GetOperationDetail. Type: String Default: None Constraints: Maximum 255 characters.
        public let operationId: String

        public init(operationId: String) {
            self.operationId = operationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let operationId = dictionary["OperationId"] as? String else { throw InitializableError.missingRequiredParam("OperationId") }
            self.operationId = operationId
        }
    }

    public enum DomainAvailability: String, CustomStringConvertible {
        case available = "AVAILABLE"
        case available_reserved = "AVAILABLE_RESERVED"
        case available_preorder = "AVAILABLE_PREORDER"
        case unavailable = "UNAVAILABLE"
        case unavailable_premium = "UNAVAILABLE_PREMIUM"
        case unavailable_restricted = "UNAVAILABLE_RESTRICTED"
        case reserved = "RESERVED"
        case dont_know = "DONT_KNOW"
        public var description: String { return self.rawValue }
    }

    public struct UpdateDomainContactPrivacyRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries will return contact information for our registrar partner, Gandi, instead of the contact information that you enter. Type: Boolean Default: None Valid values: true | false Required: No
        public let techPrivacy: Bool?
        /// The name of a domain. Type: String Default: None Constraints: The domain name can contain only the letters a through z, the numbers 0 through 9, and hyphen (-). Internationalized Domain Names are not supported. Required: Yes
        public let domainName: String
        /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries will return contact information for our registrar partner, Gandi, instead of the contact information that you enter. Type: Boolean Default: None Valid values: true | false Required: No
        public let registrantPrivacy: Bool?
        /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries will return contact information for our registrar partner, Gandi, instead of the contact information that you enter. Type: Boolean Default: None Valid values: true | false Required: No
        public let adminPrivacy: Bool?

        public init(techPrivacy: Bool? = nil, domainName: String, registrantPrivacy: Bool? = nil, adminPrivacy: Bool? = nil) {
            self.techPrivacy = techPrivacy
            self.domainName = domainName
            self.registrantPrivacy = registrantPrivacy
            self.adminPrivacy = adminPrivacy
        }

        public init(dictionary: [String: Any]) throws {
            self.techPrivacy = dictionary["TechPrivacy"] as? Bool
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
            self.registrantPrivacy = dictionary["RegistrantPrivacy"] as? Bool
            self.adminPrivacy = dictionary["AdminPrivacy"] as? Bool
        }
    }

    public struct ListDomainsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// For an initial request for a list of domains, omit this element. If the number of domains that are associated with the current AWS account is greater than the value that you specified for MaxItems, you can use Marker to return additional domains. Get the value of NextPageMarker from the previous response, and submit another request that includes the value of NextPageMarker in the Marker element. Type: String Default: None Constraints: The marker must match the value specified in the previous request.  Required: No
        public let marker: String?
        /// Number of domains to be returned. Type: Integer Default: 20 Constraints: A numeral between 1 and 100. Required: No
        public let maxItems: Int32?

        public init(marker: String? = nil, maxItems: Int32? = nil) {
            self.marker = marker
            self.maxItems = maxItems
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["Marker"] as? String
            self.maxItems = dictionary["MaxItems"] as? Int32
        }
    }

    public struct EnableDomainTransferLockResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Identifier for tracking the progress of the request. To use this ID to query the operation status, use GetOperationDetail. Type: String Default: None Constraints: Maximum 255 characters.
        public let operationId: String

        public init(operationId: String) {
            self.operationId = operationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let operationId = dictionary["OperationId"] as? String else { throw InitializableError.missingRequiredParam("OperationId") }
            self.operationId = operationId
        }
    }

    public struct GetDomainSuggestionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let onlyAvailable: Bool
        public let suggestionCount: Int32
        public let domainName: String

        public init(onlyAvailable: Bool, suggestionCount: Int32, domainName: String) {
            self.onlyAvailable = onlyAvailable
            self.suggestionCount = suggestionCount
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            guard let onlyAvailable = dictionary["OnlyAvailable"] as? Bool else { throw InitializableError.missingRequiredParam("OnlyAvailable") }
            self.onlyAvailable = onlyAvailable
            guard let suggestionCount = dictionary["SuggestionCount"] as? Int32 else { throw InitializableError.missingRequiredParam("SuggestionCount") }
            self.suggestionCount = suggestionCount
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public enum ExtraParamName: String, CustomStringConvertible {
        case duns_number = "DUNS_NUMBER"
        case brand_number = "BRAND_NUMBER"
        case birth_department = "BIRTH_DEPARTMENT"
        case birth_date_in_yyyy_mm_dd = "BIRTH_DATE_IN_YYYY_MM_DD"
        case birth_country = "BIRTH_COUNTRY"
        case birth_city = "BIRTH_CITY"
        case document_number = "DOCUMENT_NUMBER"
        case au_id_number = "AU_ID_NUMBER"
        case au_id_type = "AU_ID_TYPE"
        case ca_legal_type = "CA_LEGAL_TYPE"
        case ca_business_entity_type = "CA_BUSINESS_ENTITY_TYPE"
        case es_identification = "ES_IDENTIFICATION"
        case es_identification_type = "ES_IDENTIFICATION_TYPE"
        case es_legal_form = "ES_LEGAL_FORM"
        case fi_business_number = "FI_BUSINESS_NUMBER"
        case fi_id_number = "FI_ID_NUMBER"
        case it_pin = "IT_PIN"
        case ru_passport_data = "RU_PASSPORT_DATA"
        case se_id_number = "SE_ID_NUMBER"
        case sg_id_number = "SG_ID_NUMBER"
        case vat_number = "VAT_NUMBER"
        public var description: String { return self.rawValue }
    }

    public struct DeleteTagsForDomainResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct RetrieveDomainAuthCodeResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The authorization code for the domain. Type: String
        public let authCode: String

        public init(authCode: String) {
            self.authCode = authCode
        }

        public init(dictionary: [String: Any]) throws {
            guard let authCode = dictionary["AuthCode"] as? String else { throw InitializableError.missingRequiredParam("AuthCode") }
            self.authCode = authCode
        }
    }

    public struct Tag: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The value of a tag. Type: String Default: None Valid values: A-Z, a-z, 0-9, space, ".:/=+\-@" Constraints: Each value can be 0-256 characters long. Required: Yes
        public let value: String?
        /// The key (name) of a tag. Type: String Default: None Valid values: A-Z, a-z, 0-9, space, ".:/=+\-@" Constraints: Each key can be 1-128 characters long. Required: Yes
        public let key: String?

        public init(value: String? = nil, key: String? = nil) {
            self.value = value
            self.key = key
        }

        public init(dictionary: [String: Any]) throws {
            self.value = dictionary["Value"] as? String
            self.key = dictionary["Key"] as? String
        }
    }

    public struct DomainSummary: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Expiration date of the domain in Coordinated Universal Time (UTC). Type: Long
        public let expiry: Date?
        /// The name of a domain. Type: String
        public let domainName: String
        /// Indicates whether the domain is automatically renewed upon expiration. Type: Boolean Valid values: True | False
        public let autoRenew: Bool?
        /// Indicates whether a domain is locked from unauthorized transfer to another party. Type: Boolean Valid values: True | False
        public let transferLock: Bool?

        public init(expiry: Date? = nil, domainName: String, autoRenew: Bool? = nil, transferLock: Bool? = nil) {
            self.expiry = expiry
            self.domainName = domainName
            self.autoRenew = autoRenew
            self.transferLock = transferLock
        }

        public init(dictionary: [String: Any]) throws {
            self.expiry = dictionary["Expiry"] as? Date
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
            self.autoRenew = dictionary["AutoRenew"] as? Bool
            self.transferLock = dictionary["TransferLock"] as? Bool
        }
    }

    public enum ContactType: String, CustomStringConvertible {
        case person = "PERSON"
        case company = "COMPANY"
        case association = "ASSOCIATION"
        case public_body = "PUBLIC_BODY"
        case reseller = "RESELLER"
        public var description: String { return self.rawValue }
    }

    public struct CheckDomainAvailabilityResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Whether the domain name is available for registering.  You can only register domains designated as AVAILABLE.  Type: String Valid values:  AVAILABLE – The domain name is available. AVAILABLE_RESERVED – The domain name is reserved under specific conditions. AVAILABLE_PREORDER – The domain name is available and can be preordered. UNAVAILABLE – The domain name is not available. UNAVAILABLE_PREMIUM – The domain name is not available. UNAVAILABLE_RESTRICTED – The domain name is forbidden. RESERVED – The domain name has been reserved for another person or organization. DONT_KNOW – The TLD registry didn't reply with a definitive answer about whether the domain name is available. Amazon Route 53 can return this response for a variety of reasons, for example, the registry is performing maintenance. Try again later. 
        public let availability: DomainAvailability

        public init(availability: DomainAvailability) {
            self.availability = availability
        }

        public init(dictionary: [String: Any]) throws {
            guard let rawAvailability = dictionary["Availability"] as? String, let availability = DomainAvailability(rawValue: rawAvailability) else { throw InitializableError.missingRequiredParam("Availability") }
            self.availability = availability
        }
    }

    public struct TransferDomainResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Identifier for tracking the progress of the request. To use this ID to query the operation status, use GetOperationDetail. Type: String Default: None Constraints: Maximum 255 characters.
        public let operationId: String

        public init(operationId: String) {
            self.operationId = operationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let operationId = dictionary["OperationId"] as? String else { throw InitializableError.missingRequiredParam("OperationId") }
            self.operationId = operationId
        }
    }

    public enum ReachabilityStatus: String, CustomStringConvertible {
        case pending = "PENDING"
        case done = "DONE"
        case expired = "EXPIRED"
        public var description: String { return self.rawValue }
    }

    public struct DomainSuggestion: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let domainName: String?
        public let availability: String?

        public init(domainName: String? = nil, availability: String? = nil) {
            self.domainName = domainName
            self.availability = availability
        }

        public init(dictionary: [String: Any]) throws {
            self.domainName = dictionary["DomainName"] as? String
            self.availability = dictionary["Availability"] as? String
        }
    }

    public struct ListOperationsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Lists summaries of the operations. Type: Complex type containing a list of operation summaries Children: OperationId, Status, SubmittedDate, Type
        public let operations: [OperationSummary]
        /// If there are more operations than you specified for MaxItems in the request, submit another request and include the value of NextPageMarker in the value of Marker. Type: String Parent: Operations
        public let nextPageMarker: String?

        public init(operations: [OperationSummary], nextPageMarker: String? = nil) {
            self.operations = operations
            self.nextPageMarker = nextPageMarker
        }

        public init(dictionary: [String: Any]) throws {
            guard let operations = dictionary["Operations"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("Operations") }
            self.operations = try operations.map({ try OperationSummary(dictionary: $0) })
            self.nextPageMarker = dictionary["NextPageMarker"] as? String
        }
    }

    public struct ContactDetail: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// First line of the contact&apos;s address. Type: String Default: None Constraints: Maximum 255 characters. Parents: RegistrantContact, AdminContact, TechContact Required: Yes
        public let addressLine1: String?
        /// Email address of the contact. Type: String Default: None Constraints: Maximum 254 characters. Parents: RegistrantContact, AdminContact, TechContact  Required: Yes
        public let email: String?
        /// The phone number of the contact. Type: String Default: None Constraints: Phone number must be specified in the format "+[country dialing code].[number including any area code>]". For example, a US phone number might appear as "+1.1234567890". Parents: RegistrantContact, AdminContact, TechContact Required: Yes
        public let phoneNumber: String?
        /// Name of the organization for contact types other than PERSON. Type: String Default: None Constraints: Maximum 255 characters. Contact type must not be PERSON. Parents: RegistrantContact, AdminContact, TechContact Required: No
        public let organizationName: String?
        /// The state or province of the contact&apos;s city. Type: String Default: None Constraints: Maximum 255 characters. Parents: RegistrantContact, AdminContact, TechContact Required: No
        public let state: String?
        /// Last name of contact. Type: String Default: None Constraints: Maximum 255 characters. Parents: RegistrantContact, AdminContact, TechContact Required: Yes
        public let lastName: String?
        /// Indicates whether the contact is a person, company, association, or public organization. If you choose an option other than PERSON, you must enter an organization name, and you can&apos;t enable privacy protection for the contact. Type: String Default: None Constraints: Maximum 255 characters. Valid values: PERSON | COMPANY | ASSOCIATION | PUBLIC_BODY Parents: RegistrantContact, AdminContact, TechContact  Required: Yes
        public let contactType: ContactType?
        /// The zip or postal code of the contact&apos;s address. Type: String Default: None Constraints: Maximum 255 characters. Parents: RegistrantContact, AdminContact, TechContact Required: No
        public let zipCode: String?
        /// Fax number of the contact. Type: String Default: None Constraints: Phone number must be specified in the format "+[country dialing code].[number including any area code]". For example, a US phone number might appear as "+1.1234567890". Parents: RegistrantContact, AdminContact, TechContact Required: No
        public let fax: String?
        /// A list of name-value pairs for parameters required by certain top-level domains. Type: Complex Default: None Parents: RegistrantContact, AdminContact, TechContact Children: Name, Value Required: No
        public let extraParams: [ExtraParam]?
        /// First name of contact. Type: String Default: None Constraints: Maximum 255 characters. Parents: RegistrantContact, AdminContact, TechContact  Required: Yes
        public let firstName: String?
        /// The city of the contact&apos;s address. Type: String Default: None Constraints: Maximum 255 characters. Parents: RegistrantContact, AdminContact, TechContact Required: Yes
        public let city: String?
        /// Code for the country of the contact&apos;s address. Type: String Default: None Constraints: Maximum 255 characters. Parents: RegistrantContact, AdminContact, TechContact Required: Yes
        public let countryCode: CountryCode?
        /// Second line of contact&apos;s address, if any. Type: String Default: None Constraints: Maximum 255 characters. Parents: RegistrantContact, AdminContact, TechContact Required: No
        public let addressLine2: String?

        public init(addressLine1: String? = nil, email: String? = nil, phoneNumber: String? = nil, organizationName: String? = nil, state: String? = nil, lastName: String? = nil, contactType: ContactType? = nil, zipCode: String? = nil, fax: String? = nil, extraParams: [ExtraParam]? = nil, firstName: String? = nil, city: String? = nil, countryCode: CountryCode? = nil, addressLine2: String? = nil) {
            self.addressLine1 = addressLine1
            self.email = email
            self.phoneNumber = phoneNumber
            self.organizationName = organizationName
            self.state = state
            self.lastName = lastName
            self.contactType = contactType
            self.zipCode = zipCode
            self.fax = fax
            self.extraParams = extraParams
            self.firstName = firstName
            self.city = city
            self.countryCode = countryCode
            self.addressLine2 = addressLine2
        }

        public init(dictionary: [String: Any]) throws {
            self.addressLine1 = dictionary["AddressLine1"] as? String
            self.email = dictionary["Email"] as? String
            self.phoneNumber = dictionary["PhoneNumber"] as? String
            self.organizationName = dictionary["OrganizationName"] as? String
            self.state = dictionary["State"] as? String
            self.lastName = dictionary["LastName"] as? String
            if let contactType = dictionary["ContactType"] as? String { self.contactType = ContactType(rawValue: contactType) } else { self.contactType = nil }
            self.zipCode = dictionary["ZipCode"] as? String
            self.fax = dictionary["Fax"] as? String
            if let extraParams = dictionary["ExtraParams"] as? [[String: Any]] {
                self.extraParams = try extraParams.map({ try ExtraParam(dictionary: $0) })
            } else { 
                self.extraParams = nil
            }
            self.firstName = dictionary["FirstName"] as? String
            self.city = dictionary["City"] as? String
            if let countryCode = dictionary["CountryCode"] as? String { self.countryCode = CountryCode(rawValue: countryCode) } else { self.countryCode = nil }
            self.addressLine2 = dictionary["AddressLine2"] as? String
        }
    }

    public struct EnableDomainAutoRenewResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ViewBillingResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A summary of billing records. Type: Complex type containing a list of billing record summaries. Children: DomainName, Operation, InvoiceId, BillDate and Price
        public let billingRecords: [BillingRecord]?
        /// If there are more billing records than you specified for MaxItems in the request, submit another request and include the value of NextPageMarker in the value of Marker. Type: String Parent: BillingRecords
        public let nextPageMarker: String?

        public init(billingRecords: [BillingRecord]? = nil, nextPageMarker: String? = nil) {
            self.billingRecords = billingRecords
            self.nextPageMarker = nextPageMarker
        }

        public init(dictionary: [String: Any]) throws {
            if let billingRecords = dictionary["BillingRecords"] as? [[String: Any]] {
                self.billingRecords = try billingRecords.map({ try BillingRecord(dictionary: $0) })
            } else { 
                self.billingRecords = nil
            }
            self.nextPageMarker = dictionary["NextPageMarker"] as? String
        }
    }

    public struct UpdateDomainNameserversResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Identifier for tracking the progress of the request. To use this ID to query the operation status, use GetOperationDetail. Type: String Default: None Constraints: Maximum 255 characters.
        public let operationId: String

        public init(operationId: String) {
            self.operationId = operationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let operationId = dictionary["OperationId"] as? String else { throw InitializableError.missingRequiredParam("OperationId") }
            self.operationId = operationId
        }
    }

    public struct ListTagsForDomainRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The domain for which you want to get a list of tags.
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public struct ListTagsForDomainResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of the tags that are associated with the specified domain. Type: A complex type containing a list of tags Each tag includes the following elements.  Key The key (name) of a tag. Type: String  Value The value of a tag. Type: String  
        public let tagList: [Tag]

        public init(tagList: [Tag]) {
            self.tagList = tagList
        }

        public init(dictionary: [String: Any]) throws {
            guard let tagList = dictionary["TagList"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("TagList") }
            self.tagList = try tagList.map({ try Tag(dictionary: $0) })
        }
    }

    public struct UpdateTagsForDomainResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct GetDomainDetailRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of a domain. Type: String Default: None Constraints: The domain name can contain only the letters a through z, the numbers 0 through 9, and hyphen (-). Internationalized Domain Names are not supported. Required: Yes
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public struct TransferDomainRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Reserved for future use.
        public let idnLangCode: String?
        /// Provides detailed contact information. Type: Complex Children: FirstName, MiddleName, LastName, ContactType, OrganizationName, AddressLine1, AddressLine2, City, State, CountryCode, ZipCode, PhoneNumber, Email, Fax, ExtraParams Required: Yes
        public let adminContact: ContactDetail
        /// The number of years the domain will be registered. Domains are registered for a minimum of one year. The maximum period depends on the top-level domain. Type: Integer Default: 1 Valid values: Integer from 1 to 10 Required: Yes
        public let durationInYears: Int32
        /// Provides detailed contact information. Type: Complex Children: FirstName, MiddleName, LastName, ContactType, OrganizationName, AddressLine1, AddressLine2, City, State, CountryCode, ZipCode, PhoneNumber, Email, Fax, ExtraParams Required: Yes
        public let registrantContact: ContactDetail
        /// Contains details for the host and glue IP addresses. Type: Complex Children: GlueIps, Name Required: No
        public let nameservers: [Nameserver]?
        /// Provides detailed contact information. Type: Complex Children: FirstName, MiddleName, LastName, ContactType, OrganizationName, AddressLine1, AddressLine2, City, State, CountryCode, ZipCode, PhoneNumber, Email, Fax, ExtraParams Required: Yes
        public let techContact: ContactDetail
        /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries will return contact information for our registrar partner, Gandi, instead of the contact information that you enter. Type: Boolean Default: true Valid values: true | false Required: No
        public let privacyProtectTechContact: Bool?
        /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries will return contact information for our registrar partner, Gandi, instead of the contact information that you enter. Type: Boolean Default: true Valid values: true | false Required: No
        public let privacyProtectRegistrantContact: Bool?
        /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries will return contact information for our registrar partner, Gandi, instead of the contact information that you enter. Type: Boolean Default: true Valid values: true | false Required: No
        public let privacyProtectAdminContact: Bool?
        /// The name of a domain. Type: String Default: None Constraints: The domain name can contain only the letters a through z, the numbers 0 through 9, and hyphen (-). Internationalized Domain Names are not supported. Required: Yes
        public let domainName: String
        /// Indicates whether the domain will be automatically renewed (true) or not (false). Autorenewal only takes effect after the account is charged. Type: Boolean Valid values: true | false Default: true Required: No
        public let autoRenew: Bool?
        /// The authorization code for the domain. You get this value from the current registrar. Type: String Required: Yes
        public let authCode: String?

        public init(idnLangCode: String? = nil, adminContact: ContactDetail, durationInYears: Int32, registrantContact: ContactDetail, nameservers: [Nameserver]? = nil, techContact: ContactDetail, privacyProtectTechContact: Bool? = nil, privacyProtectRegistrantContact: Bool? = nil, privacyProtectAdminContact: Bool? = nil, domainName: String, autoRenew: Bool? = nil, authCode: String? = nil) {
            self.idnLangCode = idnLangCode
            self.adminContact = adminContact
            self.durationInYears = durationInYears
            self.registrantContact = registrantContact
            self.nameservers = nameservers
            self.techContact = techContact
            self.privacyProtectTechContact = privacyProtectTechContact
            self.privacyProtectRegistrantContact = privacyProtectRegistrantContact
            self.privacyProtectAdminContact = privacyProtectAdminContact
            self.domainName = domainName
            self.autoRenew = autoRenew
            self.authCode = authCode
        }

        public init(dictionary: [String: Any]) throws {
            self.idnLangCode = dictionary["IdnLangCode"] as? String
            guard let adminContact = dictionary["AdminContact"] as? [String: Any] else { throw InitializableError.missingRequiredParam("AdminContact") }
            self.adminContact = try Route53domains.ContactDetail(dictionary: adminContact)
            guard let durationInYears = dictionary["DurationInYears"] as? Int32 else { throw InitializableError.missingRequiredParam("DurationInYears") }
            self.durationInYears = durationInYears
            guard let registrantContact = dictionary["RegistrantContact"] as? [String: Any] else { throw InitializableError.missingRequiredParam("RegistrantContact") }
            self.registrantContact = try Route53domains.ContactDetail(dictionary: registrantContact)
            if let nameservers = dictionary["Nameservers"] as? [[String: Any]] {
                self.nameservers = try nameservers.map({ try Nameserver(dictionary: $0) })
            } else { 
                self.nameservers = nil
            }
            guard let techContact = dictionary["TechContact"] as? [String: Any] else { throw InitializableError.missingRequiredParam("TechContact") }
            self.techContact = try Route53domains.ContactDetail(dictionary: techContact)
            self.privacyProtectTechContact = dictionary["PrivacyProtectTechContact"] as? Bool
            self.privacyProtectRegistrantContact = dictionary["PrivacyProtectRegistrantContact"] as? Bool
            self.privacyProtectAdminContact = dictionary["PrivacyProtectAdminContact"] as? Bool
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
            self.autoRenew = dictionary["AutoRenew"] as? Bool
            self.authCode = dictionary["AuthCode"] as? String
        }
    }

    public struct EnableDomainTransferLockRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of a domain. Type: String Default: None Constraints: The domain name can contain only the letters a through z, the numbers 0 through 9, and hyphen (-). Internationalized Domain Names are not supported. Required: Yes
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public struct UpdateTagsForDomainRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of the tag keys and values that you want to add or update. If you specify a key that already exists, the corresponding value will be replaced. Type: A complex type containing a list of tags Default: None Required: No'> Each tag includes the following elements:  Key The key (name) of a tag. Type: String Default: None Valid values: Unicode characters including alphanumeric, space, and ".:/=+\-@" Constraints: Each key can be 1-128 characters long. Required: Yes  Value The value of a tag. Type: String Default: None Valid values: Unicode characters including alphanumeric, space, and ".:/=+\-@" Constraints: Each value can be 0-256 characters long. Required: Yes  
        public let tagsToUpdate: [Tag]?
        /// The domain for which you want to add or update tags. The name of a domain. Type: String Default: None Constraints: The domain name can contain only the letters a through z, the numbers 0 through 9, and hyphen (-). Hyphens are allowed only when they&apos;re surrounded by letters, numbers, or other hyphens. You can&apos;t specify a hyphen at the beginning or end of a label. To specify an Internationalized Domain Name, you must convert the name to Punycode. Required: Yes
        public let domainName: String

        public init(tagsToUpdate: [Tag]? = nil, domainName: String) {
            self.tagsToUpdate = tagsToUpdate
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            if let tagsToUpdate = dictionary["TagsToUpdate"] as? [[String: Any]] {
                self.tagsToUpdate = try tagsToUpdate.map({ try Tag(dictionary: $0) })
            } else { 
                self.tagsToUpdate = nil
            }
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public struct GetContactReachabilityStatusResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The domain name for which you requested the reachability status.
        public let domainName: String?
        /// Whether the registrant contact has responded. PENDING indicates that we sent the confirmation email and haven't received a response yet, DONE indicates that we sent the email and got confirmation from the registrant contact, and EXPIRED indicates that the time limit expired before the registrant contact responded.  Type: String Valid values: PENDING, DONE, EXPIRED
        public let status: ReachabilityStatus?

        public init(domainName: String? = nil, status: ReachabilityStatus? = nil) {
            self.domainName = domainName
            self.status = status
        }

        public init(dictionary: [String: Any]) throws {
            self.domainName = dictionary["domainName"] as? String
            if let status = dictionary["status"] as? String { self.status = ReachabilityStatus(rawValue: status) } else { self.status = nil }
        }
    }

    public struct DeleteTagsForDomainRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of tag keys to delete. Type: A list that contains the keys of the tags that you want to delete. Default: None Required: No'>
        public let tagsToDelete: [String]
        /// The domain for which you want to delete one or more tags. The name of a domain. Type: String Default: None Constraints: The domain name can contain only the letters a through z, the numbers 0 through 9, and hyphen (-). Hyphens are allowed only when they&apos;re surrounded by letters, numbers, or other hyphens. You can&apos;t specify a hyphen at the beginning or end of a label. To specify an Internationalized Domain Name, you must convert the name to Punycode. Required: Yes
        public let domainName: String

        public init(tagsToDelete: [String], domainName: String) {
            self.tagsToDelete = tagsToDelete
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            guard let tagsToDelete = dictionary["TagsToDelete"] as? [String] else { throw InitializableError.missingRequiredParam("TagsToDelete") }
            self.tagsToDelete = tagsToDelete
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public struct GetContactReachabilityStatusRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the domain for which you want to know whether the registrant contact has confirmed that the email address is valid. Type: String Default: None Required: Yes
        public let domainName: String?

        public init(domainName: String? = nil) {
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            self.domainName = dictionary["domainName"] as? String
        }
    }

    public struct ExtraParam: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Values corresponding to the additional parameter names required by some top-level domains. Type: String Default: None Constraints: Maximum 2048 characters. Parent: ExtraParams Required: Yes
        public let value: String
        /// Name of the additional parameter required by the top-level domain. Type: String Default: None Valid values: DUNS_NUMBER | BRAND_NUMBER | BIRTH_DEPARTMENT | BIRTH_DATE_IN_YYYY_MM_DD | BIRTH_COUNTRY | BIRTH_CITY | DOCUMENT_NUMBER | AU_ID_NUMBER | AU_ID_TYPE | CA_LEGAL_TYPE | CA_BUSINESS_ENTITY_TYPE |ES_IDENTIFICATION | ES_IDENTIFICATION_TYPE | ES_LEGAL_FORM | FI_BUSINESS_NUMBER | FI_ID_NUMBER | IT_PIN | RU_PASSPORT_DATA | SE_ID_NUMBER | SG_ID_NUMBER | VAT_NUMBER Parent: ExtraParams Required: Yes
        public let name: ExtraParamName

        public init(value: String, name: ExtraParamName) {
            self.value = value
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            guard let value = dictionary["Value"] as? String else { throw InitializableError.missingRequiredParam("Value") }
            self.value = value
            guard let rawName = dictionary["Name"] as? String, let name = ExtraParamName(rawValue: rawName) else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
        }
    }

    public struct GetOperationDetailResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The current status of the requested operation in the system. Type: String
        public let status: OperationStatus?
        /// The identifier for the operation. Type: String
        public let operationId: String?
        /// Detailed information on the status including possible errors. Type: String
        public let message: String?
        /// The date when the request was submitted.
        public let submittedDate: Date?
        /// The type of operation that was requested. Type: String
        public let `type`: OperationType?
        /// The name of a domain. Type: String
        public let domainName: String?

        public init(status: OperationStatus? = nil, operationId: String? = nil, message: String? = nil, submittedDate: Date? = nil, type: OperationType? = nil, domainName: String? = nil) {
            self.status = status
            self.operationId = operationId
            self.message = message
            self.submittedDate = submittedDate
            self.`type` = `type`
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            if let status = dictionary["Status"] as? String { self.status = OperationStatus(rawValue: status) } else { self.status = nil }
            self.operationId = dictionary["OperationId"] as? String
            self.message = dictionary["Message"] as? String
            self.submittedDate = dictionary["SubmittedDate"] as? Date
            if let `type` = dictionary["Type"] as? String { self.`type` = OperationType(rawValue: `type`) } else { self.`type` = nil }
            self.domainName = dictionary["DomainName"] as? String
        }
    }

    public struct EnableDomainAutoRenewRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public struct Nameserver: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Glue IP address of a name server entry. Glue IP addresses are required only when the name of the name server is a subdomain of the domain. For example, if your domain is example.com and the name server for the domain is ns.example.com, you need to specify the IP address for ns.example.com. Type: List of IP addresses. Constraints: The list can contain only one IPv4 and one IPv6 address. Parent: Nameservers
        public let glueIps: [String]?
        /// The fully qualified host name of the name server. Type: String Constraint: Maximum 255 characterss Parent: Nameservers
        public let name: String

        public init(glueIps: [String]? = nil, name: String) {
            self.glueIps = glueIps
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            self.glueIps = dictionary["GlueIps"] as? [String]
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
        }
    }

    public struct RetrieveDomainAuthCodeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of a domain. Type: String Default: None Constraints: The domain name can contain only the letters a through z, the numbers 0 through 9, and hyphen (-). Internationalized Domain Names are not supported. Required: Yes
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public struct BillingRecord: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The date that the operation was billed, in Unix format. Type: Double
        public let billDate: Date?
        /// The ID of the invoice that is associated with the billing record. Type: String
        public let invoiceId: String?
        /// The name of a domain. Type: String
        public let domainName: String?
        /// The operation that you were charged for. Type: String Valid values:  REGISTER_DOMAIN TRANSFER_IN_DOMAIN RENEW_DOMAIN CHANGE_DOMAIN_OWNER  
        public let operation: OperationType?
        /// The price that you were charged for the operation, in US dollars. Type: Double Example value: 12.0
        public let price: Double?

        public init(billDate: Date? = nil, invoiceId: String? = nil, domainName: String? = nil, operation: OperationType? = nil, price: Double? = nil) {
            self.billDate = billDate
            self.invoiceId = invoiceId
            self.domainName = domainName
            self.operation = operation
            self.price = price
        }

        public init(dictionary: [String: Any]) throws {
            self.billDate = dictionary["BillDate"] as? Date
            self.invoiceId = dictionary["InvoiceId"] as? String
            self.domainName = dictionary["DomainName"] as? String
            if let operation = dictionary["Operation"] as? String { self.operation = OperationType(rawValue: operation) } else { self.operation = nil }
            self.price = dictionary["Price"] as? Double
        }
    }

    public struct RegisterDomainRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Reserved for future use.
        public let idnLangCode: String?
        /// Provides detailed contact information. Type: Complex Children: FirstName, MiddleName, LastName, ContactType, OrganizationName, AddressLine1, AddressLine2, City, State, CountryCode, ZipCode, PhoneNumber, Email, Fax, ExtraParams Required: Yes
        public let adminContact: ContactDetail
        /// The number of years the domain will be registered. Domains are registered for a minimum of one year. The maximum period depends on the top-level domain. Type: Integer Default: 1 Valid values: Integer from 1 to 10 Required: Yes
        public let durationInYears: Int32
        /// Provides detailed contact information. Type: Complex Children: FirstName, MiddleName, LastName, ContactType, OrganizationName, AddressLine1, AddressLine2, City, State, CountryCode, ZipCode, PhoneNumber, Email, Fax, ExtraParams Required: Yes
        public let registrantContact: ContactDetail
        /// Provides detailed contact information. Type: Complex Children: FirstName, MiddleName, LastName, ContactType, OrganizationName, AddressLine1, AddressLine2, City, State, CountryCode, ZipCode, PhoneNumber, Email, Fax, ExtraParams Required: Yes
        public let techContact: ContactDetail
        /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries will return contact information for our registrar partner, Gandi, instead of the contact information that you enter. Type: Boolean Default: true Valid values: true | false Required: No
        public let privacyProtectTechContact: Bool?
        /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries will return contact information for our registrar partner, Gandi, instead of the contact information that you enter. Type: Boolean Default: true Valid values: true | false Required: No
        public let privacyProtectRegistrantContact: Bool?
        /// The name of a domain. Type: String Default: None Constraints: The domain name can contain only the letters a through z, the numbers 0 through 9, and hyphen (-). Internationalized Domain Names are not supported. Required: Yes
        public let domainName: String
        /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries will return contact information for our registrar partner, Gandi, instead of the contact information that you enter. Type: Boolean Default: true Valid values: true | false Required: No
        public let privacyProtectAdminContact: Bool?
        /// Indicates whether the domain will be automatically renewed (true) or not (false). Autorenewal only takes effect after the account is charged. Type: Boolean Valid values: true | false Default: true Required: No
        public let autoRenew: Bool?

        public init(idnLangCode: String? = nil, adminContact: ContactDetail, durationInYears: Int32, registrantContact: ContactDetail, techContact: ContactDetail, privacyProtectTechContact: Bool? = nil, privacyProtectRegistrantContact: Bool? = nil, domainName: String, privacyProtectAdminContact: Bool? = nil, autoRenew: Bool? = nil) {
            self.idnLangCode = idnLangCode
            self.adminContact = adminContact
            self.durationInYears = durationInYears
            self.registrantContact = registrantContact
            self.techContact = techContact
            self.privacyProtectTechContact = privacyProtectTechContact
            self.privacyProtectRegistrantContact = privacyProtectRegistrantContact
            self.domainName = domainName
            self.privacyProtectAdminContact = privacyProtectAdminContact
            self.autoRenew = autoRenew
        }

        public init(dictionary: [String: Any]) throws {
            self.idnLangCode = dictionary["IdnLangCode"] as? String
            guard let adminContact = dictionary["AdminContact"] as? [String: Any] else { throw InitializableError.missingRequiredParam("AdminContact") }
            self.adminContact = try Route53domains.ContactDetail(dictionary: adminContact)
            guard let durationInYears = dictionary["DurationInYears"] as? Int32 else { throw InitializableError.missingRequiredParam("DurationInYears") }
            self.durationInYears = durationInYears
            guard let registrantContact = dictionary["RegistrantContact"] as? [String: Any] else { throw InitializableError.missingRequiredParam("RegistrantContact") }
            self.registrantContact = try Route53domains.ContactDetail(dictionary: registrantContact)
            guard let techContact = dictionary["TechContact"] as? [String: Any] else { throw InitializableError.missingRequiredParam("TechContact") }
            self.techContact = try Route53domains.ContactDetail(dictionary: techContact)
            self.privacyProtectTechContact = dictionary["PrivacyProtectTechContact"] as? Bool
            self.privacyProtectRegistrantContact = dictionary["PrivacyProtectRegistrantContact"] as? Bool
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
            self.privacyProtectAdminContact = dictionary["PrivacyProtectAdminContact"] as? Bool
            self.autoRenew = dictionary["AutoRenew"] as? Bool
        }
    }

    public struct ResendContactReachabilityEmailResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// True if the email address for the registrant contact has already been verified, and false otherwise. If the email address has already been verified, we don't send another confirmation email.
        public let isAlreadyVerified: Bool?
        /// The email address for the registrant contact at the time that we sent the verification email.
        public let emailAddress: String?
        /// The domain name for which you requested a confirmation email.
        public let domainName: String?

        public init(isAlreadyVerified: Bool? = nil, emailAddress: String? = nil, domainName: String? = nil) {
            self.isAlreadyVerified = isAlreadyVerified
            self.emailAddress = emailAddress
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            self.isAlreadyVerified = dictionary["isAlreadyVerified"] as? Bool
            self.emailAddress = dictionary["emailAddress"] as? String
            self.domainName = dictionary["domainName"] as? String
        }
    }

    public enum OperationType: String, CustomStringConvertible {
        case register_domain = "REGISTER_DOMAIN"
        case delete_domain = "DELETE_DOMAIN"
        case transfer_in_domain = "TRANSFER_IN_DOMAIN"
        case update_domain_contact = "UPDATE_DOMAIN_CONTACT"
        case update_nameserver = "UPDATE_NAMESERVER"
        case change_privacy_protection = "CHANGE_PRIVACY_PROTECTION"
        case domain_lock = "DOMAIN_LOCK"
        public var description: String { return self.rawValue }
    }

    public struct DisableDomainAutoRenewRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public struct GetDomainDetailResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Reserved for future use.
        public let registryDomainId: String?
        /// Reseller of the domain. Domains registered or transferred using Amazon Route 53 domains will have "Amazon" as the reseller.  Type: String
        public let reseller: String?
        /// Provides details about the domain registrant.  Type: Complex Children: FirstName, MiddleName, LastName, ContactType, OrganizationName, AddressLine1, AddressLine2, City, State, CountryCode, ZipCode, PhoneNumber, Email, Fax, ExtraParams
        public let registrantContact: ContactDetail
        /// An array of domain name status codes, also known as Extensible Provisioning Protocol (EPP) status codes. ICANN, the organization that maintains a central database of domain names, has developed a set of domain name status codes that tell you the status of a variety of operations on a domain name, for example, registering a domain name, transferring a domain name to another registrar, renewing the registration for a domain name, and so on. All registrars use this same set of status codes. For a current list of domain name status codes and an explanation of what each code means, go to the ICANN website and search for epp status codes. (Search on the ICANN website; web searches sometimes return an old version of the document.) Type: Array of String
        public let statusList: [String]?
        /// Provides details about the domain technical contact. Type: Complex Children: FirstName, MiddleName, LastName, ContactType, OrganizationName, AddressLine1, AddressLine2, City, State, CountryCode, ZipCode, PhoneNumber, Email, Fax, ExtraParams
        public let techContact: ContactDetail
        /// The date when the registration for the domain is set to expire. The date format is Unix time.
        public let expirationDate: Date?
        /// Name of the registrar of the domain as identified in the registry. Amazon Route 53 domains are registered by registrar Gandi. The value is "GANDI SAS".  Type: String
        public let registrarName: String?
        /// Specifies whether contact information for the tech contact is concealed from WHOIS queries. If the value is true, WHOIS ("who is") queries will return contact information for our registrar partner, Gandi, instead of the contact information that you enter. Type: Boolean
        public let techPrivacy: Bool?
        /// Web address of the registrar. Type: String
        public let registrarUrl: String?
        /// The date when the domain was created as found in the response to a WHOIS query. The date format is Unix time.
        public let creationDate: Date?
        /// Email address to contact to report incorrect contact information for a domain, to report that the domain is being used to send spam, to report that someone is cybersquatting on a domain name, or report some other type of abuse.  Type: String
        public let abuseContactEmail: String?
        /// Specifies whether contact information for the admin contact is concealed from WHOIS queries. If the value is true, WHOIS ("who is") queries will return contact information for our registrar partner, Gandi, instead of the contact information that you enter. Type: Boolean
        public let adminPrivacy: Bool?
        /// Phone number for reporting abuse.  Type: String
        public let abuseContactPhone: String?
        /// Provides details about the domain administrative contact.  Type: Complex Children: FirstName, MiddleName, LastName, ContactType, OrganizationName, AddressLine1, AddressLine2, City, State, CountryCode, ZipCode, PhoneNumber, Email, Fax, ExtraParams
        public let adminContact: ContactDetail
        /// The last updated date of the domain as found in the response to a WHOIS query. The date format is Unix time.
        public let updatedDate: Date?
        /// The fully qualified name of the WHOIS server that can answer the WHOIS query for the domain. Type: String
        public let whoIsServer: String?
        /// The name of the domain. Type: String
        public let nameservers: [Nameserver]
        /// Reserved for future use.
        public let dnsSec: String?
        /// The name of a domain. Type: String
        public let domainName: String
        /// Specifies whether contact information for the registrant contact is concealed from WHOIS queries. If the value is true, WHOIS ("who is") queries will return contact information for our registrar partner, Gandi, instead of the contact information that you enter. Type: Boolean
        public let registrantPrivacy: Bool?
        /// Specifies whether the domain registration is set to renew automatically. Type: Boolean
        public let autoRenew: Bool?

        public init(registryDomainId: String? = nil, reseller: String? = nil, registrantContact: ContactDetail, statusList: [String]? = nil, techContact: ContactDetail, expirationDate: Date? = nil, registrarName: String? = nil, techPrivacy: Bool? = nil, registrarUrl: String? = nil, creationDate: Date? = nil, abuseContactEmail: String? = nil, adminPrivacy: Bool? = nil, abuseContactPhone: String? = nil, adminContact: ContactDetail, updatedDate: Date? = nil, whoIsServer: String? = nil, nameservers: [Nameserver], dnsSec: String? = nil, domainName: String, registrantPrivacy: Bool? = nil, autoRenew: Bool? = nil) {
            self.registryDomainId = registryDomainId
            self.reseller = reseller
            self.registrantContact = registrantContact
            self.statusList = statusList
            self.techContact = techContact
            self.expirationDate = expirationDate
            self.registrarName = registrarName
            self.techPrivacy = techPrivacy
            self.registrarUrl = registrarUrl
            self.creationDate = creationDate
            self.abuseContactEmail = abuseContactEmail
            self.adminPrivacy = adminPrivacy
            self.abuseContactPhone = abuseContactPhone
            self.adminContact = adminContact
            self.updatedDate = updatedDate
            self.whoIsServer = whoIsServer
            self.nameservers = nameservers
            self.dnsSec = dnsSec
            self.domainName = domainName
            self.registrantPrivacy = registrantPrivacy
            self.autoRenew = autoRenew
        }

        public init(dictionary: [String: Any]) throws {
            self.registryDomainId = dictionary["RegistryDomainId"] as? String
            self.reseller = dictionary["Reseller"] as? String
            guard let registrantContact = dictionary["RegistrantContact"] as? [String: Any] else { throw InitializableError.missingRequiredParam("RegistrantContact") }
            self.registrantContact = try Route53domains.ContactDetail(dictionary: registrantContact)
            self.statusList = dictionary["StatusList"] as? [String]
            guard let techContact = dictionary["TechContact"] as? [String: Any] else { throw InitializableError.missingRequiredParam("TechContact") }
            self.techContact = try Route53domains.ContactDetail(dictionary: techContact)
            self.expirationDate = dictionary["ExpirationDate"] as? Date
            self.registrarName = dictionary["RegistrarName"] as? String
            self.techPrivacy = dictionary["TechPrivacy"] as? Bool
            self.registrarUrl = dictionary["RegistrarUrl"] as? String
            self.creationDate = dictionary["CreationDate"] as? Date
            self.abuseContactEmail = dictionary["AbuseContactEmail"] as? String
            self.adminPrivacy = dictionary["AdminPrivacy"] as? Bool
            self.abuseContactPhone = dictionary["AbuseContactPhone"] as? String
            guard let adminContact = dictionary["AdminContact"] as? [String: Any] else { throw InitializableError.missingRequiredParam("AdminContact") }
            self.adminContact = try Route53domains.ContactDetail(dictionary: adminContact)
            self.updatedDate = dictionary["UpdatedDate"] as? Date
            self.whoIsServer = dictionary["WhoIsServer"] as? String
            guard let nameservers = dictionary["Nameservers"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("Nameservers") }
            self.nameservers = try nameservers.map({ try Nameserver(dictionary: $0) })
            self.dnsSec = dictionary["DnsSec"] as? String
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
            self.registrantPrivacy = dictionary["RegistrantPrivacy"] as? Bool
            self.autoRenew = dictionary["AutoRenew"] as? Bool
        }
    }

    public struct DisableDomainTransferLockRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of a domain. Type: String Default: None Constraints: The domain name can contain only the letters a through z, the numbers 0 through 9, and hyphen (-). Internationalized Domain Names are not supported. Required: Yes
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public struct RenewDomainResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let operationId: String

        public init(operationId: String) {
            self.operationId = operationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let operationId = dictionary["OperationId"] as? String else { throw InitializableError.missingRequiredParam("OperationId") }
            self.operationId = operationId
        }
    }

    public struct OperationSummary: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The current status of the requested operation in the system. Type: String
        public let status: OperationStatus
        /// Identifier returned to track the requested action. Type: String
        public let operationId: String
        /// The date when the request was submitted.
        public let submittedDate: Date
        /// Type of the action requested. Type: String Valid values: REGISTER_DOMAIN | DELETE_DOMAIN | TRANSFER_IN_DOMAIN | UPDATE_DOMAIN_CONTACT | UPDATE_NAMESERVER | CHANGE_PRIVACY_PROTECTION | DOMAIN_LOCK
        public let `type`: OperationType

        public init(status: OperationStatus, operationId: String, submittedDate: Date, type: OperationType) {
            self.status = status
            self.operationId = operationId
            self.submittedDate = submittedDate
            self.`type` = `type`
        }

        public init(dictionary: [String: Any]) throws {
            guard let rawStatus = dictionary["Status"] as? String, let status = OperationStatus(rawValue: rawStatus) else { throw InitializableError.missingRequiredParam("Status") }
            self.status = status
            guard let operationId = dictionary["OperationId"] as? String else { throw InitializableError.missingRequiredParam("OperationId") }
            self.operationId = operationId
            guard let submittedDate = dictionary["SubmittedDate"] as? Date else { throw InitializableError.missingRequiredParam("SubmittedDate") }
            self.submittedDate = submittedDate
            guard let rawType = dictionary["Type"] as? String, let `type` = OperationType(rawValue: rawType) else { throw InitializableError.missingRequiredParam("Type") }
            self.`type` = `type`
        }
    }

    public struct UpdateDomainContactPrivacyResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Identifier for tracking the progress of the request. To use this ID to query the operation status, use GetOperationDetail. Type: String Default: None Constraints: Maximum 255 characters.
        public let operationId: String

        public init(operationId: String) {
            self.operationId = operationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let operationId = dictionary["OperationId"] as? String else { throw InitializableError.missingRequiredParam("OperationId") }
            self.operationId = operationId
        }
    }

    public struct DisableDomainAutoRenewResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct CheckDomainAvailabilityRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Reserved for future use.
        public let idnLangCode: String?
        /// The name of a domain. Type: String Default: None Constraints: The domain name can contain only the letters a through z, the numbers 0 through 9, and hyphen (-). Internationalized Domain Names are not supported. Required: Yes
        public let domainName: String

        public init(idnLangCode: String? = nil, domainName: String) {
            self.idnLangCode = idnLangCode
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            self.idnLangCode = dictionary["IdnLangCode"] as? String
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public struct UpdateDomainContactResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Identifier for tracking the progress of the request. To use this ID to query the operation status, use GetOperationDetail. Type: String Default: None Constraints: Maximum 255 characters.
        public let operationId: String

        public init(operationId: String) {
            self.operationId = operationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let operationId = dictionary["OperationId"] as? String else { throw InitializableError.missingRequiredParam("OperationId") }
            self.operationId = operationId
        }
    }

    public struct ViewBillingRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The number of billing records to be returned. Type: Integer Default: 20 Constraints: A value between 1 and 100. Required: No
        public let maxItems: Int32?
        /// The beginning date and time for the time period for which you want a list of billing records. Specify the date in Unix time format. Type: Double Default: None Required: Yes
        public let start: Date?
        /// For an initial request for a list of billing records, omit this element. If the number of billing records that are associated with the current AWS account during the specified period is greater than the value that you specified for MaxItems, you can use Marker to return additional billing records. Get the value of NextPageMarker from the previous response, and submit another request that includes the value of NextPageMarker in the Marker element.  Type: String Default: None Constraints: The marker must match the value of NextPageMarker that was returned in the previous response. Required: No
        public let marker: String?
        /// The end date and time for the time period for which you want a list of billing records. Specify the date in Unix time format. Type: Double Default: None Required: Yes
        public let end: Date?

        public init(maxItems: Int32? = nil, start: Date? = nil, marker: String? = nil, end: Date? = nil) {
            self.maxItems = maxItems
            self.start = start
            self.marker = marker
            self.end = end
        }

        public init(dictionary: [String: Any]) throws {
            self.maxItems = dictionary["MaxItems"] as? Int32
            self.start = dictionary["Start"] as? Date
            self.marker = dictionary["Marker"] as? String
            self.end = dictionary["End"] as? Date
        }
    }

    public struct UpdateDomainContactRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Provides detailed contact information. Type: Complex Children: FirstName, MiddleName, LastName, ContactType, OrganizationName, AddressLine1, AddressLine2, City, State, CountryCode, ZipCode, PhoneNumber, Email, Fax, ExtraParams Required: Yes
        public let adminContact: ContactDetail?
        /// The name of a domain. Type: String Default: None Constraints: The domain name can contain only the letters a through z, the numbers 0 through 9, and hyphen (-). Internationalized Domain Names are not supported. Required: Yes
        public let domainName: String
        /// Provides detailed contact information. Type: Complex Children: FirstName, MiddleName, LastName, ContactType, OrganizationName, AddressLine1, AddressLine2, City, State, CountryCode, ZipCode, PhoneNumber, Email, Fax, ExtraParams Required: Yes
        public let registrantContact: ContactDetail?
        /// Provides detailed contact information. Type: Complex Children: FirstName, MiddleName, LastName, ContactType, OrganizationName, AddressLine1, AddressLine2, City, State, CountryCode, ZipCode, PhoneNumber, Email, Fax, ExtraParams Required: Yes
        public let techContact: ContactDetail?

        public init(adminContact: ContactDetail? = nil, domainName: String, registrantContact: ContactDetail? = nil, techContact: ContactDetail? = nil) {
            self.adminContact = adminContact
            self.domainName = domainName
            self.registrantContact = registrantContact
            self.techContact = techContact
        }

        public init(dictionary: [String: Any]) throws {
            if let adminContact = dictionary["AdminContact"] as? [String: Any] { self.adminContact = try Route53domains.ContactDetail(dictionary: adminContact) } else { self.adminContact = nil }
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
            if let registrantContact = dictionary["RegistrantContact"] as? [String: Any] { self.registrantContact = try Route53domains.ContactDetail(dictionary: registrantContact) } else { self.registrantContact = nil }
            if let techContact = dictionary["TechContact"] as? [String: Any] { self.techContact = try Route53domains.ContactDetail(dictionary: techContact) } else { self.techContact = nil }
        }
    }

    public struct UpdateDomainNameserversRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The authorization key for .fi domains
        public let fIAuthKey: String?
        /// A list of new name servers for the domain. Type: Complex Children: Name, GlueIps Required: Yes
        public let nameservers: [Nameserver]
        /// The name of a domain. Type: String Default: None Constraints: The domain name can contain only the letters a through z, the numbers 0 through 9, and hyphen (-). Internationalized Domain Names are not supported. Required: Yes
        public let domainName: String

        public init(fIAuthKey: String? = nil, nameservers: [Nameserver], domainName: String) {
            self.fIAuthKey = fIAuthKey
            self.nameservers = nameservers
            self.domainName = domainName
        }

        public init(dictionary: [String: Any]) throws {
            self.fIAuthKey = dictionary["FIAuthKey"] as? String
            guard let nameservers = dictionary["Nameservers"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("Nameservers") }
            self.nameservers = try nameservers.map({ try Nameserver(dictionary: $0) })
            guard let domainName = dictionary["DomainName"] as? String else { throw InitializableError.missingRequiredParam("DomainName") }
            self.domainName = domainName
        }
    }

    public struct DisableDomainTransferLockResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Identifier for tracking the progress of the request. To use this ID to query the operation status, use GetOperationDetail. Type: String Default: None Constraints: Maximum 255 characters.
        public let operationId: String

        public init(operationId: String) {
            self.operationId = operationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let operationId = dictionary["OperationId"] as? String else { throw InitializableError.missingRequiredParam("OperationId") }
            self.operationId = operationId
        }
    }

    public enum CountryCode: String, CustomStringConvertible {
        case ad = "AD"
        case ae = "AE"
        case af = "AF"
        case ag = "AG"
        case ai = "AI"
        case al = "AL"
        case am = "AM"
        case an = "AN"
        case ao = "AO"
        case aq = "AQ"
        case ar = "AR"
        case `as` = "AS"
        case at = "AT"
        case au = "AU"
        case aw = "AW"
        case az = "AZ"
        case ba = "BA"
        case bb = "BB"
        case bd = "BD"
        case be = "BE"
        case bf = "BF"
        case bg = "BG"
        case bh = "BH"
        case bi = "BI"
        case bj = "BJ"
        case bl = "BL"
        case bm = "BM"
        case bn = "BN"
        case bo = "BO"
        case br = "BR"
        case bs = "BS"
        case bt = "BT"
        case bw = "BW"
        case by = "BY"
        case bz = "BZ"
        case ca = "CA"
        case cc = "CC"
        case cd = "CD"
        case cf = "CF"
        case cg = "CG"
        case ch = "CH"
        case ci = "CI"
        case ck = "CK"
        case cl = "CL"
        case cm = "CM"
        case cn = "CN"
        case co = "CO"
        case cr = "CR"
        case cu = "CU"
        case cv = "CV"
        case cx = "CX"
        case cy = "CY"
        case cz = "CZ"
        case de = "DE"
        case dj = "DJ"
        case dk = "DK"
        case dm = "DM"
        case `do` = "DO"
        case dz = "DZ"
        case ec = "EC"
        case ee = "EE"
        case eg = "EG"
        case er = "ER"
        case es = "ES"
        case et = "ET"
        case fi = "FI"
        case fj = "FJ"
        case fk = "FK"
        case fm = "FM"
        case fo = "FO"
        case fr = "FR"
        case ga = "GA"
        case gb = "GB"
        case gd = "GD"
        case ge = "GE"
        case gh = "GH"
        case gi = "GI"
        case gl = "GL"
        case gm = "GM"
        case gn = "GN"
        case gq = "GQ"
        case gr = "GR"
        case gt = "GT"
        case gu = "GU"
        case gw = "GW"
        case gy = "GY"
        case hk = "HK"
        case hn = "HN"
        case hr = "HR"
        case ht = "HT"
        case hu = "HU"
        case id = "ID"
        case ie = "IE"
        case il = "IL"
        case im = "IM"
        case `in` = "IN"
        case iq = "IQ"
        case ir = "IR"
        case `is` = "IS"
        case it = "IT"
        case jm = "JM"
        case jo = "JO"
        case jp = "JP"
        case ke = "KE"
        case kg = "KG"
        case kh = "KH"
        case ki = "KI"
        case km = "KM"
        case kn = "KN"
        case kp = "KP"
        case kr = "KR"
        case kw = "KW"
        case ky = "KY"
        case kz = "KZ"
        case la = "LA"
        case lb = "LB"
        case lc = "LC"
        case li = "LI"
        case lk = "LK"
        case lr = "LR"
        case ls = "LS"
        case lt = "LT"
        case lu = "LU"
        case lv = "LV"
        case ly = "LY"
        case ma = "MA"
        case mc = "MC"
        case md = "MD"
        case me = "ME"
        case mf = "MF"
        case mg = "MG"
        case mh = "MH"
        case mk = "MK"
        case ml = "ML"
        case mm = "MM"
        case mn = "MN"
        case mo = "MO"
        case mp = "MP"
        case mr = "MR"
        case ms = "MS"
        case mt = "MT"
        case mu = "MU"
        case mv = "MV"
        case mw = "MW"
        case mx = "MX"
        case my = "MY"
        case mz = "MZ"
        case na = "NA"
        case nc = "NC"
        case ne = "NE"
        case ng = "NG"
        case ni = "NI"
        case nl = "NL"
        case no = "NO"
        case np = "NP"
        case nr = "NR"
        case nu = "NU"
        case nz = "NZ"
        case om = "OM"
        case pa = "PA"
        case pe = "PE"
        case pf = "PF"
        case pg = "PG"
        case ph = "PH"
        case pk = "PK"
        case pl = "PL"
        case pm = "PM"
        case pn = "PN"
        case pr = "PR"
        case pt = "PT"
        case pw = "PW"
        case py = "PY"
        case qa = "QA"
        case ro = "RO"
        case rs = "RS"
        case ru = "RU"
        case rw = "RW"
        case sa = "SA"
        case sb = "SB"
        case sc = "SC"
        case sd = "SD"
        case se = "SE"
        case sg = "SG"
        case sh = "SH"
        case si = "SI"
        case sk = "SK"
        case sl = "SL"
        case sm = "SM"
        case sn = "SN"
        case so = "SO"
        case sr = "SR"
        case st = "ST"
        case sv = "SV"
        case sy = "SY"
        case sz = "SZ"
        case tc = "TC"
        case td = "TD"
        case tg = "TG"
        case th = "TH"
        case tj = "TJ"
        case tk = "TK"
        case tl = "TL"
        case tm = "TM"
        case tn = "TN"
        case to = "TO"
        case tr = "TR"
        case tt = "TT"
        case tv = "TV"
        case tw = "TW"
        case tz = "TZ"
        case ua = "UA"
        case ug = "UG"
        case us = "US"
        case uy = "UY"
        case uz = "UZ"
        case va = "VA"
        case vc = "VC"
        case ve = "VE"
        case vg = "VG"
        case vi = "VI"
        case vn = "VN"
        case vu = "VU"
        case wf = "WF"
        case ws = "WS"
        case ye = "YE"
        case yt = "YT"
        case za = "ZA"
        case zm = "ZM"
        case zw = "ZW"
        public var description: String { return self.rawValue }
    }

}