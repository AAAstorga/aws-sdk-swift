// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Directconnect {

    public struct CreateLagRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The AWS Direct Connect location in which the LAG should be allocated. Example: EqSV5 Default: None
        public let location: String
        /// The bandwidth of the individual physical connections bundled by the LAG. Default: None Available values: 1Gbps, 10Gbps
        public let connectionsBandwidth: String
        /// The ID of an existing connection to migrate to the LAG. Default: None
        public let connectionId: String?
        /// The number of physical connections initially provisioned and bundled by the LAG. Default: None
        public let numberOfConnections: Int32
        /// The name of the LAG. Example: "3x10G LAG to AWS" Default: None
        public let lagName: String

        public init(location: String, connectionsBandwidth: String, connectionId: String? = nil, numberOfConnections: Int32, lagName: String) {
            self.location = location
            self.connectionsBandwidth = connectionsBandwidth
            self.connectionId = connectionId
            self.numberOfConnections = numberOfConnections
            self.lagName = lagName
        }

        public init(dictionary: [String: Any]) throws {
            guard let location = dictionary["location"] as? String else { throw InitializableError.missingRequiredParam("location") }
            self.location = location
            guard let connectionsBandwidth = dictionary["connectionsBandwidth"] as? String else { throw InitializableError.missingRequiredParam("connectionsBandwidth") }
            self.connectionsBandwidth = connectionsBandwidth
            self.connectionId = dictionary["connectionId"] as? String
            guard let numberOfConnections = dictionary["numberOfConnections"] as? Int32 else { throw InitializableError.missingRequiredParam("numberOfConnections") }
            self.numberOfConnections = numberOfConnections
            guard let lagName = dictionary["lagName"] as? String else { throw InitializableError.missingRequiredParam("lagName") }
            self.lagName = lagName
        }
    }

    public struct DescribeTagsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the tags.
        public let resourceTags: [ResourceTag]?

        public init(resourceTags: [ResourceTag]? = nil) {
            self.resourceTags = resourceTags
        }

        public init(dictionary: [String: Any]) throws {
            if let resourceTags = dictionary["resourceTags"] as? [[String: Any]] {
                self.resourceTags = try resourceTags.map({ try ResourceTag(dictionary: $0) })
            } else { 
                self.resourceTags = nil
            }
        }
    }

    public struct VirtualGateways: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of virtual private gateways.
        public let virtualGateways: [VirtualGateway]?

        public init(virtualGateways: [VirtualGateway]? = nil) {
            self.virtualGateways = virtualGateways
        }

        public init(dictionary: [String: Any]) throws {
            if let virtualGateways = dictionary["virtualGateways"] as? [[String: Any]] {
                self.virtualGateways = try virtualGateways.map({ try VirtualGateway(dictionary: $0) })
            } else { 
                self.virtualGateways = nil
            }
        }
    }

    public struct TagResourceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Amazon Resource Name (ARN) of the Direct Connect resource. Example: arn:aws:directconnect:us-east-1:123456789012:dxcon/dxcon-fg5678gh
        public let resourceArn: String
        /// The list of tags to add.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceArn = dictionary["resourceArn"] as? String else { throw InitializableError.missingRequiredParam("resourceArn") }
            self.resourceArn = resourceArn
            guard let tags = dictionary["tags"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("tags") }
            self.tags = try tags.map({ try Tag(dictionary: $0) })
        }
    }

    public struct AllocateHostedConnectionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The numeric account ID of the customer for whom the connection will be provisioned. Example: 123443215678 Default: None
        public let ownerAccount: String
        /// The name of the provisioned connection. Example: "500M Connection to AWS" Default: None
        public let connectionName: String
        /// The ID of the interconnect or LAG on which the connection will be provisioned. Example: dxcon-456abc78 or dxlag-abc123 Default: None
        public let connectionId: String
        /// The dedicated VLAN provisioned to the hosted connection. Example: 101 Default: None
        public let vlan: Int32
        /// The bandwidth of the connection. Example: 500Mbps  Default: None Values: 50Mbps, 100Mbps, 200Mbps, 300Mbps, 400Mbps, or 500Mbps
        public let bandwidth: String

        public init(ownerAccount: String, connectionName: String, connectionId: String, vlan: Int32, bandwidth: String) {
            self.ownerAccount = ownerAccount
            self.connectionName = connectionName
            self.connectionId = connectionId
            self.vlan = vlan
            self.bandwidth = bandwidth
        }

        public init(dictionary: [String: Any]) throws {
            guard let ownerAccount = dictionary["ownerAccount"] as? String else { throw InitializableError.missingRequiredParam("ownerAccount") }
            self.ownerAccount = ownerAccount
            guard let connectionName = dictionary["connectionName"] as? String else { throw InitializableError.missingRequiredParam("connectionName") }
            self.connectionName = connectionName
            guard let connectionId = dictionary["connectionId"] as? String else { throw InitializableError.missingRequiredParam("connectionId") }
            self.connectionId = connectionId
            guard let vlan = dictionary["vlan"] as? Int32 else { throw InitializableError.missingRequiredParam("vlan") }
            self.vlan = vlan
            guard let bandwidth = dictionary["bandwidth"] as? String else { throw InitializableError.missingRequiredParam("bandwidth") }
            self.bandwidth = bandwidth
        }
    }

    public struct Lag: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of connections bundled by this LAG.
        public let connections: [Connection]?
        public let location: String?
        public let lagId: String?
        public let lagState: LagState?
        /// The AWS Direct Connection endpoint that hosts the LAG.
        public let awsDevice: String?
        /// The number of physical connections bundled by the LAG, up to a maximum of 10.
        public let numberOfConnections: Int32?
        /// The owner of the LAG.
        public let ownerAccount: String?
        public let region: String?
        /// The minimum number of physical connections that must be operational for the LAG itself to be operational. If the number of operational connections drops below this setting, the LAG state changes to down. This value can help to ensure that a LAG is not overutilized if a significant number of its bundled connections go down.
        public let minimumLinks: Int32?
        /// Indicates whether the LAG can host other connections.  This is intended for use by AWS Direct Connect partners only. 
        public let allowsHostedConnections: Bool?
        /// The individual bandwidth of the physical connections bundled by the LAG. Available values: 1Gbps, 10Gbps
        public let connectionsBandwidth: String?
        /// The name of the LAG.
        public let lagName: String?

        public init(connections: [Connection]? = nil, location: String? = nil, lagId: String? = nil, lagState: LagState? = nil, awsDevice: String? = nil, numberOfConnections: Int32? = nil, ownerAccount: String? = nil, region: String? = nil, minimumLinks: Int32? = nil, allowsHostedConnections: Bool? = nil, connectionsBandwidth: String? = nil, lagName: String? = nil) {
            self.connections = connections
            self.location = location
            self.lagId = lagId
            self.lagState = lagState
            self.awsDevice = awsDevice
            self.numberOfConnections = numberOfConnections
            self.ownerAccount = ownerAccount
            self.region = region
            self.minimumLinks = minimumLinks
            self.allowsHostedConnections = allowsHostedConnections
            self.connectionsBandwidth = connectionsBandwidth
            self.lagName = lagName
        }

        public init(dictionary: [String: Any]) throws {
            if let connections = dictionary["connections"] as? [[String: Any]] {
                self.connections = try connections.map({ try Connection(dictionary: $0) })
            } else { 
                self.connections = nil
            }
            self.location = dictionary["location"] as? String
            self.lagId = dictionary["lagId"] as? String
            if let lagState = dictionary["lagState"] as? String { self.lagState = LagState(rawValue: lagState) } else { self.lagState = nil }
            self.awsDevice = dictionary["awsDevice"] as? String
            self.numberOfConnections = dictionary["numberOfConnections"] as? Int32
            self.ownerAccount = dictionary["ownerAccount"] as? String
            self.region = dictionary["region"] as? String
            self.minimumLinks = dictionary["minimumLinks"] as? Int32
            self.allowsHostedConnections = dictionary["allowsHostedConnections"] as? Bool
            self.connectionsBandwidth = dictionary["connectionsBandwidth"] as? String
            self.lagName = dictionary["lagName"] as? String
        }
    }

    public struct DeleteVirtualInterfaceResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let virtualInterfaceState: VirtualInterfaceState?

        public init(virtualInterfaceState: VirtualInterfaceState? = nil) {
            self.virtualInterfaceState = virtualInterfaceState
        }

        public init(dictionary: [String: Any]) throws {
            if let virtualInterfaceState = dictionary["virtualInterfaceState"] as? String { self.virtualInterfaceState = VirtualInterfaceState(rawValue: virtualInterfaceState) } else { self.virtualInterfaceState = nil }
        }
    }

    public struct AssociateVirtualInterfaceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the virtual interface. Example: dxvif-123dfg56 Default: None
        public let virtualInterfaceId: String
        /// The ID of the LAG or connection with which to associate the virtual interface. Example: dxlag-abc123 or dxcon-abc123 Default: None
        public let connectionId: String

        public init(virtualInterfaceId: String, connectionId: String) {
            self.virtualInterfaceId = virtualInterfaceId
            self.connectionId = connectionId
        }

        public init(dictionary: [String: Any]) throws {
            guard let virtualInterfaceId = dictionary["virtualInterfaceId"] as? String else { throw InitializableError.missingRequiredParam("virtualInterfaceId") }
            self.virtualInterfaceId = virtualInterfaceId
            guard let connectionId = dictionary["connectionId"] as? String else { throw InitializableError.missingRequiredParam("connectionId") }
            self.connectionId = connectionId
        }
    }

    public enum BGPPeerState: String, CustomStringConvertible {
        case verifying = "verifying"
        case pending = "pending"
        case available = "available"
        case deleting = "deleting"
        case deleted = "deleted"
        public var description: String { return self.rawValue }
    }

    public struct CreateBGPPeerResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let virtualInterface: VirtualInterface?

        public init(virtualInterface: VirtualInterface? = nil) {
            self.virtualInterface = virtualInterface
        }

        public init(dictionary: [String: Any]) throws {
            if let virtualInterface = dictionary["virtualInterface"] as? [String: Any] { self.virtualInterface = try Directconnect.VirtualInterface(dictionary: virtualInterface) } else { self.virtualInterface = nil }
        }
    }

    public struct DescribeLagsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the LAG. Example: dxlag-abc123 Default: None
        public let lagId: String?

        public init(lagId: String? = nil) {
            self.lagId = lagId
        }

        public init(dictionary: [String: Any]) throws {
            self.lagId = dictionary["lagId"] as? String
        }
    }

    public struct DescribeTagsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Amazon Resource Names (ARNs) of the Direct Connect resources.
        public let resourceArns: [String]

        public init(resourceArns: [String]) {
            self.resourceArns = resourceArns
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceArns = dictionary["resourceArns"] as? [String] else { throw InitializableError.missingRequiredParam("resourceArns") }
            self.resourceArns = resourceArns
        }
    }

    public struct DescribeConnectionLoaResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let loa: Loa?

        public init(loa: Loa? = nil) {
            self.loa = loa
        }

        public init(dictionary: [String: Any]) throws {
            if let loa = dictionary["loa"] as? [String: Any] { self.loa = try Directconnect.Loa(dictionary: loa) } else { self.loa = nil }
        }
    }

    public enum LagState: String, CustomStringConvertible {
        case requested = "requested"
        case pending = "pending"
        case available = "available"
        case down = "down"
        case deleting = "deleting"
        case deleted = "deleted"
        public var description: String { return self.rawValue }
    }

    public struct NewPublicVirtualInterfaceAllocation: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let customerAddress: String?
        public let virtualInterfaceName: String
        public let authKey: String?
        public let amazonAddress: String?
        public let asn: Int32
        public let addressFamily: AddressFamily?
        public let routeFilterPrefixes: [RouteFilterPrefix]?
        public let vlan: Int32

        public init(customerAddress: String? = nil, virtualInterfaceName: String, authKey: String? = nil, amazonAddress: String? = nil, asn: Int32, addressFamily: AddressFamily? = nil, routeFilterPrefixes: [RouteFilterPrefix]? = nil, vlan: Int32) {
            self.customerAddress = customerAddress
            self.virtualInterfaceName = virtualInterfaceName
            self.authKey = authKey
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.addressFamily = addressFamily
            self.routeFilterPrefixes = routeFilterPrefixes
            self.vlan = vlan
        }

        public init(dictionary: [String: Any]) throws {
            self.customerAddress = dictionary["customerAddress"] as? String
            guard let virtualInterfaceName = dictionary["virtualInterfaceName"] as? String else { throw InitializableError.missingRequiredParam("virtualInterfaceName") }
            self.virtualInterfaceName = virtualInterfaceName
            self.authKey = dictionary["authKey"] as? String
            self.amazonAddress = dictionary["amazonAddress"] as? String
            guard let asn = dictionary["asn"] as? Int32 else { throw InitializableError.missingRequiredParam("asn") }
            self.asn = asn
            if let addressFamily = dictionary["addressFamily"] as? String { self.addressFamily = AddressFamily(rawValue: addressFamily) } else { self.addressFamily = nil }
            if let routeFilterPrefixes = dictionary["routeFilterPrefixes"] as? [[String: Any]] {
                self.routeFilterPrefixes = try routeFilterPrefixes.map({ try RouteFilterPrefix(dictionary: $0) })
            } else { 
                self.routeFilterPrefixes = nil
            }
            guard let vlan = dictionary["vlan"] as? Int32 else { throw InitializableError.missingRequiredParam("vlan") }
            self.vlan = vlan
        }
    }

    public enum InterconnectState: String, CustomStringConvertible {
        case requested = "requested"
        case pending = "pending"
        case available = "available"
        case down = "down"
        case deleting = "deleting"
        case deleted = "deleted"
        public var description: String { return self.rawValue }
    }

    public struct Tag: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The key of the tag.
        public let key: String
        /// The value of the tag.
        public let value: String?

        public init(key: String, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public init(dictionary: [String: Any]) throws {
            guard let key = dictionary["key"] as? String else { throw InitializableError.missingRequiredParam("key") }
            self.key = key
            self.value = dictionary["value"] as? String
        }
    }

    public struct CreatePrivateVirtualInterfaceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let connectionId: String
        /// Detailed information for the private virtual interface to be created. Default: None
        public let newPrivateVirtualInterface: NewPrivateVirtualInterface

        public init(connectionId: String, newPrivateVirtualInterface: NewPrivateVirtualInterface) {
            self.connectionId = connectionId
            self.newPrivateVirtualInterface = newPrivateVirtualInterface
        }

        public init(dictionary: [String: Any]) throws {
            guard let connectionId = dictionary["connectionId"] as? String else { throw InitializableError.missingRequiredParam("connectionId") }
            self.connectionId = connectionId
            guard let newPrivateVirtualInterface = dictionary["newPrivateVirtualInterface"] as? [String: Any] else { throw InitializableError.missingRequiredParam("newPrivateVirtualInterface") }
            self.newPrivateVirtualInterface = try Directconnect.NewPrivateVirtualInterface(dictionary: newPrivateVirtualInterface)
        }
    }

    public struct AssociateHostedConnectionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the hosted connection. Example: dxcon-abc123 Default: None
        public let connectionId: String
        /// The ID of the interconnect or the LAG. Example: dxcon-abc123 or dxlag-abc123 Default: None
        public let parentConnectionId: String

        public init(connectionId: String, parentConnectionId: String) {
            self.connectionId = connectionId
            self.parentConnectionId = parentConnectionId
        }

        public init(dictionary: [String: Any]) throws {
            guard let connectionId = dictionary["connectionId"] as? String else { throw InitializableError.missingRequiredParam("connectionId") }
            self.connectionId = connectionId
            guard let parentConnectionId = dictionary["parentConnectionId"] as? String else { throw InitializableError.missingRequiredParam("parentConnectionId") }
            self.parentConnectionId = parentConnectionId
        }
    }

    public struct DeleteInterconnectRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let interconnectId: String

        public init(interconnectId: String) {
            self.interconnectId = interconnectId
        }

        public init(dictionary: [String: Any]) throws {
            guard let interconnectId = dictionary["interconnectId"] as? String else { throw InitializableError.missingRequiredParam("interconnectId") }
            self.interconnectId = interconnectId
        }
    }

    public struct DescribeInterconnectLoaRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the service provider who establishes connectivity on your behalf. If you supply this parameter, the LOA-CFA lists the provider name alongside your company name as the requester of the cross connect. Default: None
        public let providerName: String?
        public let loaContentType: LoaContentType?
        public let interconnectId: String

        public init(providerName: String? = nil, loaContentType: LoaContentType? = nil, interconnectId: String) {
            self.providerName = providerName
            self.loaContentType = loaContentType
            self.interconnectId = interconnectId
        }

        public init(dictionary: [String: Any]) throws {
            self.providerName = dictionary["providerName"] as? String
            if let loaContentType = dictionary["loaContentType"] as? String { self.loaContentType = LoaContentType(rawValue: loaContentType) } else { self.loaContentType = nil }
            guard let interconnectId = dictionary["interconnectId"] as? String else { throw InitializableError.missingRequiredParam("interconnectId") }
            self.interconnectId = interconnectId
        }
    }

    public struct NewPublicVirtualInterface: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let customerAddress: String?
        public let virtualInterfaceName: String
        public let authKey: String?
        public let amazonAddress: String?
        public let asn: Int32
        public let addressFamily: AddressFamily?
        public let routeFilterPrefixes: [RouteFilterPrefix]?
        public let vlan: Int32

        public init(customerAddress: String? = nil, virtualInterfaceName: String, authKey: String? = nil, amazonAddress: String? = nil, asn: Int32, addressFamily: AddressFamily? = nil, routeFilterPrefixes: [RouteFilterPrefix]? = nil, vlan: Int32) {
            self.customerAddress = customerAddress
            self.virtualInterfaceName = virtualInterfaceName
            self.authKey = authKey
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.addressFamily = addressFamily
            self.routeFilterPrefixes = routeFilterPrefixes
            self.vlan = vlan
        }

        public init(dictionary: [String: Any]) throws {
            self.customerAddress = dictionary["customerAddress"] as? String
            guard let virtualInterfaceName = dictionary["virtualInterfaceName"] as? String else { throw InitializableError.missingRequiredParam("virtualInterfaceName") }
            self.virtualInterfaceName = virtualInterfaceName
            self.authKey = dictionary["authKey"] as? String
            self.amazonAddress = dictionary["amazonAddress"] as? String
            guard let asn = dictionary["asn"] as? Int32 else { throw InitializableError.missingRequiredParam("asn") }
            self.asn = asn
            if let addressFamily = dictionary["addressFamily"] as? String { self.addressFamily = AddressFamily(rawValue: addressFamily) } else { self.addressFamily = nil }
            if let routeFilterPrefixes = dictionary["routeFilterPrefixes"] as? [[String: Any]] {
                self.routeFilterPrefixes = try routeFilterPrefixes.map({ try RouteFilterPrefix(dictionary: $0) })
            } else { 
                self.routeFilterPrefixes = nil
            }
            guard let vlan = dictionary["vlan"] as? Int32 else { throw InitializableError.missingRequiredParam("vlan") }
            self.vlan = vlan
        }
    }

    public struct Interconnects: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of interconnects.
        public let interconnects: [Interconnect]?

        public init(interconnects: [Interconnect]? = nil) {
            self.interconnects = interconnects
        }

        public init(dictionary: [String: Any]) throws {
            if let interconnects = dictionary["interconnects"] as? [[String: Any]] {
                self.interconnects = try interconnects.map({ try Interconnect(dictionary: $0) })
            } else { 
                self.interconnects = nil
            }
        }
    }

    public struct AllocatePrivateVirtualInterfaceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The connection ID on which the private virtual interface is provisioned. Default: None
        public let connectionId: String
        /// Detailed information for the private virtual interface to be provisioned. Default: None
        public let newPrivateVirtualInterfaceAllocation: NewPrivateVirtualInterfaceAllocation
        /// The AWS account that will own the new private virtual interface. Default: None
        public let ownerAccount: String

        public init(connectionId: String, newPrivateVirtualInterfaceAllocation: NewPrivateVirtualInterfaceAllocation, ownerAccount: String) {
            self.connectionId = connectionId
            self.newPrivateVirtualInterfaceAllocation = newPrivateVirtualInterfaceAllocation
            self.ownerAccount = ownerAccount
        }

        public init(dictionary: [String: Any]) throws {
            guard let connectionId = dictionary["connectionId"] as? String else { throw InitializableError.missingRequiredParam("connectionId") }
            self.connectionId = connectionId
            guard let newPrivateVirtualInterfaceAllocation = dictionary["newPrivateVirtualInterfaceAllocation"] as? [String: Any] else { throw InitializableError.missingRequiredParam("newPrivateVirtualInterfaceAllocation") }
            self.newPrivateVirtualInterfaceAllocation = try Directconnect.NewPrivateVirtualInterfaceAllocation(dictionary: newPrivateVirtualInterfaceAllocation)
            guard let ownerAccount = dictionary["ownerAccount"] as? String else { throw InitializableError.missingRequiredParam("ownerAccount") }
            self.ownerAccount = ownerAccount
        }
    }

    public struct DeleteLagRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the LAG to delete. Example: dxlag-abc123 Default: None
        public let lagId: String

        public init(lagId: String) {
            self.lagId = lagId
        }

        public init(dictionary: [String: Any]) throws {
            guard let lagId = dictionary["lagId"] as? String else { throw InitializableError.missingRequiredParam("lagId") }
            self.lagId = lagId
        }
    }

    public struct UpdateLagRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The minimum number of physical connections that must be operational for the LAG itself to be operational. Default: None
        public let minimumLinks: Int32?
        /// The ID of the LAG to update. Example: dxlag-abc123 Default: None
        public let lagId: String
        /// The name for the LAG. Example: "3x10G LAG to AWS" Default: None
        public let lagName: String?

        public init(minimumLinks: Int32? = nil, lagId: String, lagName: String? = nil) {
            self.minimumLinks = minimumLinks
            self.lagId = lagId
            self.lagName = lagName
        }

        public init(dictionary: [String: Any]) throws {
            self.minimumLinks = dictionary["minimumLinks"] as? Int32
            guard let lagId = dictionary["lagId"] as? String else { throw InitializableError.missingRequiredParam("lagId") }
            self.lagId = lagId
            self.lagName = dictionary["lagName"] as? String
        }
    }

    public struct NewPrivateVirtualInterface: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let customerAddress: String?
        public let virtualInterfaceName: String
        public let authKey: String?
        public let amazonAddress: String?
        public let asn: Int32
        public let addressFamily: AddressFamily?
        public let virtualGatewayId: String
        public let vlan: Int32

        public init(customerAddress: String? = nil, virtualInterfaceName: String, authKey: String? = nil, amazonAddress: String? = nil, asn: Int32, addressFamily: AddressFamily? = nil, virtualGatewayId: String, vlan: Int32) {
            self.customerAddress = customerAddress
            self.virtualInterfaceName = virtualInterfaceName
            self.authKey = authKey
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.addressFamily = addressFamily
            self.virtualGatewayId = virtualGatewayId
            self.vlan = vlan
        }

        public init(dictionary: [String: Any]) throws {
            self.customerAddress = dictionary["customerAddress"] as? String
            guard let virtualInterfaceName = dictionary["virtualInterfaceName"] as? String else { throw InitializableError.missingRequiredParam("virtualInterfaceName") }
            self.virtualInterfaceName = virtualInterfaceName
            self.authKey = dictionary["authKey"] as? String
            self.amazonAddress = dictionary["amazonAddress"] as? String
            guard let asn = dictionary["asn"] as? Int32 else { throw InitializableError.missingRequiredParam("asn") }
            self.asn = asn
            if let addressFamily = dictionary["addressFamily"] as? String { self.addressFamily = AddressFamily(rawValue: addressFamily) } else { self.addressFamily = nil }
            guard let virtualGatewayId = dictionary["virtualGatewayId"] as? String else { throw InitializableError.missingRequiredParam("virtualGatewayId") }
            self.virtualGatewayId = virtualGatewayId
            guard let vlan = dictionary["vlan"] as? Int32 else { throw InitializableError.missingRequiredParam("vlan") }
            self.vlan = vlan
        }
    }

    public struct DescribeHostedConnectionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the interconnect or LAG on which the hosted connections are provisioned. Example: dxcon-abc123 or dxlag-abc123 Default: None
        public let connectionId: String

        public init(connectionId: String) {
            self.connectionId = connectionId
        }

        public init(dictionary: [String: Any]) throws {
            guard let connectionId = dictionary["connectionId"] as? String else { throw InitializableError.missingRequiredParam("connectionId") }
            self.connectionId = connectionId
        }
    }

    public struct DeleteConnectionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let connectionId: String

        public init(connectionId: String) {
            self.connectionId = connectionId
        }

        public init(dictionary: [String: Any]) throws {
            guard let connectionId = dictionary["connectionId"] as? String else { throw InitializableError.missingRequiredParam("connectionId") }
            self.connectionId = connectionId
        }
    }

    public struct NewPrivateVirtualInterfaceAllocation: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let customerAddress: String?
        public let virtualInterfaceName: String
        public let authKey: String?
        public let amazonAddress: String?
        public let asn: Int32
        public let addressFamily: AddressFamily?
        public let vlan: Int32

        public init(customerAddress: String? = nil, virtualInterfaceName: String, authKey: String? = nil, amazonAddress: String? = nil, asn: Int32, addressFamily: AddressFamily? = nil, vlan: Int32) {
            self.customerAddress = customerAddress
            self.virtualInterfaceName = virtualInterfaceName
            self.authKey = authKey
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.addressFamily = addressFamily
            self.vlan = vlan
        }

        public init(dictionary: [String: Any]) throws {
            self.customerAddress = dictionary["customerAddress"] as? String
            guard let virtualInterfaceName = dictionary["virtualInterfaceName"] as? String else { throw InitializableError.missingRequiredParam("virtualInterfaceName") }
            self.virtualInterfaceName = virtualInterfaceName
            self.authKey = dictionary["authKey"] as? String
            self.amazonAddress = dictionary["amazonAddress"] as? String
            guard let asn = dictionary["asn"] as? Int32 else { throw InitializableError.missingRequiredParam("asn") }
            self.asn = asn
            if let addressFamily = dictionary["addressFamily"] as? String { self.addressFamily = AddressFamily(rawValue: addressFamily) } else { self.addressFamily = nil }
            guard let vlan = dictionary["vlan"] as? Int32 else { throw InitializableError.missingRequiredParam("vlan") }
            self.vlan = vlan
        }
    }

    public struct CreatePublicVirtualInterfaceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let connectionId: String
        /// Detailed information for the public virtual interface to be created. Default: None
        public let newPublicVirtualInterface: NewPublicVirtualInterface

        public init(connectionId: String, newPublicVirtualInterface: NewPublicVirtualInterface) {
            self.connectionId = connectionId
            self.newPublicVirtualInterface = newPublicVirtualInterface
        }

        public init(dictionary: [String: Any]) throws {
            guard let connectionId = dictionary["connectionId"] as? String else { throw InitializableError.missingRequiredParam("connectionId") }
            self.connectionId = connectionId
            guard let newPublicVirtualInterface = dictionary["newPublicVirtualInterface"] as? [String: Any] else { throw InitializableError.missingRequiredParam("newPublicVirtualInterface") }
            self.newPublicVirtualInterface = try Directconnect.NewPublicVirtualInterface(dictionary: newPublicVirtualInterface)
        }
    }

    public enum VirtualInterfaceState: String, CustomStringConvertible {
        case confirming = "confirming"
        case verifying = "verifying"
        case pending = "pending"
        case available = "available"
        case down = "down"
        case deleting = "deleting"
        case deleted = "deleted"
        case rejected = "rejected"
        public var description: String { return self.rawValue }
    }

    public struct DescribeInterconnectsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let interconnectId: String?

        public init(interconnectId: String? = nil) {
            self.interconnectId = interconnectId
        }

        public init(dictionary: [String: Any]) throws {
            self.interconnectId = dictionary["interconnectId"] as? String
        }
    }

    public struct ResourceTag: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Amazon Resource Name (ARN) of the Direct Connect resource.
        public let resourceArn: String?
        /// The tags.
        public let tags: [Tag]?

        public init(resourceArn: String? = nil, tags: [Tag]? = nil) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public init(dictionary: [String: Any]) throws {
            self.resourceArn = dictionary["resourceArn"] as? String
            if let tags = dictionary["tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            } else { 
                self.tags = nil
            }
        }
    }

    public struct ConfirmConnectionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let connectionId: String

        public init(connectionId: String) {
            self.connectionId = connectionId
        }

        public init(dictionary: [String: Any]) throws {
            guard let connectionId = dictionary["connectionId"] as? String else { throw InitializableError.missingRequiredParam("connectionId") }
            self.connectionId = connectionId
        }
    }

    public struct AssociateConnectionWithLagRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the connection. Example: dxcon-abc123 Default: None
        public let connectionId: String
        /// The ID of the LAG with which to associate the connection. Example: dxlag-abc123 Default: None
        public let lagId: String

        public init(connectionId: String, lagId: String) {
            self.connectionId = connectionId
            self.lagId = lagId
        }

        public init(dictionary: [String: Any]) throws {
            guard let connectionId = dictionary["connectionId"] as? String else { throw InitializableError.missingRequiredParam("connectionId") }
            self.connectionId = connectionId
            guard let lagId = dictionary["lagId"] as? String else { throw InitializableError.missingRequiredParam("lagId") }
            self.lagId = lagId
        }
    }

    public enum AddressFamily: String, CustomStringConvertible {
        case ipv4 = "ipv4"
        case ipv6 = "ipv6"
        public var description: String { return self.rawValue }
    }

    public struct AllocatePublicVirtualInterfaceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Detailed information for the public virtual interface to be provisioned. Default: None
        public let newPublicVirtualInterfaceAllocation: NewPublicVirtualInterfaceAllocation
        /// The connection ID on which the public virtual interface is provisioned. Default: None
        public let connectionId: String
        /// The AWS account that will own the new public virtual interface. Default: None
        public let ownerAccount: String

        public init(newPublicVirtualInterfaceAllocation: NewPublicVirtualInterfaceAllocation, connectionId: String, ownerAccount: String) {
            self.newPublicVirtualInterfaceAllocation = newPublicVirtualInterfaceAllocation
            self.connectionId = connectionId
            self.ownerAccount = ownerAccount
        }

        public init(dictionary: [String: Any]) throws {
            guard let newPublicVirtualInterfaceAllocation = dictionary["newPublicVirtualInterfaceAllocation"] as? [String: Any] else { throw InitializableError.missingRequiredParam("newPublicVirtualInterfaceAllocation") }
            self.newPublicVirtualInterfaceAllocation = try Directconnect.NewPublicVirtualInterfaceAllocation(dictionary: newPublicVirtualInterfaceAllocation)
            guard let connectionId = dictionary["connectionId"] as? String else { throw InitializableError.missingRequiredParam("connectionId") }
            self.connectionId = connectionId
            guard let ownerAccount = dictionary["ownerAccount"] as? String else { throw InitializableError.missingRequiredParam("ownerAccount") }
            self.ownerAccount = ownerAccount
        }
    }

    public struct ConfirmPublicVirtualInterfaceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let virtualInterfaceId: String

        public init(virtualInterfaceId: String) {
            self.virtualInterfaceId = virtualInterfaceId
        }

        public init(dictionary: [String: Any]) throws {
            guard let virtualInterfaceId = dictionary["virtualInterfaceId"] as? String else { throw InitializableError.missingRequiredParam("virtualInterfaceId") }
            self.virtualInterfaceId = virtualInterfaceId
        }
    }

    public struct CreateInterconnectRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Where the interconnect is located Example: EqSV5 Default: None
        public let location: String
        public let lagId: String?
        /// The name of the interconnect. Example: "1G Interconnect to AWS" Default: None
        public let interconnectName: String
        /// The port bandwidth Example: 1Gbps Default: None Available values: 1Gbps,10Gbps
        public let bandwidth: String

        public init(location: String, lagId: String? = nil, interconnectName: String, bandwidth: String) {
            self.location = location
            self.lagId = lagId
            self.interconnectName = interconnectName
            self.bandwidth = bandwidth
        }

        public init(dictionary: [String: Any]) throws {
            guard let location = dictionary["location"] as? String else { throw InitializableError.missingRequiredParam("location") }
            self.location = location
            self.lagId = dictionary["lagId"] as? String
            guard let interconnectName = dictionary["interconnectName"] as? String else { throw InitializableError.missingRequiredParam("interconnectName") }
            self.interconnectName = interconnectName
            guard let bandwidth = dictionary["bandwidth"] as? String else { throw InitializableError.missingRequiredParam("bandwidth") }
            self.bandwidth = bandwidth
        }
    }

    public struct Connections: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of connections.
        public let connections: [Connection]?

        public init(connections: [Connection]? = nil) {
            self.connections = connections
        }

        public init(dictionary: [String: Any]) throws {
            if let connections = dictionary["connections"] as? [[String: Any]] {
                self.connections = try connections.map({ try Connection(dictionary: $0) })
            } else { 
                self.connections = nil
            }
        }
    }

    public struct DescribeInterconnectLoaResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let loa: Loa?

        public init(loa: Loa? = nil) {
            self.loa = loa
        }

        public init(dictionary: [String: Any]) throws {
            if let loa = dictionary["loa"] as? [String: Any] { self.loa = try Directconnect.Loa(dictionary: loa) } else { self.loa = nil }
        }
    }

    public struct Connection: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The time of the most recent call to DescribeLoa for this connection.
        public let loaIssueTime: Date?
        /// Bandwidth of the connection. Example: 1Gbps (for regular connections), or 500Mbps (for hosted connections) Default: None
        public let bandwidth: String?
        public let location: String?
        public let lagId: String?
        /// The Direct Connection endpoint which the physical connection terminates on.
        public let awsDevice: String?
        public let connectionId: String?
        public let region: String?
        /// The AWS account that will own the new connection.
        public let ownerAccount: String?
        public let connectionState: ConnectionState?
        public let connectionName: String?
        public let vlan: Int32?
        /// The name of the AWS Direct Connect service provider associated with the connection.
        public let partnerName: String?

        public init(loaIssueTime: Date? = nil, bandwidth: String? = nil, location: String? = nil, lagId: String? = nil, awsDevice: String? = nil, connectionId: String? = nil, region: String? = nil, ownerAccount: String? = nil, connectionState: ConnectionState? = nil, connectionName: String? = nil, vlan: Int32? = nil, partnerName: String? = nil) {
            self.loaIssueTime = loaIssueTime
            self.bandwidth = bandwidth
            self.location = location
            self.lagId = lagId
            self.awsDevice = awsDevice
            self.connectionId = connectionId
            self.region = region
            self.ownerAccount = ownerAccount
            self.connectionState = connectionState
            self.connectionName = connectionName
            self.vlan = vlan
            self.partnerName = partnerName
        }

        public init(dictionary: [String: Any]) throws {
            self.loaIssueTime = dictionary["loaIssueTime"] as? Date
            self.bandwidth = dictionary["bandwidth"] as? String
            self.location = dictionary["location"] as? String
            self.lagId = dictionary["lagId"] as? String
            self.awsDevice = dictionary["awsDevice"] as? String
            self.connectionId = dictionary["connectionId"] as? String
            self.region = dictionary["region"] as? String
            self.ownerAccount = dictionary["ownerAccount"] as? String
            if let connectionState = dictionary["connectionState"] as? String { self.connectionState = ConnectionState(rawValue: connectionState) } else { self.connectionState = nil }
            self.connectionName = dictionary["connectionName"] as? String
            self.vlan = dictionary["vlan"] as? Int32
            self.partnerName = dictionary["partnerName"] as? String
        }
    }

    public struct DescribeConnectionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let connectionId: String?

        public init(connectionId: String? = nil) {
            self.connectionId = connectionId
        }

        public init(dictionary: [String: Any]) throws {
            self.connectionId = dictionary["connectionId"] as? String
        }
    }

    public struct Lags: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of LAGs.
        public let lags: [Lag]?

        public init(lags: [Lag]? = nil) {
            self.lags = lags
        }

        public init(dictionary: [String: Any]) throws {
            if let lags = dictionary["lags"] as? [[String: Any]] {
                self.lags = try lags.map({ try Lag(dictionary: $0) })
            } else { 
                self.lags = nil
            }
        }
    }

    public struct DeleteInterconnectResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let interconnectState: InterconnectState?

        public init(interconnectState: InterconnectState? = nil) {
            self.interconnectState = interconnectState
        }

        public init(dictionary: [String: Any]) throws {
            if let interconnectState = dictionary["interconnectState"] as? String { self.interconnectState = InterconnectState(rawValue: interconnectState) } else { self.interconnectState = nil }
        }
    }

    public struct TagResourceResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct BGPPeer: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let bgpPeerState: BGPPeerState?
        public let customerAddress: String?
        public let bgpStatus: BGPStatus?
        public let authKey: String?
        public let amazonAddress: String?
        public let asn: Int32?
        public let addressFamily: AddressFamily?

        public init(bgpPeerState: BGPPeerState? = nil, customerAddress: String? = nil, bgpStatus: BGPStatus? = nil, authKey: String? = nil, amazonAddress: String? = nil, asn: Int32? = nil, addressFamily: AddressFamily? = nil) {
            self.bgpPeerState = bgpPeerState
            self.customerAddress = customerAddress
            self.bgpStatus = bgpStatus
            self.authKey = authKey
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.addressFamily = addressFamily
        }

        public init(dictionary: [String: Any]) throws {
            if let bgpPeerState = dictionary["bgpPeerState"] as? String { self.bgpPeerState = BGPPeerState(rawValue: bgpPeerState) } else { self.bgpPeerState = nil }
            self.customerAddress = dictionary["customerAddress"] as? String
            if let bgpStatus = dictionary["bgpStatus"] as? String { self.bgpStatus = BGPStatus(rawValue: bgpStatus) } else { self.bgpStatus = nil }
            self.authKey = dictionary["authKey"] as? String
            self.amazonAddress = dictionary["amazonAddress"] as? String
            self.asn = dictionary["asn"] as? Int32
            if let addressFamily = dictionary["addressFamily"] as? String { self.addressFamily = AddressFamily(rawValue: addressFamily) } else { self.addressFamily = nil }
        }
    }

    public struct DisassociateConnectionFromLagRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the connection to disassociate from the LAG. Example: dxcon-abc123 Default: None
        public let connectionId: String
        /// The ID of the LAG. Example: dxlag-abc123 Default: None
        public let lagId: String

        public init(connectionId: String, lagId: String) {
            self.connectionId = connectionId
            self.lagId = lagId
        }

        public init(dictionary: [String: Any]) throws {
            guard let connectionId = dictionary["connectionId"] as? String else { throw InitializableError.missingRequiredParam("connectionId") }
            self.connectionId = connectionId
            guard let lagId = dictionary["lagId"] as? String else { throw InitializableError.missingRequiredParam("lagId") }
            self.lagId = lagId
        }
    }

    public struct CreateBGPPeerRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the virtual interface on which the BGP peer will be provisioned. Example: dxvif-456abc78 Default: None
        public let virtualInterfaceId: String?
        /// Detailed information for the BGP peer to be created. Default: None
        public let newBGPPeer: NewBGPPeer?

        public init(virtualInterfaceId: String? = nil, newBGPPeer: NewBGPPeer? = nil) {
            self.virtualInterfaceId = virtualInterfaceId
            self.newBGPPeer = newBGPPeer
        }

        public init(dictionary: [String: Any]) throws {
            self.virtualInterfaceId = dictionary["virtualInterfaceId"] as? String
            if let newBGPPeer = dictionary["newBGPPeer"] as? [String: Any] { self.newBGPPeer = try Directconnect.NewBGPPeer(dictionary: newBGPPeer) } else { self.newBGPPeer = nil }
        }
    }

    public enum ConnectionState: String, CustomStringConvertible {
        case ordering = "ordering"
        case requested = "requested"
        case pending = "pending"
        case available = "available"
        case down = "down"
        case deleting = "deleting"
        case deleted = "deleted"
        case rejected = "rejected"
        public var description: String { return self.rawValue }
    }

    public struct ConfirmPrivateVirtualInterfaceResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let virtualInterfaceState: VirtualInterfaceState?

        public init(virtualInterfaceState: VirtualInterfaceState? = nil) {
            self.virtualInterfaceState = virtualInterfaceState
        }

        public init(dictionary: [String: Any]) throws {
            if let virtualInterfaceState = dictionary["virtualInterfaceState"] as? String { self.virtualInterfaceState = VirtualInterfaceState(rawValue: virtualInterfaceState) } else { self.virtualInterfaceState = nil }
        }
    }

    public struct DeleteBGPPeerResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let virtualInterface: VirtualInterface?

        public init(virtualInterface: VirtualInterface? = nil) {
            self.virtualInterface = virtualInterface
        }

        public init(dictionary: [String: Any]) throws {
            if let virtualInterface = dictionary["virtualInterface"] as? [String: Any] { self.virtualInterface = try Directconnect.VirtualInterface(dictionary: virtualInterface) } else { self.virtualInterface = nil }
        }
    }

    public struct DescribeVirtualInterfacesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let virtualInterfaceId: String?
        public let connectionId: String?

        public init(virtualInterfaceId: String? = nil, connectionId: String? = nil) {
            self.virtualInterfaceId = virtualInterfaceId
            self.connectionId = connectionId
        }

        public init(dictionary: [String: Any]) throws {
            self.virtualInterfaceId = dictionary["virtualInterfaceId"] as? String
            self.connectionId = dictionary["connectionId"] as? String
        }
    }

    public struct DescribeLoaRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the service provider who establishes connectivity on your behalf. If you supply this parameter, the LOA-CFA lists the provider name alongside your company name as the requester of the cross connect. Default: None
        public let providerName: String?
        /// The ID of a connection, LAG, or interconnect for which to get the LOA-CFA information. Example: dxcon-abc123 or dxlag-abc123 Default: None
        public let connectionId: String
        /// A standard media type indicating the content type of the LOA-CFA document. Currently, the only supported value is "application/pdf". Default: application/pdf
        public let loaContentType: LoaContentType?

        public init(providerName: String? = nil, connectionId: String, loaContentType: LoaContentType? = nil) {
            self.providerName = providerName
            self.connectionId = connectionId
            self.loaContentType = loaContentType
        }

        public init(dictionary: [String: Any]) throws {
            self.providerName = dictionary["providerName"] as? String
            guard let connectionId = dictionary["connectionId"] as? String else { throw InitializableError.missingRequiredParam("connectionId") }
            self.connectionId = connectionId
            if let loaContentType = dictionary["loaContentType"] as? String { self.loaContentType = LoaContentType(rawValue: loaContentType) } else { self.loaContentType = nil }
        }
    }

    public struct DeleteBGPPeerRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the virtual interface from which the BGP peer will be deleted. Example: dxvif-456abc78 Default: None
        public let virtualInterfaceId: String?
        public let asn: Int32?
        public let customerAddress: String?

        public init(virtualInterfaceId: String? = nil, asn: Int32? = nil, customerAddress: String? = nil) {
            self.virtualInterfaceId = virtualInterfaceId
            self.asn = asn
            self.customerAddress = customerAddress
        }

        public init(dictionary: [String: Any]) throws {
            self.virtualInterfaceId = dictionary["virtualInterfaceId"] as? String
            self.asn = dictionary["asn"] as? Int32
            self.customerAddress = dictionary["customerAddress"] as? String
        }
    }

    public struct Interconnect: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The time of the most recent call to DescribeInterconnectLoa for this Interconnect.
        public let loaIssueTime: Date?
        public let interconnectState: InterconnectState?
        public let location: String?
        /// The Direct Connection endpoint which the physical connection terminates on.
        public let awsDevice: String?
        public let lagId: String?
        public let region: String?
        public let interconnectName: String?
        public let interconnectId: String?
        public let bandwidth: String?

        public init(loaIssueTime: Date? = nil, interconnectState: InterconnectState? = nil, location: String? = nil, awsDevice: String? = nil, lagId: String? = nil, region: String? = nil, interconnectName: String? = nil, interconnectId: String? = nil, bandwidth: String? = nil) {
            self.loaIssueTime = loaIssueTime
            self.interconnectState = interconnectState
            self.location = location
            self.awsDevice = awsDevice
            self.lagId = lagId
            self.region = region
            self.interconnectName = interconnectName
            self.interconnectId = interconnectId
            self.bandwidth = bandwidth
        }

        public init(dictionary: [String: Any]) throws {
            self.loaIssueTime = dictionary["loaIssueTime"] as? Date
            if let interconnectState = dictionary["interconnectState"] as? String { self.interconnectState = InterconnectState(rawValue: interconnectState) } else { self.interconnectState = nil }
            self.location = dictionary["location"] as? String
            self.awsDevice = dictionary["awsDevice"] as? String
            self.lagId = dictionary["lagId"] as? String
            self.region = dictionary["region"] as? String
            self.interconnectName = dictionary["interconnectName"] as? String
            self.interconnectId = dictionary["interconnectId"] as? String
            self.bandwidth = dictionary["bandwidth"] as? String
        }
    }

    public struct AllocateConnectionOnInterconnectRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Bandwidth of the connection. Example: "500Mbps" Default: None Values: 50Mbps, 100Mbps, 200Mbps, 300Mbps, 400Mbps, or 500Mbps
        public let bandwidth: String
        /// Name of the provisioned connection. Example: "500M Connection to AWS" Default: None
        public let connectionName: String
        /// ID of the interconnect on which the connection will be provisioned. Example: dxcon-456abc78 Default: None
        public let interconnectId: String
        /// The dedicated VLAN provisioned to the connection. Example: 101 Default: None
        public let vlan: Int32
        /// Numeric account Id of the customer for whom the connection will be provisioned. Example: 123443215678 Default: None
        public let ownerAccount: String

        public init(bandwidth: String, connectionName: String, interconnectId: String, vlan: Int32, ownerAccount: String) {
            self.bandwidth = bandwidth
            self.connectionName = connectionName
            self.interconnectId = interconnectId
            self.vlan = vlan
            self.ownerAccount = ownerAccount
        }

        public init(dictionary: [String: Any]) throws {
            guard let bandwidth = dictionary["bandwidth"] as? String else { throw InitializableError.missingRequiredParam("bandwidth") }
            self.bandwidth = bandwidth
            guard let connectionName = dictionary["connectionName"] as? String else { throw InitializableError.missingRequiredParam("connectionName") }
            self.connectionName = connectionName
            guard let interconnectId = dictionary["interconnectId"] as? String else { throw InitializableError.missingRequiredParam("interconnectId") }
            self.interconnectId = interconnectId
            guard let vlan = dictionary["vlan"] as? Int32 else { throw InitializableError.missingRequiredParam("vlan") }
            self.vlan = vlan
            guard let ownerAccount = dictionary["ownerAccount"] as? String else { throw InitializableError.missingRequiredParam("ownerAccount") }
            self.ownerAccount = ownerAccount
        }
    }

    public struct DescribeConnectionsOnInterconnectRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// ID of the interconnect on which a list of connection is provisioned. Example: dxcon-abc123 Default: None
        public let interconnectId: String

        public init(interconnectId: String) {
            self.interconnectId = interconnectId
        }

        public init(dictionary: [String: Any]) throws {
            guard let interconnectId = dictionary["interconnectId"] as? String else { throw InitializableError.missingRequiredParam("interconnectId") }
            self.interconnectId = interconnectId
        }
    }

    public enum LoaContentType: String, CustomStringConvertible {
        case application_pdf = "application/pdf"
        public var description: String { return self.rawValue }
    }

    public struct VirtualInterfaces: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of virtual interfaces.
        public let virtualInterfaces: [VirtualInterface]?

        public init(virtualInterfaces: [VirtualInterface]? = nil) {
            self.virtualInterfaces = virtualInterfaces
        }

        public init(dictionary: [String: Any]) throws {
            if let virtualInterfaces = dictionary["virtualInterfaces"] as? [[String: Any]] {
                self.virtualInterfaces = try virtualInterfaces.map({ try VirtualInterface(dictionary: $0) })
            } else { 
                self.virtualInterfaces = nil
            }
        }
    }

    public enum BGPStatus: String, CustomStringConvertible {
        case up = "up"
        case down = "down"
        public var description: String { return self.rawValue }
    }

    public struct UntagResourceResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct Location: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The code used to indicate the AWS Direct Connect location.
        public let locationCode: String?
        /// The name of the AWS Direct Connect location. The name includes the colocation partner name and the physical site of the lit building.
        public let locationName: String?

        public init(locationCode: String? = nil, locationName: String? = nil) {
            self.locationCode = locationCode
            self.locationName = locationName
        }

        public init(dictionary: [String: Any]) throws {
            self.locationCode = dictionary["locationCode"] as? String
            self.locationName = dictionary["locationName"] as? String
        }
    }

    public struct Loa: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let loaContentType: LoaContentType?
        public let loaContent: Data?

        public init(loaContentType: LoaContentType? = nil, loaContent: Data? = nil) {
            self.loaContentType = loaContentType
            self.loaContent = loaContent
        }

        public init(dictionary: [String: Any]) throws {
            if let loaContentType = dictionary["loaContentType"] as? String { self.loaContentType = LoaContentType(rawValue: loaContentType) } else { self.loaContentType = nil }
            self.loaContent = dictionary["loaContent"] as? Data
        }
    }

    public struct VirtualInterface: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let customerAddress: String?
        public let virtualInterfaceType: String?
        public let connectionId: String?
        /// The AWS account that will own the new virtual interface.
        public let ownerAccount: String?
        public let asn: Int32?
        public let addressFamily: AddressFamily?
        public let routeFilterPrefixes: [RouteFilterPrefix]?
        public let location: String?
        public let virtualInterfaceName: String?
        public let authKey: String?
        public let amazonAddress: String?
        /// Information for generating the customer router configuration.
        public let customerRouterConfig: String?
        public let bgpPeers: [BGPPeer]?
        public let virtualGatewayId: String?
        public let virtualInterfaceId: String?
        public let virtualInterfaceState: VirtualInterfaceState?
        public let vlan: Int32?

        public init(customerAddress: String? = nil, virtualInterfaceType: String? = nil, connectionId: String? = nil, ownerAccount: String? = nil, asn: Int32? = nil, addressFamily: AddressFamily? = nil, routeFilterPrefixes: [RouteFilterPrefix]? = nil, location: String? = nil, virtualInterfaceName: String? = nil, authKey: String? = nil, amazonAddress: String? = nil, customerRouterConfig: String? = nil, bgpPeers: [BGPPeer]? = nil, virtualGatewayId: String? = nil, virtualInterfaceId: String? = nil, virtualInterfaceState: VirtualInterfaceState? = nil, vlan: Int32? = nil) {
            self.customerAddress = customerAddress
            self.virtualInterfaceType = virtualInterfaceType
            self.connectionId = connectionId
            self.ownerAccount = ownerAccount
            self.asn = asn
            self.addressFamily = addressFamily
            self.routeFilterPrefixes = routeFilterPrefixes
            self.location = location
            self.virtualInterfaceName = virtualInterfaceName
            self.authKey = authKey
            self.amazonAddress = amazonAddress
            self.customerRouterConfig = customerRouterConfig
            self.bgpPeers = bgpPeers
            self.virtualGatewayId = virtualGatewayId
            self.virtualInterfaceId = virtualInterfaceId
            self.virtualInterfaceState = virtualInterfaceState
            self.vlan = vlan
        }

        public init(dictionary: [String: Any]) throws {
            self.customerAddress = dictionary["customerAddress"] as? String
            self.virtualInterfaceType = dictionary["virtualInterfaceType"] as? String
            self.connectionId = dictionary["connectionId"] as? String
            self.ownerAccount = dictionary["ownerAccount"] as? String
            self.asn = dictionary["asn"] as? Int32
            if let addressFamily = dictionary["addressFamily"] as? String { self.addressFamily = AddressFamily(rawValue: addressFamily) } else { self.addressFamily = nil }
            if let routeFilterPrefixes = dictionary["routeFilterPrefixes"] as? [[String: Any]] {
                self.routeFilterPrefixes = try routeFilterPrefixes.map({ try RouteFilterPrefix(dictionary: $0) })
            } else { 
                self.routeFilterPrefixes = nil
            }
            self.location = dictionary["location"] as? String
            self.virtualInterfaceName = dictionary["virtualInterfaceName"] as? String
            self.authKey = dictionary["authKey"] as? String
            self.amazonAddress = dictionary["amazonAddress"] as? String
            self.customerRouterConfig = dictionary["customerRouterConfig"] as? String
            if let bgpPeers = dictionary["bgpPeers"] as? [[String: Any]] {
                self.bgpPeers = try bgpPeers.map({ try BGPPeer(dictionary: $0) })
            } else { 
                self.bgpPeers = nil
            }
            self.virtualGatewayId = dictionary["virtualGatewayId"] as? String
            self.virtualInterfaceId = dictionary["virtualInterfaceId"] as? String
            if let virtualInterfaceState = dictionary["virtualInterfaceState"] as? String { self.virtualInterfaceState = VirtualInterfaceState(rawValue: virtualInterfaceState) } else { self.virtualInterfaceState = nil }
            self.vlan = dictionary["vlan"] as? Int32
        }
    }

    public struct ConfirmPublicVirtualInterfaceResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let virtualInterfaceState: VirtualInterfaceState?

        public init(virtualInterfaceState: VirtualInterfaceState? = nil) {
            self.virtualInterfaceState = virtualInterfaceState
        }

        public init(dictionary: [String: Any]) throws {
            if let virtualInterfaceState = dictionary["virtualInterfaceState"] as? String { self.virtualInterfaceState = VirtualInterfaceState(rawValue: virtualInterfaceState) } else { self.virtualInterfaceState = nil }
        }
    }

    public struct Locations: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of colocation hubs where network providers have equipment. Most regions have multiple locations available.
        public let locations: [Location]?

        public init(locations: [Location]? = nil) {
            self.locations = locations
        }

        public init(dictionary: [String: Any]) throws {
            if let locations = dictionary["locations"] as? [[String: Any]] {
                self.locations = try locations.map({ try Location(dictionary: $0) })
            } else { 
                self.locations = nil
            }
        }
    }

    public struct CreateConnectionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let connectionName: String
        public let location: String
        public let lagId: String?
        public let bandwidth: String

        public init(connectionName: String, location: String, lagId: String? = nil, bandwidth: String) {
            self.connectionName = connectionName
            self.location = location
            self.lagId = lagId
            self.bandwidth = bandwidth
        }

        public init(dictionary: [String: Any]) throws {
            guard let connectionName = dictionary["connectionName"] as? String else { throw InitializableError.missingRequiredParam("connectionName") }
            self.connectionName = connectionName
            guard let location = dictionary["location"] as? String else { throw InitializableError.missingRequiredParam("location") }
            self.location = location
            self.lagId = dictionary["lagId"] as? String
            guard let bandwidth = dictionary["bandwidth"] as? String else { throw InitializableError.missingRequiredParam("bandwidth") }
            self.bandwidth = bandwidth
        }
    }

    public struct DescribeConnectionLoaRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the APN partner or service provider who establishes connectivity on your behalf. If you supply this parameter, the LOA-CFA lists the provider name alongside your company name as the requester of the cross connect. Default: None
        public let providerName: String?
        public let connectionId: String
        public let loaContentType: LoaContentType?

        public init(providerName: String? = nil, connectionId: String, loaContentType: LoaContentType? = nil) {
            self.providerName = providerName
            self.connectionId = connectionId
            self.loaContentType = loaContentType
        }

        public init(dictionary: [String: Any]) throws {
            self.providerName = dictionary["providerName"] as? String
            guard let connectionId = dictionary["connectionId"] as? String else { throw InitializableError.missingRequiredParam("connectionId") }
            self.connectionId = connectionId
            if let loaContentType = dictionary["loaContentType"] as? String { self.loaContentType = LoaContentType(rawValue: loaContentType) } else { self.loaContentType = nil }
        }
    }

    public struct ConfirmPrivateVirtualInterfaceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let virtualInterfaceId: String
        /// ID of the virtual private gateway that will be attached to the virtual interface.  A virtual private gateway can be managed via the Amazon Virtual Private Cloud (VPC) console or the EC2 CreateVpnGateway action. Default: None
        public let virtualGatewayId: String

        public init(virtualInterfaceId: String, virtualGatewayId: String) {
            self.virtualInterfaceId = virtualInterfaceId
            self.virtualGatewayId = virtualGatewayId
        }

        public init(dictionary: [String: Any]) throws {
            guard let virtualInterfaceId = dictionary["virtualInterfaceId"] as? String else { throw InitializableError.missingRequiredParam("virtualInterfaceId") }
            self.virtualInterfaceId = virtualInterfaceId
            guard let virtualGatewayId = dictionary["virtualGatewayId"] as? String else { throw InitializableError.missingRequiredParam("virtualGatewayId") }
            self.virtualGatewayId = virtualGatewayId
        }
    }

    public struct NewBGPPeer: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let amazonAddress: String?
        public let customerAddress: String?
        public let addressFamily: AddressFamily?
        public let asn: Int32?
        public let authKey: String?

        public init(amazonAddress: String? = nil, customerAddress: String? = nil, addressFamily: AddressFamily? = nil, asn: Int32? = nil, authKey: String? = nil) {
            self.amazonAddress = amazonAddress
            self.customerAddress = customerAddress
            self.addressFamily = addressFamily
            self.asn = asn
            self.authKey = authKey
        }

        public init(dictionary: [String: Any]) throws {
            self.amazonAddress = dictionary["amazonAddress"] as? String
            self.customerAddress = dictionary["customerAddress"] as? String
            if let addressFamily = dictionary["addressFamily"] as? String { self.addressFamily = AddressFamily(rawValue: addressFamily) } else { self.addressFamily = nil }
            self.asn = dictionary["asn"] as? Int32
            self.authKey = dictionary["authKey"] as? String
        }
    }

    public struct ConfirmConnectionResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let connectionState: ConnectionState?

        public init(connectionState: ConnectionState? = nil) {
            self.connectionState = connectionState
        }

        public init(dictionary: [String: Any]) throws {
            if let connectionState = dictionary["connectionState"] as? String { self.connectionState = ConnectionState(rawValue: connectionState) } else { self.connectionState = nil }
        }
    }

    public struct RouteFilterPrefix: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// CIDR notation for the advertised route. Multiple routes are separated by commas. IPv6 CIDRs must be at least a /64 or shorter Example: 10.10.10.0/24,10.10.11.0/24,2001:db8::/64
        public let cidr: String?

        public init(cidr: String? = nil) {
            self.cidr = cidr
        }

        public init(dictionary: [String: Any]) throws {
            self.cidr = dictionary["cidr"] as? String
        }
    }

    public struct DeleteVirtualInterfaceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let virtualInterfaceId: String

        public init(virtualInterfaceId: String) {
            self.virtualInterfaceId = virtualInterfaceId
        }

        public init(dictionary: [String: Any]) throws {
            guard let virtualInterfaceId = dictionary["virtualInterfaceId"] as? String else { throw InitializableError.missingRequiredParam("virtualInterfaceId") }
            self.virtualInterfaceId = virtualInterfaceId
        }
    }

    public struct UntagResourceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Amazon Resource Name (ARN) of the Direct Connect resource.
        public let resourceArn: String
        /// The list of tag keys to remove.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceArn = dictionary["resourceArn"] as? String else { throw InitializableError.missingRequiredParam("resourceArn") }
            self.resourceArn = resourceArn
            guard let tagKeys = dictionary["tagKeys"] as? [String] else { throw InitializableError.missingRequiredParam("tagKeys") }
            self.tagKeys = tagKeys
        }
    }

    public struct VirtualGateway: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let virtualGatewayState: String?
        public let virtualGatewayId: String?

        public init(virtualGatewayState: String? = nil, virtualGatewayId: String? = nil) {
            self.virtualGatewayState = virtualGatewayState
            self.virtualGatewayId = virtualGatewayId
        }

        public init(dictionary: [String: Any]) throws {
            self.virtualGatewayState = dictionary["virtualGatewayState"] as? String
            self.virtualGatewayId = dictionary["virtualGatewayId"] as? String
        }
    }

}