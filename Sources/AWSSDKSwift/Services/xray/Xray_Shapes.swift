// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Xray {

    public struct BatchGetTracesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Pagination token. Not used.
        public let nextToken: String?
        /// Full traces for the specified requests.
        public let traces: [Trace]?
        /// Trace IDs of requests that haven't been processed.
        public let unprocessedTraceIds: [String]?

        public init(nextToken: String? = nil, traces: [Trace]? = nil, unprocessedTraceIds: [String]? = nil) {
            self.nextToken = nextToken
            self.traces = traces
            self.unprocessedTraceIds = unprocessedTraceIds
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let traces = dictionary["Traces"] as? [[String: Any]] {
                self.traces = try traces.map({ try Trace(dictionary: $0) })
            } else { 
                self.traces = nil
            }
            self.unprocessedTraceIds = dictionary["UnprocessedTraceIds"] as? [String]
        }
    }

    public struct EdgeStatistics: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The aggregate response time of completed requests.
        public let totalResponseTime: Double?
        /// Information about requests that failed with a 5xx Server Error status code.
        public let faultStatistics: FaultStatistics?
        /// The number of requests that completed with a 2xx Success status code.
        public let okCount: Int64?
        /// Information about requests that failed with a 4xx Client Error status code.
        public let errorStatistics: ErrorStatistics?
        /// The total number of completed requests.
        public let totalCount: Int64?

        public init(totalResponseTime: Double? = nil, faultStatistics: FaultStatistics? = nil, okCount: Int64? = nil, errorStatistics: ErrorStatistics? = nil, totalCount: Int64? = nil) {
            self.totalResponseTime = totalResponseTime
            self.faultStatistics = faultStatistics
            self.okCount = okCount
            self.errorStatistics = errorStatistics
            self.totalCount = totalCount
        }

        public init(dictionary: [String: Any]) throws {
            self.totalResponseTime = dictionary["TotalResponseTime"] as? Double
            if let faultStatistics = dictionary["FaultStatistics"] as? [String: Any] { self.faultStatistics = try Xray.FaultStatistics(dictionary: faultStatistics) } else { self.faultStatistics = nil }
            self.okCount = dictionary["OkCount"] as? Int64
            if let errorStatistics = dictionary["ErrorStatistics"] as? [String: Any] { self.errorStatistics = try Xray.ErrorStatistics(dictionary: errorStatistics) } else { self.errorStatistics = nil }
            self.totalCount = dictionary["TotalCount"] as? Int64
        }
    }

    public struct Segment: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The segment document.
        public let document: String?
        /// The segment's ID.
        public let id: String?

        public init(document: String? = nil, id: String? = nil) {
            self.document = document
            self.id = id
        }

        public init(dictionary: [String: Any]) throws {
            self.document = dictionary["Document"] as? String
            self.id = dictionary["Id"] as? String
        }
    }

    public struct Alias: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The type of the alias.
        public let `type`: String?
        /// The canonical name of the alias.
        public let name: String?
        /// A list of names for the alias, including the canonical name.
        public let names: [String]?

        public init(type: String? = nil, name: String? = nil, names: [String]? = nil) {
            self.`type` = `type`
            self.name = name
            self.names = names
        }

        public init(dictionary: [String: Any]) throws {
            self.`type` = dictionary["Type"] as? String
            self.name = dictionary["Name"] as? String
            self.names = dictionary["Names"] as? [String]
        }
    }

    public struct ValueWithServiceIds: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Services to which the annotation applies.
        public let serviceIds: [ServiceId]?
        /// Values of the annotation.
        public let annotationValue: AnnotationValue?

        public init(serviceIds: [ServiceId]? = nil, annotationValue: AnnotationValue? = nil) {
            self.serviceIds = serviceIds
            self.annotationValue = annotationValue
        }

        public init(dictionary: [String: Any]) throws {
            if let serviceIds = dictionary["ServiceIds"] as? [[String: Any]] {
                self.serviceIds = try serviceIds.map({ try ServiceId(dictionary: $0) })
            } else { 
                self.serviceIds = nil
            }
            if let annotationValue = dictionary["AnnotationValue"] as? [String: Any] { self.annotationValue = try Xray.AnnotationValue(dictionary: annotationValue) } else { self.annotationValue = nil }
        }
    }

    public struct HistogramEntry: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The value of the entry.
        public let value: Double?
        /// The prevalence of the entry.
        public let count: Int32?

        public init(value: Double? = nil, count: Int32? = nil) {
            self.value = value
            self.count = count
        }

        public init(dictionary: [String: Any]) throws {
            self.value = dictionary["Value"] as? Double
            self.count = dictionary["Count"] as? Int32
        }
    }

    public struct UnprocessedTraceSegment: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The segment's ID.
        public let id: String?
        /// The error that caused processing to fail.
        public let errorCode: String?
        /// The error message.
        public let message: String?

        public init(id: String? = nil, errorCode: String? = nil, message: String? = nil) {
            self.id = id
            self.errorCode = errorCode
            self.message = message
        }

        public init(dictionary: [String: Any]) throws {
            self.id = dictionary["Id"] as? String
            self.errorCode = dictionary["ErrorCode"] as? String
            self.message = dictionary["Message"] as? String
        }
    }

    public struct GetTraceSummariesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The number of traces that were processed to get this set of summaries.
        public let tracesProcessedCount: Int64?
        /// Trace IDs and metadata for traces that were found in the specified time frame.
        public let traceSummaries: [TraceSummary]?
        /// If the requested time frame contained more than one page of results, you can use this token to retrieve the next page. The first page contains the most most recent results, closest to the end of the time frame.
        public let nextToken: String?
        /// The start time of this page of results.
        public let approximateTime: Date?

        public init(tracesProcessedCount: Int64? = nil, traceSummaries: [TraceSummary]? = nil, nextToken: String? = nil, approximateTime: Date? = nil) {
            self.tracesProcessedCount = tracesProcessedCount
            self.traceSummaries = traceSummaries
            self.nextToken = nextToken
            self.approximateTime = approximateTime
        }

        public init(dictionary: [String: Any]) throws {
            self.tracesProcessedCount = dictionary["TracesProcessedCount"] as? Int64
            if let traceSummaries = dictionary["TraceSummaries"] as? [[String: Any]] {
                self.traceSummaries = try traceSummaries.map({ try TraceSummary(dictionary: $0) })
            } else { 
                self.traceSummaries = nil
            }
            self.nextToken = dictionary["NextToken"] as? String
            self.approximateTime = dictionary["ApproximateTime"] as? Date
        }
    }

    public struct Edge: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The start time of the first segment on the edge.
        public let startTime: Date?
        /// Response statistics for segments on the edge.
        public let summaryStatistics: EdgeStatistics?
        /// The end time of the last segment on the edge.
        public let endTime: Date?
        /// Identifier of the edge. Unique within a service map.
        public let referenceId: Int32?
        /// Aliases for the edge.
        public let aliases: [Alias]?
        /// Histogram describing the prominence of response times on the edge.
        public let responseTimeHistogram: [HistogramEntry]?

        public init(startTime: Date? = nil, summaryStatistics: EdgeStatistics? = nil, endTime: Date? = nil, referenceId: Int32? = nil, aliases: [Alias]? = nil, responseTimeHistogram: [HistogramEntry]? = nil) {
            self.startTime = startTime
            self.summaryStatistics = summaryStatistics
            self.endTime = endTime
            self.referenceId = referenceId
            self.aliases = aliases
            self.responseTimeHistogram = responseTimeHistogram
        }

        public init(dictionary: [String: Any]) throws {
            self.startTime = dictionary["StartTime"] as? Date
            if let summaryStatistics = dictionary["SummaryStatistics"] as? [String: Any] { self.summaryStatistics = try Xray.EdgeStatistics(dictionary: summaryStatistics) } else { self.summaryStatistics = nil }
            self.endTime = dictionary["EndTime"] as? Date
            self.referenceId = dictionary["ReferenceId"] as? Int32
            if let aliases = dictionary["Aliases"] as? [[String: Any]] {
                self.aliases = try aliases.map({ try Alias(dictionary: $0) })
            } else { 
                self.aliases = nil
            }
            if let responseTimeHistogram = dictionary["ResponseTimeHistogram"] as? [[String: Any]] {
                self.responseTimeHistogram = try responseTimeHistogram.map({ try HistogramEntry(dictionary: $0) })
            } else { 
                self.responseTimeHistogram = nil
            }
        }
    }

    public struct ErrorStatistics: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The total number of requests that failed with a 4xx Client Error status code.
        public let totalCount: Int64?
        /// The number of requests that failed with untracked 4xx Client Error status codes.
        public let otherCount: Int64?
        /// The number of requests that failed with a 419 throttling status code.
        public let throttleCount: Int64?

        public init(totalCount: Int64? = nil, otherCount: Int64? = nil, throttleCount: Int64? = nil) {
            self.totalCount = totalCount
            self.otherCount = otherCount
            self.throttleCount = throttleCount
        }

        public init(dictionary: [String: Any]) throws {
            self.totalCount = dictionary["TotalCount"] as? Int64
            self.otherCount = dictionary["OtherCount"] as? Int64
            self.throttleCount = dictionary["ThrottleCount"] as? Int64
        }
    }

    public struct GetServiceGraphRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The end of the time frame for which to generate a graph.
        public let endTime: Date
        /// Pagination token. Not used.
        public let nextToken: String?
        /// The start of the time frame for which to generate a graph.
        public let startTime: Date

        public init(endTime: Date, nextToken: String? = nil, startTime: Date) {
            self.endTime = endTime
            self.nextToken = nextToken
            self.startTime = startTime
        }

        public init(dictionary: [String: Any]) throws {
            guard let endTime = dictionary["EndTime"] as? Date else { throw InitializableError.missingRequiredParam("EndTime") }
            self.endTime = endTime
            self.nextToken = dictionary["NextToken"] as? String
            guard let startTime = dictionary["StartTime"] as? Date else { throw InitializableError.missingRequiredParam("StartTime") }
            self.startTime = startTime
        }
    }

    public struct PutTraceSegmentsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Segments that failed processing.
        public let unprocessedTraceSegments: [UnprocessedTraceSegment]?

        public init(unprocessedTraceSegments: [UnprocessedTraceSegment]? = nil) {
            self.unprocessedTraceSegments = unprocessedTraceSegments
        }

        public init(dictionary: [String: Any]) throws {
            if let unprocessedTraceSegments = dictionary["UnprocessedTraceSegments"] as? [[String: Any]] {
                self.unprocessedTraceSegments = try unprocessedTraceSegments.map({ try UnprocessedTraceSegment(dictionary: $0) })
            } else { 
                self.unprocessedTraceSegments = nil
            }
        }
    }

    public struct AnnotationValue: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Value for a Boolean annotation.
        public let booleanValue: Bool?
        /// Value for a String annotation.
        public let stringValue: String?
        /// Value for a Number annotation.
        public let numberValue: Double?

        public init(booleanValue: Bool? = nil, stringValue: String? = nil, numberValue: Double? = nil) {
            self.booleanValue = booleanValue
            self.stringValue = stringValue
            self.numberValue = numberValue
        }

        public init(dictionary: [String: Any]) throws {
            self.booleanValue = dictionary["BooleanValue"] as? Bool
            self.stringValue = dictionary["StringValue"] as? String
            self.numberValue = dictionary["NumberValue"] as? Double
        }
    }

    public struct GetServiceGraphResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The start of the time frame for which the graph was generated.
        public let startTime: Date?
        /// The end of the time frame for which the graph was generated.
        public let endTime: Date?
        /// The services that have processed a traced request during the specified time frame.
        public let services: [Service]?
        /// Pagination token. Not used.
        public let nextToken: String?

        public init(startTime: Date? = nil, endTime: Date? = nil, services: [Service]? = nil, nextToken: String? = nil) {
            self.startTime = startTime
            self.endTime = endTime
            self.services = services
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            self.startTime = dictionary["StartTime"] as? Date
            self.endTime = dictionary["EndTime"] as? Date
            if let services = dictionary["Services"] as? [[String: Any]] {
                self.services = try services.map({ try Service(dictionary: $0) })
            } else { 
                self.services = nil
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct TraceUser: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Services that the user's request hit.
        public let serviceIds: [ServiceId]?
        /// The user's name.
        public let userName: String?

        public init(serviceIds: [ServiceId]? = nil, userName: String? = nil) {
            self.serviceIds = serviceIds
            self.userName = userName
        }

        public init(dictionary: [String: Any]) throws {
            if let serviceIds = dictionary["ServiceIds"] as? [[String: Any]] {
                self.serviceIds = try serviceIds.map({ try ServiceId(dictionary: $0) })
            } else { 
                self.serviceIds = nil
            }
            self.userName = dictionary["UserName"] as? String
        }
    }

    public struct FaultStatistics: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The total number of requests that failed with a 5xx Server Error status code.
        public let totalCount: Int64?
        /// The number of requests that failed with untracked 5xx Server Error status codes.
        public let otherCount: Int64?

        public init(totalCount: Int64? = nil, otherCount: Int64? = nil) {
            self.totalCount = totalCount
            self.otherCount = otherCount
        }

        public init(dictionary: [String: Any]) throws {
            self.totalCount = dictionary["TotalCount"] as? Int64
            self.otherCount = dictionary["OtherCount"] as? Int64
        }
    }

    public struct Http: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IP address of the requestor.
        public let clientIp: String?
        /// The request URL.
        public let httpURL: String?
        /// The request method.
        public let httpMethod: String?
        /// The response status.
        public let httpStatus: Int32?
        /// The request's user agent string.
        public let userAgent: String?

        public init(clientIp: String? = nil, httpURL: String? = nil, httpMethod: String? = nil, httpStatus: Int32? = nil, userAgent: String? = nil) {
            self.clientIp = clientIp
            self.httpURL = httpURL
            self.httpMethod = httpMethod
            self.httpStatus = httpStatus
            self.userAgent = userAgent
        }

        public init(dictionary: [String: Any]) throws {
            self.clientIp = dictionary["ClientIp"] as? String
            self.httpURL = dictionary["HttpURL"] as? String
            self.httpMethod = dictionary["HttpMethod"] as? String
            self.httpStatus = dictionary["HttpStatus"] as? Int32
            self.userAgent = dictionary["UserAgent"] as? String
        }
    }

    public struct ServiceStatistics: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The aggregate response time of completed requests.
        public let totalResponseTime: Double?
        /// Information about requests that failed with a 5xx Server Error status code.
        public let faultStatistics: FaultStatistics?
        /// The number of requests that completed with a 2xx Success status code.
        public let okCount: Int64?
        /// Information about requests that failed with a 4xx Client Error status code.
        public let errorStatistics: ErrorStatistics?
        /// The total number of completed requests.
        public let totalCount: Int64?

        public init(totalResponseTime: Double? = nil, faultStatistics: FaultStatistics? = nil, okCount: Int64? = nil, errorStatistics: ErrorStatistics? = nil, totalCount: Int64? = nil) {
            self.totalResponseTime = totalResponseTime
            self.faultStatistics = faultStatistics
            self.okCount = okCount
            self.errorStatistics = errorStatistics
            self.totalCount = totalCount
        }

        public init(dictionary: [String: Any]) throws {
            self.totalResponseTime = dictionary["TotalResponseTime"] as? Double
            if let faultStatistics = dictionary["FaultStatistics"] as? [String: Any] { self.faultStatistics = try Xray.FaultStatistics(dictionary: faultStatistics) } else { self.faultStatistics = nil }
            self.okCount = dictionary["OkCount"] as? Int64
            if let errorStatistics = dictionary["ErrorStatistics"] as? [String: Any] { self.errorStatistics = try Xray.ErrorStatistics(dictionary: errorStatistics) } else { self.errorStatistics = nil }
            self.totalCount = dictionary["TotalCount"] as? Int64
        }
    }

    public struct GetTraceGraphRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Trace IDs of requests for which to generate a service graph.
        public let traceIds: [String]
        /// Pagination token. Not used.
        public let nextToken: String?

        public init(traceIds: [String], nextToken: String? = nil) {
            self.traceIds = traceIds
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            guard let traceIds = dictionary["TraceIds"] as? [String] else { throw InitializableError.missingRequiredParam("TraceIds") }
            self.traceIds = traceIds
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct GetTraceGraphResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The services that have processed one of the specified requests.
        public let services: [Service]?
        /// Pagination token. Not used.
        public let nextToken: String?

        public init(services: [Service]? = nil, nextToken: String? = nil) {
            self.services = services
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let services = dictionary["Services"] as? [[String: Any]] {
                self.services = try services.map({ try Service(dictionary: $0) })
            } else { 
                self.services = nil
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct Trace: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Segment documents for the segments and subsegments that comprise the trace.
        public let segments: [Segment]?
        /// The length of time in seconds between the start time of the root segment and the end time of the last segment that completed.
        public let duration: Double?
        /// The unique identifier for the request that generated the trace's segments and subsegments.
        public let id: String?

        public init(segments: [Segment]? = nil, duration: Double? = nil, id: String? = nil) {
            self.segments = segments
            self.duration = duration
            self.id = id
        }

        public init(dictionary: [String: Any]) throws {
            if let segments = dictionary["Segments"] as? [[String: Any]] {
                self.segments = try segments.map({ try Segment(dictionary: $0) })
            } else { 
                self.segments = nil
            }
            self.duration = dictionary["Duration"] as? Double
            self.id = dictionary["Id"] as? String
        }
    }

    public struct PutTraceSegmentsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A JSON document defining one or more segments or subsegments. Segments must include the following fields.  Required Segment Document Fields     name - The name of the service that handled the request.    id - A 64-bit identifier for the segment, unique among segments in the same trace, in 16 hexadecimal digits.    trace_id - A unique identifier that connects all segments and subsegments originating from a single client request.    start_time - Time the segment or subsegment was created, in floating point seconds in epoch time, accurate to milliseconds. For example, 1480615200.010 or 1.480615200010E9.    end_time - Time the segment or subsegment was closed. For example, 1480615200.090 or 1.480615200090E9. Specify either an end_time or in_progress.    in_progress - Set to true instead of specifying an end_time to record that a segment has been started, but is not complete. Send an in progress segment when your application receives a request that will take a long time to serve, to trace the fact that the request was received. When the response is sent, send the complete segment to overwrite the in-progress segment.   A trace_id consists of three numbers separated by hyphens. For example, 1-58406520-a006649127e371903a2de979. This includes:  Trace ID Format    The version number, i.e. 1.   The time of the original request, in Unix epoch time, in 8 hexadecimal digits. For example, 10:00AM December 2nd, 2016 PST in epoch time is 1480615200 seconds, or 58406520 in hexadecimal.   A 96-bit identifier for the trace, globally unique, in 24 hexadecimal digits.  
        public let traceSegmentDocuments: [String]

        public init(traceSegmentDocuments: [String]) {
            self.traceSegmentDocuments = traceSegmentDocuments
        }

        public init(dictionary: [String: Any]) throws {
            guard let traceSegmentDocuments = dictionary["TraceSegmentDocuments"] as? [String] else { throw InitializableError.missingRequiredParam("TraceSegmentDocuments") }
            self.traceSegmentDocuments = traceSegmentDocuments
        }
    }

    public struct GetTraceSummariesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The start of the time frame for which to retrieve traces.
        public let startTime: Date
        /// The end of the time frame for which to retrieve traces.
        public let endTime: Date
        /// Specify a filter expression to retrieve trace summaries for services or requests that meet certain requirements.
        public let filterExpression: String?
        /// Set to true to get summaries for only a subset of available traces.
        public let sampling: Bool?
        /// Specify the pagination token returned by a previous request to retrieve the next page of results.
        public let nextToken: String?

        public init(startTime: Date, endTime: Date, filterExpression: String? = nil, sampling: Bool? = nil, nextToken: String? = nil) {
            self.startTime = startTime
            self.endTime = endTime
            self.filterExpression = filterExpression
            self.sampling = sampling
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            guard let startTime = dictionary["StartTime"] as? Date else { throw InitializableError.missingRequiredParam("StartTime") }
            self.startTime = startTime
            guard let endTime = dictionary["EndTime"] as? Date else { throw InitializableError.missingRequiredParam("EndTime") }
            self.endTime = endTime
            self.filterExpression = dictionary["FilterExpression"] as? String
            self.sampling = dictionary["Sampling"] as? Bool
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct PutTelemetryRecordsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct PutTelemetryRecordsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let eC2InstanceId: String?
        public let hostname: String?
        public let telemetryRecords: [TelemetryRecord]
        public let resourceARN: String?

        public init(eC2InstanceId: String? = nil, hostname: String? = nil, telemetryRecords: [TelemetryRecord], resourceARN: String? = nil) {
            self.eC2InstanceId = eC2InstanceId
            self.hostname = hostname
            self.telemetryRecords = telemetryRecords
            self.resourceARN = resourceARN
        }

        public init(dictionary: [String: Any]) throws {
            self.eC2InstanceId = dictionary["EC2InstanceId"] as? String
            self.hostname = dictionary["Hostname"] as? String
            guard let telemetryRecords = dictionary["TelemetryRecords"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("TelemetryRecords") }
            self.telemetryRecords = try telemetryRecords.map({ try TelemetryRecord(dictionary: $0) })
            self.resourceARN = dictionary["ResourceARN"] as? String
        }
    }

    public struct Service: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The start time of the first segment that the service generated.
        public let startTime: Date?
        /// Aggregated statistics for the service.
        public let summaryStatistics: ServiceStatistics?
        /// Histogram mapping the spread of trace durations
        public let durationHistogram: [HistogramEntry]?
        /// Identifier of the AWS account in which the service runs.
        public let accountId: String?
        /// Indicates that the service was the first service to process a request.
        public let root: Bool?
        /// The canonical name of the service.
        public let name: String?
        /// The service's state.
        public let state: String?
        /// The end time of the last segment that the service generated.
        public let endTime: Date?
        /// Identifier for the service. Unique within the service map.
        public let referenceId: Int32?
        /// A list of names for the service, including the canonical name.
        public let names: [String]?
        /// Connections to downstream services.
        public let edges: [Edge]?
        /// The type of service.   AWS Resource - The type of an AWS resource. For example, AWS::EC2::Instance for a application running on Amazon EC2 or AWS::DynamoDB::Table for an Amazon DynamoDB table that the application used.   AWS Service - The type of an AWS service. For example, AWS::DynamoDB for downstream calls to Amazon DynamoDB that didn't target a specific table.    client - Represents the clients that sent requests to a root service.    remote - A downstream service of indeterminate type.  
        public let `type`: String?

        public init(startTime: Date? = nil, summaryStatistics: ServiceStatistics? = nil, durationHistogram: [HistogramEntry]? = nil, accountId: String? = nil, root: Bool? = nil, name: String? = nil, state: String? = nil, endTime: Date? = nil, referenceId: Int32? = nil, names: [String]? = nil, edges: [Edge]? = nil, type: String? = nil) {
            self.startTime = startTime
            self.summaryStatistics = summaryStatistics
            self.durationHistogram = durationHistogram
            self.accountId = accountId
            self.root = root
            self.name = name
            self.state = state
            self.endTime = endTime
            self.referenceId = referenceId
            self.names = names
            self.edges = edges
            self.`type` = `type`
        }

        public init(dictionary: [String: Any]) throws {
            self.startTime = dictionary["StartTime"] as? Date
            if let summaryStatistics = dictionary["SummaryStatistics"] as? [String: Any] { self.summaryStatistics = try Xray.ServiceStatistics(dictionary: summaryStatistics) } else { self.summaryStatistics = nil }
            if let durationHistogram = dictionary["DurationHistogram"] as? [[String: Any]] {
                self.durationHistogram = try durationHistogram.map({ try HistogramEntry(dictionary: $0) })
            } else { 
                self.durationHistogram = nil
            }
            self.accountId = dictionary["AccountId"] as? String
            self.root = dictionary["Root"] as? Bool
            self.name = dictionary["Name"] as? String
            self.state = dictionary["State"] as? String
            self.endTime = dictionary["EndTime"] as? Date
            self.referenceId = dictionary["ReferenceId"] as? Int32
            self.names = dictionary["Names"] as? [String]
            if let edges = dictionary["Edges"] as? [[String: Any]] {
                self.edges = try edges.map({ try Edge(dictionary: $0) })
            } else { 
                self.edges = nil
            }
            self.`type` = dictionary["Type"] as? String
        }
    }

    public struct ServiceId: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let accountId: String?
        public let names: [String]?
        public let `type`: String?
        public let name: String?

        public init(accountId: String? = nil, names: [String]? = nil, type: String? = nil, name: String? = nil) {
            self.accountId = accountId
            self.names = names
            self.`type` = `type`
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            self.accountId = dictionary["AccountId"] as? String
            self.names = dictionary["Names"] as? [String]
            self.`type` = dictionary["Type"] as? String
            self.name = dictionary["Name"] as? String
        }
    }

    public struct BackendConnectionErrors: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let connectionRefusedCount: Int32?
        public let timeoutCount: Int32?
        public let unknownHostCount: Int32?
        public let hTTPCode5XXCount: Int32?
        public let otherCount: Int32?
        public let hTTPCode4XXCount: Int32?

        public init(connectionRefusedCount: Int32? = nil, timeoutCount: Int32? = nil, unknownHostCount: Int32? = nil, hTTPCode5XXCount: Int32? = nil, otherCount: Int32? = nil, hTTPCode4XXCount: Int32? = nil) {
            self.connectionRefusedCount = connectionRefusedCount
            self.timeoutCount = timeoutCount
            self.unknownHostCount = unknownHostCount
            self.hTTPCode5XXCount = hTTPCode5XXCount
            self.otherCount = otherCount
            self.hTTPCode4XXCount = hTTPCode4XXCount
        }

        public init(dictionary: [String: Any]) throws {
            self.connectionRefusedCount = dictionary["ConnectionRefusedCount"] as? Int32
            self.timeoutCount = dictionary["TimeoutCount"] as? Int32
            self.unknownHostCount = dictionary["UnknownHostCount"] as? Int32
            self.hTTPCode5XXCount = dictionary["HTTPCode5XXCount"] as? Int32
            self.otherCount = dictionary["OtherCount"] as? Int32
            self.hTTPCode4XXCount = dictionary["HTTPCode4XXCount"] as? Int32
        }
    }

    public struct TelemetryRecord: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let segmentsRejectedCount: Int32?
        public let timestamp: Date?
        public let segmentsReceivedCount: Int32?
        public let segmentsSentCount: Int32?
        public let segmentsSpilloverCount: Int32?
        public let backendConnectionErrors: BackendConnectionErrors?

        public init(segmentsRejectedCount: Int32? = nil, timestamp: Date? = nil, segmentsReceivedCount: Int32? = nil, segmentsSentCount: Int32? = nil, segmentsSpilloverCount: Int32? = nil, backendConnectionErrors: BackendConnectionErrors? = nil) {
            self.segmentsRejectedCount = segmentsRejectedCount
            self.timestamp = timestamp
            self.segmentsReceivedCount = segmentsReceivedCount
            self.segmentsSentCount = segmentsSentCount
            self.segmentsSpilloverCount = segmentsSpilloverCount
            self.backendConnectionErrors = backendConnectionErrors
        }

        public init(dictionary: [String: Any]) throws {
            self.segmentsRejectedCount = dictionary["SegmentsRejectedCount"] as? Int32
            self.timestamp = dictionary["Timestamp"] as? Date
            self.segmentsReceivedCount = dictionary["SegmentsReceivedCount"] as? Int32
            self.segmentsSentCount = dictionary["SegmentsSentCount"] as? Int32
            self.segmentsSpilloverCount = dictionary["SegmentsSpilloverCount"] as? Int32
            if let backendConnectionErrors = dictionary["BackendConnectionErrors"] as? [String: Any] { self.backendConnectionErrors = try Xray.BackendConnectionErrors(dictionary: backendConnectionErrors) } else { self.backendConnectionErrors = nil }
        }
    }

    public struct BatchGetTracesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Specify the trace IDs of requests for which to retrieve segments.
        public let traceIds: [String]
        /// Pagination token. Not used.
        public let nextToken: String?

        public init(traceIds: [String], nextToken: String? = nil) {
            self.traceIds = traceIds
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            guard let traceIds = dictionary["TraceIds"] as? [String] else { throw InitializableError.missingRequiredParam("TraceIds") }
            self.traceIds = traceIds
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct TraceSummary: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more of the segment documents is in progress.
        public let isPartial: Bool?
        /// Service IDs from the trace's segment documents.
        public let serviceIds: [ServiceId]?
        /// Information about the HTTP request served by the trace.
        public let http: Http?
        /// One or more of the segment documents has a 400 series error.
        public let hasError: Bool?
        /// The unique identifier for the request that generated the trace's segments and subsegments.
        public let id: String?
        /// One or more of the segment documents has a 429 throttling error.
        public let hasThrottle: Bool?
        /// Users from the trace's segment documents.
        public let users: [TraceUser]?
        /// Annotations from the trace's segment documents.
        public let annotations: [String: [ValueWithServiceIds]]?
        /// The length of time in seconds between the start time of the root segment and the end time of the last segment that completed.
        public let duration: Double?
        /// One or more of the segment documents has a 500 series error.
        public let hasFault: Bool?
        /// The length of time in seconds between the start and end times of the root segment. If the service performs work asynchronously, the response time measures the time before the response is sent to the user, while the duration measures the amount of time before the last traced activity completes.
        public let responseTime: Double?

        public init(isPartial: Bool? = nil, serviceIds: [ServiceId]? = nil, http: Http? = nil, hasError: Bool? = nil, id: String? = nil, hasThrottle: Bool? = nil, users: [TraceUser]? = nil, annotations: [String: [ValueWithServiceIds]]? = nil, duration: Double? = nil, hasFault: Bool? = nil, responseTime: Double? = nil) {
            self.isPartial = isPartial
            self.serviceIds = serviceIds
            self.http = http
            self.hasError = hasError
            self.id = id
            self.hasThrottle = hasThrottle
            self.users = users
            self.annotations = annotations
            self.duration = duration
            self.hasFault = hasFault
            self.responseTime = responseTime
        }

        public init(dictionary: [String: Any]) throws {
            self.isPartial = dictionary["IsPartial"] as? Bool
            if let serviceIds = dictionary["ServiceIds"] as? [[String: Any]] {
                self.serviceIds = try serviceIds.map({ try ServiceId(dictionary: $0) })
            } else { 
                self.serviceIds = nil
            }
            if let http = dictionary["Http"] as? [String: Any] { self.http = try Xray.Http(dictionary: http) } else { self.http = nil }
            self.hasError = dictionary["HasError"] as? Bool
            self.id = dictionary["Id"] as? String
            self.hasThrottle = dictionary["HasThrottle"] as? Bool
            if let users = dictionary["Users"] as? [[String: Any]] {
                self.users = try users.map({ try TraceUser(dictionary: $0) })
            } else { 
                self.users = nil
            }
            if let annotations = dictionary["Annotations"] as? [String: Any] {
                var annotationsDict: [String: [ValueWithServiceIds]] = [:]
                for (key, value) in annotations {
                    guard let valueWithServiceIds = value as? [[String: Any]] else { throw InitializableError.convertingError }
                    let valueWithServiceIdsList: [ValueWithServiceIds] = try valueWithServiceIds.map { try ValueWithServiceIds(dictionary: $0) }
                    annotationsDict[key] = valueWithServiceIdsList
                }
                self.annotations = annotationsDict
            } else { 
                self.annotations = nil
            }
            self.duration = dictionary["Duration"] as? Double
            self.hasFault = dictionary["HasFault"] as? Bool
            self.responseTime = dictionary["ResponseTime"] as? Double
        }
    }

}