// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Elasticloadbalancing {

    public struct PolicyAttributeTypeDescription: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the attribute.
        public let attributeName: String?
        /// The type of the attribute. For example, Boolean or Integer.
        public let attributeType: String?
        /// The default value of the attribute, if applicable.
        public let defaultValue: String?
        /// The cardinality of the attribute. Valid values:   ONE(1) : Single value required   ZERO_OR_ONE(0..1) : Up to one value is allowed   ZERO_OR_MORE(0..*) : Optional. Multiple values are allowed   ONE_OR_MORE(1..*0) : Required. Multiple values are allowed  
        public let cardinality: String?
        /// A description of the attribute.
        public let description: String?

        public init(attributeName: String? = nil, attributeType: String? = nil, defaultValue: String? = nil, cardinality: String? = nil, description: String? = nil) {
            self.attributeName = attributeName
            self.attributeType = attributeType
            self.defaultValue = defaultValue
            self.cardinality = cardinality
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.attributeName = dictionary["AttributeName"] as? String
            self.attributeType = dictionary["AttributeType"] as? String
            self.defaultValue = dictionary["DefaultValue"] as? String
            self.cardinality = dictionary["Cardinality"] as? String
            self.description = dictionary["Description"] as? String
        }
    }

    public struct AddAvailabilityZonesOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The updated list of Availability Zones for the load balancer.
        public let availabilityZones: [String]?

        public init(availabilityZones: [String]? = nil) {
            self.availabilityZones = availabilityZones
        }

        public init(dictionary: [String: Any]) throws {
            self.availabilityZones = dictionary["AvailabilityZones"] as? [String]
        }
    }

    public struct DeleteLoadBalancerPolicyInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the load balancer.
        public let loadBalancerName: String
        /// The name of the policy.
        public let policyName: String

        public init(loadBalancerName: String, policyName: String) {
            self.loadBalancerName = loadBalancerName
            self.policyName = policyName
        }

        public init(dictionary: [String: Any]) throws {
            guard let loadBalancerName = dictionary["LoadBalancerName"] as? String else { throw InitializableError.missingRequiredParam("LoadBalancerName") }
            self.loadBalancerName = loadBalancerName
            guard let policyName = dictionary["PolicyName"] as? String else { throw InitializableError.missingRequiredParam("PolicyName") }
            self.policyName = policyName
        }
    }

    public struct PolicyAttributeDescription: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the attribute.
        public let attributeName: String?
        /// The value of the attribute.
        public let attributeValue: String?

        public init(attributeName: String? = nil, attributeValue: String? = nil) {
            self.attributeName = attributeName
            self.attributeValue = attributeValue
        }

        public init(dictionary: [String: Any]) throws {
            self.attributeName = dictionary["AttributeName"] as? String
            self.attributeValue = dictionary["AttributeValue"] as? String
        }
    }

    public struct DetachLoadBalancerFromSubnetsInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IDs of the subnets.
        public let subnets: [String]
        /// The name of the load balancer.
        public let loadBalancerName: String

        public init(subnets: [String], loadBalancerName: String) {
            self.subnets = subnets
            self.loadBalancerName = loadBalancerName
        }

        public init(dictionary: [String: Any]) throws {
            guard let subnets = dictionary["Subnets"] as? [String] else { throw InitializableError.missingRequiredParam("Subnets") }
            self.subnets = subnets
            guard let loadBalancerName = dictionary["LoadBalancerName"] as? String else { throw InitializableError.missingRequiredParam("LoadBalancerName") }
            self.loadBalancerName = loadBalancerName
        }
    }

    public struct DescribeAccessPointsOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the load balancers.
        public let loadBalancerDescriptions: [LoadBalancerDescription]?
        /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
        public let nextMarker: String?

        public init(loadBalancerDescriptions: [LoadBalancerDescription]? = nil, nextMarker: String? = nil) {
            self.loadBalancerDescriptions = loadBalancerDescriptions
            self.nextMarker = nextMarker
        }

        public init(dictionary: [String: Any]) throws {
            if let loadBalancerDescriptions = dictionary["LoadBalancerDescriptions"] as? [[String: Any]] {
                self.loadBalancerDescriptions = try loadBalancerDescriptions.map({ try LoadBalancerDescription(dictionary: $0) })
            } else { 
                self.loadBalancerDescriptions = nil
            }
            self.nextMarker = dictionary["NextMarker"] as? String
        }
    }

    public struct RemoveAvailabilityZonesInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Availability Zones.
        public let availabilityZones: [String]
        /// The name of the load balancer.
        public let loadBalancerName: String

        public init(availabilityZones: [String], loadBalancerName: String) {
            self.availabilityZones = availabilityZones
            self.loadBalancerName = loadBalancerName
        }

        public init(dictionary: [String: Any]) throws {
            guard let availabilityZones = dictionary["AvailabilityZones"] as? [String] else { throw InitializableError.missingRequiredParam("AvailabilityZones") }
            self.availabilityZones = availabilityZones
            guard let loadBalancerName = dictionary["LoadBalancerName"] as? String else { throw InitializableError.missingRequiredParam("LoadBalancerName") }
            self.loadBalancerName = loadBalancerName
        }
    }

    public struct CreateLoadBalancerListenerInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the load balancer.
        public let loadBalancerName: String
        /// The listeners.
        public let listeners: [Listener]

        public init(loadBalancerName: String, listeners: [Listener]) {
            self.loadBalancerName = loadBalancerName
            self.listeners = listeners
        }

        public init(dictionary: [String: Any]) throws {
            guard let loadBalancerName = dictionary["LoadBalancerName"] as? String else { throw InitializableError.missingRequiredParam("LoadBalancerName") }
            self.loadBalancerName = loadBalancerName
            guard let listeners = dictionary["Listeners"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("Listeners") }
            self.listeners = try listeners.map({ try Listener(dictionary: $0) })
        }
    }

    public struct CreateAccessPointOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The DNS name of the load balancer.
        public let dNSName: String?

        public init(dNSName: String? = nil) {
            self.dNSName = dNSName
        }

        public init(dictionary: [String: Any]) throws {
            self.dNSName = dictionary["DNSName"] as? String
        }
    }

    public struct ModifyLoadBalancerAttributesInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the load balancer.
        public let loadBalancerName: String
        /// The attributes of the load balancer.
        public let loadBalancerAttributes: LoadBalancerAttributes

        public init(loadBalancerName: String, loadBalancerAttributes: LoadBalancerAttributes) {
            self.loadBalancerName = loadBalancerName
            self.loadBalancerAttributes = loadBalancerAttributes
        }

        public init(dictionary: [String: Any]) throws {
            guard let loadBalancerName = dictionary["LoadBalancerName"] as? String else { throw InitializableError.missingRequiredParam("LoadBalancerName") }
            self.loadBalancerName = loadBalancerName
            guard let loadBalancerAttributes = dictionary["LoadBalancerAttributes"] as? [String: Any] else { throw InitializableError.missingRequiredParam("LoadBalancerAttributes") }
            self.loadBalancerAttributes = try Elasticloadbalancing.LoadBalancerAttributes(dictionary: loadBalancerAttributes)
        }
    }

    public struct AttachLoadBalancerToSubnetsInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IDs of the subnets to add. You can add only one subnet per Availability Zone.
        public let subnets: [String]
        /// The name of the load balancer.
        public let loadBalancerName: String

        public init(subnets: [String], loadBalancerName: String) {
            self.subnets = subnets
            self.loadBalancerName = loadBalancerName
        }

        public init(dictionary: [String: Any]) throws {
            guard let subnets = dictionary["Subnets"] as? [String] else { throw InitializableError.missingRequiredParam("Subnets") }
            self.subnets = subnets
            guard let loadBalancerName = dictionary["LoadBalancerName"] as? String else { throw InitializableError.missingRequiredParam("LoadBalancerName") }
            self.loadBalancerName = loadBalancerName
        }
    }

    public struct TagKeyOnly: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the key.
        public let key: String?

        public init(key: String? = nil) {
            self.key = key
        }

        public init(dictionary: [String: Any]) throws {
            self.key = dictionary["Key"] as? String
        }
    }

    public struct ListenerDescription: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The policies. If there are no policies enabled, the list is empty.
        public let policyNames: [String]?
        public let listener: Listener?

        public init(policyNames: [String]? = nil, listener: Listener? = nil) {
            self.policyNames = policyNames
            self.listener = listener
        }

        public init(dictionary: [String: Any]) throws {
            self.policyNames = dictionary["PolicyNames"] as? [String]
            if let listener = dictionary["Listener"] as? [String: Any] { self.listener = try Elasticloadbalancing.Listener(dictionary: listener) } else { self.listener = nil }
        }
    }

    public struct DeregisterEndPointsOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The remaining instances registered with the load balancer.
        public let instances: [Instance]?

        public init(instances: [Instance]? = nil) {
            self.instances = instances
        }

        public init(dictionary: [String: Any]) throws {
            if let instances = dictionary["Instances"] as? [[String: Any]] {
                self.instances = try instances.map({ try Instance(dictionary: $0) })
            } else { 
                self.instances = nil
            }
        }
    }

    public struct LoadBalancerAttributes: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// If enabled, the load balancer allows the connections to remain idle (no data is sent over the connection) for the specified duration. By default, Elastic Load Balancing maintains a 60-second idle connection timeout for both front-end and back-end connections of your load balancer. For more information, see Configure Idle Connection Timeout in the Classic Load Balancers Guide.
        public let connectionSettings: ConnectionSettings?
        /// This parameter is reserved.
        public let additionalAttributes: [AdditionalAttribute]?
        /// If enabled, the load balancer captures detailed information of all requests and delivers the information to the Amazon S3 bucket that you specify. For more information, see Enable Access Logs in the Classic Load Balancers Guide.
        public let accessLog: AccessLog?
        /// If enabled, the load balancer allows existing requests to complete before the load balancer shifts traffic away from a deregistered or unhealthy instance. For more information, see Configure Connection Draining in the Classic Load Balancers Guide.
        public let connectionDraining: ConnectionDraining?
        /// If enabled, the load balancer routes the request traffic evenly across all instances regardless of the Availability Zones. For more information, see Configure Cross-Zone Load Balancing in the Classic Load Balancers Guide.
        public let crossZoneLoadBalancing: CrossZoneLoadBalancing?

        public init(connectionSettings: ConnectionSettings? = nil, additionalAttributes: [AdditionalAttribute]? = nil, accessLog: AccessLog? = nil, connectionDraining: ConnectionDraining? = nil, crossZoneLoadBalancing: CrossZoneLoadBalancing? = nil) {
            self.connectionSettings = connectionSettings
            self.additionalAttributes = additionalAttributes
            self.accessLog = accessLog
            self.connectionDraining = connectionDraining
            self.crossZoneLoadBalancing = crossZoneLoadBalancing
        }

        public init(dictionary: [String: Any]) throws {
            if let connectionSettings = dictionary["ConnectionSettings"] as? [String: Any] { self.connectionSettings = try Elasticloadbalancing.ConnectionSettings(dictionary: connectionSettings) } else { self.connectionSettings = nil }
            if let additionalAttributes = dictionary["AdditionalAttributes"] as? [[String: Any]] {
                self.additionalAttributes = try additionalAttributes.map({ try AdditionalAttribute(dictionary: $0) })
            } else { 
                self.additionalAttributes = nil
            }
            if let accessLog = dictionary["AccessLog"] as? [String: Any] { self.accessLog = try Elasticloadbalancing.AccessLog(dictionary: accessLog) } else { self.accessLog = nil }
            if let connectionDraining = dictionary["ConnectionDraining"] as? [String: Any] { self.connectionDraining = try Elasticloadbalancing.ConnectionDraining(dictionary: connectionDraining) } else { self.connectionDraining = nil }
            if let crossZoneLoadBalancing = dictionary["CrossZoneLoadBalancing"] as? [String: Any] { self.crossZoneLoadBalancing = try Elasticloadbalancing.CrossZoneLoadBalancing(dictionary: crossZoneLoadBalancing) } else { self.crossZoneLoadBalancing = nil }
        }
    }

    public struct DescribeAccessPointsInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The marker for the next set of results. (You received this marker from a previous call.)
        public let marker: String?
        /// The names of the load balancers.
        public let loadBalancerNames: [String]?
        /// The maximum number of results to return with this call (a number from 1 to 400). The default is 400.
        public let pageSize: Int32?

        public init(marker: String? = nil, loadBalancerNames: [String]? = nil, pageSize: Int32? = nil) {
            self.marker = marker
            self.loadBalancerNames = loadBalancerNames
            self.pageSize = pageSize
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["Marker"] as? String
            self.loadBalancerNames = dictionary["LoadBalancerNames"] as? [String]
            self.pageSize = dictionary["PageSize"] as? Int32
        }
    }

    public struct AdditionalAttribute: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// This parameter is reserved.
        public let value: String?
        /// This parameter is reserved.
        public let key: String?

        public init(value: String? = nil, key: String? = nil) {
            self.value = value
            self.key = key
        }

        public init(dictionary: [String: Any]) throws {
            self.value = dictionary["Value"] as? String
            self.key = dictionary["Key"] as? String
        }
    }

    public struct SetLoadBalancerPoliciesOfListenerInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the load balancer.
        public let loadBalancerName: String
        /// The external port of the load balancer.
        public let loadBalancerPort: Int32
        /// The names of the policies. This list must include all policies to be enabled. If you omit a policy that is currently enabled, it is disabled. If the list is empty, all current policies are disabled.
        public let policyNames: [String]

        public init(loadBalancerName: String, loadBalancerPort: Int32, policyNames: [String]) {
            self.loadBalancerName = loadBalancerName
            self.loadBalancerPort = loadBalancerPort
            self.policyNames = policyNames
        }

        public init(dictionary: [String: Any]) throws {
            guard let loadBalancerName = dictionary["LoadBalancerName"] as? String else { throw InitializableError.missingRequiredParam("LoadBalancerName") }
            self.loadBalancerName = loadBalancerName
            guard let loadBalancerPort = dictionary["LoadBalancerPort"] as? Int32 else { throw InitializableError.missingRequiredParam("LoadBalancerPort") }
            self.loadBalancerPort = loadBalancerPort
            guard let policyNames = dictionary["PolicyNames"] as? [String] else { throw InitializableError.missingRequiredParam("PolicyNames") }
            self.policyNames = policyNames
        }
    }

    public struct AddAvailabilityZonesInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Availability Zones. These must be in the same region as the load balancer.
        public let availabilityZones: [String]
        /// The name of the load balancer.
        public let loadBalancerName: String

        public init(availabilityZones: [String], loadBalancerName: String) {
            self.availabilityZones = availabilityZones
            self.loadBalancerName = loadBalancerName
        }

        public init(dictionary: [String: Any]) throws {
            guard let availabilityZones = dictionary["AvailabilityZones"] as? [String] else { throw InitializableError.missingRequiredParam("AvailabilityZones") }
            self.availabilityZones = availabilityZones
            guard let loadBalancerName = dictionary["LoadBalancerName"] as? String else { throw InitializableError.missingRequiredParam("LoadBalancerName") }
            self.loadBalancerName = loadBalancerName
        }
    }

    public struct Tag: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The value of the tag.
        public let value: String?
        /// The key of the tag.
        public let key: String

        public init(value: String? = nil, key: String) {
            self.value = value
            self.key = key
        }

        public init(dictionary: [String: Any]) throws {
            self.value = dictionary["Value"] as? String
            guard let key = dictionary["Key"] as? String else { throw InitializableError.missingRequiredParam("Key") }
            self.key = key
        }
    }

    public struct SetLoadBalancerPoliciesOfListenerOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct TagDescription: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the load balancer.
        public let loadBalancerName: String?
        /// The tags.
        public let tags: [Tag]?

        public init(loadBalancerName: String? = nil, tags: [Tag]? = nil) {
            self.loadBalancerName = loadBalancerName
            self.tags = tags
        }

        public init(dictionary: [String: Any]) throws {
            self.loadBalancerName = dictionary["LoadBalancerName"] as? String
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            } else { 
                self.tags = nil
            }
        }
    }

    public struct CreateLBCookieStickinessPolicyOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ApplySecurityGroupsToLoadBalancerInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the load balancer.
        public let loadBalancerName: String
        /// The IDs of the security groups to associate with the load balancer. Note that you cannot specify the name of the security group.
        public let securityGroups: [String]

        public init(loadBalancerName: String, securityGroups: [String]) {
            self.loadBalancerName = loadBalancerName
            self.securityGroups = securityGroups
        }

        public init(dictionary: [String: Any]) throws {
            guard let loadBalancerName = dictionary["LoadBalancerName"] as? String else { throw InitializableError.missingRequiredParam("LoadBalancerName") }
            self.loadBalancerName = loadBalancerName
            guard let securityGroups = dictionary["SecurityGroups"] as? [String] else { throw InitializableError.missingRequiredParam("SecurityGroups") }
            self.securityGroups = securityGroups
        }
    }

    public struct ConnectionDraining: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The maximum time, in seconds, to keep the existing connections open before deregistering the instances.
        public let timeout: Int32?
        /// Specifies whether connection draining is enabled for the load balancer.
        public let enabled: Bool

        public init(timeout: Int32? = nil, enabled: Bool) {
            self.timeout = timeout
            self.enabled = enabled
        }

        public init(dictionary: [String: Any]) throws {
            self.timeout = dictionary["Timeout"] as? Int32
            guard let enabled = dictionary["Enabled"] as? Bool else { throw InitializableError.missingRequiredParam("Enabled") }
            self.enabled = enabled
        }
    }

    public struct AccessLog: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The interval for publishing the access logs. You can specify an interval of either 5 minutes or 60 minutes. Default: 60 minutes
        public let emitInterval: Int32?
        /// The name of the Amazon S3 bucket where the access logs are stored.
        public let s3BucketName: String?
        /// The logical hierarchy you created for your Amazon S3 bucket, for example my-bucket-prefix/prod. If the prefix is not provided, the log is placed at the root level of the bucket.
        public let s3BucketPrefix: String?
        /// Specifies whether access logs are enabled for the load balancer.
        public let enabled: Bool

        public init(emitInterval: Int32? = nil, s3BucketName: String? = nil, s3BucketPrefix: String? = nil, enabled: Bool) {
            self.emitInterval = emitInterval
            self.s3BucketName = s3BucketName
            self.s3BucketPrefix = s3BucketPrefix
            self.enabled = enabled
        }

        public init(dictionary: [String: Any]) throws {
            self.emitInterval = dictionary["EmitInterval"] as? Int32
            self.s3BucketName = dictionary["S3BucketName"] as? String
            self.s3BucketPrefix = dictionary["S3BucketPrefix"] as? String
            guard let enabled = dictionary["Enabled"] as? Bool else { throw InitializableError.missingRequiredParam("Enabled") }
            self.enabled = enabled
        }
    }

    public struct Listener: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The protocol to use for routing traffic to instances: HTTP, HTTPS, TCP, or SSL. If the front-end protocol is HTTP, HTTPS, TCP, or SSL, InstanceProtocol must be at the same protocol. If there is another listener with the same InstancePort whose InstanceProtocol is secure, (HTTPS or SSL), the listener's InstanceProtocol must also be secure. If there is another listener with the same InstancePort whose InstanceProtocol is HTTP or TCP, the listener's InstanceProtocol must be HTTP or TCP.
        public let instanceProtocol: String?
        /// The port on which the instance is listening.
        public let instancePort: Int32
        /// The port on which the load balancer is listening. On EC2-VPC, you can specify any port from the range 1-65535. On EC2-Classic, you can specify any port from the following list: 25, 80, 443, 465, 587, 1024-65535.
        public let loadBalancerPort: Int32
        /// The load balancer transport protocol to use for routing: HTTP, HTTPS, TCP, or SSL.
        public let `protocol`: String
        /// The Amazon Resource Name (ARN) of the server certificate.
        public let sSLCertificateId: String?

        public init(instanceProtocol: String? = nil, instancePort: Int32, loadBalancerPort: Int32, protocol: String, sSLCertificateId: String? = nil) {
            self.instanceProtocol = instanceProtocol
            self.instancePort = instancePort
            self.loadBalancerPort = loadBalancerPort
            self.`protocol` = `protocol`
            self.sSLCertificateId = sSLCertificateId
        }

        public init(dictionary: [String: Any]) throws {
            self.instanceProtocol = dictionary["InstanceProtocol"] as? String
            guard let instancePort = dictionary["InstancePort"] as? Int32 else { throw InitializableError.missingRequiredParam("InstancePort") }
            self.instancePort = instancePort
            guard let loadBalancerPort = dictionary["LoadBalancerPort"] as? Int32 else { throw InitializableError.missingRequiredParam("LoadBalancerPort") }
            self.loadBalancerPort = loadBalancerPort
            guard let `protocol` = dictionary["Protocol"] as? String else { throw InitializableError.missingRequiredParam("Protocol") }
            self.`protocol` = `protocol`
            self.sSLCertificateId = dictionary["SSLCertificateId"] as? String
        }
    }

    public struct Instance: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The instance ID.
        public let instanceId: String?

        public init(instanceId: String? = nil) {
            self.instanceId = instanceId
        }

        public init(dictionary: [String: Any]) throws {
            self.instanceId = dictionary["InstanceId"] as? String
        }
    }

    public struct CreateLBCookieStickinessPolicyInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the load balancer.
        public let loadBalancerName: String
        /// The time period, in seconds, after which the cookie should be considered stale. If you do not specify this parameter, the default value is 0, which indicates that the sticky session should last for the duration of the browser session.
        public let cookieExpirationPeriod: Int64?
        /// The name of the policy being created. Policy names must consist of alphanumeric characters and dashes (-). This name must be unique within the set of policies for this load balancer.
        public let policyName: String

        public init(loadBalancerName: String, cookieExpirationPeriod: Int64? = nil, policyName: String) {
            self.loadBalancerName = loadBalancerName
            self.cookieExpirationPeriod = cookieExpirationPeriod
            self.policyName = policyName
        }

        public init(dictionary: [String: Any]) throws {
            guard let loadBalancerName = dictionary["LoadBalancerName"] as? String else { throw InitializableError.missingRequiredParam("LoadBalancerName") }
            self.loadBalancerName = loadBalancerName
            self.cookieExpirationPeriod = dictionary["CookieExpirationPeriod"] as? Int64
            guard let policyName = dictionary["PolicyName"] as? String else { throw InitializableError.missingRequiredParam("PolicyName") }
            self.policyName = policyName
        }
    }

    public struct RegisterEndPointsOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The updated list of instances for the load balancer.
        public let instances: [Instance]?

        public init(instances: [Instance]? = nil) {
            self.instances = instances
        }

        public init(dictionary: [String: Any]) throws {
            if let instances = dictionary["Instances"] as? [[String: Any]] {
                self.instances = try instances.map({ try Instance(dictionary: $0) })
            } else { 
                self.instances = nil
            }
        }
    }

    public struct Policies: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The stickiness policies created using CreateAppCookieStickinessPolicy.
        public let appCookieStickinessPolicies: [AppCookieStickinessPolicy]?
        /// The policies other than the stickiness policies.
        public let otherPolicies: [String]?
        /// The stickiness policies created using CreateLBCookieStickinessPolicy.
        public let lBCookieStickinessPolicies: [LBCookieStickinessPolicy]?

        public init(appCookieStickinessPolicies: [AppCookieStickinessPolicy]? = nil, otherPolicies: [String]? = nil, lBCookieStickinessPolicies: [LBCookieStickinessPolicy]? = nil) {
            self.appCookieStickinessPolicies = appCookieStickinessPolicies
            self.otherPolicies = otherPolicies
            self.lBCookieStickinessPolicies = lBCookieStickinessPolicies
        }

        public init(dictionary: [String: Any]) throws {
            if let appCookieStickinessPolicies = dictionary["AppCookieStickinessPolicies"] as? [[String: Any]] {
                self.appCookieStickinessPolicies = try appCookieStickinessPolicies.map({ try AppCookieStickinessPolicy(dictionary: $0) })
            } else { 
                self.appCookieStickinessPolicies = nil
            }
            self.otherPolicies = dictionary["OtherPolicies"] as? [String]
            if let lBCookieStickinessPolicies = dictionary["LBCookieStickinessPolicies"] as? [[String: Any]] {
                self.lBCookieStickinessPolicies = try lBCookieStickinessPolicies.map({ try LBCookieStickinessPolicy(dictionary: $0) })
            } else { 
                self.lBCookieStickinessPolicies = nil
            }
        }
    }

    public struct DescribeLoadBalancerAttributesInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the load balancer.
        public let loadBalancerName: String

        public init(loadBalancerName: String) {
            self.loadBalancerName = loadBalancerName
        }

        public init(dictionary: [String: Any]) throws {
            guard let loadBalancerName = dictionary["LoadBalancerName"] as? String else { throw InitializableError.missingRequiredParam("LoadBalancerName") }
            self.loadBalancerName = loadBalancerName
        }
    }

    public struct DescribeTagsOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the tags.
        public let tagDescriptions: [TagDescription]?

        public init(tagDescriptions: [TagDescription]? = nil) {
            self.tagDescriptions = tagDescriptions
        }

        public init(dictionary: [String: Any]) throws {
            if let tagDescriptions = dictionary["TagDescriptions"] as? [[String: Any]] {
                self.tagDescriptions = try tagDescriptions.map({ try TagDescription(dictionary: $0) })
            } else { 
                self.tagDescriptions = nil
            }
        }
    }

    public struct PolicyAttribute: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the attribute.
        public let attributeName: String?
        /// The value of the attribute.
        public let attributeValue: String?

        public init(attributeName: String? = nil, attributeValue: String? = nil) {
            self.attributeName = attributeName
            self.attributeValue = attributeValue
        }

        public init(dictionary: [String: Any]) throws {
            self.attributeName = dictionary["AttributeName"] as? String
            self.attributeValue = dictionary["AttributeValue"] as? String
        }
    }

    public struct RegisterEndPointsInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the load balancer.
        public let loadBalancerName: String
        /// The IDs of the instances.
        public let instances: [Instance]

        public init(loadBalancerName: String, instances: [Instance]) {
            self.loadBalancerName = loadBalancerName
            self.instances = instances
        }

        public init(dictionary: [String: Any]) throws {
            guard let loadBalancerName = dictionary["LoadBalancerName"] as? String else { throw InitializableError.missingRequiredParam("LoadBalancerName") }
            self.loadBalancerName = loadBalancerName
            guard let instances = dictionary["Instances"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("Instances") }
            self.instances = try instances.map({ try Instance(dictionary: $0) })
        }
    }

    public struct AddTagsOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct DeleteLoadBalancerPolicyOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct HealthCheck: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The instance being checked. The protocol is either TCP, HTTP, HTTPS, or SSL. The range of valid ports is one (1) through 65535. TCP is the default, specified as a TCP: port pair, for example "TCP:5000". In this case, a health check simply attempts to open a TCP connection to the instance on the specified port. Failure to connect within the configured timeout is considered unhealthy. SSL is also specified as SSL: port pair, for example, SSL:5000. For HTTP/HTTPS, you must include a ping path in the string. HTTP is specified as a HTTP:port;/;PathToPing; grouping, for example "HTTP:80/weather/us/wa/seattle". In this case, a HTTP GET request is issued to the instance on the given port and path. Any answer other than "200 OK" within the timeout period is considered unhealthy. The total length of the HTTP ping target must be 1024 16-bit Unicode characters or less.
        public let target: String
        /// The number of consecutive health check failures required before moving the instance to the Unhealthy state.
        public let unhealthyThreshold: Int32
        /// The number of consecutive health checks successes required before moving the instance to the Healthy state.
        public let healthyThreshold: Int32
        /// The approximate interval, in seconds, between health checks of an individual instance.
        public let interval: Int32
        /// The amount of time, in seconds, during which no response means a failed health check. This value must be less than the Interval value.
        public let timeout: Int32

        public init(target: String, unhealthyThreshold: Int32, healthyThreshold: Int32, interval: Int32, timeout: Int32) {
            self.target = target
            self.unhealthyThreshold = unhealthyThreshold
            self.healthyThreshold = healthyThreshold
            self.interval = interval
            self.timeout = timeout
        }

        public init(dictionary: [String: Any]) throws {
            guard let target = dictionary["Target"] as? String else { throw InitializableError.missingRequiredParam("Target") }
            self.target = target
            guard let unhealthyThreshold = dictionary["UnhealthyThreshold"] as? Int32 else { throw InitializableError.missingRequiredParam("UnhealthyThreshold") }
            self.unhealthyThreshold = unhealthyThreshold
            guard let healthyThreshold = dictionary["HealthyThreshold"] as? Int32 else { throw InitializableError.missingRequiredParam("HealthyThreshold") }
            self.healthyThreshold = healthyThreshold
            guard let interval = dictionary["Interval"] as? Int32 else { throw InitializableError.missingRequiredParam("Interval") }
            self.interval = interval
            guard let timeout = dictionary["Timeout"] as? Int32 else { throw InitializableError.missingRequiredParam("Timeout") }
            self.timeout = timeout
        }
    }

    public struct ModifyLoadBalancerAttributesOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the load balancer.
        public let loadBalancerName: String?
        public let loadBalancerAttributes: LoadBalancerAttributes?

        public init(loadBalancerName: String? = nil, loadBalancerAttributes: LoadBalancerAttributes? = nil) {
            self.loadBalancerName = loadBalancerName
            self.loadBalancerAttributes = loadBalancerAttributes
        }

        public init(dictionary: [String: Any]) throws {
            self.loadBalancerName = dictionary["LoadBalancerName"] as? String
            if let loadBalancerAttributes = dictionary["LoadBalancerAttributes"] as? [String: Any] { self.loadBalancerAttributes = try Elasticloadbalancing.LoadBalancerAttributes(dictionary: loadBalancerAttributes) } else { self.loadBalancerAttributes = nil }
        }
    }

    public struct PolicyDescription: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the policy type.
        public let policyTypeName: String?
        /// The policy attributes.
        public let policyAttributeDescriptions: [PolicyAttributeDescription]?
        /// The name of the policy.
        public let policyName: String?

        public init(policyTypeName: String? = nil, policyAttributeDescriptions: [PolicyAttributeDescription]? = nil, policyName: String? = nil) {
            self.policyTypeName = policyTypeName
            self.policyAttributeDescriptions = policyAttributeDescriptions
            self.policyName = policyName
        }

        public init(dictionary: [String: Any]) throws {
            self.policyTypeName = dictionary["PolicyTypeName"] as? String
            if let policyAttributeDescriptions = dictionary["PolicyAttributeDescriptions"] as? [[String: Any]] {
                self.policyAttributeDescriptions = try policyAttributeDescriptions.map({ try PolicyAttributeDescription(dictionary: $0) })
            } else { 
                self.policyAttributeDescriptions = nil
            }
            self.policyName = dictionary["PolicyName"] as? String
        }
    }

    public struct CreateAppCookieStickinessPolicyInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the application cookie used for stickiness.
        public let cookieName: String
        /// The name of the load balancer.
        public let loadBalancerName: String
        /// The name of the policy being created. Policy names must consist of alphanumeric characters and dashes (-). This name must be unique within the set of policies for this load balancer.
        public let policyName: String

        public init(cookieName: String, loadBalancerName: String, policyName: String) {
            self.cookieName = cookieName
            self.loadBalancerName = loadBalancerName
            self.policyName = policyName
        }

        public init(dictionary: [String: Any]) throws {
            guard let cookieName = dictionary["CookieName"] as? String else { throw InitializableError.missingRequiredParam("CookieName") }
            self.cookieName = cookieName
            guard let loadBalancerName = dictionary["LoadBalancerName"] as? String else { throw InitializableError.missingRequiredParam("LoadBalancerName") }
            self.loadBalancerName = loadBalancerName
            guard let policyName = dictionary["PolicyName"] as? String else { throw InitializableError.missingRequiredParam("PolicyName") }
            self.policyName = policyName
        }
    }

    public struct DescribeLoadBalancerPoliciesOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the policies.
        public let policyDescriptions: [PolicyDescription]?

        public init(policyDescriptions: [PolicyDescription]? = nil) {
            self.policyDescriptions = policyDescriptions
        }

        public init(dictionary: [String: Any]) throws {
            if let policyDescriptions = dictionary["PolicyDescriptions"] as? [[String: Any]] {
                self.policyDescriptions = try policyDescriptions.map({ try PolicyDescription(dictionary: $0) })
            } else { 
                self.policyDescriptions = nil
            }
        }
    }

    public struct DeleteAccessPointInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the load balancer.
        public let loadBalancerName: String

        public init(loadBalancerName: String) {
            self.loadBalancerName = loadBalancerName
        }

        public init(dictionary: [String: Any]) throws {
            guard let loadBalancerName = dictionary["LoadBalancerName"] as? String else { throw InitializableError.missingRequiredParam("LoadBalancerName") }
            self.loadBalancerName = loadBalancerName
        }
    }

    public struct PolicyTypeDescription: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the policy type.
        public let policyTypeName: String?
        /// The description of the policy attributes associated with the policies defined by Elastic Load Balancing.
        public let policyAttributeTypeDescriptions: [PolicyAttributeTypeDescription]?
        /// A description of the policy type.
        public let description: String?

        public init(policyTypeName: String? = nil, policyAttributeTypeDescriptions: [PolicyAttributeTypeDescription]? = nil, description: String? = nil) {
            self.policyTypeName = policyTypeName
            self.policyAttributeTypeDescriptions = policyAttributeTypeDescriptions
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.policyTypeName = dictionary["PolicyTypeName"] as? String
            if let policyAttributeTypeDescriptions = dictionary["PolicyAttributeTypeDescriptions"] as? [[String: Any]] {
                self.policyAttributeTypeDescriptions = try policyAttributeTypeDescriptions.map({ try PolicyAttributeTypeDescription(dictionary: $0) })
            } else { 
                self.policyAttributeTypeDescriptions = nil
            }
            self.description = dictionary["Description"] as? String
        }
    }

    public struct DetachLoadBalancerFromSubnetsOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IDs of the remaining subnets for the load balancer.
        public let subnets: [String]?

        public init(subnets: [String]? = nil) {
            self.subnets = subnets
        }

        public init(dictionary: [String: Any]) throws {
            self.subnets = dictionary["Subnets"] as? [String]
        }
    }

    public struct ConfigureHealthCheckOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The updated health check.
        public let healthCheck: HealthCheck?

        public init(healthCheck: HealthCheck? = nil) {
            self.healthCheck = healthCheck
        }

        public init(dictionary: [String: Any]) throws {
            if let healthCheck = dictionary["HealthCheck"] as? [String: Any] { self.healthCheck = try Elasticloadbalancing.HealthCheck(dictionary: healthCheck) } else { self.healthCheck = nil }
        }
    }

    public struct DescribeLoadBalancerPolicyTypesInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The names of the policy types. If no names are specified, describes all policy types defined by Elastic Load Balancing.
        public let policyTypeNames: [String]?

        public init(policyTypeNames: [String]? = nil) {
            self.policyTypeNames = policyTypeNames
        }

        public init(dictionary: [String: Any]) throws {
            self.policyTypeNames = dictionary["PolicyTypeNames"] as? [String]
        }
    }

    public struct CreateAccessPointInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more Availability Zones from the same region as the load balancer. You must specify at least one Availability Zone. You can add more Availability Zones after you create the load balancer using EnableAvailabilityZonesForLoadBalancer.
        public let availabilityZones: [String]?
        /// The IDs of the security groups to assign to the load balancer.
        public let securityGroups: [String]?
        /// The listeners. For more information, see Listeners for Your Classic Load Balancer in the Classic Load Balancers Guide.
        public let listeners: [Listener]
        /// A list of tags to assign to the load balancer. For more information about tagging your load balancer, see Tag Your Classic Load Balancer in the Classic Load Balancers Guide.
        public let tags: [Tag]?
        /// The IDs of the subnets in your VPC to attach to the load balancer. Specify one subnet per Availability Zone specified in AvailabilityZones.
        public let subnets: [String]?
        /// The type of a load balancer. Valid only for load balancers in a VPC. By default, Elastic Load Balancing creates an Internet-facing load balancer with a DNS name that resolves to public IP addresses. For more information about Internet-facing and Internal load balancers, see Load Balancer Scheme in the Elastic Load Balancing User Guide. Specify internal to create a load balancer with a DNS name that resolves to private IP addresses.
        public let scheme: String?
        /// The name of the load balancer. This name must be unique within your set of load balancers for the region, must have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, and cannot begin or end with a hyphen.
        public let loadBalancerName: String

        public init(availabilityZones: [String]? = nil, securityGroups: [String]? = nil, listeners: [Listener], tags: [Tag]? = nil, subnets: [String]? = nil, scheme: String? = nil, loadBalancerName: String) {
            self.availabilityZones = availabilityZones
            self.securityGroups = securityGroups
            self.listeners = listeners
            self.tags = tags
            self.subnets = subnets
            self.scheme = scheme
            self.loadBalancerName = loadBalancerName
        }

        public init(dictionary: [String: Any]) throws {
            self.availabilityZones = dictionary["AvailabilityZones"] as? [String]
            self.securityGroups = dictionary["SecurityGroups"] as? [String]
            guard let listeners = dictionary["Listeners"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("Listeners") }
            self.listeners = try listeners.map({ try Listener(dictionary: $0) })
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            } else { 
                self.tags = nil
            }
            self.subnets = dictionary["Subnets"] as? [String]
            self.scheme = dictionary["Scheme"] as? String
            guard let loadBalancerName = dictionary["LoadBalancerName"] as? String else { throw InitializableError.missingRequiredParam("LoadBalancerName") }
            self.loadBalancerName = loadBalancerName
        }
    }

    public struct SetLoadBalancerPoliciesForBackendServerOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct CreateLoadBalancerListenerOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct SetLoadBalancerListenerSSLCertificateOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct DescribeLoadBalancerPoliciesInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the load balancer.
        public let loadBalancerName: String?
        /// The names of the policies.
        public let policyNames: [String]?

        public init(loadBalancerName: String? = nil, policyNames: [String]? = nil) {
            self.loadBalancerName = loadBalancerName
            self.policyNames = policyNames
        }

        public init(dictionary: [String: Any]) throws {
            self.loadBalancerName = dictionary["LoadBalancerName"] as? String
            self.policyNames = dictionary["PolicyNames"] as? [String]
        }
    }

    public struct DeleteLoadBalancerListenerInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The client port numbers of the listeners.
        public let loadBalancerPorts: [Int32]
        /// The name of the load balancer.
        public let loadBalancerName: String

        public init(loadBalancerPorts: [Int32], loadBalancerName: String) {
            self.loadBalancerPorts = loadBalancerPorts
            self.loadBalancerName = loadBalancerName
        }

        public init(dictionary: [String: Any]) throws {
            guard let loadBalancerPorts = dictionary["LoadBalancerPorts"] as? [Int32] else { throw InitializableError.missingRequiredParam("LoadBalancerPorts") }
            self.loadBalancerPorts = loadBalancerPorts
            guard let loadBalancerName = dictionary["LoadBalancerName"] as? String else { throw InitializableError.missingRequiredParam("LoadBalancerName") }
            self.loadBalancerName = loadBalancerName
        }
    }

    public struct CreateLoadBalancerPolicyOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct InstanceState: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the cause of OutOfService instances. Specifically, whether the cause is Elastic Load Balancing or the instance. Valid values: ELB | Instance | N/A 
        public let reasonCode: String?
        /// The ID of the instance.
        public let instanceId: String?
        /// The current state of the instance. Valid values: InService | OutOfService | Unknown 
        public let state: String?
        /// A description of the instance state. This string can contain one or more of the following messages.    N/A     A transient error occurred. Please try again later.     Instance has failed at least the UnhealthyThreshold number of health checks consecutively.     Instance has not passed the configured HealthyThreshold number of health checks consecutively.     Instance registration is still in progress.     Instance is in the EC2 Availability Zone for which LoadBalancer is not configured to route traffic to.     Instance is not currently registered with the LoadBalancer.     Instance deregistration currently in progress.     Disable Availability Zone is currently in progress.     Instance is in pending state.     Instance is in stopped state.     Instance is in terminated state.   
        public let description: String?

        public init(reasonCode: String? = nil, instanceId: String? = nil, state: String? = nil, description: String? = nil) {
            self.reasonCode = reasonCode
            self.instanceId = instanceId
            self.state = state
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.reasonCode = dictionary["ReasonCode"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            self.state = dictionary["State"] as? String
            self.description = dictionary["Description"] as? String
        }
    }

    public struct DeregisterEndPointsInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the load balancer.
        public let loadBalancerName: String
        /// The IDs of the instances.
        public let instances: [Instance]

        public init(loadBalancerName: String, instances: [Instance]) {
            self.loadBalancerName = loadBalancerName
            self.instances = instances
        }

        public init(dictionary: [String: Any]) throws {
            guard let loadBalancerName = dictionary["LoadBalancerName"] as? String else { throw InitializableError.missingRequiredParam("LoadBalancerName") }
            self.loadBalancerName = loadBalancerName
            guard let instances = dictionary["Instances"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("Instances") }
            self.instances = try instances.map({ try Instance(dictionary: $0) })
        }
    }

    public struct DeleteAccessPointOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct DescribeTagsInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The names of the load balancers.
        public let loadBalancerNames: [String]

        public init(loadBalancerNames: [String]) {
            self.loadBalancerNames = loadBalancerNames
        }

        public init(dictionary: [String: Any]) throws {
            guard let loadBalancerNames = dictionary["LoadBalancerNames"] as? [String] else { throw InitializableError.missingRequiredParam("LoadBalancerNames") }
            self.loadBalancerNames = loadBalancerNames
        }
    }

    public struct ApplySecurityGroupsToLoadBalancerOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IDs of the security groups associated with the load balancer.
        public let securityGroups: [String]?

        public init(securityGroups: [String]? = nil) {
            self.securityGroups = securityGroups
        }

        public init(dictionary: [String: Any]) throws {
            self.securityGroups = dictionary["SecurityGroups"] as? [String]
        }
    }

    public struct CrossZoneLoadBalancing: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Specifies whether cross-zone load balancing is enabled for the load balancer.
        public let enabled: Bool

        public init(enabled: Bool) {
            self.enabled = enabled
        }

        public init(dictionary: [String: Any]) throws {
            guard let enabled = dictionary["Enabled"] as? Bool else { throw InitializableError.missingRequiredParam("Enabled") }
            self.enabled = enabled
        }
    }

    public struct DescribeLoadBalancerAttributesOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the load balancer attributes.
        public let loadBalancerAttributes: LoadBalancerAttributes?

        public init(loadBalancerAttributes: LoadBalancerAttributes? = nil) {
            self.loadBalancerAttributes = loadBalancerAttributes
        }

        public init(dictionary: [String: Any]) throws {
            if let loadBalancerAttributes = dictionary["LoadBalancerAttributes"] as? [String: Any] { self.loadBalancerAttributes = try Elasticloadbalancing.LoadBalancerAttributes(dictionary: loadBalancerAttributes) } else { self.loadBalancerAttributes = nil }
        }
    }

    public struct LBCookieStickinessPolicy: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The time period, in seconds, after which the cookie should be considered stale. If this parameter is not specified, the stickiness session lasts for the duration of the browser session.
        public let cookieExpirationPeriod: Int64?
        /// The name of the policy. This name must be unique within the set of policies for this load balancer.
        public let policyName: String?

        public init(cookieExpirationPeriod: Int64? = nil, policyName: String? = nil) {
            self.cookieExpirationPeriod = cookieExpirationPeriod
            self.policyName = policyName
        }

        public init(dictionary: [String: Any]) throws {
            self.cookieExpirationPeriod = dictionary["CookieExpirationPeriod"] as? Int64
            self.policyName = dictionary["PolicyName"] as? String
        }
    }

    public struct ConnectionSettings: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The time, in seconds, that the connection is allowed to be idle (no data has been sent over the connection) before it is closed by the load balancer.
        public let idleTimeout: Int32

        public init(idleTimeout: Int32) {
            self.idleTimeout = idleTimeout
        }

        public init(dictionary: [String: Any]) throws {
            guard let idleTimeout = dictionary["IdleTimeout"] as? Int32 else { throw InitializableError.missingRequiredParam("IdleTimeout") }
            self.idleTimeout = idleTimeout
        }
    }

    public struct SetLoadBalancerPoliciesForBackendServerInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The names of the policies. If the list is empty, then all current polices are removed from the EC2 instance.
        public let policyNames: [String]
        /// The name of the load balancer.
        public let loadBalancerName: String
        /// The port number associated with the EC2 instance.
        public let instancePort: Int32

        public init(policyNames: [String], loadBalancerName: String, instancePort: Int32) {
            self.policyNames = policyNames
            self.loadBalancerName = loadBalancerName
            self.instancePort = instancePort
        }

        public init(dictionary: [String: Any]) throws {
            guard let policyNames = dictionary["PolicyNames"] as? [String] else { throw InitializableError.missingRequiredParam("PolicyNames") }
            self.policyNames = policyNames
            guard let loadBalancerName = dictionary["LoadBalancerName"] as? String else { throw InitializableError.missingRequiredParam("LoadBalancerName") }
            self.loadBalancerName = loadBalancerName
            guard let instancePort = dictionary["InstancePort"] as? Int32 else { throw InitializableError.missingRequiredParam("InstancePort") }
            self.instancePort = instancePort
        }
    }

    public struct DescribeLoadBalancerPolicyTypesOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the policy types.
        public let policyTypeDescriptions: [PolicyTypeDescription]?

        public init(policyTypeDescriptions: [PolicyTypeDescription]? = nil) {
            self.policyTypeDescriptions = policyTypeDescriptions
        }

        public init(dictionary: [String: Any]) throws {
            if let policyTypeDescriptions = dictionary["PolicyTypeDescriptions"] as? [[String: Any]] {
                self.policyTypeDescriptions = try policyTypeDescriptions.map({ try PolicyTypeDescription(dictionary: $0) })
            } else { 
                self.policyTypeDescriptions = nil
            }
        }
    }

    public struct DescribeEndPointStateOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the health of the instances.
        public let instanceStates: [InstanceState]?

        public init(instanceStates: [InstanceState]? = nil) {
            self.instanceStates = instanceStates
        }

        public init(dictionary: [String: Any]) throws {
            if let instanceStates = dictionary["InstanceStates"] as? [[String: Any]] {
                self.instanceStates = try instanceStates.map({ try InstanceState(dictionary: $0) })
            } else { 
                self.instanceStates = nil
            }
        }
    }

    public struct DeleteLoadBalancerListenerOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct SourceSecurityGroup: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The owner of the security group.
        public let ownerAlias: String?
        /// The name of the security group.
        public let groupName: String?

        public init(ownerAlias: String? = nil, groupName: String? = nil) {
            self.ownerAlias = ownerAlias
            self.groupName = groupName
        }

        public init(dictionary: [String: Any]) throws {
            self.ownerAlias = dictionary["OwnerAlias"] as? String
            self.groupName = dictionary["GroupName"] as? String
        }
    }

    public struct RemoveTagsOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct RemoveAvailabilityZonesOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The remaining Availability Zones for the load balancer.
        public let availabilityZones: [String]?

        public init(availabilityZones: [String]? = nil) {
            self.availabilityZones = availabilityZones
        }

        public init(dictionary: [String: Any]) throws {
            self.availabilityZones = dictionary["AvailabilityZones"] as? [String]
        }
    }

    public struct AppCookieStickinessPolicy: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the application cookie used for stickiness.
        public let cookieName: String?
        /// The mnemonic name for the policy being created. The name must be unique within a set of policies for this load balancer.
        public let policyName: String?

        public init(cookieName: String? = nil, policyName: String? = nil) {
            self.cookieName = cookieName
            self.policyName = policyName
        }

        public init(dictionary: [String: Any]) throws {
            self.cookieName = dictionary["CookieName"] as? String
            self.policyName = dictionary["PolicyName"] as? String
        }
    }

    public struct AddTagsInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the load balancer. You can specify one load balancer only.
        public let loadBalancerNames: [String]
        /// The tags.
        public let tags: [Tag]

        public init(loadBalancerNames: [String], tags: [Tag]) {
            self.loadBalancerNames = loadBalancerNames
            self.tags = tags
        }

        public init(dictionary: [String: Any]) throws {
            guard let loadBalancerNames = dictionary["LoadBalancerNames"] as? [String] else { throw InitializableError.missingRequiredParam("LoadBalancerNames") }
            self.loadBalancerNames = loadBalancerNames
            guard let tags = dictionary["Tags"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("Tags") }
            self.tags = try tags.map({ try Tag(dictionary: $0) })
        }
    }

    public struct CreateLoadBalancerPolicyInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The policy attributes.
        public let policyAttributes: [PolicyAttribute]?
        /// The name of the base policy type. To get the list of policy types, use DescribeLoadBalancerPolicyTypes.
        public let policyTypeName: String
        /// The name of the load balancer.
        public let loadBalancerName: String
        /// The name of the load balancer policy to be created. This name must be unique within the set of policies for this load balancer.
        public let policyName: String

        public init(policyAttributes: [PolicyAttribute]? = nil, policyTypeName: String, loadBalancerName: String, policyName: String) {
            self.policyAttributes = policyAttributes
            self.policyTypeName = policyTypeName
            self.loadBalancerName = loadBalancerName
            self.policyName = policyName
        }

        public init(dictionary: [String: Any]) throws {
            if let policyAttributes = dictionary["PolicyAttributes"] as? [[String: Any]] {
                self.policyAttributes = try policyAttributes.map({ try PolicyAttribute(dictionary: $0) })
            } else { 
                self.policyAttributes = nil
            }
            guard let policyTypeName = dictionary["PolicyTypeName"] as? String else { throw InitializableError.missingRequiredParam("PolicyTypeName") }
            self.policyTypeName = policyTypeName
            guard let loadBalancerName = dictionary["LoadBalancerName"] as? String else { throw InitializableError.missingRequiredParam("LoadBalancerName") }
            self.loadBalancerName = loadBalancerName
            guard let policyName = dictionary["PolicyName"] as? String else { throw InitializableError.missingRequiredParam("PolicyName") }
            self.policyName = policyName
        }
    }

    public struct CreateAppCookieStickinessPolicyOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct AttachLoadBalancerToSubnetsOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IDs of the subnets attached to the load balancer.
        public let subnets: [String]?

        public init(subnets: [String]? = nil) {
            self.subnets = subnets
        }

        public init(dictionary: [String: Any]) throws {
            self.subnets = dictionary["Subnets"] as? [String]
        }
    }

    public struct ConfigureHealthCheckInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the load balancer.
        public let loadBalancerName: String
        /// The configuration information.
        public let healthCheck: HealthCheck

        public init(loadBalancerName: String, healthCheck: HealthCheck) {
            self.loadBalancerName = loadBalancerName
            self.healthCheck = healthCheck
        }

        public init(dictionary: [String: Any]) throws {
            guard let loadBalancerName = dictionary["LoadBalancerName"] as? String else { throw InitializableError.missingRequiredParam("LoadBalancerName") }
            self.loadBalancerName = loadBalancerName
            guard let healthCheck = dictionary["HealthCheck"] as? [String: Any] else { throw InitializableError.missingRequiredParam("HealthCheck") }
            self.healthCheck = try Elasticloadbalancing.HealthCheck(dictionary: healthCheck)
        }
    }

    public struct BackendServerDescription: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The names of the policies enabled for the EC2 instance.
        public let policyNames: [String]?
        /// The port on which the EC2 instance is listening.
        public let instancePort: Int32?

        public init(policyNames: [String]? = nil, instancePort: Int32? = nil) {
            self.policyNames = policyNames
            self.instancePort = instancePort
        }

        public init(dictionary: [String: Any]) throws {
            self.policyNames = dictionary["PolicyNames"] as? [String]
            self.instancePort = dictionary["InstancePort"] as? Int32
        }
    }

    public struct LoadBalancerDescription: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Availability Zones for the load balancer.
        public let availabilityZones: [String]?
        /// The ID of the VPC for the load balancer.
        public let vPCId: String?
        /// Information about your EC2 instances.
        public let backendServerDescriptions: [BackendServerDescription]?
        /// The IDs of the subnets for the load balancer.
        public let subnets: [String]?
        /// The policies defined for the load balancer.
        public let policies: Policies?
        /// The ID of the Amazon Route 53 hosted zone for the load balancer.
        public let canonicalHostedZoneNameID: String?
        /// The DNS name of the load balancer.
        public let dNSName: String?
        /// The name of the load balancer.
        public let loadBalancerName: String?
        /// The date and time the load balancer was created.
        public let createdTime: Date?
        /// The DNS name of the load balancer. For more information, see Configure a Custom Domain Name in the Classic Load Balancers Guide.
        public let canonicalHostedZoneName: String?
        /// The security groups for the load balancer. Valid only for load balancers in a VPC.
        public let securityGroups: [String]?
        /// The listeners for the load balancer.
        public let listenerDescriptions: [ListenerDescription]?
        /// The security group for the load balancer, which you can use as part of your inbound rules for your registered instances. To only allow traffic from load balancers, add a security group rule that specifies this source security group as the inbound source.
        public let sourceSecurityGroup: SourceSecurityGroup?
        /// Information about the health checks conducted on the load balancer.
        public let healthCheck: HealthCheck?
        /// The IDs of the instances for the load balancer.
        public let instances: [Instance]?
        /// The type of load balancer. Valid only for load balancers in a VPC. If Scheme is internet-facing, the load balancer has a public DNS name that resolves to a public IP address. If Scheme is internal, the load balancer has a public DNS name that resolves to a private IP address.
        public let scheme: String?

        public init(availabilityZones: [String]? = nil, vPCId: String? = nil, backendServerDescriptions: [BackendServerDescription]? = nil, subnets: [String]? = nil, policies: Policies? = nil, canonicalHostedZoneNameID: String? = nil, dNSName: String? = nil, loadBalancerName: String? = nil, createdTime: Date? = nil, canonicalHostedZoneName: String? = nil, securityGroups: [String]? = nil, listenerDescriptions: [ListenerDescription]? = nil, sourceSecurityGroup: SourceSecurityGroup? = nil, healthCheck: HealthCheck? = nil, instances: [Instance]? = nil, scheme: String? = nil) {
            self.availabilityZones = availabilityZones
            self.vPCId = vPCId
            self.backendServerDescriptions = backendServerDescriptions
            self.subnets = subnets
            self.policies = policies
            self.canonicalHostedZoneNameID = canonicalHostedZoneNameID
            self.dNSName = dNSName
            self.loadBalancerName = loadBalancerName
            self.createdTime = createdTime
            self.canonicalHostedZoneName = canonicalHostedZoneName
            self.securityGroups = securityGroups
            self.listenerDescriptions = listenerDescriptions
            self.sourceSecurityGroup = sourceSecurityGroup
            self.healthCheck = healthCheck
            self.instances = instances
            self.scheme = scheme
        }

        public init(dictionary: [String: Any]) throws {
            self.availabilityZones = dictionary["AvailabilityZones"] as? [String]
            self.vPCId = dictionary["VPCId"] as? String
            if let backendServerDescriptions = dictionary["BackendServerDescriptions"] as? [[String: Any]] {
                self.backendServerDescriptions = try backendServerDescriptions.map({ try BackendServerDescription(dictionary: $0) })
            } else { 
                self.backendServerDescriptions = nil
            }
            self.subnets = dictionary["Subnets"] as? [String]
            if let policies = dictionary["Policies"] as? [String: Any] { self.policies = try Elasticloadbalancing.Policies(dictionary: policies) } else { self.policies = nil }
            self.canonicalHostedZoneNameID = dictionary["CanonicalHostedZoneNameID"] as? String
            self.dNSName = dictionary["DNSName"] as? String
            self.loadBalancerName = dictionary["LoadBalancerName"] as? String
            self.createdTime = dictionary["CreatedTime"] as? Date
            self.canonicalHostedZoneName = dictionary["CanonicalHostedZoneName"] as? String
            self.securityGroups = dictionary["SecurityGroups"] as? [String]
            if let listenerDescriptions = dictionary["ListenerDescriptions"] as? [[String: Any]] {
                self.listenerDescriptions = try listenerDescriptions.map({ try ListenerDescription(dictionary: $0) })
            } else { 
                self.listenerDescriptions = nil
            }
            if let sourceSecurityGroup = dictionary["SourceSecurityGroup"] as? [String: Any] { self.sourceSecurityGroup = try Elasticloadbalancing.SourceSecurityGroup(dictionary: sourceSecurityGroup) } else { self.sourceSecurityGroup = nil }
            if let healthCheck = dictionary["HealthCheck"] as? [String: Any] { self.healthCheck = try Elasticloadbalancing.HealthCheck(dictionary: healthCheck) } else { self.healthCheck = nil }
            if let instances = dictionary["Instances"] as? [[String: Any]] {
                self.instances = try instances.map({ try Instance(dictionary: $0) })
            } else { 
                self.instances = nil
            }
            self.scheme = dictionary["Scheme"] as? String
        }
    }

    public struct SetLoadBalancerListenerSSLCertificateInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the load balancer.
        public let loadBalancerName: String
        /// The port that uses the specified SSL certificate.
        public let loadBalancerPort: Int32
        /// The Amazon Resource Name (ARN) of the SSL certificate.
        public let sSLCertificateId: String

        public init(loadBalancerName: String, loadBalancerPort: Int32, sSLCertificateId: String) {
            self.loadBalancerName = loadBalancerName
            self.loadBalancerPort = loadBalancerPort
            self.sSLCertificateId = sSLCertificateId
        }

        public init(dictionary: [String: Any]) throws {
            guard let loadBalancerName = dictionary["LoadBalancerName"] as? String else { throw InitializableError.missingRequiredParam("LoadBalancerName") }
            self.loadBalancerName = loadBalancerName
            guard let loadBalancerPort = dictionary["LoadBalancerPort"] as? Int32 else { throw InitializableError.missingRequiredParam("LoadBalancerPort") }
            self.loadBalancerPort = loadBalancerPort
            guard let sSLCertificateId = dictionary["SSLCertificateId"] as? String else { throw InitializableError.missingRequiredParam("SSLCertificateId") }
            self.sSLCertificateId = sSLCertificateId
        }
    }

    public struct DescribeEndPointStateInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the load balancer.
        public let loadBalancerName: String
        /// The IDs of the instances.
        public let instances: [Instance]?

        public init(loadBalancerName: String, instances: [Instance]? = nil) {
            self.loadBalancerName = loadBalancerName
            self.instances = instances
        }

        public init(dictionary: [String: Any]) throws {
            guard let loadBalancerName = dictionary["LoadBalancerName"] as? String else { throw InitializableError.missingRequiredParam("LoadBalancerName") }
            self.loadBalancerName = loadBalancerName
            if let instances = dictionary["Instances"] as? [[String: Any]] {
                self.instances = try instances.map({ try Instance(dictionary: $0) })
            } else { 
                self.instances = nil
            }
        }
    }

    public struct RemoveTagsInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the load balancer. You can specify a maximum of one load balancer name.
        public let loadBalancerNames: [String]
        /// The list of tag keys to remove.
        public let tags: [TagKeyOnly]

        public init(loadBalancerNames: [String], tags: [TagKeyOnly]) {
            self.loadBalancerNames = loadBalancerNames
            self.tags = tags
        }

        public init(dictionary: [String: Any]) throws {
            guard let loadBalancerNames = dictionary["LoadBalancerNames"] as? [String] else { throw InitializableError.missingRequiredParam("LoadBalancerNames") }
            self.loadBalancerNames = loadBalancerNames
            guard let tags = dictionary["Tags"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("Tags") }
            self.tags = try tags.map({ try TagKeyOnly(dictionary: $0) })
        }
    }

}