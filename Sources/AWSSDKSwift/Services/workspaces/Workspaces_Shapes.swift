// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Workspaces {

    public struct CreateTagsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The resource ID of the request.
        public let resourceId: String
        /// The tags of the request.
        public let tags: [Tag]

        public init(resourceId: String, tags: [Tag]) {
            self.resourceId = resourceId
            self.tags = tags
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceId = dictionary["ResourceId"] as? String else { throw InitializableError.missingRequiredParam("ResourceId") }
            self.resourceId = resourceId
            guard let tags = dictionary["Tags"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("Tags") }
            self.tags = try tags.map({ try Tag(dictionary: $0) })
        }
    }

    public struct TerminateWorkspacesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of structures that specify the WorkSpaces to terminate.
        public let terminateWorkspaceRequests: [TerminateRequest]

        public init(terminateWorkspaceRequests: [TerminateRequest]) {
            self.terminateWorkspaceRequests = terminateWorkspaceRequests
        }

        public init(dictionary: [String: Any]) throws {
            guard let terminateWorkspaceRequests = dictionary["TerminateWorkspaceRequests"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("TerminateWorkspaceRequests") }
            self.terminateWorkspaceRequests = try terminateWorkspaceRequests.map({ try TerminateRequest(dictionary: $0) })
        }
    }

    public enum Compute: String, CustomStringConvertible {
        case value = "VALUE"
        case standard = "STANDARD"
        case performance = "PERFORMANCE"
        public var description: String { return self.rawValue }
    }

    public struct FailedCreateWorkspaceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The textual error message.
        public let errorMessage: String?
        /// A FailedCreateWorkspaceRequest$WorkspaceRequest object that contains the information about the WorkSpace that could not be created.
        public let workspaceRequest: WorkspaceRequest?
        /// The error code.
        public let errorCode: String?

        public init(errorMessage: String? = nil, workspaceRequest: WorkspaceRequest? = nil, errorCode: String? = nil) {
            self.errorMessage = errorMessage
            self.workspaceRequest = workspaceRequest
            self.errorCode = errorCode
        }

        public init(dictionary: [String: Any]) throws {
            self.errorMessage = dictionary["ErrorMessage"] as? String
            if let workspaceRequest = dictionary["WorkspaceRequest"] as? [String: Any] { self.workspaceRequest = try Workspaces.WorkspaceRequest(dictionary: workspaceRequest) } else { self.workspaceRequest = nil }
            self.errorCode = dictionary["ErrorCode"] as? String
        }
    }

    public struct DescribeWorkspaceBundlesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The owner of the bundles to retrieve. This parameter cannot be combined with any other filter parameter. This contains one of the following values:   null- Retrieves the bundles that belong to the account making the call.    AMAZON- Retrieves the bundles that are provided by AWS.  
        public let owner: String?
        /// The NextToken value from a previous call to this operation. Pass null if this is the first call.
        public let nextToken: String?
        /// An array of strings that contains the identifiers of the bundles to retrieve. This parameter cannot be combined with any other filter parameter.
        public let bundleIds: [String]?

        public init(owner: String? = nil, nextToken: String? = nil, bundleIds: [String]? = nil) {
            self.owner = owner
            self.nextToken = nextToken
            self.bundleIds = bundleIds
        }

        public init(dictionary: [String: Any]) throws {
            self.owner = dictionary["Owner"] as? String
            self.nextToken = dictionary["NextToken"] as? String
            self.bundleIds = dictionary["BundleIds"] as? [String]
        }
    }

    public struct UserStorage: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The amount of user storage for the bundle.
        public let capacity: String?

        public init(capacity: String? = nil) {
            self.capacity = capacity
        }

        public init(dictionary: [String: Any]) throws {
            self.capacity = dictionary["Capacity"] as? String
        }
    }

    public struct WorkspaceBundle: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The bundle description.
        public let description: String?
        /// A ComputeType object that specifies the compute type for the bundle.
        public let computeType: ComputeType?
        /// A UserStorage object that specifies the amount of user storage that the bundle contains.
        public let userStorage: UserStorage?
        /// The owner of the bundle. This contains the owner's account identifier, or AMAZON if the bundle is provided by AWS.
        public let owner: String?
        /// The name of the bundle.
        public let name: String?
        /// The bundle identifier.
        public let bundleId: String?

        public init(description: String? = nil, computeType: ComputeType? = nil, userStorage: UserStorage? = nil, owner: String? = nil, name: String? = nil, bundleId: String? = nil) {
            self.description = description
            self.computeType = computeType
            self.userStorage = userStorage
            self.owner = owner
            self.name = name
            self.bundleId = bundleId
        }

        public init(dictionary: [String: Any]) throws {
            self.description = dictionary["Description"] as? String
            if let computeType = dictionary["ComputeType"] as? [String: Any] { self.computeType = try Workspaces.ComputeType(dictionary: computeType) } else { self.computeType = nil }
            if let userStorage = dictionary["UserStorage"] as? [String: Any] { self.userStorage = try Workspaces.UserStorage(dictionary: userStorage) } else { self.userStorage = nil }
            self.owner = dictionary["Owner"] as? String
            self.name = dictionary["Name"] as? String
            self.bundleId = dictionary["BundleId"] as? String
        }
    }

    public struct RebootWorkspacesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of structures representing any WorkSpaces that could not be rebooted.
        public let failedRequests: [FailedWorkspaceChangeRequest]?

        public init(failedRequests: [FailedWorkspaceChangeRequest]? = nil) {
            self.failedRequests = failedRequests
        }

        public init(dictionary: [String: Any]) throws {
            if let failedRequests = dictionary["FailedRequests"] as? [[String: Any]] {
                self.failedRequests = try failedRequests.map({ try FailedWorkspaceChangeRequest(dictionary: $0) })
            } else { 
                self.failedRequests = nil
            }
        }
    }

    public struct DescribeTagsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The resource ID of the request.
        public let resourceId: String

        public init(resourceId: String) {
            self.resourceId = resourceId
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceId = dictionary["ResourceId"] as? String else { throw InitializableError.missingRequiredParam("ResourceId") }
            self.resourceId = resourceId
        }
    }

    public struct CreateWorkspacesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of structures that represent the WorkSpaces that could not be created.
        public let failedRequests: [FailedCreateWorkspaceRequest]?
        /// An array of structures that represent the WorkSpaces that were created. Because this operation is asynchronous, the identifier in WorkspaceId is not immediately available. If you immediately call DescribeWorkspaces with this identifier, no information will be returned.
        public let pendingRequests: [Workspace]?

        public init(failedRequests: [FailedCreateWorkspaceRequest]? = nil, pendingRequests: [Workspace]? = nil) {
            self.failedRequests = failedRequests
            self.pendingRequests = pendingRequests
        }

        public init(dictionary: [String: Any]) throws {
            if let failedRequests = dictionary["FailedRequests"] as? [[String: Any]] {
                self.failedRequests = try failedRequests.map({ try FailedCreateWorkspaceRequest(dictionary: $0) })
            } else { 
                self.failedRequests = nil
            }
            if let pendingRequests = dictionary["PendingRequests"] as? [[String: Any]] {
                self.pendingRequests = try pendingRequests.map({ try Workspace(dictionary: $0) })
            } else { 
                self.pendingRequests = nil
            }
        }
    }

    public struct CreateTagsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct RebootWorkspacesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of structures that specify the WorkSpaces to reboot.
        public let rebootWorkspaceRequests: [RebootRequest]

        public init(rebootWorkspaceRequests: [RebootRequest]) {
            self.rebootWorkspaceRequests = rebootWorkspaceRequests
        }

        public init(dictionary: [String: Any]) throws {
            guard let rebootWorkspaceRequests = dictionary["RebootWorkspaceRequests"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("RebootWorkspaceRequests") }
            self.rebootWorkspaceRequests = try rebootWorkspaceRequests.map({ try RebootRequest(dictionary: $0) })
        }
    }

    public struct Tag: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The value of the tag.
        public let value: String?
        /// The key of the tag.
        public let key: String

        public init(value: String? = nil, key: String) {
            self.value = value
            self.key = key
        }

        public init(dictionary: [String: Any]) throws {
            self.value = dictionary["Value"] as? String
            guard let key = dictionary["Key"] as? String else { throw InitializableError.missingRequiredParam("Key") }
            self.key = key
        }
    }

    public struct ModifyWorkspacePropertiesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct DescribeWorkspacesConnectionStatusResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The connection status of the WorkSpace.
        public let workspacesConnectionStatus: [WorkspaceConnectionStatus]?
        /// The next token of the result.
        public let nextToken: String?

        public init(workspacesConnectionStatus: [WorkspaceConnectionStatus]? = nil, nextToken: String? = nil) {
            self.workspacesConnectionStatus = workspacesConnectionStatus
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let workspacesConnectionStatus = dictionary["WorkspacesConnectionStatus"] as? [[String: Any]] {
                self.workspacesConnectionStatus = try workspacesConnectionStatus.map({ try WorkspaceConnectionStatus(dictionary: $0) })
            } else { 
                self.workspacesConnectionStatus = nil
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public enum WorkspaceDirectoryState: String, CustomStringConvertible {
        case registering = "REGISTERING"
        case registered = "REGISTERED"
        case deregistering = "DEREGISTERING"
        case deregistered = "DEREGISTERED"
        case error = "ERROR"
        public var description: String { return self.rawValue }
    }

    public enum RunningMode: String, CustomStringConvertible {
        case auto_stop = "AUTO_STOP"
        case always_on = "ALWAYS_ON"
        public var description: String { return self.rawValue }
    }

    public struct StartWorkspacesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The requests.
        public let startWorkspaceRequests: [StartRequest]

        public init(startWorkspaceRequests: [StartRequest]) {
            self.startWorkspaceRequests = startWorkspaceRequests
        }

        public init(dictionary: [String: Any]) throws {
            guard let startWorkspaceRequests = dictionary["StartWorkspaceRequests"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("StartWorkspaceRequests") }
            self.startWorkspaceRequests = try startWorkspaceRequests.map({ try StartRequest(dictionary: $0) })
        }
    }

    public enum WorkspaceState: String, CustomStringConvertible {
        case pending = "PENDING"
        case available = "AVAILABLE"
        case impaired = "IMPAIRED"
        case unhealthy = "UNHEALTHY"
        case rebooting = "REBOOTING"
        case starting = "STARTING"
        case rebuilding = "REBUILDING"
        case maintenance = "MAINTENANCE"
        case terminating = "TERMINATING"
        case terminated = "TERMINATED"
        case suspended = "SUSPENDED"
        case stopping = "STOPPING"
        case stopped = "STOPPED"
        case error = "ERROR"
        public var description: String { return self.rawValue }
    }

    public struct ComputeType: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the compute type for the bundle.
        public let name: Compute?

        public init(name: Compute? = nil) {
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            if let name = dictionary["Name"] as? String { self.name = Compute(rawValue: name) } else { self.name = nil }
        }
    }

    public struct FailedWorkspaceChangeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The textual error message.
        public let errorMessage: String?
        /// The error code.
        public let errorCode: String?
        /// The identifier of the WorkSpace.
        public let workspaceId: String?

        public init(errorMessage: String? = nil, errorCode: String? = nil, workspaceId: String? = nil) {
            self.errorMessage = errorMessage
            self.errorCode = errorCode
            self.workspaceId = workspaceId
        }

        public init(dictionary: [String: Any]) throws {
            self.errorMessage = dictionary["ErrorMessage"] as? String
            self.errorCode = dictionary["ErrorCode"] as? String
            self.workspaceId = dictionary["WorkspaceId"] as? String
        }
    }

    public struct StopRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the WorkSpace.
        public let workspaceId: String?

        public init(workspaceId: String? = nil) {
            self.workspaceId = workspaceId
        }

        public init(dictionary: [String: Any]) throws {
            self.workspaceId = dictionary["WorkspaceId"] as? String
        }
    }

    public struct StartRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the WorkSpace.
        public let workspaceId: String?

        public init(workspaceId: String? = nil) {
            self.workspaceId = workspaceId
        }

        public init(dictionary: [String: Any]) throws {
            self.workspaceId = dictionary["WorkspaceId"] as? String
        }
    }

    public struct DefaultWorkspaceCreationProperties: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The organizational unit (OU) in the directory that the WorkSpace machine accounts are placed in.
        public let defaultOu: String?
        /// The identifier of any custom security groups that are applied to the WorkSpaces when they are created.
        public let customSecurityGroupId: String?
        /// A public IP address will be attached to all WorkSpaces that are created or rebuilt.
        public let enableInternetAccess: Bool?
        /// The WorkSpace user is an administrator on the WorkSpace.
        public let userEnabledAsLocalAdministrator: Bool?
        /// Specifies if the directory is enabled for Amazon WorkDocs.
        public let enableWorkDocs: Bool?

        public init(defaultOu: String? = nil, customSecurityGroupId: String? = nil, enableInternetAccess: Bool? = nil, userEnabledAsLocalAdministrator: Bool? = nil, enableWorkDocs: Bool? = nil) {
            self.defaultOu = defaultOu
            self.customSecurityGroupId = customSecurityGroupId
            self.enableInternetAccess = enableInternetAccess
            self.userEnabledAsLocalAdministrator = userEnabledAsLocalAdministrator
            self.enableWorkDocs = enableWorkDocs
        }

        public init(dictionary: [String: Any]) throws {
            self.defaultOu = dictionary["DefaultOu"] as? String
            self.customSecurityGroupId = dictionary["CustomSecurityGroupId"] as? String
            self.enableInternetAccess = dictionary["EnableInternetAccess"] as? Bool
            self.userEnabledAsLocalAdministrator = dictionary["UserEnabledAsLocalAdministrator"] as? Bool
            self.enableWorkDocs = dictionary["EnableWorkDocs"] as? Bool
        }
    }

    public struct StopWorkspacesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The requests.
        public let stopWorkspaceRequests: [StopRequest]

        public init(stopWorkspaceRequests: [StopRequest]) {
            self.stopWorkspaceRequests = stopWorkspaceRequests
        }

        public init(dictionary: [String: Any]) throws {
            guard let stopWorkspaceRequests = dictionary["StopWorkspaceRequests"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("StopWorkspaceRequests") }
            self.stopWorkspaceRequests = try stopWorkspaceRequests.map({ try StopRequest(dictionary: $0) })
        }
    }

    public struct DescribeWorkspacesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Specifies the directory identifier to which to limit the WorkSpaces. Optionally, you can specify a specific directory user with the UserName parameter. This parameter cannot be combined with any other filter parameter.
        public let directoryId: String?
        /// Used with the DirectoryId parameter to specify the directory user for whom to obtain the WorkSpace.
        public let userName: String?
        /// The maximum number of items to return.
        public let limit: Int32?
        /// The NextToken value from a previous call to this operation. Pass null if this is the first call.
        public let nextToken: String?
        /// An array of strings that contain the identifiers of the WorkSpaces for which to retrieve information. This parameter cannot be combined with any other filter parameter. Because the CreateWorkspaces operation is asynchronous, the identifier it returns is not immediately available. If you immediately call DescribeWorkspaces with this identifier, no information is returned.
        public let workspaceIds: [String]?
        /// The identifier of a bundle to obtain the WorkSpaces for. All WorkSpaces that are created from this bundle will be retrieved. This parameter cannot be combined with any other filter parameter.
        public let bundleId: String?

        public init(directoryId: String? = nil, userName: String? = nil, limit: Int32? = nil, nextToken: String? = nil, workspaceIds: [String]? = nil, bundleId: String? = nil) {
            self.directoryId = directoryId
            self.userName = userName
            self.limit = limit
            self.nextToken = nextToken
            self.workspaceIds = workspaceIds
            self.bundleId = bundleId
        }

        public init(dictionary: [String: Any]) throws {
            self.directoryId = dictionary["DirectoryId"] as? String
            self.userName = dictionary["UserName"] as? String
            self.limit = dictionary["Limit"] as? Int32
            self.nextToken = dictionary["NextToken"] as? String
            self.workspaceIds = dictionary["WorkspaceIds"] as? [String]
            self.bundleId = dictionary["BundleId"] as? String
        }
    }

    public struct RebuildWorkspacesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of structures representing any WorkSpaces that could not be rebuilt.
        public let failedRequests: [FailedWorkspaceChangeRequest]?

        public init(failedRequests: [FailedWorkspaceChangeRequest]? = nil) {
            self.failedRequests = failedRequests
        }

        public init(dictionary: [String: Any]) throws {
            if let failedRequests = dictionary["FailedRequests"] as? [[String: Any]] {
                self.failedRequests = try failedRequests.map({ try FailedWorkspaceChangeRequest(dictionary: $0) })
            } else { 
                self.failedRequests = nil
            }
        }
    }

    public struct RebootRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The identifier of the WorkSpace to reboot.
        public let workspaceId: String

        public init(workspaceId: String) {
            self.workspaceId = workspaceId
        }

        public init(dictionary: [String: Any]) throws {
            guard let workspaceId = dictionary["WorkspaceId"] as? String else { throw InitializableError.missingRequiredParam("WorkspaceId") }
            self.workspaceId = workspaceId
        }
    }

    public struct DescribeWorkspacesConnectionStatusRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of strings that contain the identifiers of the WorkSpaces.
        public let workspaceIds: [String]?
        /// The next token of the request.
        public let nextToken: String?

        public init(workspaceIds: [String]? = nil, nextToken: String? = nil) {
            self.workspaceIds = workspaceIds
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            self.workspaceIds = dictionary["WorkspaceIds"] as? [String]
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct WorkspaceConnectionStatus: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the WorkSpace.
        public let workspaceId: String?
        /// The connection state of the WorkSpace. Returns UNKOWN if the WorkSpace is in a Stopped state.
        public let connectionState: ConnectionState?
        /// The timestamp of the last known user connection.
        public let lastKnownUserConnectionTimestamp: Date?
        /// The timestamp of the connection state check.
        public let connectionStateCheckTimestamp: Date?

        public init(workspaceId: String? = nil, connectionState: ConnectionState? = nil, lastKnownUserConnectionTimestamp: Date? = nil, connectionStateCheckTimestamp: Date? = nil) {
            self.workspaceId = workspaceId
            self.connectionState = connectionState
            self.lastKnownUserConnectionTimestamp = lastKnownUserConnectionTimestamp
            self.connectionStateCheckTimestamp = connectionStateCheckTimestamp
        }

        public init(dictionary: [String: Any]) throws {
            self.workspaceId = dictionary["WorkspaceId"] as? String
            if let connectionState = dictionary["ConnectionState"] as? String { self.connectionState = ConnectionState(rawValue: connectionState) } else { self.connectionState = nil }
            self.lastKnownUserConnectionTimestamp = dictionary["LastKnownUserConnectionTimestamp"] as? Date
            self.connectionStateCheckTimestamp = dictionary["ConnectionStateCheckTimestamp"] as? Date
        }
    }

    public struct DescribeTagsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The list of tags.
        public let tagList: [Tag]?

        public init(tagList: [Tag]? = nil) {
            self.tagList = tagList
        }

        public init(dictionary: [String: Any]) throws {
            if let tagList = dictionary["TagList"] as? [[String: Any]] {
                self.tagList = try tagList.map({ try Tag(dictionary: $0) })
            } else { 
                self.tagList = nil
            }
        }
    }

    public enum ConnectionState: String, CustomStringConvertible {
        case connected = "CONNECTED"
        case disconnected = "DISCONNECTED"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public struct DescribeWorkspacesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// If not null, more results are available. Pass this value for the NextToken parameter in a subsequent call to this operation to retrieve the next set of items. This token is valid for one day and must be used within that time frame.
        public let nextToken: String?
        /// An array of structures that contain the information about the WorkSpaces. Because the CreateWorkspaces operation is asynchronous, some of this information may be incomplete for a newly-created WorkSpace.
        public let workspaces: [Workspace]?

        public init(nextToken: String? = nil, workspaces: [Workspace]? = nil) {
            self.nextToken = nextToken
            self.workspaces = workspaces
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let workspaces = dictionary["Workspaces"] as? [[String: Any]] {
                self.workspaces = try workspaces.map({ try Workspace(dictionary: $0) })
            } else { 
                self.workspaces = nil
            }
        }
    }

    public struct WorkspaceProperties: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The running mode of the WorkSpace. AlwaysOn WorkSpaces are billed monthly. AutoStop WorkSpaces are billed by the hour and stopped when no longer being used in order to save on costs.
        public let runningMode: RunningMode?
        /// The time after a user logs off when WorkSpaces are automatically stopped. Configured in 60 minute intervals.
        public let runningModeAutoStopTimeoutInMinutes: Int32?

        public init(runningMode: RunningMode? = nil, runningModeAutoStopTimeoutInMinutes: Int32? = nil) {
            self.runningMode = runningMode
            self.runningModeAutoStopTimeoutInMinutes = runningModeAutoStopTimeoutInMinutes
        }

        public init(dictionary: [String: Any]) throws {
            if let runningMode = dictionary["RunningMode"] as? String { self.runningMode = RunningMode(rawValue: runningMode) } else { self.runningMode = nil }
            self.runningModeAutoStopTimeoutInMinutes = dictionary["RunningModeAutoStopTimeoutInMinutes"] as? Int32
        }
    }

    public struct ModifyWorkspacePropertiesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the WorkSpace.
        public let workspaceId: String
        /// The WorkSpace properties of the request.
        public let workspaceProperties: WorkspaceProperties

        public init(workspaceId: String, workspaceProperties: WorkspaceProperties) {
            self.workspaceId = workspaceId
            self.workspaceProperties = workspaceProperties
        }

        public init(dictionary: [String: Any]) throws {
            guard let workspaceId = dictionary["WorkspaceId"] as? String else { throw InitializableError.missingRequiredParam("WorkspaceId") }
            self.workspaceId = workspaceId
            guard let workspaceProperties = dictionary["WorkspaceProperties"] as? [String: Any] else { throw InitializableError.missingRequiredParam("WorkspaceProperties") }
            self.workspaceProperties = try Workspaces.WorkspaceProperties(dictionary: workspaceProperties)
        }
    }

    public struct DescribeWorkspaceBundlesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// If not null, more results are available. Pass this value for the NextToken parameter in a subsequent call to this operation to retrieve the next set of items. This token is valid for one day and must be used within that time frame.
        public let nextToken: String?
        /// An array of structures that contain information about the bundles.
        public let bundles: [WorkspaceBundle]?

        public init(nextToken: String? = nil, bundles: [WorkspaceBundle]? = nil) {
            self.nextToken = nextToken
            self.bundles = bundles
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let bundles = dictionary["Bundles"] as? [[String: Any]] {
                self.bundles = try bundles.map({ try WorkspaceBundle(dictionary: $0) })
            } else { 
                self.bundles = nil
            }
        }
    }

    public struct DeleteTagsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The resource ID of the request.
        public let resourceId: String
        /// The tag keys of the request.
        public let tagKeys: [String]

        public init(resourceId: String, tagKeys: [String]) {
            self.resourceId = resourceId
            self.tagKeys = tagKeys
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceId = dictionary["ResourceId"] as? String else { throw InitializableError.missingRequiredParam("ResourceId") }
            self.resourceId = resourceId
            guard let tagKeys = dictionary["TagKeys"] as? [String] else { throw InitializableError.missingRequiredParam("TagKeys") }
            self.tagKeys = tagKeys
        }
    }

    public struct Workspace: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The identifier of the subnet that the WorkSpace is in.
        public let subnetId: String?
        /// The user that the WorkSpace is assigned to.
        public let userName: String?
        /// The operational state of the WorkSpace.
        public let state: WorkspaceState?
        /// Specifies whether the data stored on the root volume, or C: drive, is encrypted.
        public let rootVolumeEncryptionEnabled: Bool?
        /// The identifier of the AWS Directory Service directory that the WorkSpace belongs to.
        public let directoryId: String?
        public let workspaceProperties: WorkspaceProperties?
        /// The name of the WorkSpace as seen by the operating system.
        public let computerName: String?
        /// If the WorkSpace could not be created, this contains a textual error message that describes the failure.
        public let errorMessage: String?
        /// If the WorkSpace could not be created, this contains the error code.
        public let errorCode: String?
        /// The identifier of the bundle that the WorkSpace was created from.
        public let bundleId: String?
        /// Specifies whether the data stored on the user volume, or D: drive, is encrypted.
        public let userVolumeEncryptionEnabled: Bool?
        /// The identifier of the WorkSpace.
        public let workspaceId: String?
        /// The KMS key used to encrypt data stored on your WorkSpace.
        public let volumeEncryptionKey: String?
        /// The IP address of the WorkSpace.
        public let ipAddress: String?

        public init(subnetId: String? = nil, userName: String? = nil, state: WorkspaceState? = nil, rootVolumeEncryptionEnabled: Bool? = nil, directoryId: String? = nil, workspaceProperties: WorkspaceProperties? = nil, computerName: String? = nil, errorMessage: String? = nil, errorCode: String? = nil, bundleId: String? = nil, userVolumeEncryptionEnabled: Bool? = nil, workspaceId: String? = nil, volumeEncryptionKey: String? = nil, ipAddress: String? = nil) {
            self.subnetId = subnetId
            self.userName = userName
            self.state = state
            self.rootVolumeEncryptionEnabled = rootVolumeEncryptionEnabled
            self.directoryId = directoryId
            self.workspaceProperties = workspaceProperties
            self.computerName = computerName
            self.errorMessage = errorMessage
            self.errorCode = errorCode
            self.bundleId = bundleId
            self.userVolumeEncryptionEnabled = userVolumeEncryptionEnabled
            self.workspaceId = workspaceId
            self.volumeEncryptionKey = volumeEncryptionKey
            self.ipAddress = ipAddress
        }

        public init(dictionary: [String: Any]) throws {
            self.subnetId = dictionary["SubnetId"] as? String
            self.userName = dictionary["UserName"] as? String
            if let state = dictionary["State"] as? String { self.state = WorkspaceState(rawValue: state) } else { self.state = nil }
            self.rootVolumeEncryptionEnabled = dictionary["RootVolumeEncryptionEnabled"] as? Bool
            self.directoryId = dictionary["DirectoryId"] as? String
            if let workspaceProperties = dictionary["WorkspaceProperties"] as? [String: Any] { self.workspaceProperties = try Workspaces.WorkspaceProperties(dictionary: workspaceProperties) } else { self.workspaceProperties = nil }
            self.computerName = dictionary["ComputerName"] as? String
            self.errorMessage = dictionary["ErrorMessage"] as? String
            self.errorCode = dictionary["ErrorCode"] as? String
            self.bundleId = dictionary["BundleId"] as? String
            self.userVolumeEncryptionEnabled = dictionary["UserVolumeEncryptionEnabled"] as? Bool
            self.workspaceId = dictionary["WorkspaceId"] as? String
            self.volumeEncryptionKey = dictionary["VolumeEncryptionKey"] as? String
            self.ipAddress = dictionary["IpAddress"] as? String
        }
    }

    public struct RebuildWorkspacesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of structures that specify the WorkSpaces to rebuild.
        public let rebuildWorkspaceRequests: [RebuildRequest]

        public init(rebuildWorkspaceRequests: [RebuildRequest]) {
            self.rebuildWorkspaceRequests = rebuildWorkspaceRequests
        }

        public init(dictionary: [String: Any]) throws {
            guard let rebuildWorkspaceRequests = dictionary["RebuildWorkspaceRequests"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("RebuildWorkspaceRequests") }
            self.rebuildWorkspaceRequests = try rebuildWorkspaceRequests.map({ try RebuildRequest(dictionary: $0) })
        }
    }

    public struct DescribeWorkspaceDirectoriesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of structures that contain information about the directories.
        public let directories: [WorkspaceDirectory]?
        /// If not null, more results are available. Pass this value for the NextToken parameter in a subsequent call to this operation to retrieve the next set of items. This token is valid for one day and must be used within that time frame.
        public let nextToken: String?

        public init(directories: [WorkspaceDirectory]? = nil, nextToken: String? = nil) {
            self.directories = directories
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let directories = dictionary["Directories"] as? [[String: Any]] {
                self.directories = try directories.map({ try WorkspaceDirectory(dictionary: $0) })
            } else { 
                self.directories = nil
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct TerminateWorkspacesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of structures representing any WorkSpaces that could not be terminated.
        public let failedRequests: [FailedWorkspaceChangeRequest]?

        public init(failedRequests: [FailedWorkspaceChangeRequest]? = nil) {
            self.failedRequests = failedRequests
        }

        public init(dictionary: [String: Any]) throws {
            if let failedRequests = dictionary["FailedRequests"] as? [[String: Any]] {
                self.failedRequests = try failedRequests.map({ try FailedWorkspaceChangeRequest(dictionary: $0) })
            } else { 
                self.failedRequests = nil
            }
        }
    }

    public struct StopWorkspacesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The failed requests.
        public let failedRequests: [FailedWorkspaceChangeRequest]?

        public init(failedRequests: [FailedWorkspaceChangeRequest]? = nil) {
            self.failedRequests = failedRequests
        }

        public init(dictionary: [String: Any]) throws {
            if let failedRequests = dictionary["FailedRequests"] as? [[String: Any]] {
                self.failedRequests = try failedRequests.map({ try FailedWorkspaceChangeRequest(dictionary: $0) })
            } else { 
                self.failedRequests = nil
            }
        }
    }

    public enum WorkspaceDirectoryType: String, CustomStringConvertible {
        case simple_ad = "SIMPLE_AD"
        case ad_connector = "AD_CONNECTOR"
        public var description: String { return self.rawValue }
    }

    public struct RebuildRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The identifier of the WorkSpace to rebuild.
        public let workspaceId: String

        public init(workspaceId: String) {
            self.workspaceId = workspaceId
        }

        public init(dictionary: [String: Any]) throws {
            guard let workspaceId = dictionary["WorkspaceId"] as? String else { throw InitializableError.missingRequiredParam("WorkspaceId") }
            self.workspaceId = workspaceId
        }
    }

    public struct CreateWorkspacesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of structures that specify the WorkSpaces to create.
        public let workspaces: [WorkspaceRequest]

        public init(workspaces: [WorkspaceRequest]) {
            self.workspaces = workspaces
        }

        public init(dictionary: [String: Any]) throws {
            guard let workspaces = dictionary["Workspaces"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("Workspaces") }
            self.workspaces = try workspaces.map({ try WorkspaceRequest(dictionary: $0) })
        }
    }

    public struct WorkspaceDirectory: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of strings that contains the identifiers of the subnets used with the directory.
        public let subnetIds: [String]?
        /// A structure that specifies the default creation properties for all WorkSpaces in the directory.
        public let workspaceCreationProperties: DefaultWorkspaceCreationProperties?
        /// An array of strings that contains the IP addresses of the DNS servers for the directory.
        public let dnsIpAddresses: [String]?
        /// The registration code for the directory. This is the code that users enter in their Amazon WorkSpaces client application to connect to the directory.
        public let registrationCode: String?
        /// The state of the directory's registration with Amazon WorkSpaces
        public let state: WorkspaceDirectoryState?
        /// The user name for the service account.
        public let customerUserName: String?
        /// The directory alias.
        public let alias: String?
        /// The directory identifier.
        public let directoryId: String?
        /// The identifier of the security group that is assigned to new WorkSpaces.
        public let workspaceSecurityGroupId: String?
        /// The directory type.
        public let directoryType: WorkspaceDirectoryType?
        /// The identifier of the IAM role. This is the role that allows Amazon WorkSpaces to make calls to other services, such as Amazon EC2, on your behalf.
        public let iamRoleId: String?
        /// The name of the directory.
        public let directoryName: String?

        public init(subnetIds: [String]? = nil, workspaceCreationProperties: DefaultWorkspaceCreationProperties? = nil, dnsIpAddresses: [String]? = nil, registrationCode: String? = nil, state: WorkspaceDirectoryState? = nil, customerUserName: String? = nil, alias: String? = nil, directoryId: String? = nil, workspaceSecurityGroupId: String? = nil, directoryType: WorkspaceDirectoryType? = nil, iamRoleId: String? = nil, directoryName: String? = nil) {
            self.subnetIds = subnetIds
            self.workspaceCreationProperties = workspaceCreationProperties
            self.dnsIpAddresses = dnsIpAddresses
            self.registrationCode = registrationCode
            self.state = state
            self.customerUserName = customerUserName
            self.alias = alias
            self.directoryId = directoryId
            self.workspaceSecurityGroupId = workspaceSecurityGroupId
            self.directoryType = directoryType
            self.iamRoleId = iamRoleId
            self.directoryName = directoryName
        }

        public init(dictionary: [String: Any]) throws {
            self.subnetIds = dictionary["SubnetIds"] as? [String]
            if let workspaceCreationProperties = dictionary["WorkspaceCreationProperties"] as? [String: Any] { self.workspaceCreationProperties = try Workspaces.DefaultWorkspaceCreationProperties(dictionary: workspaceCreationProperties) } else { self.workspaceCreationProperties = nil }
            self.dnsIpAddresses = dictionary["DnsIpAddresses"] as? [String]
            self.registrationCode = dictionary["RegistrationCode"] as? String
            if let state = dictionary["State"] as? String { self.state = WorkspaceDirectoryState(rawValue: state) } else { self.state = nil }
            self.customerUserName = dictionary["CustomerUserName"] as? String
            self.alias = dictionary["Alias"] as? String
            self.directoryId = dictionary["DirectoryId"] as? String
            self.workspaceSecurityGroupId = dictionary["WorkspaceSecurityGroupId"] as? String
            if let directoryType = dictionary["DirectoryType"] as? String { self.directoryType = WorkspaceDirectoryType(rawValue: directoryType) } else { self.directoryType = nil }
            self.iamRoleId = dictionary["IamRoleId"] as? String
            self.directoryName = dictionary["DirectoryName"] as? String
        }
    }

    public struct WorkspaceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The username that the WorkSpace is assigned to. This username must exist in the AWS Directory Service directory specified by the DirectoryId member.
        public let userName: String
        /// The KMS key used to encrypt data stored on your WorkSpace.
        public let volumeEncryptionKey: String?
        /// The tags of the WorkSpace request.
        public let tags: [Tag]?
        public let workspaceProperties: WorkspaceProperties?
        /// The identifier of the AWS Directory Service directory to create the WorkSpace in. You can use the DescribeWorkspaceDirectories operation to obtain a list of the directories that are available.
        public let directoryId: String
        /// Specifies whether the data stored on the root volume, or C: drive, is encrypted.
        public let rootVolumeEncryptionEnabled: Bool?
        /// Specifies whether the data stored on the user volume, or D: drive, is encrypted.
        public let userVolumeEncryptionEnabled: Bool?
        /// The identifier of the bundle to create the WorkSpace from. You can use the DescribeWorkspaceBundles operation to obtain a list of the bundles that are available.
        public let bundleId: String

        public init(userName: String, volumeEncryptionKey: String? = nil, tags: [Tag]? = nil, workspaceProperties: WorkspaceProperties? = nil, directoryId: String, rootVolumeEncryptionEnabled: Bool? = nil, userVolumeEncryptionEnabled: Bool? = nil, bundleId: String) {
            self.userName = userName
            self.volumeEncryptionKey = volumeEncryptionKey
            self.tags = tags
            self.workspaceProperties = workspaceProperties
            self.directoryId = directoryId
            self.rootVolumeEncryptionEnabled = rootVolumeEncryptionEnabled
            self.userVolumeEncryptionEnabled = userVolumeEncryptionEnabled
            self.bundleId = bundleId
        }

        public init(dictionary: [String: Any]) throws {
            guard let userName = dictionary["UserName"] as? String else { throw InitializableError.missingRequiredParam("UserName") }
            self.userName = userName
            self.volumeEncryptionKey = dictionary["VolumeEncryptionKey"] as? String
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            } else { 
                self.tags = nil
            }
            if let workspaceProperties = dictionary["WorkspaceProperties"] as? [String: Any] { self.workspaceProperties = try Workspaces.WorkspaceProperties(dictionary: workspaceProperties) } else { self.workspaceProperties = nil }
            guard let directoryId = dictionary["DirectoryId"] as? String else { throw InitializableError.missingRequiredParam("DirectoryId") }
            self.directoryId = directoryId
            self.rootVolumeEncryptionEnabled = dictionary["RootVolumeEncryptionEnabled"] as? Bool
            self.userVolumeEncryptionEnabled = dictionary["UserVolumeEncryptionEnabled"] as? Bool
            guard let bundleId = dictionary["BundleId"] as? String else { throw InitializableError.missingRequiredParam("BundleId") }
            self.bundleId = bundleId
        }
    }

    public struct StartWorkspacesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The failed requests.
        public let failedRequests: [FailedWorkspaceChangeRequest]?

        public init(failedRequests: [FailedWorkspaceChangeRequest]? = nil) {
            self.failedRequests = failedRequests
        }

        public init(dictionary: [String: Any]) throws {
            if let failedRequests = dictionary["FailedRequests"] as? [[String: Any]] {
                self.failedRequests = try failedRequests.map({ try FailedWorkspaceChangeRequest(dictionary: $0) })
            } else { 
                self.failedRequests = nil
            }
        }
    }

    public struct DeleteTagsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct DescribeWorkspaceDirectoriesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The NextToken value from a previous call to this operation. Pass null if this is the first call.
        public let nextToken: String?
        /// An array of strings that contains the directory identifiers to retrieve information for. If this member is null, all directories are retrieved.
        public let directoryIds: [String]?

        public init(nextToken: String? = nil, directoryIds: [String]? = nil) {
            self.nextToken = nextToken
            self.directoryIds = directoryIds
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            self.directoryIds = dictionary["DirectoryIds"] as? [String]
        }
    }

    public struct TerminateRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The identifier of the WorkSpace to terminate.
        public let workspaceId: String

        public init(workspaceId: String) {
            self.workspaceId = workspaceId
        }

        public init(dictionary: [String: Any]) throws {
            guard let workspaceId = dictionary["WorkspaceId"] as? String else { throw InitializableError.missingRequiredParam("WorkspaceId") }
            self.workspaceId = workspaceId
        }
    }

}