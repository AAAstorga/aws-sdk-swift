// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension MediaConvert {

    public enum CmafSegmentControl: String, CustomStringConvertible, Codable {
        case singleFile = "SINGLE_FILE"
        case segmentedFiles = "SEGMENTED_FILES"
        public var description: String { return self.rawValue }
    }

    public enum PresetListBy: String, CustomStringConvertible, Codable {
        case name = "NAME"
        case creationDate = "CREATION_DATE"
        case system = "SYSTEM"
        public var description: String { return self.rawValue }
    }

    public struct TimecodeBurnin: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FontSize", location: .body(locationName: "fontSize"), required: false, type: .integer), 
            AWSShapeMember(label: "Prefix", location: .body(locationName: "prefix"), required: false, type: .string), 
            AWSShapeMember(label: "Position", location: .body(locationName: "position"), required: false, type: .enum)
        ]
        /// Use Font Size (FontSize) to set the font size of any burned-in timecode. Valid values are 10, 16, 32, 48.
        public let fontSize: Int32?
        /// Use Prefix (Prefix) to place ASCII characters before any burned-in timecode. For example, a prefix of "EZ-" will result in the timecode "EZ-00:00:00:00". Provide either the characters themselves or the ASCII code equivalents. The supported range of characters is 0x20 through 0x7e. This includes letters, numbers, and all special characters represented on a standard English keyboard.
        public let prefix: String?
        public let position: TimecodeBurninPosition?

        public init(fontSize: Int32? = nil, prefix: String? = nil, position: TimecodeBurninPosition? = nil) {
            self.fontSize = fontSize
            self.prefix = prefix
            self.position = position
        }

        private enum CodingKeys: String, CodingKey {
            case fontSize = "fontSize"
            case prefix = "prefix"
            case position = "position"
        }
    }

    public enum LanguageCode: String, CustomStringConvertible, Codable {
        case eng = "ENG"
        case spa = "SPA"
        case fra = "FRA"
        case deu = "DEU"
        case ger = "GER"
        case zho = "ZHO"
        case ara = "ARA"
        case hin = "HIN"
        case jpn = "JPN"
        case rus = "RUS"
        case por = "POR"
        case ita = "ITA"
        case urd = "URD"
        case vie = "VIE"
        case kor = "KOR"
        case pan = "PAN"
        case abk = "ABK"
        case aar = "AAR"
        case afr = "AFR"
        case aka = "AKA"
        case sqi = "SQI"
        case amh = "AMH"
        case arg = "ARG"
        case hye = "HYE"
        case asm = "ASM"
        case ava = "AVA"
        case ave = "AVE"
        case aym = "AYM"
        case aze = "AZE"
        case bam = "BAM"
        case bak = "BAK"
        case eus = "EUS"
        case bel = "BEL"
        case ben = "BEN"
        case bih = "BIH"
        case bis = "BIS"
        case bos = "BOS"
        case bre = "BRE"
        case bul = "BUL"
        case mya = "MYA"
        case cat = "CAT"
        case khm = "KHM"
        case cha = "CHA"
        case che = "CHE"
        case nya = "NYA"
        case chu = "CHU"
        case chv = "CHV"
        case cor = "COR"
        case cos = "COS"
        case cre = "CRE"
        case hrv = "HRV"
        case ces = "CES"
        case dan = "DAN"
        case div = "DIV"
        case nld = "NLD"
        case dzo = "DZO"
        case enm = "ENM"
        case epo = "EPO"
        case est = "EST"
        case ewe = "EWE"
        case fao = "FAO"
        case fij = "FIJ"
        case fin = "FIN"
        case frm = "FRM"
        case ful = "FUL"
        case gla = "GLA"
        case glg = "GLG"
        case lug = "LUG"
        case kat = "KAT"
        case ell = "ELL"
        case grn = "GRN"
        case guj = "GUJ"
        case hat = "HAT"
        case hau = "HAU"
        case heb = "HEB"
        case her = "HER"
        case hmo = "HMO"
        case hun = "HUN"
        case isl = "ISL"
        case ido = "IDO"
        case ibo = "IBO"
        case ind = "IND"
        case ina = "INA"
        case ile = "ILE"
        case iku = "IKU"
        case ipk = "IPK"
        case gle = "GLE"
        case jav = "JAV"
        case kal = "KAL"
        case kan = "KAN"
        case kau = "KAU"
        case kas = "KAS"
        case kaz = "KAZ"
        case kik = "KIK"
        case kin = "KIN"
        case kir = "KIR"
        case kom = "KOM"
        case kon = "KON"
        case kua = "KUA"
        case kur = "KUR"
        case lao = "LAO"
        case lat = "LAT"
        case lav = "LAV"
        case lim = "LIM"
        case lin = "LIN"
        case lit = "LIT"
        case lub = "LUB"
        case ltz = "LTZ"
        case mkd = "MKD"
        case mlg = "MLG"
        case msa = "MSA"
        case mal = "MAL"
        case mlt = "MLT"
        case glv = "GLV"
        case mri = "MRI"
        case mar = "MAR"
        case mah = "MAH"
        case mon = "MON"
        case nau = "NAU"
        case nav = "NAV"
        case nde = "NDE"
        case nbl = "NBL"
        case ndo = "NDO"
        case nep = "NEP"
        case sme = "SME"
        case nor = "NOR"
        case nob = "NOB"
        case nno = "NNO"
        case oci = "OCI"
        case oji = "OJI"
        case ori = "ORI"
        case orm = "ORM"
        case oss = "OSS"
        case pli = "PLI"
        case fas = "FAS"
        case pol = "POL"
        case pus = "PUS"
        case que = "QUE"
        case qaa = "QAA"
        case ron = "RON"
        case roh = "ROH"
        case run = "RUN"
        case smo = "SMO"
        case sag = "SAG"
        case san = "SAN"
        case srd = "SRD"
        case srb = "SRB"
        case sna = "SNA"
        case iii = "III"
        case snd = "SND"
        case sin = "SIN"
        case slk = "SLK"
        case slv = "SLV"
        case som = "SOM"
        case sot = "SOT"
        case sun = "SUN"
        case swa = "SWA"
        case ssw = "SSW"
        case swe = "SWE"
        case tgl = "TGL"
        case tah = "TAH"
        case tgk = "TGK"
        case tam = "TAM"
        case tat = "TAT"
        case tel = "TEL"
        case tha = "THA"
        case bod = "BOD"
        case tir = "TIR"
        case ton = "TON"
        case tso = "TSO"
        case tsn = "TSN"
        case tur = "TUR"
        case tuk = "TUK"
        case twi = "TWI"
        case uig = "UIG"
        case ukr = "UKR"
        case uzb = "UZB"
        case ven = "VEN"
        case vol = "VOL"
        case wln = "WLN"
        case cym = "CYM"
        case fry = "FRY"
        case wol = "WOL"
        case xho = "XHO"
        case yid = "YID"
        case yor = "YOR"
        case zha = "ZHA"
        case zul = "ZUL"
        case orj = "ORJ"
        case qpc = "QPC"
        case tng = "TNG"
        public var description: String { return self.rawValue }
    }

    public enum Mpeg2Telecine: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case soft = "SOFT"
        case hard = "HARD"
        public var description: String { return self.rawValue }
    }

    public struct JobTemplate: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "Type", location: .body(locationName: "type"), required: false, type: .enum), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: true, type: .string), 
            AWSShapeMember(label: "CreatedAt", location: .body(locationName: "createdAt"), required: false, type: .timestamp), 
            AWSShapeMember(label: "Category", location: .body(locationName: "category"), required: false, type: .string), 
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "Settings", location: .body(locationName: "settings"), required: true, type: .structure), 
            AWSShapeMember(label: "LastUpdated", location: .body(locationName: "lastUpdated"), required: false, type: .timestamp), 
            AWSShapeMember(label: "Queue", location: .body(locationName: "queue"), required: false, type: .string)
        ]
        /// An optional description you create for each job template.
        public let description: String?
        /// A job template can be of two types: system or custom. System or built-in job templates can't be modified or deleted by the user.
        public let `type`: `Type`?
        /// A name you create for each job template. Each name must be unique within your account.
        public let name: String
        /// The timestamp in epoch seconds for Job template creation.
        public let createdAt: TimeStamp?
        /// An optional category you create to organize your job templates.
        public let category: String?
        /// An identifier for this resource that is unique within all of AWS.
        public let arn: String?
        public let settings: JobTemplateSettings
        /// The timestamp in epoch seconds when the Job template was last updated.
        public let lastUpdated: TimeStamp?
        /// Optional. The queue that jobs created from this template are assigned to. If you don't specify this, jobs will go to the default queue.
        public let queue: String?

        public init(description: String? = nil, type: `Type`? = nil, name: String, createdAt: TimeStamp? = nil, category: String? = nil, arn: String? = nil, settings: JobTemplateSettings, lastUpdated: TimeStamp? = nil, queue: String? = nil) {
            self.description = description
            self.`type` = `type`
            self.name = name
            self.createdAt = createdAt
            self.category = category
            self.arn = arn
            self.settings = settings
            self.lastUpdated = lastUpdated
            self.queue = queue
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case `type` = "type"
            case name = "name"
            case createdAt = "createdAt"
            case category = "category"
            case arn = "arn"
            case settings = "settings"
            case lastUpdated = "lastUpdated"
            case queue = "queue"
        }
    }

    public struct TimecodeConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TimestampOffset", location: .body(locationName: "timestampOffset"), required: false, type: .string), 
            AWSShapeMember(label: "Source", location: .body(locationName: "source"), required: false, type: .enum), 
            AWSShapeMember(label: "Anchor", location: .body(locationName: "anchor"), required: false, type: .string), 
            AWSShapeMember(label: "Start", location: .body(locationName: "start"), required: false, type: .string)
        ]
        /// Only applies to outputs that support program-date-time stamp. Use Timestamp offset (TimestampOffset) to overwrite the timecode date without affecting the time and frame number. Provide the new date as a string in the format "yyyy-mm-dd".  To use Time stamp offset, you must also enable Insert program-date-time (InsertProgramDateTime) in the output settings. For example, if the date part of your timecodes is 2002-1-25 and you want to change it to one year later, set Timestamp offset (TimestampOffset) to 2003-1-25.
        public let timestampOffset: String?
        public let source: TimecodeSource?
        /// If you use an editing platform that relies on an anchor timecode, use Anchor Timecode (Anchor) to specify a timecode that will match the input video frame to the output video frame. Use 24-hour format with frame number, (HH:MM:SS:FF) or (HH:MM:SS;FF). This setting ignores framerate conversion. System behavior for Anchor Timecode varies depending on your setting for Source (TimecodeSource). * If Source (TimecodeSource) is set to Specified Start (SPECIFIEDSTART), the first input frame is the specified value in Start Timecode (Start). Anchor Timecode (Anchor) and Start Timecode (Start) are used calculate output timecode. * If Source (TimecodeSource) is set to Start at 0 (ZEROBASED)  the  first frame is 00:00:00:00. * If Source (TimecodeSource) is set to Embedded (EMBEDDED), the  first frame is the timecode value on the first input frame of the input.
        public let anchor: String?
        /// Only use when you set Source (TimecodeSource) to Specified start (SPECIFIEDSTART). Use Start timecode (Start) to specify the timecode for the initial frame. Use 24-hour format with frame number, (HH:MM:SS:FF) or (HH:MM:SS;FF).
        public let start: String?

        public init(timestampOffset: String? = nil, source: TimecodeSource? = nil, anchor: String? = nil, start: String? = nil) {
            self.timestampOffset = timestampOffset
            self.source = source
            self.anchor = anchor
            self.start = start
        }

        private enum CodingKeys: String, CodingKey {
            case timestampOffset = "timestampOffset"
            case source = "source"
            case anchor = "anchor"
            case start = "start"
        }
    }

    public enum AudioDefaultSelection: String, CustomStringConvertible, Codable {
        case `default` = "DEFAULT"
        case notDefault = "NOT_DEFAULT"
        public var description: String { return self.rawValue }
    }

    public enum HlsStreamInfResolution: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public enum BurninSubtitleAlignment: String, CustomStringConvertible, Codable {
        case centered = "CENTERED"
        case left = "LEFT"
        public var description: String { return self.rawValue }
    }

    public struct MotionImageInserter: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InsertionMode", location: .body(locationName: "insertionMode"), required: false, type: .enum), 
            AWSShapeMember(label: "StartTime", location: .body(locationName: "startTime"), required: false, type: .string), 
            AWSShapeMember(label: "Framerate", location: .body(locationName: "framerate"), required: false, type: .structure), 
            AWSShapeMember(label: "Playback", location: .body(locationName: "playback"), required: false, type: .enum), 
            AWSShapeMember(label: "Input", location: .body(locationName: "input"), required: false, type: .string), 
            AWSShapeMember(label: "Offset", location: .body(locationName: "offset"), required: false, type: .structure)
        ]
        /// Choose the type of motion graphic asset that you are providing for your overlay. You can choose either a .mov file or a series of .png files.
        public let insertionMode: MotionImageInsertionMode?
        /// Specify when the motion overlay begins. Use timecode format (HH:MM:SS:FF or HH:MM:SS;FF). Make sure that the timecode you provide here takes into account how you have set up your timecode configuration under both job settings and input settings. The simplest way to do that is to set both to start at 0. If you need to set up your job to follow timecodes embedded in your source that don't start at zero, make sure that you specify a start time that is after the first embedded timecode. For more information, see https://docs.aws.amazon.com/mediaconvert/latest/ug/setting-up-timecode.html Find job-wide and input timecode configuration settings in your JSON job settings specification at settings>timecodeConfig>source and settings>inputs>timecodeSource.
        public let startTime: String?
        /// If your motion graphic asset is a .mov file, keep this setting unspecified. If your motion graphic asset is a series of .png files, specify the framerate of the overlay in frames per second, as a fraction. For example, specify 24 fps as 24/1. Make sure that the number of images in your series matches the framerate and your intended overlay duration. For example, if you want a 30-second overlay at 30 fps, you should have 900 .png images. This overlay framerate doesn't need to match the framerate of the underlying video.
        public let framerate: MotionImageInsertionFramerate?
        /// Specify whether your motion graphic overlay repeats on a loop or plays only once.
        public let playback: MotionImagePlayback?
        /// Specify the .mov file or series of .png files that you want to overlay on your video. For .png files, provide the file name of the first file in the series. Make sure that the names of the .png files end with sequential numbers that specify the order that they are played in. For example, overlay_000.png, overlay_001.png, overlay_002.png, and so on. The sequence must start at zero, and each image file name must have the same number of digits. Pad your initial file names with enough zeros to complete the sequence. For example, if the first image is overlay_0.png, there can be only 10 images in the sequence, with the last image being overlay_9.png. But if the first image is overlay_00.png, there can be 100 images in the sequence.
        public let input: String?
        /// Use Offset to specify the placement of your motion graphic overlay on the video frame. Specify in pixels, from the upper-left corner of the frame. If you don't specify an offset, the service scales your overlay to the full size of the frame. Otherwise, the service inserts the overlay at its native resolution and scales the size up or down with any video scaling.
        public let offset: MotionImageInsertionOffset?

        public init(insertionMode: MotionImageInsertionMode? = nil, startTime: String? = nil, framerate: MotionImageInsertionFramerate? = nil, playback: MotionImagePlayback? = nil, input: String? = nil, offset: MotionImageInsertionOffset? = nil) {
            self.insertionMode = insertionMode
            self.startTime = startTime
            self.framerate = framerate
            self.playback = playback
            self.input = input
            self.offset = offset
        }

        private enum CodingKeys: String, CodingKey {
            case insertionMode = "insertionMode"
            case startTime = "startTime"
            case framerate = "framerate"
            case playback = "playback"
            case input = "input"
            case offset = "offset"
        }
    }

    public enum Eac3BitstreamMode: String, CustomStringConvertible, Codable {
        case completeMain = "COMPLETE_MAIN"
        case commentary = "COMMENTARY"
        case emergency = "EMERGENCY"
        case hearingImpaired = "HEARING_IMPAIRED"
        case visuallyImpaired = "VISUALLY_IMPAIRED"
        public var description: String { return self.rawValue }
    }

    public enum Order: String, CustomStringConvertible, Codable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public struct CreatePresetResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Preset", location: .body(locationName: "preset"), required: false, type: .structure)
        ]
        public let preset: Preset?

        public init(preset: Preset? = nil) {
            self.preset = preset
        }

        private enum CodingKeys: String, CodingKey {
            case preset = "preset"
        }
    }

    public struct MotionImageInsertionFramerate: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FramerateDenominator", location: .body(locationName: "framerateDenominator"), required: false, type: .integer), 
            AWSShapeMember(label: "FramerateNumerator", location: .body(locationName: "framerateNumerator"), required: false, type: .integer)
        ]
        /// The bottom of the fraction that expresses your overlay framerate. For example, if your framerate is 24 fps, set this value to 1.
        public let framerateDenominator: Int32?
        /// The top of the fraction that expresses your overlay framerate. For example, if your framerate is 24 fps, set this value to 24.
        public let framerateNumerator: Int32?

        public init(framerateDenominator: Int32? = nil, framerateNumerator: Int32? = nil) {
            self.framerateDenominator = framerateDenominator
            self.framerateNumerator = framerateNumerator
        }

        private enum CodingKeys: String, CodingKey {
            case framerateDenominator = "framerateDenominator"
            case framerateNumerator = "framerateNumerator"
        }
    }

    public enum Eac3SurroundMode: String, CustomStringConvertible, Codable {
        case notIndicated = "NOT_INDICATED"
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public enum H265TemporalAdaptiveQuantization: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct H265QvbrSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "QvbrQualityLevel", location: .body(locationName: "qvbrQualityLevel"), required: false, type: .integer), 
            AWSShapeMember(label: "MaxAverageBitrate", location: .body(locationName: "maxAverageBitrate"), required: false, type: .integer)
        ]
        /// Required when you use QVBR rate control mode. That is, when you specify qvbrSettings within h265Settings. Specify the target quality level for this output, from 1 to 10. Use higher numbers for greater quality. Level 10 results in nearly lossless compression. The quality level for most broadcast-quality transcodes is between 6 and 9.
        public let qvbrQualityLevel: Int32?
        /// Use this setting only when Rate control mode is QVBR and Quality tuning level is Multi-pass HQ. For Max average bitrate values suited to the complexity of your input video, the service limits the average bitrate of the video part of this output to the value you choose. That is, the total size of the video element is less than or equal to the value you set multiplied by the number of seconds of encoded output.
        public let maxAverageBitrate: Int32?

        public init(qvbrQualityLevel: Int32? = nil, maxAverageBitrate: Int32? = nil) {
            self.qvbrQualityLevel = qvbrQualityLevel
            self.maxAverageBitrate = maxAverageBitrate
        }

        private enum CodingKeys: String, CodingKey {
            case qvbrQualityLevel = "qvbrQualityLevel"
            case maxAverageBitrate = "maxAverageBitrate"
        }
    }

    public enum FileSourceConvert608To708: String, CustomStringConvertible, Codable {
        case upconvert = "UPCONVERT"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public enum MovCslgAtom: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public struct CaptionDestinationSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TtmlDestinationSettings", location: .body(locationName: "ttmlDestinationSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "SccDestinationSettings", location: .body(locationName: "sccDestinationSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "DestinationType", location: .body(locationName: "destinationType"), required: false, type: .enum), 
            AWSShapeMember(label: "DvbSubDestinationSettings", location: .body(locationName: "dvbSubDestinationSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "TeletextDestinationSettings", location: .body(locationName: "teletextDestinationSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "BurninDestinationSettings", location: .body(locationName: "burninDestinationSettings"), required: false, type: .structure)
        ]
        public let ttmlDestinationSettings: TtmlDestinationSettings?
        public let sccDestinationSettings: SccDestinationSettings?
        public let destinationType: CaptionDestinationType?
        public let dvbSubDestinationSettings: DvbSubDestinationSettings?
        public let teletextDestinationSettings: TeletextDestinationSettings?
        public let burninDestinationSettings: BurninDestinationSettings?

        public init(ttmlDestinationSettings: TtmlDestinationSettings? = nil, sccDestinationSettings: SccDestinationSettings? = nil, destinationType: CaptionDestinationType? = nil, dvbSubDestinationSettings: DvbSubDestinationSettings? = nil, teletextDestinationSettings: TeletextDestinationSettings? = nil, burninDestinationSettings: BurninDestinationSettings? = nil) {
            self.ttmlDestinationSettings = ttmlDestinationSettings
            self.sccDestinationSettings = sccDestinationSettings
            self.destinationType = destinationType
            self.dvbSubDestinationSettings = dvbSubDestinationSettings
            self.teletextDestinationSettings = teletextDestinationSettings
            self.burninDestinationSettings = burninDestinationSettings
        }

        private enum CodingKeys: String, CodingKey {
            case ttmlDestinationSettings = "ttmlDestinationSettings"
            case sccDestinationSettings = "sccDestinationSettings"
            case destinationType = "destinationType"
            case dvbSubDestinationSettings = "dvbSubDestinationSettings"
            case teletextDestinationSettings = "teletextDestinationSettings"
            case burninDestinationSettings = "burninDestinationSettings"
        }
    }

    public struct NoiseReducerSpatialFilterSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Speed", location: .body(locationName: "speed"), required: false, type: .integer), 
            AWSShapeMember(label: "Strength", location: .body(locationName: "strength"), required: false, type: .integer), 
            AWSShapeMember(label: "PostFilterSharpenStrength", location: .body(locationName: "postFilterSharpenStrength"), required: false, type: .integer)
        ]
        /// The speed of the filter, from -2 (lower speed) to 3 (higher speed), with 0 being the nominal value.
        public let speed: Int32?
        /// Relative strength of noise reducing filter. Higher values produce stronger filtering.
        public let strength: Int32?
        /// Specify strength of post noise reduction sharpening filter, with 0 disabling the filter and 3 enabling it at maximum strength.
        public let postFilterSharpenStrength: Int32?

        public init(speed: Int32? = nil, strength: Int32? = nil, postFilterSharpenStrength: Int32? = nil) {
            self.speed = speed
            self.strength = strength
            self.postFilterSharpenStrength = postFilterSharpenStrength
        }

        private enum CodingKeys: String, CodingKey {
            case speed = "speed"
            case strength = "strength"
            case postFilterSharpenStrength = "postFilterSharpenStrength"
        }
    }

    public enum Mpeg2SlowPal: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum DvbSubtitleOutlineColor: String, CustomStringConvertible, Codable {
        case black = "BLACK"
        case white = "WHITE"
        case yellow = "YELLOW"
        case red = "RED"
        case green = "GREEN"
        case blue = "BLUE"
        public var description: String { return self.rawValue }
    }

    public struct FileGroupSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Destination", location: .body(locationName: "destination"), required: false, type: .string)
        ]
        /// Use Destination (Destination) to specify the S3 output location and the output filename base. Destination accepts format identifiers. If you do not specify the base filename in the URI, the service will use the filename of the input file. If your job has multiple inputs, the service uses the filename of the first input file.
        public let destination: String?

        public init(destination: String? = nil) {
            self.destination = destination
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "destination"
        }
    }

    public struct MsSmoothGroupSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Encryption", location: .body(locationName: "encryption"), required: false, type: .structure), 
            AWSShapeMember(label: "FragmentLength", location: .body(locationName: "fragmentLength"), required: false, type: .integer), 
            AWSShapeMember(label: "AudioDeduplication", location: .body(locationName: "audioDeduplication"), required: false, type: .enum), 
            AWSShapeMember(label: "ManifestEncoding", location: .body(locationName: "manifestEncoding"), required: false, type: .enum), 
            AWSShapeMember(label: "Destination", location: .body(locationName: "destination"), required: false, type: .string)
        ]
        public let encryption: MsSmoothEncryptionSettings?
        /// Use Fragment length (FragmentLength) to specify the mp4 fragment sizes in seconds. Fragment length must be compatible with GOP size and framerate.
        public let fragmentLength: Int32?
        public let audioDeduplication: MsSmoothAudioDeduplication?
        public let manifestEncoding: MsSmoothManifestEncoding?
        /// Use Destination (Destination) to specify the S3 output location and the output filename base. Destination accepts format identifiers. If you do not specify the base filename in the URI, the service will use the filename of the input file. If your job has multiple inputs, the service uses the filename of the first input file.
        public let destination: String?

        public init(encryption: MsSmoothEncryptionSettings? = nil, fragmentLength: Int32? = nil, audioDeduplication: MsSmoothAudioDeduplication? = nil, manifestEncoding: MsSmoothManifestEncoding? = nil, destination: String? = nil) {
            self.encryption = encryption
            self.fragmentLength = fragmentLength
            self.audioDeduplication = audioDeduplication
            self.manifestEncoding = manifestEncoding
            self.destination = destination
        }

        private enum CodingKeys: String, CodingKey {
            case encryption = "encryption"
            case fragmentLength = "fragmentLength"
            case audioDeduplication = "audioDeduplication"
            case manifestEncoding = "manifestEncoding"
            case destination = "destination"
        }
    }

    public struct DeletePresetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", location: .uri(locationName: "name"), required: true, type: .string)
        ]
        /// The name of the preset to be deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public enum Mp4MoovPlacement: String, CustomStringConvertible, Codable {
        case progressiveDownload = "PROGRESSIVE_DOWNLOAD"
        case normal = "NORMAL"
        public var description: String { return self.rawValue }
    }

    public struct InputDecryptionSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "KmsKeyRegion", location: .body(locationName: "kmsKeyRegion"), required: false, type: .string), 
            AWSShapeMember(label: "EncryptedDecryptionKey", location: .body(locationName: "encryptedDecryptionKey"), required: false, type: .string), 
            AWSShapeMember(label: "InitializationVector", location: .body(locationName: "initializationVector"), required: false, type: .string), 
            AWSShapeMember(label: "DecryptionMode", location: .body(locationName: "decryptionMode"), required: false, type: .enum)
        ]
        /// The AWS region in which decryption key was encrypted with KMS
        public let kmsKeyRegion: String?
        /// Decryption key either 128 or 192 or 256 bits encrypted with KMS
        public let encryptedDecryptionKey: String?
        /// Initialization Vector 96 bits (CTR/GCM mode only) or 128 bits.
        public let initializationVector: String?
        public let decryptionMode: DecryptionMode?

        public init(kmsKeyRegion: String? = nil, encryptedDecryptionKey: String? = nil, initializationVector: String? = nil, decryptionMode: DecryptionMode? = nil) {
            self.kmsKeyRegion = kmsKeyRegion
            self.encryptedDecryptionKey = encryptedDecryptionKey
            self.initializationVector = initializationVector
            self.decryptionMode = decryptionMode
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyRegion = "kmsKeyRegion"
            case encryptedDecryptionKey = "encryptedDecryptionKey"
            case initializationVector = "initializationVector"
            case decryptionMode = "decryptionMode"
        }
    }

    public enum Eac3DcFilter: String, CustomStringConvertible, Codable {
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public enum ContainerType: String, CustomStringConvertible, Codable {
        case f4v = "F4V"
        case ismv = "ISMV"
        case m2ts = "M2TS"
        case m3u8 = "M3U8"
        case cmfc = "CMFC"
        case mov = "MOV"
        case mp4 = "MP4"
        case mpd = "MPD"
        case mxf = "MXF"
        case raw = "RAW"
        public var description: String { return self.rawValue }
    }

    public struct OutputGroupDetail: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "OutputDetails", location: .body(locationName: "outputDetails"), required: false, type: .list)
        ]
        /// Details about the output
        public let outputDetails: [OutputDetail]?

        public init(outputDetails: [OutputDetail]? = nil) {
            self.outputDetails = outputDetails
        }

        private enum CodingKeys: String, CodingKey {
            case outputDetails = "outputDetails"
        }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable {
        case submitted = "SUBMITTED"
        case progressing = "PROGRESSING"
        case complete = "COMPLETE"
        case canceled = "CANCELED"
        case error = "ERROR"
        public var description: String { return self.rawValue }
    }

    public enum H264InterlaceMode: String, CustomStringConvertible, Codable {
        case progressive = "PROGRESSIVE"
        case topField = "TOP_FIELD"
        case bottomField = "BOTTOM_FIELD"
        case followTopField = "FOLLOW_TOP_FIELD"
        case followBottomField = "FOLLOW_BOTTOM_FIELD"
        public var description: String { return self.rawValue }
    }

    public enum MsSmoothAudioDeduplication: String, CustomStringConvertible, Codable {
        case combineDuplicateStreams = "COMBINE_DUPLICATE_STREAMS"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum BurninSubtitleBackgroundColor: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case black = "BLACK"
        case white = "WHITE"
        public var description: String { return self.rawValue }
    }

    public struct CaptionDescriptionPreset: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DestinationSettings", location: .body(locationName: "destinationSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "CustomLanguageCode", location: .body(locationName: "customLanguageCode"), required: false, type: .string), 
            AWSShapeMember(label: "LanguageDescription", location: .body(locationName: "languageDescription"), required: false, type: .string), 
            AWSShapeMember(label: "LanguageCode", location: .body(locationName: "languageCode"), required: false, type: .enum)
        ]
        public let destinationSettings: CaptionDestinationSettings?
        /// Indicates the language of the caption output track, using the ISO 639-2 or ISO 639-3 three-letter language code
        public let customLanguageCode: String?
        /// Human readable information to indicate captions available for players (eg. English, or Spanish). Alphanumeric characters, spaces, and underscore are legal.
        public let languageDescription: String?
        /// Indicates the language of the caption output track.
        public let languageCode: LanguageCode?

        public init(destinationSettings: CaptionDestinationSettings? = nil, customLanguageCode: String? = nil, languageDescription: String? = nil, languageCode: LanguageCode? = nil) {
            self.destinationSettings = destinationSettings
            self.customLanguageCode = customLanguageCode
            self.languageDescription = languageDescription
            self.languageCode = languageCode
        }

        private enum CodingKeys: String, CodingKey {
            case destinationSettings = "destinationSettings"
            case customLanguageCode = "customLanguageCode"
            case languageDescription = "languageDescription"
            case languageCode = "languageCode"
        }
    }

    public enum M2tsPcrControl: String, CustomStringConvertible, Codable {
        case pcrEveryPesPacket = "PCR_EVERY_PES_PACKET"
        case configuredPcrPeriod = "CONFIGURED_PCR_PERIOD"
        public var description: String { return self.rawValue }
    }

    public enum QueueStatus: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case paused = "PAUSED"
        public var description: String { return self.rawValue }
    }

    public enum Mpeg2RateControlMode: String, CustomStringConvertible, Codable {
        case vbr = "VBR"
        case cbr = "CBR"
        public var description: String { return self.rawValue }
    }

    public enum InputFilterEnable: String, CustomStringConvertible, Codable {
        case auto = "AUTO"
        case disable = "DISABLE"
        case force = "FORCE"
        public var description: String { return self.rawValue }
    }

    public enum M2tsRateMode: String, CustomStringConvertible, Codable {
        case vbr = "VBR"
        case cbr = "CBR"
        public var description: String { return self.rawValue }
    }

    public enum Mpeg2QualityTuningLevel: String, CustomStringConvertible, Codable {
        case singlePass = "SINGLE_PASS"
        case multiPass = "MULTI_PASS"
        public var description: String { return self.rawValue }
    }

    public struct Hdr10Metadata: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WhitePointX", location: .body(locationName: "whitePointX"), required: false, type: .integer), 
            AWSShapeMember(label: "MinLuminance", location: .body(locationName: "minLuminance"), required: false, type: .integer), 
            AWSShapeMember(label: "RedPrimaryY", location: .body(locationName: "redPrimaryY"), required: false, type: .integer), 
            AWSShapeMember(label: "BluePrimaryX", location: .body(locationName: "bluePrimaryX"), required: false, type: .integer), 
            AWSShapeMember(label: "MaxFrameAverageLightLevel", location: .body(locationName: "maxFrameAverageLightLevel"), required: false, type: .integer), 
            AWSShapeMember(label: "RedPrimaryX", location: .body(locationName: "redPrimaryX"), required: false, type: .integer), 
            AWSShapeMember(label: "GreenPrimaryY", location: .body(locationName: "greenPrimaryY"), required: false, type: .integer), 
            AWSShapeMember(label: "MaxLuminance", location: .body(locationName: "maxLuminance"), required: false, type: .integer), 
            AWSShapeMember(label: "MaxContentLightLevel", location: .body(locationName: "maxContentLightLevel"), required: false, type: .integer), 
            AWSShapeMember(label: "BluePrimaryY", location: .body(locationName: "bluePrimaryY"), required: false, type: .integer), 
            AWSShapeMember(label: "GreenPrimaryX", location: .body(locationName: "greenPrimaryX"), required: false, type: .integer), 
            AWSShapeMember(label: "WhitePointY", location: .body(locationName: "whitePointY"), required: false, type: .integer)
        ]
        /// HDR Master Display Information must be provided by a color grader, using color grading tools. Range is 0 to 50,000, each increment represents 0.00002 in CIE1931 color coordinate. Note that this setting is not for color correction.
        public let whitePointX: Int32?
        /// Nominal minimum mastering display luminance in units of of 0.0001 candelas per square meter
        public let minLuminance: Int32?
        /// HDR Master Display Information must be provided by a color grader, using color grading tools. Range is 0 to 50,000, each increment represents 0.00002 in CIE1931 color coordinate. Note that this setting is not for color correction.
        public let redPrimaryY: Int32?
        /// HDR Master Display Information must be provided by a color grader, using color grading tools. Range is 0 to 50,000, each increment represents 0.00002 in CIE1931 color coordinate. Note that this setting is not for color correction.
        public let bluePrimaryX: Int32?
        /// Maximum average light level of any frame in the coded video sequence, in units of candelas per square meter.
        public let maxFrameAverageLightLevel: Int32?
        /// HDR Master Display Information must be provided by a color grader, using color grading tools. Range is 0 to 50,000, each increment represents 0.00002 in CIE1931 color coordinate. Note that this setting is not for color correction.
        public let redPrimaryX: Int32?
        /// HDR Master Display Information must be provided by a color grader, using color grading tools. Range is 0 to 50,000, each increment represents 0.00002 in CIE1931 color coordinate. Note that this setting is not for color correction.
        public let greenPrimaryY: Int32?
        /// Nominal maximum mastering display luminance in units of of 0.0001 candelas per square meter.
        public let maxLuminance: Int32?
        /// Maximum light level among all samples in the coded video sequence, in units of candelas per square meter.
        public let maxContentLightLevel: Int32?
        /// HDR Master Display Information must be provided by a color grader, using color grading tools. Range is 0 to 50,000, each increment represents 0.00002 in CIE1931 color coordinate. Note that this setting is not for color correction.
        public let bluePrimaryY: Int32?
        /// HDR Master Display Information must be provided by a color grader, using color grading tools. Range is 0 to 50,000, each increment represents 0.00002 in CIE1931 color coordinate. Note that this setting is not for color correction.
        public let greenPrimaryX: Int32?
        /// HDR Master Display Information must be provided by a color grader, using color grading tools. Range is 0 to 50,000, each increment represents 0.00002 in CIE1931 color coordinate. Note that this setting is not for color correction.
        public let whitePointY: Int32?

        public init(whitePointX: Int32? = nil, minLuminance: Int32? = nil, redPrimaryY: Int32? = nil, bluePrimaryX: Int32? = nil, maxFrameAverageLightLevel: Int32? = nil, redPrimaryX: Int32? = nil, greenPrimaryY: Int32? = nil, maxLuminance: Int32? = nil, maxContentLightLevel: Int32? = nil, bluePrimaryY: Int32? = nil, greenPrimaryX: Int32? = nil, whitePointY: Int32? = nil) {
            self.whitePointX = whitePointX
            self.minLuminance = minLuminance
            self.redPrimaryY = redPrimaryY
            self.bluePrimaryX = bluePrimaryX
            self.maxFrameAverageLightLevel = maxFrameAverageLightLevel
            self.redPrimaryX = redPrimaryX
            self.greenPrimaryY = greenPrimaryY
            self.maxLuminance = maxLuminance
            self.maxContentLightLevel = maxContentLightLevel
            self.bluePrimaryY = bluePrimaryY
            self.greenPrimaryX = greenPrimaryX
            self.whitePointY = whitePointY
        }

        private enum CodingKeys: String, CodingKey {
            case whitePointX = "whitePointX"
            case minLuminance = "minLuminance"
            case redPrimaryY = "redPrimaryY"
            case bluePrimaryX = "bluePrimaryX"
            case maxFrameAverageLightLevel = "maxFrameAverageLightLevel"
            case redPrimaryX = "redPrimaryX"
            case greenPrimaryY = "greenPrimaryY"
            case maxLuminance = "maxLuminance"
            case maxContentLightLevel = "maxContentLightLevel"
            case bluePrimaryY = "bluePrimaryY"
            case greenPrimaryX = "greenPrimaryX"
            case whitePointY = "whitePointY"
        }
    }

    public enum ColorSpace: String, CustomStringConvertible, Codable {
        case follow = "FOLLOW"
        case rec601 = "REC_601"
        case rec709 = "REC_709"
        case hdr10 = "HDR10"
        case hlg2020 = "HLG_2020"
        public var description: String { return self.rawValue }
    }

    public enum M2tsSegmentationStyle: String, CustomStringConvertible, Codable {
        case maintainCadence = "MAINTAIN_CADENCE"
        case resetCadence = "RESET_CADENCE"
        public var description: String { return self.rawValue }
    }

    public struct H264Settings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InterlaceMode", location: .body(locationName: "interlaceMode"), required: false, type: .enum), 
            AWSShapeMember(label: "GopSize", location: .body(locationName: "gopSize"), required: false, type: .double), 
            AWSShapeMember(label: "HrdBufferSize", location: .body(locationName: "hrdBufferSize"), required: false, type: .integer), 
            AWSShapeMember(label: "Slices", location: .body(locationName: "slices"), required: false, type: .integer), 
            AWSShapeMember(label: "SlowPal", location: .body(locationName: "slowPal"), required: false, type: .enum), 
            AWSShapeMember(label: "FramerateConversionAlgorithm", location: .body(locationName: "framerateConversionAlgorithm"), required: false, type: .enum), 
            AWSShapeMember(label: "CodecProfile", location: .body(locationName: "codecProfile"), required: false, type: .enum), 
            AWSShapeMember(label: "MaxBitrate", location: .body(locationName: "maxBitrate"), required: false, type: .integer), 
            AWSShapeMember(label: "FramerateDenominator", location: .body(locationName: "framerateDenominator"), required: false, type: .integer), 
            AWSShapeMember(label: "RepeatPps", location: .body(locationName: "repeatPps"), required: false, type: .enum), 
            AWSShapeMember(label: "CodecLevel", location: .body(locationName: "codecLevel"), required: false, type: .enum), 
            AWSShapeMember(label: "QualityTuningLevel", location: .body(locationName: "qualityTuningLevel"), required: false, type: .enum), 
            AWSShapeMember(label: "SpatialAdaptiveQuantization", location: .body(locationName: "spatialAdaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "UnregisteredSeiTimecode", location: .body(locationName: "unregisteredSeiTimecode"), required: false, type: .enum), 
            AWSShapeMember(label: "Softness", location: .body(locationName: "softness"), required: false, type: .integer), 
            AWSShapeMember(label: "SceneChangeDetect", location: .body(locationName: "sceneChangeDetect"), required: false, type: .enum), 
            AWSShapeMember(label: "Bitrate", location: .body(locationName: "bitrate"), required: false, type: .integer), 
            AWSShapeMember(label: "HrdBufferInitialFillPercentage", location: .body(locationName: "hrdBufferInitialFillPercentage"), required: false, type: .integer), 
            AWSShapeMember(label: "GopClosedCadence", location: .body(locationName: "gopClosedCadence"), required: false, type: .integer), 
            AWSShapeMember(label: "FieldEncoding", location: .body(locationName: "fieldEncoding"), required: false, type: .enum), 
            AWSShapeMember(label: "QvbrSettings", location: .body(locationName: "qvbrSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "NumberBFramesBetweenReferenceFrames", location: .body(locationName: "numberBFramesBetweenReferenceFrames"), required: false, type: .integer), 
            AWSShapeMember(label: "FramerateNumerator", location: .body(locationName: "framerateNumerator"), required: false, type: .integer), 
            AWSShapeMember(label: "ParControl", location: .body(locationName: "parControl"), required: false, type: .enum), 
            AWSShapeMember(label: "ParDenominator", location: .body(locationName: "parDenominator"), required: false, type: .integer), 
            AWSShapeMember(label: "MinIInterval", location: .body(locationName: "minIInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "GopSizeUnits", location: .body(locationName: "gopSizeUnits"), required: false, type: .enum), 
            AWSShapeMember(label: "EntropyEncoding", location: .body(locationName: "entropyEncoding"), required: false, type: .enum), 
            AWSShapeMember(label: "NumberReferenceFrames", location: .body(locationName: "numberReferenceFrames"), required: false, type: .integer), 
            AWSShapeMember(label: "RateControlMode", location: .body(locationName: "rateControlMode"), required: false, type: .enum), 
            AWSShapeMember(label: "AdaptiveQuantization", location: .body(locationName: "adaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "FramerateControl", location: .body(locationName: "framerateControl"), required: false, type: .enum), 
            AWSShapeMember(label: "DynamicSubGop", location: .body(locationName: "dynamicSubGop"), required: false, type: .enum), 
            AWSShapeMember(label: "Telecine", location: .body(locationName: "telecine"), required: false, type: .enum), 
            AWSShapeMember(label: "Syntax", location: .body(locationName: "syntax"), required: false, type: .enum), 
            AWSShapeMember(label: "ParNumerator", location: .body(locationName: "parNumerator"), required: false, type: .integer), 
            AWSShapeMember(label: "TemporalAdaptiveQuantization", location: .body(locationName: "temporalAdaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "FlickerAdaptiveQuantization", location: .body(locationName: "flickerAdaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "GopBReference", location: .body(locationName: "gopBReference"), required: false, type: .enum)
        ]
        public let interlaceMode: H264InterlaceMode?
        /// GOP Length (keyframe interval) in frames or seconds. Must be greater than zero.
        public let gopSize: Double?
        /// Size of buffer (HRD buffer model) in bits. For example, enter five megabits as 5000000.
        public let hrdBufferSize: Int32?
        /// Number of slices per picture. Must be less than or equal to the number of macroblock rows for progressive pictures, and less than or equal to half the number of macroblock rows for interlaced pictures.
        public let slices: Int32?
        public let slowPal: H264SlowPal?
        public let framerateConversionAlgorithm: H264FramerateConversionAlgorithm?
        public let codecProfile: H264CodecProfile?
        /// Maximum bitrate in bits/second. For example, enter five megabits per second as 5000000. Required when Rate control mode is QVBR.
        public let maxBitrate: Int32?
        /// When you use the API for transcode jobs that use framerate conversion, specify the framerate as a fraction. For example,  24000 / 1001 = 23.976 fps. Use FramerateDenominator to specify the denominator of this fraction. In this example, use 1001 for the value of FramerateDenominator. When you use the console for transcode jobs that use framerate conversion, provide the value as a decimal number for Framerate. In this example, specify 23.976.
        public let framerateDenominator: Int32?
        public let repeatPps: H264RepeatPps?
        public let codecLevel: H264CodecLevel?
        public let qualityTuningLevel: H264QualityTuningLevel?
        public let spatialAdaptiveQuantization: H264SpatialAdaptiveQuantization?
        public let unregisteredSeiTimecode: H264UnregisteredSeiTimecode?
        /// Softness. Selects quantizer matrix, larger values reduce high-frequency content in the encoded image.
        public let softness: Int32?
        public let sceneChangeDetect: H264SceneChangeDetect?
        /// Average bitrate in bits/second. Required for VBR and CBR. For MS Smooth outputs, bitrates must be unique when rounded down to the nearest multiple of 1000.
        public let bitrate: Int32?
        /// Percentage of the buffer that should initially be filled (HRD buffer model).
        public let hrdBufferInitialFillPercentage: Int32?
        /// Frequency of closed GOPs. In streaming applications, it is recommended that this be set to 1 so a decoder joining mid-stream will receive an IDR frame as quickly as possible. Setting this value to 0 will break output segmenting.
        public let gopClosedCadence: Int32?
        public let fieldEncoding: H264FieldEncoding?
        /// Settings for quality-defined variable bitrate encoding with the H.264 codec. Required when you set Rate control mode to QVBR. Not valid when you set Rate control mode to a value other than QVBR, or when you don't define Rate control mode.
        public let qvbrSettings: H264QvbrSettings?
        /// Number of B-frames between reference frames.
        public let numberBFramesBetweenReferenceFrames: Int32?
        /// Framerate numerator - framerate is a fraction, e.g. 24000 / 1001 = 23.976 fps.
        public let framerateNumerator: Int32?
        public let parControl: H264ParControl?
        /// Pixel Aspect Ratio denominator.
        public let parDenominator: Int32?
        /// Enforces separation between repeated (cadence) I-frames and I-frames inserted by Scene Change Detection. If a scene change I-frame is within I-interval frames of a cadence I-frame, the GOP is shrunk and/or stretched to the scene change I-frame. GOP stretch requires enabling lookahead as well as setting I-interval. The normal cadence resumes for the next GOP. This setting is only used when Scene Change Detect is enabled. Note: Maximum GOP stretch = GOP size + Min-I-interval - 1
        public let minIInterval: Int32?
        public let gopSizeUnits: H264GopSizeUnits?
        public let entropyEncoding: H264EntropyEncoding?
        /// Number of reference frames to use. The encoder may use more than requested if using B-frames and/or interlaced encoding.
        public let numberReferenceFrames: Int32?
        public let rateControlMode: H264RateControlMode?
        public let adaptiveQuantization: H264AdaptiveQuantization?
        public let framerateControl: H264FramerateControl?
        /// Choose Adaptive to improve subjective video quality for high-motion content. This will cause the service to use fewer B-frames (which infer information based on other frames) for high-motion portions of the video and more B-frames for low-motion portions. The maximum number of B-frames is limited by the value you provide for the setting B frames between reference frames (numberBFramesBetweenReferenceFrames).
        public let dynamicSubGop: H264DynamicSubGop?
        public let telecine: H264Telecine?
        public let syntax: H264Syntax?
        /// Pixel Aspect Ratio numerator.
        public let parNumerator: Int32?
        public let temporalAdaptiveQuantization: H264TemporalAdaptiveQuantization?
        public let flickerAdaptiveQuantization: H264FlickerAdaptiveQuantization?
        public let gopBReference: H264GopBReference?

        public init(interlaceMode: H264InterlaceMode? = nil, gopSize: Double? = nil, hrdBufferSize: Int32? = nil, slices: Int32? = nil, slowPal: H264SlowPal? = nil, framerateConversionAlgorithm: H264FramerateConversionAlgorithm? = nil, codecProfile: H264CodecProfile? = nil, maxBitrate: Int32? = nil, framerateDenominator: Int32? = nil, repeatPps: H264RepeatPps? = nil, codecLevel: H264CodecLevel? = nil, qualityTuningLevel: H264QualityTuningLevel? = nil, spatialAdaptiveQuantization: H264SpatialAdaptiveQuantization? = nil, unregisteredSeiTimecode: H264UnregisteredSeiTimecode? = nil, softness: Int32? = nil, sceneChangeDetect: H264SceneChangeDetect? = nil, bitrate: Int32? = nil, hrdBufferInitialFillPercentage: Int32? = nil, gopClosedCadence: Int32? = nil, fieldEncoding: H264FieldEncoding? = nil, qvbrSettings: H264QvbrSettings? = nil, numberBFramesBetweenReferenceFrames: Int32? = nil, framerateNumerator: Int32? = nil, parControl: H264ParControl? = nil, parDenominator: Int32? = nil, minIInterval: Int32? = nil, gopSizeUnits: H264GopSizeUnits? = nil, entropyEncoding: H264EntropyEncoding? = nil, numberReferenceFrames: Int32? = nil, rateControlMode: H264RateControlMode? = nil, adaptiveQuantization: H264AdaptiveQuantization? = nil, framerateControl: H264FramerateControl? = nil, dynamicSubGop: H264DynamicSubGop? = nil, telecine: H264Telecine? = nil, syntax: H264Syntax? = nil, parNumerator: Int32? = nil, temporalAdaptiveQuantization: H264TemporalAdaptiveQuantization? = nil, flickerAdaptiveQuantization: H264FlickerAdaptiveQuantization? = nil, gopBReference: H264GopBReference? = nil) {
            self.interlaceMode = interlaceMode
            self.gopSize = gopSize
            self.hrdBufferSize = hrdBufferSize
            self.slices = slices
            self.slowPal = slowPal
            self.framerateConversionAlgorithm = framerateConversionAlgorithm
            self.codecProfile = codecProfile
            self.maxBitrate = maxBitrate
            self.framerateDenominator = framerateDenominator
            self.repeatPps = repeatPps
            self.codecLevel = codecLevel
            self.qualityTuningLevel = qualityTuningLevel
            self.spatialAdaptiveQuantization = spatialAdaptiveQuantization
            self.unregisteredSeiTimecode = unregisteredSeiTimecode
            self.softness = softness
            self.sceneChangeDetect = sceneChangeDetect
            self.bitrate = bitrate
            self.hrdBufferInitialFillPercentage = hrdBufferInitialFillPercentage
            self.gopClosedCadence = gopClosedCadence
            self.fieldEncoding = fieldEncoding
            self.qvbrSettings = qvbrSettings
            self.numberBFramesBetweenReferenceFrames = numberBFramesBetweenReferenceFrames
            self.framerateNumerator = framerateNumerator
            self.parControl = parControl
            self.parDenominator = parDenominator
            self.minIInterval = minIInterval
            self.gopSizeUnits = gopSizeUnits
            self.entropyEncoding = entropyEncoding
            self.numberReferenceFrames = numberReferenceFrames
            self.rateControlMode = rateControlMode
            self.adaptiveQuantization = adaptiveQuantization
            self.framerateControl = framerateControl
            self.dynamicSubGop = dynamicSubGop
            self.telecine = telecine
            self.syntax = syntax
            self.parNumerator = parNumerator
            self.temporalAdaptiveQuantization = temporalAdaptiveQuantization
            self.flickerAdaptiveQuantization = flickerAdaptiveQuantization
            self.gopBReference = gopBReference
        }

        private enum CodingKeys: String, CodingKey {
            case interlaceMode = "interlaceMode"
            case gopSize = "gopSize"
            case hrdBufferSize = "hrdBufferSize"
            case slices = "slices"
            case slowPal = "slowPal"
            case framerateConversionAlgorithm = "framerateConversionAlgorithm"
            case codecProfile = "codecProfile"
            case maxBitrate = "maxBitrate"
            case framerateDenominator = "framerateDenominator"
            case repeatPps = "repeatPps"
            case codecLevel = "codecLevel"
            case qualityTuningLevel = "qualityTuningLevel"
            case spatialAdaptiveQuantization = "spatialAdaptiveQuantization"
            case unregisteredSeiTimecode = "unregisteredSeiTimecode"
            case softness = "softness"
            case sceneChangeDetect = "sceneChangeDetect"
            case bitrate = "bitrate"
            case hrdBufferInitialFillPercentage = "hrdBufferInitialFillPercentage"
            case gopClosedCadence = "gopClosedCadence"
            case fieldEncoding = "fieldEncoding"
            case qvbrSettings = "qvbrSettings"
            case numberBFramesBetweenReferenceFrames = "numberBFramesBetweenReferenceFrames"
            case framerateNumerator = "framerateNumerator"
            case parControl = "parControl"
            case parDenominator = "parDenominator"
            case minIInterval = "minIInterval"
            case gopSizeUnits = "gopSizeUnits"
            case entropyEncoding = "entropyEncoding"
            case numberReferenceFrames = "numberReferenceFrames"
            case rateControlMode = "rateControlMode"
            case adaptiveQuantization = "adaptiveQuantization"
            case framerateControl = "framerateControl"
            case dynamicSubGop = "dynamicSubGop"
            case telecine = "telecine"
            case syntax = "syntax"
            case parNumerator = "parNumerator"
            case temporalAdaptiveQuantization = "temporalAdaptiveQuantization"
            case flickerAdaptiveQuantization = "flickerAdaptiveQuantization"
            case gopBReference = "gopBReference"
        }
    }

    public enum HlsCaptionLanguageSetting: String, CustomStringConvertible, Codable {
        case insert = "INSERT"
        case omit = "OMIT"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public struct ProresSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InterlaceMode", location: .body(locationName: "interlaceMode"), required: false, type: .enum), 
            AWSShapeMember(label: "Telecine", location: .body(locationName: "telecine"), required: false, type: .enum), 
            AWSShapeMember(label: "ParControl", location: .body(locationName: "parControl"), required: false, type: .enum), 
            AWSShapeMember(label: "FramerateControl", location: .body(locationName: "framerateControl"), required: false, type: .enum), 
            AWSShapeMember(label: "FramerateConversionAlgorithm", location: .body(locationName: "framerateConversionAlgorithm"), required: false, type: .enum), 
            AWSShapeMember(label: "FramerateNumerator", location: .body(locationName: "framerateNumerator"), required: false, type: .integer), 
            AWSShapeMember(label: "FramerateDenominator", location: .body(locationName: "framerateDenominator"), required: false, type: .integer), 
            AWSShapeMember(label: "SlowPal", location: .body(locationName: "slowPal"), required: false, type: .enum), 
            AWSShapeMember(label: "CodecProfile", location: .body(locationName: "codecProfile"), required: false, type: .enum), 
            AWSShapeMember(label: "ParNumerator", location: .body(locationName: "parNumerator"), required: false, type: .integer), 
            AWSShapeMember(label: "ParDenominator", location: .body(locationName: "parDenominator"), required: false, type: .integer)
        ]
        public let interlaceMode: ProresInterlaceMode?
        public let telecine: ProresTelecine?
        public let parControl: ProresParControl?
        public let framerateControl: ProresFramerateControl?
        public let framerateConversionAlgorithm: ProresFramerateConversionAlgorithm?
        /// When you use the API for transcode jobs that use framerate conversion, specify the framerate as a fraction. For example,  24000 / 1001 = 23.976 fps. Use FramerateNumerator to specify the numerator of this fraction. In this example, use 24000 for the value of FramerateNumerator.
        public let framerateNumerator: Int32?
        /// Framerate denominator.
        public let framerateDenominator: Int32?
        public let slowPal: ProresSlowPal?
        public let codecProfile: ProresCodecProfile?
        /// Pixel Aspect Ratio numerator.
        public let parNumerator: Int32?
        /// Pixel Aspect Ratio denominator.
        public let parDenominator: Int32?

        public init(interlaceMode: ProresInterlaceMode? = nil, telecine: ProresTelecine? = nil, parControl: ProresParControl? = nil, framerateControl: ProresFramerateControl? = nil, framerateConversionAlgorithm: ProresFramerateConversionAlgorithm? = nil, framerateNumerator: Int32? = nil, framerateDenominator: Int32? = nil, slowPal: ProresSlowPal? = nil, codecProfile: ProresCodecProfile? = nil, parNumerator: Int32? = nil, parDenominator: Int32? = nil) {
            self.interlaceMode = interlaceMode
            self.telecine = telecine
            self.parControl = parControl
            self.framerateControl = framerateControl
            self.framerateConversionAlgorithm = framerateConversionAlgorithm
            self.framerateNumerator = framerateNumerator
            self.framerateDenominator = framerateDenominator
            self.slowPal = slowPal
            self.codecProfile = codecProfile
            self.parNumerator = parNumerator
            self.parDenominator = parDenominator
        }

        private enum CodingKeys: String, CodingKey {
            case interlaceMode = "interlaceMode"
            case telecine = "telecine"
            case parControl = "parControl"
            case framerateControl = "framerateControl"
            case framerateConversionAlgorithm = "framerateConversionAlgorithm"
            case framerateNumerator = "framerateNumerator"
            case framerateDenominator = "framerateDenominator"
            case slowPal = "slowPal"
            case codecProfile = "codecProfile"
            case parNumerator = "parNumerator"
            case parDenominator = "parDenominator"
        }
    }

    public struct AudioDescription: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StreamName", location: .body(locationName: "streamName"), required: false, type: .string), 
            AWSShapeMember(label: "AudioType", location: .body(locationName: "audioType"), required: false, type: .integer), 
            AWSShapeMember(label: "AudioSourceName", location: .body(locationName: "audioSourceName"), required: false, type: .string), 
            AWSShapeMember(label: "CodecSettings", location: .body(locationName: "codecSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "CustomLanguageCode", location: .body(locationName: "customLanguageCode"), required: false, type: .string), 
            AWSShapeMember(label: "LanguageCodeControl", location: .body(locationName: "languageCodeControl"), required: false, type: .enum), 
            AWSShapeMember(label: "LanguageCode", location: .body(locationName: "languageCode"), required: false, type: .enum), 
            AWSShapeMember(label: "RemixSettings", location: .body(locationName: "remixSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "AudioTypeControl", location: .body(locationName: "audioTypeControl"), required: false, type: .enum), 
            AWSShapeMember(label: "AudioNormalizationSettings", location: .body(locationName: "audioNormalizationSettings"), required: false, type: .structure)
        ]
        /// Used for MS Smooth and Apple HLS outputs. Indicates the name displayed by the player (eg. English, or Director Commentary). Alphanumeric characters, spaces, and underscore are legal.
        public let streamName: String?
        /// Applies only if Follow Input Audio Type is unchecked (false). A number between 0 and 255. The following are defined in ISO-IEC 13818-1: 0 = Undefined, 1 = Clean Effects, 2 = Hearing Impaired, 3 = Visually Impaired Commentary, 4-255 = Reserved.
        public let audioType: Int32?
        /// Specifies which audio data to use from each input. In the simplest case, specify an "Audio Selector":#inputs-audio_selector by name based on its order within each input. For example if you specify "Audio Selector 3", then the third audio selector will be used from each input. If an input does not have an "Audio Selector 3", then the audio selector marked as "default" in that input will be used. If there is no audio selector marked as "default", silence will be inserted for the duration of that input. Alternatively, an "Audio Selector Group":#inputs-audio_selector_group name may be specified, with similar default/silence behavior. If no audio_source_name is specified, then "Audio Selector 1" will be chosen automatically.
        public let audioSourceName: String?
        public let codecSettings: AudioCodecSettings?
        /// Specify the language for this audio output track, using the ISO 639-2 or ISO 639-3 three-letter language code. The language specified will be used when 'Follow Input Language Code' is not selected or when 'Follow Input Language Code' is selected but there is no ISO 639 language code specified by the input.
        public let customLanguageCode: String?
        public let languageCodeControl: AudioLanguageCodeControl?
        /// Indicates the language of the audio output track. The ISO 639 language specified in the 'Language Code' drop down will be used when 'Follow Input Language Code' is not selected or when 'Follow Input Language Code' is selected but there is no ISO 639 language code specified by the input.
        public let languageCode: LanguageCode?
        /// Advanced audio remixing settings.
        public let remixSettings: RemixSettings?
        public let audioTypeControl: AudioTypeControl?
        public let audioNormalizationSettings: AudioNormalizationSettings?

        public init(streamName: String? = nil, audioType: Int32? = nil, audioSourceName: String? = nil, codecSettings: AudioCodecSettings? = nil, customLanguageCode: String? = nil, languageCodeControl: AudioLanguageCodeControl? = nil, languageCode: LanguageCode? = nil, remixSettings: RemixSettings? = nil, audioTypeControl: AudioTypeControl? = nil, audioNormalizationSettings: AudioNormalizationSettings? = nil) {
            self.streamName = streamName
            self.audioType = audioType
            self.audioSourceName = audioSourceName
            self.codecSettings = codecSettings
            self.customLanguageCode = customLanguageCode
            self.languageCodeControl = languageCodeControl
            self.languageCode = languageCode
            self.remixSettings = remixSettings
            self.audioTypeControl = audioTypeControl
            self.audioNormalizationSettings = audioNormalizationSettings
        }

        private enum CodingKeys: String, CodingKey {
            case streamName = "streamName"
            case audioType = "audioType"
            case audioSourceName = "audioSourceName"
            case codecSettings = "codecSettings"
            case customLanguageCode = "customLanguageCode"
            case languageCodeControl = "languageCodeControl"
            case languageCode = "languageCode"
            case remixSettings = "remixSettings"
            case audioTypeControl = "audioTypeControl"
            case audioNormalizationSettings = "audioNormalizationSettings"
        }
    }

    public enum Mpeg2CodecProfile: String, CustomStringConvertible, Codable {
        case main = "MAIN"
        case profile422 = "PROFILE_422"
        public var description: String { return self.rawValue }
    }

    public struct DeleteJobTemplateRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", location: .uri(locationName: "name"), required: true, type: .string)
        ]
        /// The name of the job template to be deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct M3u8Settings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PcrControl", location: .body(locationName: "pcrControl"), required: false, type: .enum), 
            AWSShapeMember(label: "PatInterval", location: .body(locationName: "patInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "PmtInterval", location: .body(locationName: "pmtInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "NielsenId3", location: .body(locationName: "nielsenId3"), required: false, type: .enum), 
            AWSShapeMember(label: "Scte35Pid", location: .body(locationName: "scte35Pid"), required: false, type: .integer), 
            AWSShapeMember(label: "TimedMetadataPid", location: .body(locationName: "timedMetadataPid"), required: false, type: .integer), 
            AWSShapeMember(label: "VideoPid", location: .body(locationName: "videoPid"), required: false, type: .integer), 
            AWSShapeMember(label: "Scte35Source", location: .body(locationName: "scte35Source"), required: false, type: .enum), 
            AWSShapeMember(label: "PmtPid", location: .body(locationName: "pmtPid"), required: false, type: .integer), 
            AWSShapeMember(label: "ProgramNumber", location: .body(locationName: "programNumber"), required: false, type: .integer), 
            AWSShapeMember(label: "AudioPids", location: .body(locationName: "audioPids"), required: false, type: .list), 
            AWSShapeMember(label: "AudioFramesPerPes", location: .body(locationName: "audioFramesPerPes"), required: false, type: .integer), 
            AWSShapeMember(label: "TimedMetadata", location: .body(locationName: "timedMetadata"), required: false, type: .enum), 
            AWSShapeMember(label: "TransportStreamId", location: .body(locationName: "transportStreamId"), required: false, type: .integer), 
            AWSShapeMember(label: "PrivateMetadataPid", location: .body(locationName: "privateMetadataPid"), required: false, type: .integer), 
            AWSShapeMember(label: "PcrPid", location: .body(locationName: "pcrPid"), required: false, type: .integer)
        ]
        public let pcrControl: M3u8PcrControl?
        /// The number of milliseconds between instances of this table in the output transport stream.
        public let patInterval: Int32?
        /// The number of milliseconds between instances of this table in the output transport stream.
        public let pmtInterval: Int32?
        public let nielsenId3: M3u8NielsenId3?
        /// Packet Identifier (PID) of the SCTE-35 stream in the transport stream.
        public let scte35Pid: Int32?
        /// Packet Identifier (PID) of the timed metadata stream in the transport stream.
        public let timedMetadataPid: Int32?
        /// Packet Identifier (PID) of the elementary video stream in the transport stream.
        public let videoPid: Int32?
        public let scte35Source: M3u8Scte35Source?
        /// Packet Identifier (PID) for the Program Map Table (PMT) in the transport stream.
        public let pmtPid: Int32?
        /// The value of the program number field in the Program Map Table.
        public let programNumber: Int32?
        /// Packet Identifier (PID) of the elementary audio stream(s) in the transport stream. Multiple values are accepted, and can be entered in ranges and/or by comma separation.
        public let audioPids: [Int32]?
        /// The number of audio frames to insert for each PES packet.
        public let audioFramesPerPes: Int32?
        public let timedMetadata: TimedMetadata?
        /// The value of the transport stream ID field in the Program Map Table.
        public let transportStreamId: Int32?
        /// Packet Identifier (PID) of the private metadata stream in the transport stream.
        public let privateMetadataPid: Int32?
        /// Packet Identifier (PID) of the Program Clock Reference (PCR) in the transport stream. When no value is given, the encoder will assign the same value as the Video PID.
        public let pcrPid: Int32?

        public init(pcrControl: M3u8PcrControl? = nil, patInterval: Int32? = nil, pmtInterval: Int32? = nil, nielsenId3: M3u8NielsenId3? = nil, scte35Pid: Int32? = nil, timedMetadataPid: Int32? = nil, videoPid: Int32? = nil, scte35Source: M3u8Scte35Source? = nil, pmtPid: Int32? = nil, programNumber: Int32? = nil, audioPids: [Int32]? = nil, audioFramesPerPes: Int32? = nil, timedMetadata: TimedMetadata? = nil, transportStreamId: Int32? = nil, privateMetadataPid: Int32? = nil, pcrPid: Int32? = nil) {
            self.pcrControl = pcrControl
            self.patInterval = patInterval
            self.pmtInterval = pmtInterval
            self.nielsenId3 = nielsenId3
            self.scte35Pid = scte35Pid
            self.timedMetadataPid = timedMetadataPid
            self.videoPid = videoPid
            self.scte35Source = scte35Source
            self.pmtPid = pmtPid
            self.programNumber = programNumber
            self.audioPids = audioPids
            self.audioFramesPerPes = audioFramesPerPes
            self.timedMetadata = timedMetadata
            self.transportStreamId = transportStreamId
            self.privateMetadataPid = privateMetadataPid
            self.pcrPid = pcrPid
        }

        private enum CodingKeys: String, CodingKey {
            case pcrControl = "pcrControl"
            case patInterval = "patInterval"
            case pmtInterval = "pmtInterval"
            case nielsenId3 = "nielsenId3"
            case scte35Pid = "scte35Pid"
            case timedMetadataPid = "timedMetadataPid"
            case videoPid = "videoPid"
            case scte35Source = "scte35Source"
            case pmtPid = "pmtPid"
            case programNumber = "programNumber"
            case audioPids = "audioPids"
            case audioFramesPerPes = "audioFramesPerPes"
            case timedMetadata = "timedMetadata"
            case transportStreamId = "transportStreamId"
            case privateMetadataPid = "privateMetadataPid"
            case pcrPid = "pcrPid"
        }
    }

    public struct JobSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Inputs", location: .body(locationName: "inputs"), required: false, type: .list), 
            AWSShapeMember(label: "MotionImageInserter", location: .body(locationName: "motionImageInserter"), required: false, type: .structure), 
            AWSShapeMember(label: "TimedMetadataInsertion", location: .body(locationName: "timedMetadataInsertion"), required: false, type: .structure), 
            AWSShapeMember(label: "NielsenConfiguration", location: .body(locationName: "nielsenConfiguration"), required: false, type: .structure), 
            AWSShapeMember(label: "AvailBlanking", location: .body(locationName: "availBlanking"), required: false, type: .structure), 
            AWSShapeMember(label: "AdAvailOffset", location: .body(locationName: "adAvailOffset"), required: false, type: .integer), 
            AWSShapeMember(label: "OutputGroups", location: .body(locationName: "outputGroups"), required: false, type: .list), 
            AWSShapeMember(label: "TimecodeConfig", location: .body(locationName: "timecodeConfig"), required: false, type: .structure)
        ]
        /// Use Inputs (inputs) to define source file used in the transcode job. There can be multiple inputs add in a job. These inputs will be concantenated together to create the output.
        public let inputs: [Input]?
        /// Overlay motion graphics on top of your video. The motion graphics that you specify here appear on all outputs in all output groups.
        public let motionImageInserter: MotionImageInserter?
        public let timedMetadataInsertion: TimedMetadataInsertion?
        public let nielsenConfiguration: NielsenConfiguration?
        /// Settings for ad avail blanking.  Video can be blanked or overlaid with an image, and audio muted during SCTE-35 triggered ad avails.
        public let availBlanking: AvailBlanking?
        /// When specified, this offset (in milliseconds) is added to the input Ad Avail PTS time.
        public let adAvailOffset: Int32?
        /// (OutputGroups) contains one group of settings for each set of outputs that share a common package type. All unpackaged files (MPEG-4, MPEG-2 TS, Quicktime, MXF, and no container) are grouped in a single output group as well. Required in (OutputGroups) is a group of settings that apply to the whole group. This required object depends on the value you set for (Type) under (OutputGroups)>(OutputGroupSettings). Type, settings object pairs are as follows. * FILE_GROUP_SETTINGS, FileGroupSettings * HLS_GROUP_SETTINGS, HlsGroupSettings * DASH_ISO_GROUP_SETTINGS, DashIsoGroupSettings * MS_SMOOTH_GROUP_SETTINGS, MsSmoothGroupSettings * CMAF_GROUP_SETTINGS, CmafGroupSettings
        public let outputGroups: [OutputGroup]?
        /// Contains settings used to acquire and adjust timecode information from inputs.
        public let timecodeConfig: TimecodeConfig?

        public init(inputs: [Input]? = nil, motionImageInserter: MotionImageInserter? = nil, timedMetadataInsertion: TimedMetadataInsertion? = nil, nielsenConfiguration: NielsenConfiguration? = nil, availBlanking: AvailBlanking? = nil, adAvailOffset: Int32? = nil, outputGroups: [OutputGroup]? = nil, timecodeConfig: TimecodeConfig? = nil) {
            self.inputs = inputs
            self.motionImageInserter = motionImageInserter
            self.timedMetadataInsertion = timedMetadataInsertion
            self.nielsenConfiguration = nielsenConfiguration
            self.availBlanking = availBlanking
            self.adAvailOffset = adAvailOffset
            self.outputGroups = outputGroups
            self.timecodeConfig = timecodeConfig
        }

        private enum CodingKeys: String, CodingKey {
            case inputs = "inputs"
            case motionImageInserter = "motionImageInserter"
            case timedMetadataInsertion = "timedMetadataInsertion"
            case nielsenConfiguration = "nielsenConfiguration"
            case availBlanking = "availBlanking"
            case adAvailOffset = "adAvailOffset"
            case outputGroups = "outputGroups"
            case timecodeConfig = "timecodeConfig"
        }
    }

    public struct NoiseReducerFilterSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Strength", location: .body(locationName: "strength"), required: false, type: .integer)
        ]
        /// Relative strength of noise reducing filter. Higher values produce stronger filtering.
        public let strength: Int32?

        public init(strength: Int32? = nil) {
            self.strength = strength
        }

        private enum CodingKeys: String, CodingKey {
            case strength = "strength"
        }
    }

    public enum H264FlickerAdaptiveQuantization: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct H265Settings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FramerateDenominator", location: .body(locationName: "framerateDenominator"), required: false, type: .integer), 
            AWSShapeMember(label: "GopSizeUnits", location: .body(locationName: "gopSizeUnits"), required: false, type: .enum), 
            AWSShapeMember(label: "NumberReferenceFrames", location: .body(locationName: "numberReferenceFrames"), required: false, type: .integer), 
            AWSShapeMember(label: "DynamicSubGop", location: .body(locationName: "dynamicSubGop"), required: false, type: .enum), 
            AWSShapeMember(label: "CodecLevel", location: .body(locationName: "codecLevel"), required: false, type: .enum), 
            AWSShapeMember(label: "Slices", location: .body(locationName: "slices"), required: false, type: .integer), 
            AWSShapeMember(label: "QvbrSettings", location: .body(locationName: "qvbrSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "SampleAdaptiveOffsetFilterMode", location: .body(locationName: "sampleAdaptiveOffsetFilterMode"), required: false, type: .enum), 
            AWSShapeMember(label: "HrdBufferInitialFillPercentage", location: .body(locationName: "hrdBufferInitialFillPercentage"), required: false, type: .integer), 
            AWSShapeMember(label: "TemporalAdaptiveQuantization", location: .body(locationName: "temporalAdaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "TemporalIds", location: .body(locationName: "temporalIds"), required: false, type: .enum), 
            AWSShapeMember(label: "SceneChangeDetect", location: .body(locationName: "sceneChangeDetect"), required: false, type: .enum), 
            AWSShapeMember(label: "ParNumerator", location: .body(locationName: "parNumerator"), required: false, type: .integer), 
            AWSShapeMember(label: "FramerateConversionAlgorithm", location: .body(locationName: "framerateConversionAlgorithm"), required: false, type: .enum), 
            AWSShapeMember(label: "GopBReference", location: .body(locationName: "gopBReference"), required: false, type: .enum), 
            AWSShapeMember(label: "RateControlMode", location: .body(locationName: "rateControlMode"), required: false, type: .enum), 
            AWSShapeMember(label: "AlternateTransferFunctionSei", location: .body(locationName: "alternateTransferFunctionSei"), required: false, type: .enum), 
            AWSShapeMember(label: "FramerateNumerator", location: .body(locationName: "framerateNumerator"), required: false, type: .integer), 
            AWSShapeMember(label: "NumberBFramesBetweenReferenceFrames", location: .body(locationName: "numberBFramesBetweenReferenceFrames"), required: false, type: .integer), 
            AWSShapeMember(label: "AdaptiveQuantization", location: .body(locationName: "adaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "SpatialAdaptiveQuantization", location: .body(locationName: "spatialAdaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "Bitrate", location: .body(locationName: "bitrate"), required: false, type: .integer), 
            AWSShapeMember(label: "QualityTuningLevel", location: .body(locationName: "qualityTuningLevel"), required: false, type: .enum), 
            AWSShapeMember(label: "CodecProfile", location: .body(locationName: "codecProfile"), required: false, type: .enum), 
            AWSShapeMember(label: "Tiles", location: .body(locationName: "tiles"), required: false, type: .enum), 
            AWSShapeMember(label: "HrdBufferSize", location: .body(locationName: "hrdBufferSize"), required: false, type: .integer), 
            AWSShapeMember(label: "FlickerAdaptiveQuantization", location: .body(locationName: "flickerAdaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "WriteMp4PackagingType", location: .body(locationName: "writeMp4PackagingType"), required: false, type: .enum), 
            AWSShapeMember(label: "MinIInterval", location: .body(locationName: "minIInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "FramerateControl", location: .body(locationName: "framerateControl"), required: false, type: .enum), 
            AWSShapeMember(label: "Telecine", location: .body(locationName: "telecine"), required: false, type: .enum), 
            AWSShapeMember(label: "ParDenominator", location: .body(locationName: "parDenominator"), required: false, type: .integer), 
            AWSShapeMember(label: "GopClosedCadence", location: .body(locationName: "gopClosedCadence"), required: false, type: .integer), 
            AWSShapeMember(label: "SlowPal", location: .body(locationName: "slowPal"), required: false, type: .enum), 
            AWSShapeMember(label: "GopSize", location: .body(locationName: "gopSize"), required: false, type: .double), 
            AWSShapeMember(label: "UnregisteredSeiTimecode", location: .body(locationName: "unregisteredSeiTimecode"), required: false, type: .enum), 
            AWSShapeMember(label: "InterlaceMode", location: .body(locationName: "interlaceMode"), required: false, type: .enum), 
            AWSShapeMember(label: "ParControl", location: .body(locationName: "parControl"), required: false, type: .enum), 
            AWSShapeMember(label: "MaxBitrate", location: .body(locationName: "maxBitrate"), required: false, type: .integer)
        ]
        /// Framerate denominator.
        public let framerateDenominator: Int32?
        public let gopSizeUnits: H265GopSizeUnits?
        /// Number of reference frames to use. The encoder may use more than requested if using B-frames and/or interlaced encoding.
        public let numberReferenceFrames: Int32?
        /// Choose Adaptive to improve subjective video quality for high-motion content. This will cause the service to use fewer B-frames (which infer information based on other frames) for high-motion portions of the video and more B-frames for low-motion portions. The maximum number of B-frames is limited by the value you provide for the setting B frames between reference frames (numberBFramesBetweenReferenceFrames).
        public let dynamicSubGop: H265DynamicSubGop?
        public let codecLevel: H265CodecLevel?
        /// Number of slices per picture. Must be less than or equal to the number of macroblock rows for progressive pictures, and less than or equal to half the number of macroblock rows for interlaced pictures.
        public let slices: Int32?
        /// Settings for quality-defined variable bitrate encoding with the H.265 codec. Required when you set Rate control mode to QVBR. Not valid when you set Rate control mode to a value other than QVBR, or when you don't define Rate control mode.
        public let qvbrSettings: H265QvbrSettings?
        public let sampleAdaptiveOffsetFilterMode: H265SampleAdaptiveOffsetFilterMode?
        /// Percentage of the buffer that should initially be filled (HRD buffer model).
        public let hrdBufferInitialFillPercentage: Int32?
        public let temporalAdaptiveQuantization: H265TemporalAdaptiveQuantization?
        public let temporalIds: H265TemporalIds?
        public let sceneChangeDetect: H265SceneChangeDetect?
        /// Pixel Aspect Ratio numerator.
        public let parNumerator: Int32?
        public let framerateConversionAlgorithm: H265FramerateConversionAlgorithm?
        public let gopBReference: H265GopBReference?
        public let rateControlMode: H265RateControlMode?
        public let alternateTransferFunctionSei: H265AlternateTransferFunctionSei?
        /// Framerate numerator - framerate is a fraction, e.g. 24000 / 1001 = 23.976 fps.
        public let framerateNumerator: Int32?
        /// Number of B-frames between reference frames.
        public let numberBFramesBetweenReferenceFrames: Int32?
        public let adaptiveQuantization: H265AdaptiveQuantization?
        public let spatialAdaptiveQuantization: H265SpatialAdaptiveQuantization?
        /// Average bitrate in bits/second. Required for VBR and CBR. For MS Smooth outputs, bitrates must be unique when rounded down to the nearest multiple of 1000.
        public let bitrate: Int32?
        public let qualityTuningLevel: H265QualityTuningLevel?
        public let codecProfile: H265CodecProfile?
        public let tiles: H265Tiles?
        /// Size of buffer (HRD buffer model) in bits. For example, enter five megabits as 5000000.
        public let hrdBufferSize: Int32?
        public let flickerAdaptiveQuantization: H265FlickerAdaptiveQuantization?
        public let writeMp4PackagingType: H265WriteMp4PackagingType?
        /// Enforces separation between repeated (cadence) I-frames and I-frames inserted by Scene Change Detection. If a scene change I-frame is within I-interval frames of a cadence I-frame, the GOP is shrunk and/or stretched to the scene change I-frame. GOP stretch requires enabling lookahead as well as setting I-interval. The normal cadence resumes for the next GOP. This setting is only used when Scene Change Detect is enabled. Note: Maximum GOP stretch = GOP size + Min-I-interval - 1
        public let minIInterval: Int32?
        public let framerateControl: H265FramerateControl?
        public let telecine: H265Telecine?
        /// Pixel Aspect Ratio denominator.
        public let parDenominator: Int32?
        /// Frequency of closed GOPs. In streaming applications, it is recommended that this be set to 1 so a decoder joining mid-stream will receive an IDR frame as quickly as possible. Setting this value to 0 will break output segmenting.
        public let gopClosedCadence: Int32?
        public let slowPal: H265SlowPal?
        /// GOP Length (keyframe interval) in frames or seconds. Must be greater than zero.
        public let gopSize: Double?
        public let unregisteredSeiTimecode: H265UnregisteredSeiTimecode?
        public let interlaceMode: H265InterlaceMode?
        public let parControl: H265ParControl?
        /// Maximum bitrate in bits/second. For example, enter five megabits per second as 5000000. Required when Rate control mode is QVBR.
        public let maxBitrate: Int32?

        public init(framerateDenominator: Int32? = nil, gopSizeUnits: H265GopSizeUnits? = nil, numberReferenceFrames: Int32? = nil, dynamicSubGop: H265DynamicSubGop? = nil, codecLevel: H265CodecLevel? = nil, slices: Int32? = nil, qvbrSettings: H265QvbrSettings? = nil, sampleAdaptiveOffsetFilterMode: H265SampleAdaptiveOffsetFilterMode? = nil, hrdBufferInitialFillPercentage: Int32? = nil, temporalAdaptiveQuantization: H265TemporalAdaptiveQuantization? = nil, temporalIds: H265TemporalIds? = nil, sceneChangeDetect: H265SceneChangeDetect? = nil, parNumerator: Int32? = nil, framerateConversionAlgorithm: H265FramerateConversionAlgorithm? = nil, gopBReference: H265GopBReference? = nil, rateControlMode: H265RateControlMode? = nil, alternateTransferFunctionSei: H265AlternateTransferFunctionSei? = nil, framerateNumerator: Int32? = nil, numberBFramesBetweenReferenceFrames: Int32? = nil, adaptiveQuantization: H265AdaptiveQuantization? = nil, spatialAdaptiveQuantization: H265SpatialAdaptiveQuantization? = nil, bitrate: Int32? = nil, qualityTuningLevel: H265QualityTuningLevel? = nil, codecProfile: H265CodecProfile? = nil, tiles: H265Tiles? = nil, hrdBufferSize: Int32? = nil, flickerAdaptiveQuantization: H265FlickerAdaptiveQuantization? = nil, writeMp4PackagingType: H265WriteMp4PackagingType? = nil, minIInterval: Int32? = nil, framerateControl: H265FramerateControl? = nil, telecine: H265Telecine? = nil, parDenominator: Int32? = nil, gopClosedCadence: Int32? = nil, slowPal: H265SlowPal? = nil, gopSize: Double? = nil, unregisteredSeiTimecode: H265UnregisteredSeiTimecode? = nil, interlaceMode: H265InterlaceMode? = nil, parControl: H265ParControl? = nil, maxBitrate: Int32? = nil) {
            self.framerateDenominator = framerateDenominator
            self.gopSizeUnits = gopSizeUnits
            self.numberReferenceFrames = numberReferenceFrames
            self.dynamicSubGop = dynamicSubGop
            self.codecLevel = codecLevel
            self.slices = slices
            self.qvbrSettings = qvbrSettings
            self.sampleAdaptiveOffsetFilterMode = sampleAdaptiveOffsetFilterMode
            self.hrdBufferInitialFillPercentage = hrdBufferInitialFillPercentage
            self.temporalAdaptiveQuantization = temporalAdaptiveQuantization
            self.temporalIds = temporalIds
            self.sceneChangeDetect = sceneChangeDetect
            self.parNumerator = parNumerator
            self.framerateConversionAlgorithm = framerateConversionAlgorithm
            self.gopBReference = gopBReference
            self.rateControlMode = rateControlMode
            self.alternateTransferFunctionSei = alternateTransferFunctionSei
            self.framerateNumerator = framerateNumerator
            self.numberBFramesBetweenReferenceFrames = numberBFramesBetweenReferenceFrames
            self.adaptiveQuantization = adaptiveQuantization
            self.spatialAdaptiveQuantization = spatialAdaptiveQuantization
            self.bitrate = bitrate
            self.qualityTuningLevel = qualityTuningLevel
            self.codecProfile = codecProfile
            self.tiles = tiles
            self.hrdBufferSize = hrdBufferSize
            self.flickerAdaptiveQuantization = flickerAdaptiveQuantization
            self.writeMp4PackagingType = writeMp4PackagingType
            self.minIInterval = minIInterval
            self.framerateControl = framerateControl
            self.telecine = telecine
            self.parDenominator = parDenominator
            self.gopClosedCadence = gopClosedCadence
            self.slowPal = slowPal
            self.gopSize = gopSize
            self.unregisteredSeiTimecode = unregisteredSeiTimecode
            self.interlaceMode = interlaceMode
            self.parControl = parControl
            self.maxBitrate = maxBitrate
        }

        private enum CodingKeys: String, CodingKey {
            case framerateDenominator = "framerateDenominator"
            case gopSizeUnits = "gopSizeUnits"
            case numberReferenceFrames = "numberReferenceFrames"
            case dynamicSubGop = "dynamicSubGop"
            case codecLevel = "codecLevel"
            case slices = "slices"
            case qvbrSettings = "qvbrSettings"
            case sampleAdaptiveOffsetFilterMode = "sampleAdaptiveOffsetFilterMode"
            case hrdBufferInitialFillPercentage = "hrdBufferInitialFillPercentage"
            case temporalAdaptiveQuantization = "temporalAdaptiveQuantization"
            case temporalIds = "temporalIds"
            case sceneChangeDetect = "sceneChangeDetect"
            case parNumerator = "parNumerator"
            case framerateConversionAlgorithm = "framerateConversionAlgorithm"
            case gopBReference = "gopBReference"
            case rateControlMode = "rateControlMode"
            case alternateTransferFunctionSei = "alternateTransferFunctionSei"
            case framerateNumerator = "framerateNumerator"
            case numberBFramesBetweenReferenceFrames = "numberBFramesBetweenReferenceFrames"
            case adaptiveQuantization = "adaptiveQuantization"
            case spatialAdaptiveQuantization = "spatialAdaptiveQuantization"
            case bitrate = "bitrate"
            case qualityTuningLevel = "qualityTuningLevel"
            case codecProfile = "codecProfile"
            case tiles = "tiles"
            case hrdBufferSize = "hrdBufferSize"
            case flickerAdaptiveQuantization = "flickerAdaptiveQuantization"
            case writeMp4PackagingType = "writeMp4PackagingType"
            case minIInterval = "minIInterval"
            case framerateControl = "framerateControl"
            case telecine = "telecine"
            case parDenominator = "parDenominator"
            case gopClosedCadence = "gopClosedCadence"
            case slowPal = "slowPal"
            case gopSize = "gopSize"
            case unregisteredSeiTimecode = "unregisteredSeiTimecode"
            case interlaceMode = "interlaceMode"
            case parControl = "parControl"
            case maxBitrate = "maxBitrate"
        }
    }

    public enum MotionImagePlayback: String, CustomStringConvertible, Codable {
        case once = "ONCE"
        case `repeat` = "REPEAT"
        public var description: String { return self.rawValue }
    }

    public struct CmafGroupSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ManifestDurationFormat", location: .body(locationName: "manifestDurationFormat"), required: false, type: .enum), 
            AWSShapeMember(label: "MinFinalSegmentLength", location: .body(locationName: "minFinalSegmentLength"), required: false, type: .double), 
            AWSShapeMember(label: "FragmentLength", location: .body(locationName: "fragmentLength"), required: false, type: .integer), 
            AWSShapeMember(label: "WriteHlsManifest", location: .body(locationName: "writeHlsManifest"), required: false, type: .enum), 
            AWSShapeMember(label: "ManifestCompression", location: .body(locationName: "manifestCompression"), required: false, type: .enum), 
            AWSShapeMember(label: "ClientCache", location: .body(locationName: "clientCache"), required: false, type: .enum), 
            AWSShapeMember(label: "MinBufferTime", location: .body(locationName: "minBufferTime"), required: false, type: .integer), 
            AWSShapeMember(label: "Encryption", location: .body(locationName: "encryption"), required: false, type: .structure), 
            AWSShapeMember(label: "Destination", location: .body(locationName: "destination"), required: false, type: .string), 
            AWSShapeMember(label: "StreamInfResolution", location: .body(locationName: "streamInfResolution"), required: false, type: .enum), 
            AWSShapeMember(label: "CodecSpecification", location: .body(locationName: "codecSpecification"), required: false, type: .enum), 
            AWSShapeMember(label: "SegmentControl", location: .body(locationName: "segmentControl"), required: false, type: .enum), 
            AWSShapeMember(label: "BaseUrl", location: .body(locationName: "baseUrl"), required: false, type: .string), 
            AWSShapeMember(label: "WriteDashManifest", location: .body(locationName: "writeDashManifest"), required: false, type: .enum), 
            AWSShapeMember(label: "SegmentLength", location: .body(locationName: "segmentLength"), required: false, type: .integer)
        ]
        public let manifestDurationFormat: CmafManifestDurationFormat?
        /// Keep this setting at the default value of 0, unless you are troubleshooting a problem with how devices play back the end of your video asset. If you know that player devices are hanging on the final segment of your video because the length of your final segment is too short, use this setting to specify a minimum final segment length, in seconds. Choose a value that is greater than or equal to 1 and less than your segment length. When you specify a value for this setting, the encoder will combine any final segment that is shorter than the length that you specify with the previous segment. For example, your segment length is 3 seconds and your final segment is .5 seconds without a minimum final segment length; when you set the minimum final segment length to 1, your final segment is 3.5 seconds.
        public let minFinalSegmentLength: Double?
        /// Length of fragments to generate (in seconds). Fragment length must be compatible with GOP size and Framerate. Note that fragments will end on the next keyframe after this number of seconds, so actual fragment length may be longer. When Emit Single File is checked, the fragmentation is internal to a single output file and it does not cause the creation of many output files as in other output types.
        public let fragmentLength: Int32?
        public let writeHlsManifest: CmafWriteHLSManifest?
        public let manifestCompression: CmafManifestCompression?
        public let clientCache: CmafClientCache?
        /// Minimum time of initially buffered media that is needed to ensure smooth playout.
        public let minBufferTime: Int32?
        /// DRM settings.
        public let encryption: CmafEncryptionSettings?
        /// Use Destination (Destination) to specify the S3 output location and the output filename base. Destination accepts format identifiers. If you do not specify the base filename in the URI, the service will use the filename of the input file. If your job has multiple inputs, the service uses the filename of the first input file.
        public let destination: String?
        public let streamInfResolution: CmafStreamInfResolution?
        public let codecSpecification: CmafCodecSpecification?
        public let segmentControl: CmafSegmentControl?
        /// A partial URI prefix that will be put in the manifest file at the top level BaseURL element. Can be used if streams are delivered from a different URL than the manifest file.
        public let baseUrl: String?
        public let writeDashManifest: CmafWriteDASHManifest?
        /// Use this setting to specify the length, in seconds, of each individual CMAF segment. This value applies to the whole package; that is, to every output in the output group. Note that segments end on the first keyframe after this number of seconds, so the actual segment length might be slightly longer. If you set Segment control (CmafSegmentControl) to single file, the service puts the content of each output in a single file that has metadata that marks these segments. If you set it to segmented files, the service creates multiple files for each output, each with the content of one segment.
        public let segmentLength: Int32?

        public init(manifestDurationFormat: CmafManifestDurationFormat? = nil, minFinalSegmentLength: Double? = nil, fragmentLength: Int32? = nil, writeHlsManifest: CmafWriteHLSManifest? = nil, manifestCompression: CmafManifestCompression? = nil, clientCache: CmafClientCache? = nil, minBufferTime: Int32? = nil, encryption: CmafEncryptionSettings? = nil, destination: String? = nil, streamInfResolution: CmafStreamInfResolution? = nil, codecSpecification: CmafCodecSpecification? = nil, segmentControl: CmafSegmentControl? = nil, baseUrl: String? = nil, writeDashManifest: CmafWriteDASHManifest? = nil, segmentLength: Int32? = nil) {
            self.manifestDurationFormat = manifestDurationFormat
            self.minFinalSegmentLength = minFinalSegmentLength
            self.fragmentLength = fragmentLength
            self.writeHlsManifest = writeHlsManifest
            self.manifestCompression = manifestCompression
            self.clientCache = clientCache
            self.minBufferTime = minBufferTime
            self.encryption = encryption
            self.destination = destination
            self.streamInfResolution = streamInfResolution
            self.codecSpecification = codecSpecification
            self.segmentControl = segmentControl
            self.baseUrl = baseUrl
            self.writeDashManifest = writeDashManifest
            self.segmentLength = segmentLength
        }

        private enum CodingKeys: String, CodingKey {
            case manifestDurationFormat = "manifestDurationFormat"
            case minFinalSegmentLength = "minFinalSegmentLength"
            case fragmentLength = "fragmentLength"
            case writeHlsManifest = "writeHlsManifest"
            case manifestCompression = "manifestCompression"
            case clientCache = "clientCache"
            case minBufferTime = "minBufferTime"
            case encryption = "encryption"
            case destination = "destination"
            case streamInfResolution = "streamInfResolution"
            case codecSpecification = "codecSpecification"
            case segmentControl = "segmentControl"
            case baseUrl = "baseUrl"
            case writeDashManifest = "writeDashManifest"
            case segmentLength = "segmentLength"
        }
    }

    public struct VideoDetail: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WidthInPx", location: .body(locationName: "widthInPx"), required: false, type: .integer), 
            AWSShapeMember(label: "HeightInPx", location: .body(locationName: "heightInPx"), required: false, type: .integer)
        ]
        /// Width in pixels for the output
        public let widthInPx: Int32?
        /// Height in pixels for the output
        public let heightInPx: Int32?

        public init(widthInPx: Int32? = nil, heightInPx: Int32? = nil) {
            self.widthInPx = widthInPx
            self.heightInPx = heightInPx
        }

        private enum CodingKeys: String, CodingKey {
            case widthInPx = "widthInPx"
            case heightInPx = "heightInPx"
        }
    }

    public enum HlsEncryptionType: String, CustomStringConvertible, Codable {
        case aes128 = "AES128"
        case sampleAes = "SAMPLE_AES"
        public var description: String { return self.rawValue }
    }

    public enum H265GopBReference: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct ListQueuesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "ListBy", location: .querystring(locationName: "listBy"), required: false, type: .enum), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "Order", location: .querystring(locationName: "order"), required: false, type: .enum)
        ]
        /// Optional. Number of queues, up to twenty, that will be returned at one time.
        public let maxResults: Int32?
        public let listBy: QueueListBy?
        /// Use this string, provided with the response to a previous request, to request the next batch of queues.
        public let nextToken: String?
        public let order: Order?

        public init(maxResults: Int32? = nil, listBy: QueueListBy? = nil, nextToken: String? = nil, order: Order? = nil) {
            self.maxResults = maxResults
            self.listBy = listBy
            self.nextToken = nextToken
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case listBy = "listBy"
            case nextToken = "nextToken"
            case order = "order"
        }
    }

    public enum DvbSubtitleFontColor: String, CustomStringConvertible, Codable {
        case white = "WHITE"
        case black = "BLACK"
        case yellow = "YELLOW"
        case red = "RED"
        case green = "GREEN"
        case blue = "BLUE"
        public var description: String { return self.rawValue }
    }

    public enum VideoCodec: String, CustomStringConvertible, Codable {
        case frameCapture = "FRAME_CAPTURE"
        case h264 = "H_264"
        case h265 = "H_265"
        case mpeg2 = "MPEG2"
        case prores = "PRORES"
        public var description: String { return self.rawValue }
    }

    public enum HlsDirectoryStructure: String, CustomStringConvertible, Codable {
        case singleDirectory = "SINGLE_DIRECTORY"
        case subdirectoryPerStream = "SUBDIRECTORY_PER_STREAM"
        public var description: String { return self.rawValue }
    }

    public enum M2tsNielsenId3: String, CustomStringConvertible, Codable {
        case insert = "INSERT"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum H264TemporalAdaptiveQuantization: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum ProresInterlaceMode: String, CustomStringConvertible, Codable {
        case progressive = "PROGRESSIVE"
        case topField = "TOP_FIELD"
        case bottomField = "BOTTOM_FIELD"
        case followTopField = "FOLLOW_TOP_FIELD"
        case followBottomField = "FOLLOW_BOTTOM_FIELD"
        public var description: String { return self.rawValue }
    }

    public enum H264SceneChangeDetect: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum H265TemporalIds: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum Mp4CslgAtom: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public enum BurninSubtitleShadowColor: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case black = "BLACK"
        case white = "WHITE"
        public var description: String { return self.rawValue }
    }

    public struct M2tsSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TransportStreamId", location: .body(locationName: "transportStreamId"), required: false, type: .integer), 
            AWSShapeMember(label: "PmtInterval", location: .body(locationName: "pmtInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "DvbSubPids", location: .body(locationName: "dvbSubPids"), required: false, type: .list), 
            AWSShapeMember(label: "PatInterval", location: .body(locationName: "patInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "DvbTeletextPid", location: .body(locationName: "dvbTeletextPid"), required: false, type: .integer), 
            AWSShapeMember(label: "MinEbpInterval", location: .body(locationName: "minEbpInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "PcrControl", location: .body(locationName: "pcrControl"), required: false, type: .enum), 
            AWSShapeMember(label: "SegmentationMarkers", location: .body(locationName: "segmentationMarkers"), required: false, type: .enum), 
            AWSShapeMember(label: "DvbSdtSettings", location: .body(locationName: "dvbSdtSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "PmtPid", location: .body(locationName: "pmtPid"), required: false, type: .integer), 
            AWSShapeMember(label: "FragmentTime", location: .body(locationName: "fragmentTime"), required: false, type: .double), 
            AWSShapeMember(label: "AudioPids", location: .body(locationName: "audioPids"), required: false, type: .list), 
            AWSShapeMember(label: "MaxPcrInterval", location: .body(locationName: "maxPcrInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "TimedMetadataPid", location: .body(locationName: "timedMetadataPid"), required: false, type: .integer), 
            AWSShapeMember(label: "PrivateMetadataPid", location: .body(locationName: "privateMetadataPid"), required: false, type: .integer), 
            AWSShapeMember(label: "BufferModel", location: .body(locationName: "bufferModel"), required: false, type: .enum), 
            AWSShapeMember(label: "DvbTdtSettings", location: .body(locationName: "dvbTdtSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "ProgramNumber", location: .body(locationName: "programNumber"), required: false, type: .integer), 
            AWSShapeMember(label: "DvbNitSettings", location: .body(locationName: "dvbNitSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "EsRateInPes", location: .body(locationName: "esRateInPes"), required: false, type: .enum), 
            AWSShapeMember(label: "AudioBufferModel", location: .body(locationName: "audioBufferModel"), required: false, type: .enum), 
            AWSShapeMember(label: "EbpPlacement", location: .body(locationName: "ebpPlacement"), required: false, type: .enum), 
            AWSShapeMember(label: "PcrPid", location: .body(locationName: "pcrPid"), required: false, type: .integer), 
            AWSShapeMember(label: "NielsenId3", location: .body(locationName: "nielsenId3"), required: false, type: .enum), 
            AWSShapeMember(label: "Scte35Source", location: .body(locationName: "scte35Source"), required: false, type: .enum), 
            AWSShapeMember(label: "Bitrate", location: .body(locationName: "bitrate"), required: false, type: .integer), 
            AWSShapeMember(label: "NullPacketBitrate", location: .body(locationName: "nullPacketBitrate"), required: false, type: .double), 
            AWSShapeMember(label: "SegmentationTime", location: .body(locationName: "segmentationTime"), required: false, type: .double), 
            AWSShapeMember(label: "AudioFramesPerPes", location: .body(locationName: "audioFramesPerPes"), required: false, type: .integer), 
            AWSShapeMember(label: "VideoPid", location: .body(locationName: "videoPid"), required: false, type: .integer), 
            AWSShapeMember(label: "SegmentationStyle", location: .body(locationName: "segmentationStyle"), required: false, type: .enum), 
            AWSShapeMember(label: "EbpAudioInterval", location: .body(locationName: "ebpAudioInterval"), required: false, type: .enum), 
            AWSShapeMember(label: "Scte35Pid", location: .body(locationName: "scte35Pid"), required: false, type: .integer), 
            AWSShapeMember(label: "RateMode", location: .body(locationName: "rateMode"), required: false, type: .enum)
        ]
        /// The value of the transport stream ID field in the Program Map Table.
        public let transportStreamId: Int32?
        /// The number of milliseconds between instances of this table in the output transport stream.
        public let pmtInterval: Int32?
        /// Packet Identifier (PID) for input source DVB Subtitle data to this output. Multiple values are accepted, and can be entered in ranges and/or by comma separation.
        public let dvbSubPids: [Int32]?
        /// The number of milliseconds between instances of this table in the output transport stream.
        public let patInterval: Int32?
        /// Packet Identifier (PID) for input source DVB Teletext data to this output.
        public let dvbTeletextPid: Int32?
        /// When set, enforces that Encoder Boundary Points do not come within the specified time interval of each other by looking ahead at input video. If another EBP is going to come in within the specified time interval, the current EBP is not emitted, and the segment is "stretched" to the next marker. The lookahead value does not add latency to the system. The Live Event must be configured elsewhere to create sufficient latency to make the lookahead accurate.
        public let minEbpInterval: Int32?
        public let pcrControl: M2tsPcrControl?
        public let segmentationMarkers: M2tsSegmentationMarkers?
        public let dvbSdtSettings: DvbSdtSettings?
        /// Packet Identifier (PID) for the Program Map Table (PMT) in the transport stream.
        public let pmtPid: Int32?
        /// The length in seconds of each fragment. Only used with EBP markers.
        public let fragmentTime: Double?
        /// Packet Identifier (PID) of the elementary audio stream(s) in the transport stream. Multiple values are accepted, and can be entered in ranges and/or by comma separation.
        public let audioPids: [Int32]?
        /// Maximum time in milliseconds between Program Clock References (PCRs) inserted into the transport stream.
        public let maxPcrInterval: Int32?
        /// Packet Identifier (PID) of the timed metadata stream in the transport stream.
        public let timedMetadataPid: Int32?
        /// Packet Identifier (PID) of the private metadata stream in the transport stream.
        public let privateMetadataPid: Int32?
        public let bufferModel: M2tsBufferModel?
        public let dvbTdtSettings: DvbTdtSettings?
        /// The value of the program number field in the Program Map Table.
        public let programNumber: Int32?
        public let dvbNitSettings: DvbNitSettings?
        public let esRateInPes: M2tsEsRateInPes?
        public let audioBufferModel: M2tsAudioBufferModel?
        public let ebpPlacement: M2tsEbpPlacement?
        /// Packet Identifier (PID) of the Program Clock Reference (PCR) in the transport stream. When no value is given, the encoder will assign the same value as the Video PID.
        public let pcrPid: Int32?
        public let nielsenId3: M2tsNielsenId3?
        public let scte35Source: M2tsScte35Source?
        /// The output bitrate of the transport stream in bits per second. Setting to 0 lets the muxer automatically determine the appropriate bitrate. Other common values are 3750000, 7500000, and 15000000.
        public let bitrate: Int32?
        /// Value in bits per second of extra null packets to insert into the transport stream. This can be used if a downstream encryption system requires periodic null packets.
        public let nullPacketBitrate: Double?
        /// The length in seconds of each segment. Required unless markers is set to _none_.
        public let segmentationTime: Double?
        /// The number of audio frames to insert for each PES packet.
        public let audioFramesPerPes: Int32?
        /// Packet Identifier (PID) of the elementary video stream in the transport stream.
        public let videoPid: Int32?
        public let segmentationStyle: M2tsSegmentationStyle?
        public let ebpAudioInterval: M2tsEbpAudioInterval?
        /// Packet Identifier (PID) of the SCTE-35 stream in the transport stream.
        public let scte35Pid: Int32?
        public let rateMode: M2tsRateMode?

        public init(transportStreamId: Int32? = nil, pmtInterval: Int32? = nil, dvbSubPids: [Int32]? = nil, patInterval: Int32? = nil, dvbTeletextPid: Int32? = nil, minEbpInterval: Int32? = nil, pcrControl: M2tsPcrControl? = nil, segmentationMarkers: M2tsSegmentationMarkers? = nil, dvbSdtSettings: DvbSdtSettings? = nil, pmtPid: Int32? = nil, fragmentTime: Double? = nil, audioPids: [Int32]? = nil, maxPcrInterval: Int32? = nil, timedMetadataPid: Int32? = nil, privateMetadataPid: Int32? = nil, bufferModel: M2tsBufferModel? = nil, dvbTdtSettings: DvbTdtSettings? = nil, programNumber: Int32? = nil, dvbNitSettings: DvbNitSettings? = nil, esRateInPes: M2tsEsRateInPes? = nil, audioBufferModel: M2tsAudioBufferModel? = nil, ebpPlacement: M2tsEbpPlacement? = nil, pcrPid: Int32? = nil, nielsenId3: M2tsNielsenId3? = nil, scte35Source: M2tsScte35Source? = nil, bitrate: Int32? = nil, nullPacketBitrate: Double? = nil, segmentationTime: Double? = nil, audioFramesPerPes: Int32? = nil, videoPid: Int32? = nil, segmentationStyle: M2tsSegmentationStyle? = nil, ebpAudioInterval: M2tsEbpAudioInterval? = nil, scte35Pid: Int32? = nil, rateMode: M2tsRateMode? = nil) {
            self.transportStreamId = transportStreamId
            self.pmtInterval = pmtInterval
            self.dvbSubPids = dvbSubPids
            self.patInterval = patInterval
            self.dvbTeletextPid = dvbTeletextPid
            self.minEbpInterval = minEbpInterval
            self.pcrControl = pcrControl
            self.segmentationMarkers = segmentationMarkers
            self.dvbSdtSettings = dvbSdtSettings
            self.pmtPid = pmtPid
            self.fragmentTime = fragmentTime
            self.audioPids = audioPids
            self.maxPcrInterval = maxPcrInterval
            self.timedMetadataPid = timedMetadataPid
            self.privateMetadataPid = privateMetadataPid
            self.bufferModel = bufferModel
            self.dvbTdtSettings = dvbTdtSettings
            self.programNumber = programNumber
            self.dvbNitSettings = dvbNitSettings
            self.esRateInPes = esRateInPes
            self.audioBufferModel = audioBufferModel
            self.ebpPlacement = ebpPlacement
            self.pcrPid = pcrPid
            self.nielsenId3 = nielsenId3
            self.scte35Source = scte35Source
            self.bitrate = bitrate
            self.nullPacketBitrate = nullPacketBitrate
            self.segmentationTime = segmentationTime
            self.audioFramesPerPes = audioFramesPerPes
            self.videoPid = videoPid
            self.segmentationStyle = segmentationStyle
            self.ebpAudioInterval = ebpAudioInterval
            self.scte35Pid = scte35Pid
            self.rateMode = rateMode
        }

        private enum CodingKeys: String, CodingKey {
            case transportStreamId = "transportStreamId"
            case pmtInterval = "pmtInterval"
            case dvbSubPids = "dvbSubPids"
            case patInterval = "patInterval"
            case dvbTeletextPid = "dvbTeletextPid"
            case minEbpInterval = "minEbpInterval"
            case pcrControl = "pcrControl"
            case segmentationMarkers = "segmentationMarkers"
            case dvbSdtSettings = "dvbSdtSettings"
            case pmtPid = "pmtPid"
            case fragmentTime = "fragmentTime"
            case audioPids = "audioPids"
            case maxPcrInterval = "maxPcrInterval"
            case timedMetadataPid = "timedMetadataPid"
            case privateMetadataPid = "privateMetadataPid"
            case bufferModel = "bufferModel"
            case dvbTdtSettings = "dvbTdtSettings"
            case programNumber = "programNumber"
            case dvbNitSettings = "dvbNitSettings"
            case esRateInPes = "esRateInPes"
            case audioBufferModel = "audioBufferModel"
            case ebpPlacement = "ebpPlacement"
            case pcrPid = "pcrPid"
            case nielsenId3 = "nielsenId3"
            case scte35Source = "scte35Source"
            case bitrate = "bitrate"
            case nullPacketBitrate = "nullPacketBitrate"
            case segmentationTime = "segmentationTime"
            case audioFramesPerPes = "audioFramesPerPes"
            case videoPid = "videoPid"
            case segmentationStyle = "segmentationStyle"
            case ebpAudioInterval = "ebpAudioInterval"
            case scte35Pid = "scte35Pid"
            case rateMode = "rateMode"
        }
    }

    public struct FrameCaptureSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxCaptures", location: .body(locationName: "maxCaptures"), required: false, type: .integer), 
            AWSShapeMember(label: "FramerateNumerator", location: .body(locationName: "framerateNumerator"), required: false, type: .integer), 
            AWSShapeMember(label: "Quality", location: .body(locationName: "quality"), required: false, type: .integer), 
            AWSShapeMember(label: "FramerateDenominator", location: .body(locationName: "framerateDenominator"), required: false, type: .integer)
        ]
        /// Maximum number of captures (encoded jpg output files).
        public let maxCaptures: Int32?
        /// Frame capture will encode the first frame of the output stream, then one frame every framerateDenominator/framerateNumerator seconds. For example, settings of framerateNumerator = 1 and framerateDenominator = 3 (a rate of 1/3 frame per second) will capture the first frame, then 1 frame every 3s. Files will be named as filename.NNNNNNN.jpg where N is the 0-based frame sequence number zero padded to 7 decimal places.
        public let framerateNumerator: Int32?
        /// JPEG Quality - a higher value equals higher quality.
        public let quality: Int32?
        /// Frame capture will encode the first frame of the output stream, then one frame every framerateDenominator/framerateNumerator seconds. For example, settings of framerateNumerator = 1 and framerateDenominator = 3 (a rate of 1/3 frame per second) will capture the first frame, then 1 frame every 3s. Files will be named as filename.n.jpg where n is the 0-based sequence number of each Capture.
        public let framerateDenominator: Int32?

        public init(maxCaptures: Int32? = nil, framerateNumerator: Int32? = nil, quality: Int32? = nil, framerateDenominator: Int32? = nil) {
            self.maxCaptures = maxCaptures
            self.framerateNumerator = framerateNumerator
            self.quality = quality
            self.framerateDenominator = framerateDenominator
        }

        private enum CodingKeys: String, CodingKey {
            case maxCaptures = "maxCaptures"
            case framerateNumerator = "framerateNumerator"
            case quality = "quality"
            case framerateDenominator = "framerateDenominator"
        }
    }

    public struct GetPresetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", location: .uri(locationName: "name"), required: true, type: .string)
        ]
        /// The name of the preset.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public enum DashIsoWriteSegmentTimelineInRepresentation: String, CustomStringConvertible, Codable {
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public enum Mpeg2GopSizeUnits: String, CustomStringConvertible, Codable {
        case frames = "FRAMES"
        case seconds = "SECONDS"
        public var description: String { return self.rawValue }
    }

    public struct MovSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Mpeg2FourCCControl", location: .body(locationName: "mpeg2FourCCControl"), required: false, type: .enum), 
            AWSShapeMember(label: "CslgAtom", location: .body(locationName: "cslgAtom"), required: false, type: .enum), 
            AWSShapeMember(label: "Reference", location: .body(locationName: "reference"), required: false, type: .enum), 
            AWSShapeMember(label: "ClapAtom", location: .body(locationName: "clapAtom"), required: false, type: .enum), 
            AWSShapeMember(label: "PaddingControl", location: .body(locationName: "paddingControl"), required: false, type: .enum)
        ]
        public let mpeg2FourCCControl: MovMpeg2FourCCControl?
        public let cslgAtom: MovCslgAtom?
        public let reference: MovReference?
        public let clapAtom: MovClapAtom?
        public let paddingControl: MovPaddingControl?

        public init(mpeg2FourCCControl: MovMpeg2FourCCControl? = nil, cslgAtom: MovCslgAtom? = nil, reference: MovReference? = nil, clapAtom: MovClapAtom? = nil, paddingControl: MovPaddingControl? = nil) {
            self.mpeg2FourCCControl = mpeg2FourCCControl
            self.cslgAtom = cslgAtom
            self.reference = reference
            self.clapAtom = clapAtom
            self.paddingControl = paddingControl
        }

        private enum CodingKeys: String, CodingKey {
            case mpeg2FourCCControl = "mpeg2FourCCControl"
            case cslgAtom = "cslgAtom"
            case reference = "reference"
            case clapAtom = "clapAtom"
            case paddingControl = "paddingControl"
        }
    }

    public enum Eac3LfeFilter: String, CustomStringConvertible, Codable {
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public enum CmafManifestCompression: String, CustomStringConvertible, Codable {
        case gzip = "GZIP"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public struct CreateJobTemplateRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Category", location: .body(locationName: "category"), required: false, type: .string), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: true, type: .string), 
            AWSShapeMember(label: "Settings", location: .body(locationName: "settings"), required: true, type: .structure), 
            AWSShapeMember(label: "Queue", location: .body(locationName: "queue"), required: false, type: .string), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string)
        ]
        /// Optional. A category for the job template you are creating
        public let category: String?
        /// The name of the job template you are creating.
        public let name: String
        public let settings: JobTemplateSettings
        /// Optional. The queue that jobs created from this template are assigned to. If you don't specify this, jobs will go to the default queue.
        public let queue: String?
        /// The tags that you want to add to the resource. You can tag resources with a key-value pair or with only a key.
        public let tags: [String: String]?
        /// Optional. A description of the job template you are creating.
        public let description: String?

        public init(category: String? = nil, name: String, settings: JobTemplateSettings, queue: String? = nil, tags: [String: String]? = nil, description: String? = nil) {
            self.category = category
            self.name = name
            self.settings = settings
            self.queue = queue
            self.tags = tags
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case category = "category"
            case name = "name"
            case settings = "settings"
            case queue = "queue"
            case tags = "tags"
            case description = "description"
        }
    }

    public enum M2tsEbpAudioInterval: String, CustomStringConvertible, Codable {
        case videoAndFixedIntervals = "VIDEO_AND_FIXED_INTERVALS"
        case videoInterval = "VIDEO_INTERVAL"
        public var description: String { return self.rawValue }
    }

    public enum H264AdaptiveQuantization: String, CustomStringConvertible, Codable {
        case off = "OFF"
        case low = "LOW"
        case medium = "MEDIUM"
        case high = "HIGH"
        case higher = "HIGHER"
        case max = "MAX"
        public var description: String { return self.rawValue }
    }

    public enum Commitment: String, CustomStringConvertible, Codable {
        case oneYear = "ONE_YEAR"
        public var description: String { return self.rawValue }
    }

    public struct DvbTdtSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TdtInterval", location: .body(locationName: "tdtInterval"), required: false, type: .integer)
        ]
        /// The number of milliseconds between instances of this table in the output transport stream.
        public let tdtInterval: Int32?

        public init(tdtInterval: Int32? = nil) {
            self.tdtInterval = tdtInterval
        }

        private enum CodingKeys: String, CodingKey {
            case tdtInterval = "tdtInterval"
        }
    }

    public enum H265GopSizeUnits: String, CustomStringConvertible, Codable {
        case frames = "FRAMES"
        case seconds = "SECONDS"
        public var description: String { return self.rawValue }
    }

    public struct HlsGroupSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentsPerSubdirectory", location: .body(locationName: "segmentsPerSubdirectory"), required: false, type: .integer), 
            AWSShapeMember(label: "CaptionLanguageMappings", location: .body(locationName: "captionLanguageMappings"), required: false, type: .list), 
            AWSShapeMember(label: "CodecSpecification", location: .body(locationName: "codecSpecification"), required: false, type: .enum), 
            AWSShapeMember(label: "MinFinalSegmentLength", location: .body(locationName: "minFinalSegmentLength"), required: false, type: .double), 
            AWSShapeMember(label: "DirectoryStructure", location: .body(locationName: "directoryStructure"), required: false, type: .enum), 
            AWSShapeMember(label: "TimedMetadataId3Frame", location: .body(locationName: "timedMetadataId3Frame"), required: false, type: .enum), 
            AWSShapeMember(label: "SegmentLength", location: .body(locationName: "segmentLength"), required: false, type: .integer), 
            AWSShapeMember(label: "Encryption", location: .body(locationName: "encryption"), required: false, type: .structure), 
            AWSShapeMember(label: "AdMarkers", location: .body(locationName: "adMarkers"), required: false, type: .list), 
            AWSShapeMember(label: "MinSegmentLength", location: .body(locationName: "minSegmentLength"), required: false, type: .integer), 
            AWSShapeMember(label: "SegmentControl", location: .body(locationName: "segmentControl"), required: false, type: .enum), 
            AWSShapeMember(label: "TimestampDeltaMilliseconds", location: .body(locationName: "timestampDeltaMilliseconds"), required: false, type: .integer), 
            AWSShapeMember(label: "OutputSelection", location: .body(locationName: "outputSelection"), required: false, type: .enum), 
            AWSShapeMember(label: "BaseUrl", location: .body(locationName: "baseUrl"), required: false, type: .string), 
            AWSShapeMember(label: "ProgramDateTimePeriod", location: .body(locationName: "programDateTimePeriod"), required: false, type: .integer), 
            AWSShapeMember(label: "ManifestDurationFormat", location: .body(locationName: "manifestDurationFormat"), required: false, type: .enum), 
            AWSShapeMember(label: "StreamInfResolution", location: .body(locationName: "streamInfResolution"), required: false, type: .enum), 
            AWSShapeMember(label: "ClientCache", location: .body(locationName: "clientCache"), required: false, type: .enum), 
            AWSShapeMember(label: "CaptionLanguageSetting", location: .body(locationName: "captionLanguageSetting"), required: false, type: .enum), 
            AWSShapeMember(label: "ManifestCompression", location: .body(locationName: "manifestCompression"), required: false, type: .enum), 
            AWSShapeMember(label: "TimedMetadataId3Period", location: .body(locationName: "timedMetadataId3Period"), required: false, type: .integer), 
            AWSShapeMember(label: "ProgramDateTime", location: .body(locationName: "programDateTime"), required: false, type: .enum), 
            AWSShapeMember(label: "Destination", location: .body(locationName: "destination"), required: false, type: .string)
        ]
        /// Number of segments to write to a subdirectory before starting a new one. directoryStructure must be SINGLE_DIRECTORY for this setting to have an effect.
        public let segmentsPerSubdirectory: Int32?
        /// Language to be used on Caption outputs
        public let captionLanguageMappings: [HlsCaptionLanguageMapping]?
        public let codecSpecification: HlsCodecSpecification?
        /// Keep this setting at the default value of 0, unless you are troubleshooting a problem with how devices play back the end of your video asset. If you know that player devices are hanging on the final segment of your video because the length of your final segment is too short, use this setting to specify a minimum final segment length, in seconds. Choose a value that is greater than or equal to 1 and less than your segment length. When you specify a value for this setting, the encoder will combine any final segment that is shorter than the length that you specify with the previous segment. For example, your segment length is 3 seconds and your final segment is .5 seconds without a minimum final segment length; when you set the minimum final segment length to 1, your final segment is 3.5 seconds.
        public let minFinalSegmentLength: Double?
        public let directoryStructure: HlsDirectoryStructure?
        public let timedMetadataId3Frame: HlsTimedMetadataId3Frame?
        /// Length of MPEG-2 Transport Stream segments to create (in seconds). Note that segments will end on the next keyframe after this number of seconds, so actual segment length may be longer.
        public let segmentLength: Int32?
        /// DRM settings.
        public let encryption: HlsEncryptionSettings?
        /// Choose one or more ad marker types to pass SCTE35 signals through to this group of Apple HLS outputs.
        public let adMarkers: [HlsAdMarkers]?
        /// When set, Minimum Segment Size is enforced by looking ahead and back within the specified range for a nearby avail and extending the segment size if needed.
        public let minSegmentLength: Int32?
        public let segmentControl: HlsSegmentControl?
        /// Provides an extra millisecond delta offset to fine tune the timestamps.
        public let timestampDeltaMilliseconds: Int32?
        public let outputSelection: HlsOutputSelection?
        /// A partial URI prefix that will be prepended to each output in the media .m3u8 file. Can be used if base manifest is delivered from a different URL than the main .m3u8 file.
        public let baseUrl: String?
        /// Period of insertion of EXT-X-PROGRAM-DATE-TIME entry, in seconds.
        public let programDateTimePeriod: Int32?
        public let manifestDurationFormat: HlsManifestDurationFormat?
        public let streamInfResolution: HlsStreamInfResolution?
        public let clientCache: HlsClientCache?
        public let captionLanguageSetting: HlsCaptionLanguageSetting?
        public let manifestCompression: HlsManifestCompression?
        /// Timed Metadata interval in seconds.
        public let timedMetadataId3Period: Int32?
        public let programDateTime: HlsProgramDateTime?
        /// Use Destination (Destination) to specify the S3 output location and the output filename base. Destination accepts format identifiers. If you do not specify the base filename in the URI, the service will use the filename of the input file. If your job has multiple inputs, the service uses the filename of the first input file.
        public let destination: String?

        public init(segmentsPerSubdirectory: Int32? = nil, captionLanguageMappings: [HlsCaptionLanguageMapping]? = nil, codecSpecification: HlsCodecSpecification? = nil, minFinalSegmentLength: Double? = nil, directoryStructure: HlsDirectoryStructure? = nil, timedMetadataId3Frame: HlsTimedMetadataId3Frame? = nil, segmentLength: Int32? = nil, encryption: HlsEncryptionSettings? = nil, adMarkers: [HlsAdMarkers]? = nil, minSegmentLength: Int32? = nil, segmentControl: HlsSegmentControl? = nil, timestampDeltaMilliseconds: Int32? = nil, outputSelection: HlsOutputSelection? = nil, baseUrl: String? = nil, programDateTimePeriod: Int32? = nil, manifestDurationFormat: HlsManifestDurationFormat? = nil, streamInfResolution: HlsStreamInfResolution? = nil, clientCache: HlsClientCache? = nil, captionLanguageSetting: HlsCaptionLanguageSetting? = nil, manifestCompression: HlsManifestCompression? = nil, timedMetadataId3Period: Int32? = nil, programDateTime: HlsProgramDateTime? = nil, destination: String? = nil) {
            self.segmentsPerSubdirectory = segmentsPerSubdirectory
            self.captionLanguageMappings = captionLanguageMappings
            self.codecSpecification = codecSpecification
            self.minFinalSegmentLength = minFinalSegmentLength
            self.directoryStructure = directoryStructure
            self.timedMetadataId3Frame = timedMetadataId3Frame
            self.segmentLength = segmentLength
            self.encryption = encryption
            self.adMarkers = adMarkers
            self.minSegmentLength = minSegmentLength
            self.segmentControl = segmentControl
            self.timestampDeltaMilliseconds = timestampDeltaMilliseconds
            self.outputSelection = outputSelection
            self.baseUrl = baseUrl
            self.programDateTimePeriod = programDateTimePeriod
            self.manifestDurationFormat = manifestDurationFormat
            self.streamInfResolution = streamInfResolution
            self.clientCache = clientCache
            self.captionLanguageSetting = captionLanguageSetting
            self.manifestCompression = manifestCompression
            self.timedMetadataId3Period = timedMetadataId3Period
            self.programDateTime = programDateTime
            self.destination = destination
        }

        private enum CodingKeys: String, CodingKey {
            case segmentsPerSubdirectory = "segmentsPerSubdirectory"
            case captionLanguageMappings = "captionLanguageMappings"
            case codecSpecification = "codecSpecification"
            case minFinalSegmentLength = "minFinalSegmentLength"
            case directoryStructure = "directoryStructure"
            case timedMetadataId3Frame = "timedMetadataId3Frame"
            case segmentLength = "segmentLength"
            case encryption = "encryption"
            case adMarkers = "adMarkers"
            case minSegmentLength = "minSegmentLength"
            case segmentControl = "segmentControl"
            case timestampDeltaMilliseconds = "timestampDeltaMilliseconds"
            case outputSelection = "outputSelection"
            case baseUrl = "baseUrl"
            case programDateTimePeriod = "programDateTimePeriod"
            case manifestDurationFormat = "manifestDurationFormat"
            case streamInfResolution = "streamInfResolution"
            case clientCache = "clientCache"
            case captionLanguageSetting = "captionLanguageSetting"
            case manifestCompression = "manifestCompression"
            case timedMetadataId3Period = "timedMetadataId3Period"
            case programDateTime = "programDateTime"
            case destination = "destination"
        }
    }

    public enum H265SlowPal: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum Eac3DynamicRangeCompressionRf: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case filmStandard = "FILM_STANDARD"
        case filmLight = "FILM_LIGHT"
        case musicStandard = "MUSIC_STANDARD"
        case musicLight = "MUSIC_LIGHT"
        case speech = "SPEECH"
        public var description: String { return self.rawValue }
    }

    public enum Ac3BitstreamMode: String, CustomStringConvertible, Codable {
        case completeMain = "COMPLETE_MAIN"
        case commentary = "COMMENTARY"
        case dialogue = "DIALOGUE"
        case emergency = "EMERGENCY"
        case hearingImpaired = "HEARING_IMPAIRED"
        case musicAndEffects = "MUSIC_AND_EFFECTS"
        case visuallyImpaired = "VISUALLY_IMPAIRED"
        case voiceOver = "VOICE_OVER"
        public var description: String { return self.rawValue }
    }

    public struct TeletextDestinationSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PageNumber", location: .body(locationName: "pageNumber"), required: false, type: .string)
        ]
        /// Set pageNumber to the Teletext page number for the destination captions for this output. This value must be a three-digit hexadecimal string; strings ending in -FF are invalid. If you are passing through the entire set of Teletext data, do not use this field.
        public let pageNumber: String?

        public init(pageNumber: String? = nil) {
            self.pageNumber = pageNumber
        }

        private enum CodingKeys: String, CodingKey {
            case pageNumber = "pageNumber"
        }
    }

    public struct ListTagsForResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", location: .uri(locationName: "arn"), required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the resource that you want to list tags for. To get the ARN, send a GET request with the resource name.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct VideoPreprocessor: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TimecodeBurnin", location: .body(locationName: "timecodeBurnin"), required: false, type: .structure), 
            AWSShapeMember(label: "ImageInserter", location: .body(locationName: "imageInserter"), required: false, type: .structure), 
            AWSShapeMember(label: "NoiseReducer", location: .body(locationName: "noiseReducer"), required: false, type: .structure), 
            AWSShapeMember(label: "Deinterlacer", location: .body(locationName: "deinterlacer"), required: false, type: .structure), 
            AWSShapeMember(label: "ColorCorrector", location: .body(locationName: "colorCorrector"), required: false, type: .structure)
        ]
        /// Timecode burn-in (TimecodeBurnIn)--Burns the output timecode and specified prefix into the output.
        public let timecodeBurnin: TimecodeBurnin?
        /// Enable the Image inserter (ImageInserter) feature to include a graphic overlay on your video. Enable or disable this feature for each output individually. This setting is disabled by default.
        public let imageInserter: ImageInserter?
        /// Enable the Noise reducer (NoiseReducer) feature to remove noise from your video output if necessary. Enable or disable this feature for each output individually. This setting is disabled by default.
        public let noiseReducer: NoiseReducer?
        /// Use Deinterlacer (Deinterlacer) to produce smoother motion and a clearer picture.
        public let deinterlacer: Deinterlacer?
        /// Enable the Color corrector (ColorCorrector) feature if necessary. Enable or disable this feature for each output individually. This setting is disabled by default.
        public let colorCorrector: ColorCorrector?

        public init(timecodeBurnin: TimecodeBurnin? = nil, imageInserter: ImageInserter? = nil, noiseReducer: NoiseReducer? = nil, deinterlacer: Deinterlacer? = nil, colorCorrector: ColorCorrector? = nil) {
            self.timecodeBurnin = timecodeBurnin
            self.imageInserter = imageInserter
            self.noiseReducer = noiseReducer
            self.deinterlacer = deinterlacer
            self.colorCorrector = colorCorrector
        }

        private enum CodingKeys: String, CodingKey {
            case timecodeBurnin = "timecodeBurnin"
            case imageInserter = "imageInserter"
            case noiseReducer = "noiseReducer"
            case deinterlacer = "deinterlacer"
            case colorCorrector = "colorCorrector"
        }
    }

    public enum EmbeddedConvert608To708: String, CustomStringConvertible, Codable {
        case upconvert = "UPCONVERT"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public enum AudioNormalizationAlgorithmControl: String, CustomStringConvertible, Codable {
        case correctAudio = "CORRECT_AUDIO"
        case measureOnly = "MEASURE_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum ScalingBehavior: String, CustomStringConvertible, Codable {
        case `default` = "DEFAULT"
        case stretchToOutput = "STRETCH_TO_OUTPUT"
        public var description: String { return self.rawValue }
    }

    public struct VideoDescription: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Height", location: .body(locationName: "height"), required: false, type: .integer), 
            AWSShapeMember(label: "Width", location: .body(locationName: "width"), required: false, type: .integer), 
            AWSShapeMember(label: "AfdSignaling", location: .body(locationName: "afdSignaling"), required: false, type: .enum), 
            AWSShapeMember(label: "FixedAfd", location: .body(locationName: "fixedAfd"), required: false, type: .integer), 
            AWSShapeMember(label: "ColorMetadata", location: .body(locationName: "colorMetadata"), required: false, type: .enum), 
            AWSShapeMember(label: "TimecodeInsertion", location: .body(locationName: "timecodeInsertion"), required: false, type: .enum), 
            AWSShapeMember(label: "Position", location: .body(locationName: "position"), required: false, type: .structure), 
            AWSShapeMember(label: "VideoPreprocessors", location: .body(locationName: "videoPreprocessors"), required: false, type: .structure), 
            AWSShapeMember(label: "CodecSettings", location: .body(locationName: "codecSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "AntiAlias", location: .body(locationName: "antiAlias"), required: false, type: .enum), 
            AWSShapeMember(label: "DropFrameTimecode", location: .body(locationName: "dropFrameTimecode"), required: false, type: .enum), 
            AWSShapeMember(label: "RespondToAfd", location: .body(locationName: "respondToAfd"), required: false, type: .enum), 
            AWSShapeMember(label: "ScalingBehavior", location: .body(locationName: "scalingBehavior"), required: false, type: .enum), 
            AWSShapeMember(label: "Crop", location: .body(locationName: "crop"), required: false, type: .structure), 
            AWSShapeMember(label: "Sharpness", location: .body(locationName: "sharpness"), required: false, type: .integer)
        ]
        /// Use the Height (Height) setting to define the video resolution height for this output. Specify in pixels. If you don't provide a value here, the service will use the input height.
        public let height: Int32?
        /// Use Width (Width) to define the video resolution width, in pixels, for this output. If you don't provide a value here, the service will use the input width.
        public let width: Int32?
        public let afdSignaling: AfdSignaling?
        /// Applies only if you set AFD Signaling(AfdSignaling) to Fixed (FIXED). Use Fixed (FixedAfd) to specify a four-bit AFD value which the service will write on all  frames of this video output.
        public let fixedAfd: Int32?
        public let colorMetadata: ColorMetadata?
        public let timecodeInsertion: VideoTimecodeInsertion?
        /// Use Position (Position) to point to a rectangle object to define your position. This setting overrides any other aspect ratio.
        public let position: Rectangle?
        /// Find additional transcoding features under Preprocessors (VideoPreprocessors). Enable the features at each output individually. These features are disabled by default.
        public let videoPreprocessors: VideoPreprocessor?
        public let codecSettings: VideoCodecSettings?
        public let antiAlias: AntiAlias?
        public let dropFrameTimecode: DropFrameTimecode?
        public let respondToAfd: RespondToAfd?
        public let scalingBehavior: ScalingBehavior?
        /// Applies only if your input aspect ratio is different from your output aspect ratio. Use Input cropping rectangle (Crop) to specify the  video area the service will include in the output. This will crop the input source, causing video pixels to be removed on encode. Do not use this setting if you have enabled Stretch to output (stretchToOutput) in your output settings.
        public let crop: Rectangle?
        /// Use Sharpness (Sharpness)setting to specify the strength of anti-aliasing. This setting changes the width of the anti-alias filter kernel used for scaling. Sharpness only applies if your output resolution is different from your input resolution, and if you set Anti-alias (AntiAlias) to ENABLED. 0 is the softest setting, 100 the sharpest, and 50 recommended for most content.
        public let sharpness: Int32?

        public init(height: Int32? = nil, width: Int32? = nil, afdSignaling: AfdSignaling? = nil, fixedAfd: Int32? = nil, colorMetadata: ColorMetadata? = nil, timecodeInsertion: VideoTimecodeInsertion? = nil, position: Rectangle? = nil, videoPreprocessors: VideoPreprocessor? = nil, codecSettings: VideoCodecSettings? = nil, antiAlias: AntiAlias? = nil, dropFrameTimecode: DropFrameTimecode? = nil, respondToAfd: RespondToAfd? = nil, scalingBehavior: ScalingBehavior? = nil, crop: Rectangle? = nil, sharpness: Int32? = nil) {
            self.height = height
            self.width = width
            self.afdSignaling = afdSignaling
            self.fixedAfd = fixedAfd
            self.colorMetadata = colorMetadata
            self.timecodeInsertion = timecodeInsertion
            self.position = position
            self.videoPreprocessors = videoPreprocessors
            self.codecSettings = codecSettings
            self.antiAlias = antiAlias
            self.dropFrameTimecode = dropFrameTimecode
            self.respondToAfd = respondToAfd
            self.scalingBehavior = scalingBehavior
            self.crop = crop
            self.sharpness = sharpness
        }

        private enum CodingKeys: String, CodingKey {
            case height = "height"
            case width = "width"
            case afdSignaling = "afdSignaling"
            case fixedAfd = "fixedAfd"
            case colorMetadata = "colorMetadata"
            case timecodeInsertion = "timecodeInsertion"
            case position = "position"
            case videoPreprocessors = "videoPreprocessors"
            case codecSettings = "codecSettings"
            case antiAlias = "antiAlias"
            case dropFrameTimecode = "dropFrameTimecode"
            case respondToAfd = "respondToAfd"
            case scalingBehavior = "scalingBehavior"
            case crop = "crop"
            case sharpness = "sharpness"
        }
    }

    public enum AacRateControlMode: String, CustomStringConvertible, Codable {
        case cbr = "CBR"
        case vbr = "VBR"
        public var description: String { return self.rawValue }
    }

    public struct Endpoint: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Url", location: .body(locationName: "url"), required: false, type: .string)
        ]
        /// URL of endpoint
        public let url: String?

        public init(url: String? = nil) {
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case url = "url"
        }
    }

    public struct DeleteQueueRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", location: .uri(locationName: "name"), required: true, type: .string)
        ]
        /// The name of the queue that you want to delete.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct AudioNormalizationSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TargetLkfs", location: .body(locationName: "targetLkfs"), required: false, type: .double), 
            AWSShapeMember(label: "AlgorithmControl", location: .body(locationName: "algorithmControl"), required: false, type: .enum), 
            AWSShapeMember(label: "Algorithm", location: .body(locationName: "algorithm"), required: false, type: .enum), 
            AWSShapeMember(label: "PeakCalculation", location: .body(locationName: "peakCalculation"), required: false, type: .enum), 
            AWSShapeMember(label: "LoudnessLogging", location: .body(locationName: "loudnessLogging"), required: false, type: .enum), 
            AWSShapeMember(label: "CorrectionGateLevel", location: .body(locationName: "correctionGateLevel"), required: false, type: .integer)
        ]
        /// Target LKFS(loudness) to adjust volume to. If no value is entered, a default value will be used according to the chosen algorithm. The CALM Act (1770-1) recommends a target of -24 LKFS. The EBU R-128 specification (1770-2) recommends a target of -23 LKFS.
        public let targetLkfs: Double?
        public let algorithmControl: AudioNormalizationAlgorithmControl?
        public let algorithm: AudioNormalizationAlgorithm?
        public let peakCalculation: AudioNormalizationPeakCalculation?
        public let loudnessLogging: AudioNormalizationLoudnessLogging?
        /// Content measuring above this level will be corrected to the target level. Content measuring below this level will not be corrected. Gating only applies when not using real_time_correction.
        public let correctionGateLevel: Int32?

        public init(targetLkfs: Double? = nil, algorithmControl: AudioNormalizationAlgorithmControl? = nil, algorithm: AudioNormalizationAlgorithm? = nil, peakCalculation: AudioNormalizationPeakCalculation? = nil, loudnessLogging: AudioNormalizationLoudnessLogging? = nil, correctionGateLevel: Int32? = nil) {
            self.targetLkfs = targetLkfs
            self.algorithmControl = algorithmControl
            self.algorithm = algorithm
            self.peakCalculation = peakCalculation
            self.loudnessLogging = loudnessLogging
            self.correctionGateLevel = correctionGateLevel
        }

        private enum CodingKeys: String, CodingKey {
            case targetLkfs = "targetLkfs"
            case algorithmControl = "algorithmControl"
            case algorithm = "algorithm"
            case peakCalculation = "peakCalculation"
            case loudnessLogging = "loudnessLogging"
            case correctionGateLevel = "correctionGateLevel"
        }
    }

    public struct NielsenConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DistributorId", location: .body(locationName: "distributorId"), required: false, type: .string), 
            AWSShapeMember(label: "BreakoutCode", location: .body(locationName: "breakoutCode"), required: false, type: .integer)
        ]
        /// Use Distributor ID (DistributorID) to specify the distributor ID that is assigned to your organization by Neilsen.
        public let distributorId: String?
        /// Use Nielsen Configuration (NielsenConfiguration) to set the Nielsen measurement system breakout code. Supported values are 0, 3, 7, and 9.
        public let breakoutCode: Int32?

        public init(distributorId: String? = nil, breakoutCode: Int32? = nil) {
            self.distributorId = distributorId
            self.breakoutCode = breakoutCode
        }

        private enum CodingKeys: String, CodingKey {
            case distributorId = "distributorId"
            case breakoutCode = "breakoutCode"
        }
    }

    public enum H265DynamicSubGop: String, CustomStringConvertible, Codable {
        case adaptive = "ADAPTIVE"
        case `static` = "STATIC"
        public var description: String { return self.rawValue }
    }

    public struct GetJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", location: .uri(locationName: "id"), required: true, type: .string)
        ]
        /// the job ID of the job.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct GetQueueResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Queue", location: .body(locationName: "queue"), required: false, type: .structure)
        ]
        public let queue: Queue?

        public init(queue: Queue? = nil) {
            self.queue = queue
        }

        private enum CodingKeys: String, CodingKey {
            case queue = "queue"
        }
    }

    public enum AudioSelectorType: String, CustomStringConvertible, Codable {
        case pid = "PID"
        case track = "TRACK"
        case languageCode = "LANGUAGE_CODE"
        public var description: String { return self.rawValue }
    }

    public enum DvbSubtitleShadowColor: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case black = "BLACK"
        case white = "WHITE"
        public var description: String { return self.rawValue }
    }

    public enum ColorSpaceConversion: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case force601 = "FORCE_601"
        case force709 = "FORCE_709"
        case forceHdr10 = "FORCE_HDR10"
        case forceHlg2020 = "FORCE_HLG_2020"
        public var description: String { return self.rawValue }
    }

    public enum H265FramerateControl: String, CustomStringConvertible, Codable {
        case initializeFromSource = "INITIALIZE_FROM_SOURCE"
        case specified = "SPECIFIED"
        public var description: String { return self.rawValue }
    }

    public struct ListJobTemplatesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "JobTemplates", location: .body(locationName: "jobTemplates"), required: false, type: .list)
        ]
        /// Use this string to request the next batch of job templates.
        public let nextToken: String?
        /// List of Job templates.
        public let jobTemplates: [JobTemplate]?

        public init(nextToken: String? = nil, jobTemplates: [JobTemplate]? = nil) {
            self.nextToken = nextToken
            self.jobTemplates = jobTemplates
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case jobTemplates = "jobTemplates"
        }
    }

    public enum `Type`: String, CustomStringConvertible, Codable {
        case system = "SYSTEM"
        case custom = "CUSTOM"
        public var description: String { return self.rawValue }
    }

    public struct DeleteJobTemplateResponse: AWSShape {

    }

    public struct JobTemplateSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Inputs", location: .body(locationName: "inputs"), required: false, type: .list), 
            AWSShapeMember(label: "NielsenConfiguration", location: .body(locationName: "nielsenConfiguration"), required: false, type: .structure), 
            AWSShapeMember(label: "AdAvailOffset", location: .body(locationName: "adAvailOffset"), required: false, type: .integer), 
            AWSShapeMember(label: "AvailBlanking", location: .body(locationName: "availBlanking"), required: false, type: .structure), 
            AWSShapeMember(label: "TimecodeConfig", location: .body(locationName: "timecodeConfig"), required: false, type: .structure), 
            AWSShapeMember(label: "OutputGroups", location: .body(locationName: "outputGroups"), required: false, type: .list), 
            AWSShapeMember(label: "MotionImageInserter", location: .body(locationName: "motionImageInserter"), required: false, type: .structure), 
            AWSShapeMember(label: "TimedMetadataInsertion", location: .body(locationName: "timedMetadataInsertion"), required: false, type: .structure)
        ]
        /// Use Inputs (inputs) to define the source file used in the transcode job. There can only be one input in a job template.  Using the API, you can include multiple inputs when referencing a job template.
        public let inputs: [InputTemplate]?
        public let nielsenConfiguration: NielsenConfiguration?
        /// When specified, this offset (in milliseconds) is added to the input Ad Avail PTS time.
        public let adAvailOffset: Int32?
        /// Settings for ad avail blanking.  Video can be blanked or overlaid with an image, and audio muted during SCTE-35 triggered ad avails.
        public let availBlanking: AvailBlanking?
        /// Contains settings used to acquire and adjust timecode information from inputs.
        public let timecodeConfig: TimecodeConfig?
        /// (OutputGroups) contains one group of settings for each set of outputs that share a common package type. All unpackaged files (MPEG-4, MPEG-2 TS, Quicktime, MXF, and no container) are grouped in a single output group as well. Required in (OutputGroups) is a group of settings that apply to the whole group. This required object depends on the value you set for (Type) under (OutputGroups)>(OutputGroupSettings). Type, settings object pairs are as follows. * FILE_GROUP_SETTINGS, FileGroupSettings * HLS_GROUP_SETTINGS, HlsGroupSettings * DASH_ISO_GROUP_SETTINGS, DashIsoGroupSettings * MS_SMOOTH_GROUP_SETTINGS, MsSmoothGroupSettings * CMAF_GROUP_SETTINGS, CmafGroupSettings
        public let outputGroups: [OutputGroup]?
        /// Overlay motion graphics on top of your video. The motion graphics that you specify here appear on all outputs in all output groups.
        public let motionImageInserter: MotionImageInserter?
        public let timedMetadataInsertion: TimedMetadataInsertion?

        public init(inputs: [InputTemplate]? = nil, nielsenConfiguration: NielsenConfiguration? = nil, adAvailOffset: Int32? = nil, availBlanking: AvailBlanking? = nil, timecodeConfig: TimecodeConfig? = nil, outputGroups: [OutputGroup]? = nil, motionImageInserter: MotionImageInserter? = nil, timedMetadataInsertion: TimedMetadataInsertion? = nil) {
            self.inputs = inputs
            self.nielsenConfiguration = nielsenConfiguration
            self.adAvailOffset = adAvailOffset
            self.availBlanking = availBlanking
            self.timecodeConfig = timecodeConfig
            self.outputGroups = outputGroups
            self.motionImageInserter = motionImageInserter
            self.timedMetadataInsertion = timedMetadataInsertion
        }

        private enum CodingKeys: String, CodingKey {
            case inputs = "inputs"
            case nielsenConfiguration = "nielsenConfiguration"
            case adAvailOffset = "adAvailOffset"
            case availBlanking = "availBlanking"
            case timecodeConfig = "timecodeConfig"
            case outputGroups = "outputGroups"
            case motionImageInserter = "motionImageInserter"
            case timedMetadataInsertion = "timedMetadataInsertion"
        }
    }

    public enum H264CodecProfile: String, CustomStringConvertible, Codable {
        case baseline = "BASELINE"
        case high = "HIGH"
        case high10Bit = "HIGH_10BIT"
        case high422 = "HIGH_422"
        case high42210Bit = "HIGH_422_10BIT"
        case main = "MAIN"
        public var description: String { return self.rawValue }
    }

    public enum M3u8NielsenId3: String, CustomStringConvertible, Codable {
        case insert = "INSERT"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum ProresTelecine: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case hard = "HARD"
        public var description: String { return self.rawValue }
    }

    public enum HlsIFrameOnlyManifest: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public enum WavFormat: String, CustomStringConvertible, Codable {
        case riff = "RIFF"
        case rf64 = "RF64"
        public var description: String { return self.rawValue }
    }

    public enum M3u8PcrControl: String, CustomStringConvertible, Codable {
        case pcrEveryPesPacket = "PCR_EVERY_PES_PACKET"
        case configuredPcrPeriod = "CONFIGURED_PCR_PERIOD"
        public var description: String { return self.rawValue }
    }

    public enum H264GopSizeUnits: String, CustomStringConvertible, Codable {
        case frames = "FRAMES"
        case seconds = "SECONDS"
        public var description: String { return self.rawValue }
    }

    public struct DashIsoGroupSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WriteSegmentTimelineInRepresentation", location: .body(locationName: "writeSegmentTimelineInRepresentation"), required: false, type: .enum), 
            AWSShapeMember(label: "Encryption", location: .body(locationName: "encryption"), required: false, type: .structure), 
            AWSShapeMember(label: "FragmentLength", location: .body(locationName: "fragmentLength"), required: false, type: .integer), 
            AWSShapeMember(label: "BaseUrl", location: .body(locationName: "baseUrl"), required: false, type: .string), 
            AWSShapeMember(label: "Destination", location: .body(locationName: "destination"), required: false, type: .string), 
            AWSShapeMember(label: "MinBufferTime", location: .body(locationName: "minBufferTime"), required: false, type: .integer), 
            AWSShapeMember(label: "SegmentControl", location: .body(locationName: "segmentControl"), required: false, type: .enum), 
            AWSShapeMember(label: "SegmentLength", location: .body(locationName: "segmentLength"), required: false, type: .integer), 
            AWSShapeMember(label: "HbbtvCompliance", location: .body(locationName: "hbbtvCompliance"), required: false, type: .enum)
        ]
        /// When you enable Precise segment duration in manifests (writeSegmentTimelineInRepresentation), your DASH manifest shows precise segment durations. The segment duration information appears inside the SegmentTimeline element, inside SegmentTemplate at the Representation level. When this feature isn't enabled, the segment durations in your DASH manifest are approximate. The segment duration information appears in the duration attribute of the SegmentTemplate element.
        public let writeSegmentTimelineInRepresentation: DashIsoWriteSegmentTimelineInRepresentation?
        /// DRM settings.
        public let encryption: DashIsoEncryptionSettings?
        /// Length of fragments to generate (in seconds). Fragment length must be compatible with GOP size and Framerate. Note that fragments will end on the next keyframe after this number of seconds, so actual fragment length may be longer. When Emit Single File is checked, the fragmentation is internal to a single output file and it does not cause the creation of many output files as in other output types.
        public let fragmentLength: Int32?
        /// A partial URI prefix that will be put in the manifest (.mpd) file at the top level BaseURL element. Can be used if streams are delivered from a different URL than the manifest file.
        public let baseUrl: String?
        /// Use Destination (Destination) to specify the S3 output location and the output filename base. Destination accepts format identifiers. If you do not specify the base filename in the URI, the service will use the filename of the input file. If your job has multiple inputs, the service uses the filename of the first input file.
        public let destination: String?
        /// Minimum time of initially buffered media that is needed to ensure smooth playout.
        public let minBufferTime: Int32?
        public let segmentControl: DashIsoSegmentControl?
        /// Length of mpd segments to create (in seconds). Note that segments will end on the next keyframe after this number of seconds, so actual segment length may be longer. When Emit Single File is checked, the segmentation is internal to a single output file and it does not cause the creation of many output files as in other output types.
        public let segmentLength: Int32?
        public let hbbtvCompliance: DashIsoHbbtvCompliance?

        public init(writeSegmentTimelineInRepresentation: DashIsoWriteSegmentTimelineInRepresentation? = nil, encryption: DashIsoEncryptionSettings? = nil, fragmentLength: Int32? = nil, baseUrl: String? = nil, destination: String? = nil, minBufferTime: Int32? = nil, segmentControl: DashIsoSegmentControl? = nil, segmentLength: Int32? = nil, hbbtvCompliance: DashIsoHbbtvCompliance? = nil) {
            self.writeSegmentTimelineInRepresentation = writeSegmentTimelineInRepresentation
            self.encryption = encryption
            self.fragmentLength = fragmentLength
            self.baseUrl = baseUrl
            self.destination = destination
            self.minBufferTime = minBufferTime
            self.segmentControl = segmentControl
            self.segmentLength = segmentLength
            self.hbbtvCompliance = hbbtvCompliance
        }

        private enum CodingKeys: String, CodingKey {
            case writeSegmentTimelineInRepresentation = "writeSegmentTimelineInRepresentation"
            case encryption = "encryption"
            case fragmentLength = "fragmentLength"
            case baseUrl = "baseUrl"
            case destination = "destination"
            case minBufferTime = "minBufferTime"
            case segmentControl = "segmentControl"
            case segmentLength = "segmentLength"
            case hbbtvCompliance = "hbbtvCompliance"
        }
    }

    public struct ListJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Queue", location: .querystring(locationName: "queue"), required: false, type: .string), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "Status", location: .querystring(locationName: "status"), required: false, type: .enum), 
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "Order", location: .querystring(locationName: "order"), required: false, type: .enum)
        ]
        /// Provide a queue name to get back only jobs from that queue.
        public let queue: String?
        /// Use this string, provided with the response to a previous request, to request the next batch of jobs.
        public let nextToken: String?
        public let status: JobStatus?
        /// Optional. Number of jobs, up to twenty, that will be returned at one time.
        public let maxResults: Int32?
        public let order: Order?

        public init(queue: String? = nil, nextToken: String? = nil, status: JobStatus? = nil, maxResults: Int32? = nil, order: Order? = nil) {
            self.queue = queue
            self.nextToken = nextToken
            self.status = status
            self.maxResults = maxResults
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case queue = "queue"
            case nextToken = "nextToken"
            case status = "status"
            case maxResults = "maxResults"
            case order = "order"
        }
    }

    public enum H265FramerateConversionAlgorithm: String, CustomStringConvertible, Codable {
        case duplicateDrop = "DUPLICATE_DROP"
        case interpolate = "INTERPOLATE"
        public var description: String { return self.rawValue }
    }

    public enum BurninSubtitleTeletextSpacing: String, CustomStringConvertible, Codable {
        case fixedGrid = "FIXED_GRID"
        case proportional = "PROPORTIONAL"
        public var description: String { return self.rawValue }
    }

    public struct HlsCaptionLanguageMapping: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CaptionChannel", location: .body(locationName: "captionChannel"), required: false, type: .integer), 
            AWSShapeMember(label: "LanguageDescription", location: .body(locationName: "languageDescription"), required: false, type: .string), 
            AWSShapeMember(label: "CustomLanguageCode", location: .body(locationName: "customLanguageCode"), required: false, type: .string), 
            AWSShapeMember(label: "LanguageCode", location: .body(locationName: "languageCode"), required: false, type: .enum)
        ]
        /// Caption channel.
        public let captionChannel: Int32?
        /// Caption language description.
        public let languageDescription: String?
        /// Specify the language for this caption channel, using the ISO 639-2 or ISO 639-3 three-letter language code
        public let customLanguageCode: String?
        public let languageCode: LanguageCode?

        public init(captionChannel: Int32? = nil, languageDescription: String? = nil, customLanguageCode: String? = nil, languageCode: LanguageCode? = nil) {
            self.captionChannel = captionChannel
            self.languageDescription = languageDescription
            self.customLanguageCode = customLanguageCode
            self.languageCode = languageCode
        }

        private enum CodingKeys: String, CodingKey {
            case captionChannel = "captionChannel"
            case languageDescription = "languageDescription"
            case customLanguageCode = "customLanguageCode"
            case languageCode = "languageCode"
        }
    }

    public struct SccDestinationSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Framerate", location: .body(locationName: "framerate"), required: false, type: .enum)
        ]
        public let framerate: SccDestinationFramerate?

        public init(framerate: SccDestinationFramerate? = nil) {
            self.framerate = framerate
        }

        private enum CodingKeys: String, CodingKey {
            case framerate = "framerate"
        }
    }

    public enum HlsTimedMetadataId3Frame: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case priv = "PRIV"
        case tdrl = "TDRL"
        public var description: String { return self.rawValue }
    }

    public struct ExceptionBody: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Message", location: .body(locationName: "message"), required: false, type: .string)
        ]
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public enum H264EntropyEncoding: String, CustomStringConvertible, Codable {
        case cabac = "CABAC"
        case cavlc = "CAVLC"
        public var description: String { return self.rawValue }
    }

    public struct AvailBlanking: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AvailBlankingImage", location: .body(locationName: "availBlankingImage"), required: false, type: .string)
        ]
        /// Blanking image to be used. Leave empty for solid black. Only bmp and png images are supported.
        public let availBlankingImage: String?

        public init(availBlankingImage: String? = nil) {
            self.availBlankingImage = availBlankingImage
        }

        private enum CodingKeys: String, CodingKey {
            case availBlankingImage = "availBlankingImage"
        }
    }

    public enum InputDeblockFilter: String, CustomStringConvertible, Codable {
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public enum M2tsScte35Source: String, CustomStringConvertible, Codable {
        case passthrough = "PASSTHROUGH"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum M2tsBufferModel: String, CustomStringConvertible, Codable {
        case multiplex = "MULTIPLEX"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum CmafStreamInfResolution: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public struct FileSourceSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SourceFile", location: .body(locationName: "sourceFile"), required: false, type: .string), 
            AWSShapeMember(label: "TimeDelta", location: .body(locationName: "timeDelta"), required: false, type: .integer), 
            AWSShapeMember(label: "Convert608To708", location: .body(locationName: "convert608To708"), required: false, type: .enum)
        ]
        /// External caption file used for loading captions. Accepted file extensions are 'scc', 'ttml', 'dfxp', 'stl', 'srt', and 'smi'.
        public let sourceFile: String?
        /// Specifies a time delta in seconds to offset the captions from the source file.
        public let timeDelta: Int32?
        public let convert608To708: FileSourceConvert608To708?

        public init(sourceFile: String? = nil, timeDelta: Int32? = nil, convert608To708: FileSourceConvert608To708? = nil) {
            self.sourceFile = sourceFile
            self.timeDelta = timeDelta
            self.convert608To708 = convert608To708
        }

        private enum CodingKeys: String, CodingKey {
            case sourceFile = "sourceFile"
            case timeDelta = "timeDelta"
            case convert608To708 = "convert608To708"
        }
    }

    public enum HlsKeyProviderType: String, CustomStringConvertible, Codable {
        case speke = "SPEKE"
        case staticKey = "STATIC_KEY"
        public var description: String { return self.rawValue }
    }

    public enum CmafWriteDASHManifest: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct CreateQueueRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PricingPlan", location: .body(locationName: "pricingPlan"), required: false, type: .enum), 
            AWSShapeMember(label: "ReservationPlanSettings", location: .body(locationName: "reservationPlanSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: true, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map)
        ]
        /// Specifies whether the pricing plan for the queue is on-demand or reserved. For on-demand, you pay per minute, billed in increments of .01 minute. For reserved, you pay for the transcoding capacity of the entire queue, regardless of how much or how little you use it. Reserved pricing requires a 12-month commitment. When you use the API to create a queue, the default is on-demand.
        public let pricingPlan: PricingPlan?
        /// Details about the pricing plan for your reserved queue. Required for reserved queues and not applicable to on-demand queues.
        public let reservationPlanSettings: ReservationPlanSettings?
        /// The name of the queue that you are creating.
        public let name: String
        /// Optional. A description of the queue that you are creating.
        public let description: String?
        /// The tags that you want to add to the resource. You can tag resources with a key-value pair or with only a key.
        public let tags: [String: String]?

        public init(pricingPlan: PricingPlan? = nil, reservationPlanSettings: ReservationPlanSettings? = nil, name: String, description: String? = nil, tags: [String: String]? = nil) {
            self.pricingPlan = pricingPlan
            self.reservationPlanSettings = reservationPlanSettings
            self.name = name
            self.description = description
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case pricingPlan = "pricingPlan"
            case reservationPlanSettings = "reservationPlanSettings"
            case name = "name"
            case description = "description"
            case tags = "tags"
        }
    }

    public enum DeinterlaceAlgorithm: String, CustomStringConvertible, Codable {
        case interpolate = "INTERPOLATE"
        case interpolateTicker = "INTERPOLATE_TICKER"
        case blend = "BLEND"
        case blendTicker = "BLEND_TICKER"
        public var description: String { return self.rawValue }
    }

    public struct AncillarySourceSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SourceAncillaryChannelNumber", location: .body(locationName: "sourceAncillaryChannelNumber"), required: false, type: .integer)
        ]
        /// Specifies the 608 channel number in the ancillary data track from which to extract captions. Unused for passthrough.
        public let sourceAncillaryChannelNumber: Int32?

        public init(sourceAncillaryChannelNumber: Int32? = nil) {
            self.sourceAncillaryChannelNumber = sourceAncillaryChannelNumber
        }

        private enum CodingKeys: String, CodingKey {
            case sourceAncillaryChannelNumber = "sourceAncillaryChannelNumber"
        }
    }

    public struct UpdatePresetResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Preset", location: .body(locationName: "preset"), required: false, type: .structure)
        ]
        public let preset: Preset?

        public init(preset: Preset? = nil) {
            self.preset = preset
        }

        private enum CodingKeys: String, CodingKey {
            case preset = "preset"
        }
    }

    public struct DvbSdtSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ServiceProviderName", location: .body(locationName: "serviceProviderName"), required: false, type: .string), 
            AWSShapeMember(label: "ServiceName", location: .body(locationName: "serviceName"), required: false, type: .string), 
            AWSShapeMember(label: "OutputSdt", location: .body(locationName: "outputSdt"), required: false, type: .enum), 
            AWSShapeMember(label: "SdtInterval", location: .body(locationName: "sdtInterval"), required: false, type: .integer)
        ]
        /// The service provider name placed in the service_descriptor in the Service Description Table. Maximum length is 256 characters.
        public let serviceProviderName: String?
        /// The service name placed in the service_descriptor in the Service Description Table. Maximum length is 256 characters.
        public let serviceName: String?
        public let outputSdt: OutputSdt?
        /// The number of milliseconds between instances of this table in the output transport stream.
        public let sdtInterval: Int32?

        public init(serviceProviderName: String? = nil, serviceName: String? = nil, outputSdt: OutputSdt? = nil, sdtInterval: Int32? = nil) {
            self.serviceProviderName = serviceProviderName
            self.serviceName = serviceName
            self.outputSdt = outputSdt
            self.sdtInterval = sdtInterval
        }

        private enum CodingKeys: String, CodingKey {
            case serviceProviderName = "serviceProviderName"
            case serviceName = "serviceName"
            case outputSdt = "outputSdt"
            case sdtInterval = "sdtInterval"
        }
    }

    public enum H264FramerateControl: String, CustomStringConvertible, Codable {
        case initializeFromSource = "INITIALIZE_FROM_SOURCE"
        case specified = "SPECIFIED"
        public var description: String { return self.rawValue }
    }

    public enum AudioCodec: String, CustomStringConvertible, Codable {
        case aac = "AAC"
        case mp2 = "MP2"
        case wav = "WAV"
        case aiff = "AIFF"
        case ac3 = "AC3"
        case eac3 = "EAC3"
        case passthrough = "PASSTHROUGH"
        public var description: String { return self.rawValue }
    }

    public enum H264RateControlMode: String, CustomStringConvertible, Codable {
        case vbr = "VBR"
        case cbr = "CBR"
        case qvbr = "QVBR"
        public var description: String { return self.rawValue }
    }

    public struct F4vSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MoovPlacement", location: .body(locationName: "moovPlacement"), required: false, type: .enum)
        ]
        public let moovPlacement: F4vMoovPlacement?

        public init(moovPlacement: F4vMoovPlacement? = nil) {
            self.moovPlacement = moovPlacement
        }

        private enum CodingKeys: String, CodingKey {
            case moovPlacement = "moovPlacement"
        }
    }

    public struct TagResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: true, type: .map), 
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: true, type: .string)
        ]
        /// The tags that you want to add to the resource. You can tag resources with a key-value pair or with only a key.
        public let tags: [String: String]
        /// The Amazon Resource Name (ARN) of the resource that you want to tag. To get the ARN, send a GET request with the resource name.
        public let arn: String

        public init(tags: [String: String], arn: String) {
            self.tags = tags
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
            case arn = "arn"
        }
    }

    public enum TimecodeBurninPosition: String, CustomStringConvertible, Codable {
        case topCenter = "TOP_CENTER"
        case topLeft = "TOP_LEFT"
        case topRight = "TOP_RIGHT"
        case middleLeft = "MIDDLE_LEFT"
        case middleCenter = "MIDDLE_CENTER"
        case middleRight = "MIDDLE_RIGHT"
        case bottomLeft = "BOTTOM_LEFT"
        case bottomCenter = "BOTTOM_CENTER"
        case bottomRight = "BOTTOM_RIGHT"
        public var description: String { return self.rawValue }
    }

    public struct Ac3Settings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SampleRate", location: .body(locationName: "sampleRate"), required: false, type: .integer), 
            AWSShapeMember(label: "Bitrate", location: .body(locationName: "bitrate"), required: false, type: .integer), 
            AWSShapeMember(label: "BitstreamMode", location: .body(locationName: "bitstreamMode"), required: false, type: .enum), 
            AWSShapeMember(label: "Dialnorm", location: .body(locationName: "dialnorm"), required: false, type: .integer), 
            AWSShapeMember(label: "DynamicRangeCompressionProfile", location: .body(locationName: "dynamicRangeCompressionProfile"), required: false, type: .enum), 
            AWSShapeMember(label: "CodingMode", location: .body(locationName: "codingMode"), required: false, type: .enum), 
            AWSShapeMember(label: "MetadataControl", location: .body(locationName: "metadataControl"), required: false, type: .enum), 
            AWSShapeMember(label: "LfeFilter", location: .body(locationName: "lfeFilter"), required: false, type: .enum)
        ]
        /// Sample rate in hz. Sample rate is always 48000.
        public let sampleRate: Int32?
        /// Average bitrate in bits/second. Valid bitrates depend on the coding mode.
        public let bitrate: Int32?
        public let bitstreamMode: Ac3BitstreamMode?
        /// Sets the dialnorm for the output. If blank and input audio is Dolby Digital, dialnorm will be passed through.
        public let dialnorm: Int32?
        public let dynamicRangeCompressionProfile: Ac3DynamicRangeCompressionProfile?
        public let codingMode: Ac3CodingMode?
        public let metadataControl: Ac3MetadataControl?
        public let lfeFilter: Ac3LfeFilter?

        public init(sampleRate: Int32? = nil, bitrate: Int32? = nil, bitstreamMode: Ac3BitstreamMode? = nil, dialnorm: Int32? = nil, dynamicRangeCompressionProfile: Ac3DynamicRangeCompressionProfile? = nil, codingMode: Ac3CodingMode? = nil, metadataControl: Ac3MetadataControl? = nil, lfeFilter: Ac3LfeFilter? = nil) {
            self.sampleRate = sampleRate
            self.bitrate = bitrate
            self.bitstreamMode = bitstreamMode
            self.dialnorm = dialnorm
            self.dynamicRangeCompressionProfile = dynamicRangeCompressionProfile
            self.codingMode = codingMode
            self.metadataControl = metadataControl
            self.lfeFilter = lfeFilter
        }

        private enum CodingKeys: String, CodingKey {
            case sampleRate = "sampleRate"
            case bitrate = "bitrate"
            case bitstreamMode = "bitstreamMode"
            case dialnorm = "dialnorm"
            case dynamicRangeCompressionProfile = "dynamicRangeCompressionProfile"
            case codingMode = "codingMode"
            case metadataControl = "metadataControl"
            case lfeFilter = "lfeFilter"
        }
    }

    public enum Mpeg2SceneChangeDetect: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum InputPsiControl: String, CustomStringConvertible, Codable {
        case ignorePsi = "IGNORE_PSI"
        case usePsi = "USE_PSI"
        public var description: String { return self.rawValue }
    }

    public enum BurninSubtitleFontColor: String, CustomStringConvertible, Codable {
        case white = "WHITE"
        case black = "BLACK"
        case yellow = "YELLOW"
        case red = "RED"
        case green = "GREEN"
        case blue = "BLUE"
        public var description: String { return self.rawValue }
    }

    public enum HlsAdMarkers: String, CustomStringConvertible, Codable {
        case elemental = "ELEMENTAL"
        case elementalScte35 = "ELEMENTAL_SCTE35"
        public var description: String { return self.rawValue }
    }

    public struct NoiseReducer: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SpatialFilterSettings", location: .body(locationName: "spatialFilterSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "FilterSettings", location: .body(locationName: "filterSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "Filter", location: .body(locationName: "filter"), required: false, type: .enum)
        ]
        public let spatialFilterSettings: NoiseReducerSpatialFilterSettings?
        public let filterSettings: NoiseReducerFilterSettings?
        public let filter: NoiseReducerFilter?

        public init(spatialFilterSettings: NoiseReducerSpatialFilterSettings? = nil, filterSettings: NoiseReducerFilterSettings? = nil, filter: NoiseReducerFilter? = nil) {
            self.spatialFilterSettings = spatialFilterSettings
            self.filterSettings = filterSettings
            self.filter = filter
        }

        private enum CodingKeys: String, CodingKey {
            case spatialFilterSettings = "spatialFilterSettings"
            case filterSettings = "filterSettings"
            case filter = "filter"
        }
    }

    public struct Queue: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SubmittedJobsCount", location: .body(locationName: "submittedJobsCount"), required: false, type: .integer), 
            AWSShapeMember(label: "ProgressingJobsCount", location: .body(locationName: "progressingJobsCount"), required: false, type: .integer), 
            AWSShapeMember(label: "Status", location: .body(locationName: "status"), required: false, type: .enum), 
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: true, type: .string), 
            AWSShapeMember(label: "LastUpdated", location: .body(locationName: "lastUpdated"), required: false, type: .timestamp), 
            AWSShapeMember(label: "CreatedAt", location: .body(locationName: "createdAt"), required: false, type: .timestamp), 
            AWSShapeMember(label: "Type", location: .body(locationName: "type"), required: false, type: .enum), 
            AWSShapeMember(label: "PricingPlan", location: .body(locationName: "pricingPlan"), required: false, type: .enum), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "ReservationPlan", location: .body(locationName: "reservationPlan"), required: false, type: .structure)
        ]
        /// The estimated number of jobs with a SUBMITTED status.
        public let submittedJobsCount: Int32?
        /// The estimated number of jobs with a PROGRESSING status.
        public let progressingJobsCount: Int32?
        /// Queues can be ACTIVE or PAUSED. If you pause a queue, the service won't begin processing jobs in that queue. Jobs that are running when you pause the queue continue to run until they finish or result in an error.
        public let status: QueueStatus?
        /// An identifier for this resource that is unique within all of AWS.
        public let arn: String?
        /// A name that you create for each queue. Each name must be unique within your account.
        public let name: String
        /// The timestamp in epoch seconds for when you most recently updated the queue.
        public let lastUpdated: TimeStamp?
        /// The timestamp in epoch seconds for when you created the queue.
        public let createdAt: TimeStamp?
        /// Specifies whether this on-demand queue is system or custom. System queues are built in. You can't modify or delete system queues. You can create and modify custom queues.
        public let `type`: `Type`?
        /// Specifies whether the pricing plan for the queue is on-demand or reserved. For on-demand, you pay per minute, billed in increments of .01 minute. For reserved, you pay for the transcoding capacity of the entire queue, regardless of how much or how little you use it. Reserved pricing requires a 12-month commitment.
        public let pricingPlan: PricingPlan?
        /// An optional description that you create for each queue.
        public let description: String?
        /// Details about the pricing plan for your reserved queue. Required for reserved queues and not applicable to on-demand queues.
        public let reservationPlan: ReservationPlan?

        public init(submittedJobsCount: Int32? = nil, progressingJobsCount: Int32? = nil, status: QueueStatus? = nil, arn: String? = nil, name: String, lastUpdated: TimeStamp? = nil, createdAt: TimeStamp? = nil, type: `Type`? = nil, pricingPlan: PricingPlan? = nil, description: String? = nil, reservationPlan: ReservationPlan? = nil) {
            self.submittedJobsCount = submittedJobsCount
            self.progressingJobsCount = progressingJobsCount
            self.status = status
            self.arn = arn
            self.name = name
            self.lastUpdated = lastUpdated
            self.createdAt = createdAt
            self.`type` = `type`
            self.pricingPlan = pricingPlan
            self.description = description
            self.reservationPlan = reservationPlan
        }

        private enum CodingKeys: String, CodingKey {
            case submittedJobsCount = "submittedJobsCount"
            case progressingJobsCount = "progressingJobsCount"
            case status = "status"
            case arn = "arn"
            case name = "name"
            case lastUpdated = "lastUpdated"
            case createdAt = "createdAt"
            case `type` = "type"
            case pricingPlan = "pricingPlan"
            case description = "description"
            case reservationPlan = "reservationPlan"
        }
    }

    public struct AacSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CodecProfile", location: .body(locationName: "codecProfile"), required: false, type: .enum), 
            AWSShapeMember(label: "RateControlMode", location: .body(locationName: "rateControlMode"), required: false, type: .enum), 
            AWSShapeMember(label: "CodingMode", location: .body(locationName: "codingMode"), required: false, type: .enum), 
            AWSShapeMember(label: "SampleRate", location: .body(locationName: "sampleRate"), required: false, type: .integer), 
            AWSShapeMember(label: "AudioDescriptionBroadcasterMix", location: .body(locationName: "audioDescriptionBroadcasterMix"), required: false, type: .enum), 
            AWSShapeMember(label: "RawFormat", location: .body(locationName: "rawFormat"), required: false, type: .enum), 
            AWSShapeMember(label: "Specification", location: .body(locationName: "specification"), required: false, type: .enum), 
            AWSShapeMember(label: "VbrQuality", location: .body(locationName: "vbrQuality"), required: false, type: .enum), 
            AWSShapeMember(label: "Bitrate", location: .body(locationName: "bitrate"), required: false, type: .integer)
        ]
        public let codecProfile: AacCodecProfile?
        public let rateControlMode: AacRateControlMode?
        public let codingMode: AacCodingMode?
        /// Sample rate in Hz. Valid values depend on rate control mode and profile.
        public let sampleRate: Int32?
        public let audioDescriptionBroadcasterMix: AacAudioDescriptionBroadcasterMix?
        public let rawFormat: AacRawFormat?
        public let specification: AacSpecification?
        public let vbrQuality: AacVbrQuality?
        /// Average bitrate in bits/second. Defaults and valid values depend on rate control mode and profile.
        public let bitrate: Int32?

        public init(codecProfile: AacCodecProfile? = nil, rateControlMode: AacRateControlMode? = nil, codingMode: AacCodingMode? = nil, sampleRate: Int32? = nil, audioDescriptionBroadcasterMix: AacAudioDescriptionBroadcasterMix? = nil, rawFormat: AacRawFormat? = nil, specification: AacSpecification? = nil, vbrQuality: AacVbrQuality? = nil, bitrate: Int32? = nil) {
            self.codecProfile = codecProfile
            self.rateControlMode = rateControlMode
            self.codingMode = codingMode
            self.sampleRate = sampleRate
            self.audioDescriptionBroadcasterMix = audioDescriptionBroadcasterMix
            self.rawFormat = rawFormat
            self.specification = specification
            self.vbrQuality = vbrQuality
            self.bitrate = bitrate
        }

        private enum CodingKeys: String, CodingKey {
            case codecProfile = "codecProfile"
            case rateControlMode = "rateControlMode"
            case codingMode = "codingMode"
            case sampleRate = "sampleRate"
            case audioDescriptionBroadcasterMix = "audioDescriptionBroadcasterMix"
            case rawFormat = "rawFormat"
            case specification = "specification"
            case vbrQuality = "vbrQuality"
            case bitrate = "bitrate"
        }
    }

    public struct SpekeKeyProvider: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CertificateArn", location: .body(locationName: "certificateArn"), required: false, type: .string), 
            AWSShapeMember(label: "Url", location: .body(locationName: "url"), required: false, type: .string), 
            AWSShapeMember(label: "SystemIds", location: .body(locationName: "systemIds"), required: false, type: .list), 
            AWSShapeMember(label: "ResourceId", location: .body(locationName: "resourceId"), required: false, type: .string)
        ]
        /// Optional AWS Certificate Manager ARN for a certificate to send to the keyprovider. The certificate holds a key used by the keyprovider to encrypt the keys in its response.
        public let certificateArn: String?
        /// Use URL (Url) to specify the SPEKE-compliant server that will provide keys for content.
        public let url: String?
        /// Relates to SPEKE implementation. DRM system identifiers. DASH output groups support a max of two system ids. Other group types support one system id.
        public let systemIds: [String]?
        /// The SPEKE-compliant server uses Resource ID (ResourceId) to identify content.
        public let resourceId: String?

        public init(certificateArn: String? = nil, url: String? = nil, systemIds: [String]? = nil, resourceId: String? = nil) {
            self.certificateArn = certificateArn
            self.url = url
            self.systemIds = systemIds
            self.resourceId = resourceId
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "certificateArn"
            case url = "url"
            case systemIds = "systemIds"
            case resourceId = "resourceId"
        }
    }

    public enum M2tsEbpPlacement: String, CustomStringConvertible, Codable {
        case videoAndAudioPids = "VIDEO_AND_AUDIO_PIDS"
        case videoPid = "VIDEO_PID"
        public var description: String { return self.rawValue }
    }

    public enum CmafWriteHLSManifest: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum DeinterlacerControl: String, CustomStringConvertible, Codable {
        case forceAllFrames = "FORCE_ALL_FRAMES"
        case normal = "NORMAL"
        public var description: String { return self.rawValue }
    }

    public enum H264Syntax: String, CustomStringConvertible, Codable {
        case `default` = "DEFAULT"
        case rp2027 = "RP2027"
        public var description: String { return self.rawValue }
    }

    public enum DescribeEndpointsMode: String, CustomStringConvertible, Codable {
        case `default` = "DEFAULT"
        case getOnly = "GET_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum DropFrameTimecode: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum M3u8Scte35Source: String, CustomStringConvertible, Codable {
        case passthrough = "PASSTHROUGH"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum DvbSubtitleBackgroundColor: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case black = "BLACK"
        case white = "WHITE"
        public var description: String { return self.rawValue }
    }

    public enum H264DynamicSubGop: String, CustomStringConvertible, Codable {
        case adaptive = "ADAPTIVE"
        case `static` = "STATIC"
        public var description: String { return self.rawValue }
    }

    public struct ListPresetsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "Order", location: .querystring(locationName: "order"), required: false, type: .enum), 
            AWSShapeMember(label: "Category", location: .querystring(locationName: "category"), required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "ListBy", location: .querystring(locationName: "listBy"), required: false, type: .enum)
        ]
        /// Use this string, provided with the response to a previous request, to request the next batch of presets.
        public let nextToken: String?
        public let order: Order?
        /// Optionally, specify a preset category to limit responses to only presets from that category.
        public let category: String?
        /// Optional. Number of presets, up to twenty, that will be returned at one time
        public let maxResults: Int32?
        public let listBy: PresetListBy?

        public init(nextToken: String? = nil, order: Order? = nil, category: String? = nil, maxResults: Int32? = nil, listBy: PresetListBy? = nil) {
            self.nextToken = nextToken
            self.order = order
            self.category = category
            self.maxResults = maxResults
            self.listBy = listBy
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case order = "order"
            case category = "category"
            case maxResults = "maxResults"
            case listBy = "listBy"
        }
    }

    public enum H265FlickerAdaptiveQuantization: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum Mp4FreeSpaceBox: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public enum HlsClientCache: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct ImageInserter: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InsertableImages", location: .body(locationName: "insertableImages"), required: false, type: .list)
        ]
        /// Specify the images that you want to overlay on your video. The images must be PNG or TGA files.
        public let insertableImages: [InsertableImage]?

        public init(insertableImages: [InsertableImage]? = nil) {
            self.insertableImages = insertableImages
        }

        private enum CodingKeys: String, CodingKey {
            case insertableImages = "insertableImages"
        }
    }

    public enum Mpeg2IntraDcPrecision: String, CustomStringConvertible, Codable {
        case auto = "AUTO"
        case intraDcPrecision8 = "INTRA_DC_PRECISION_8"
        case intraDcPrecision9 = "INTRA_DC_PRECISION_9"
        case intraDcPrecision10 = "INTRA_DC_PRECISION_10"
        case intraDcPrecision11 = "INTRA_DC_PRECISION_11"
        public var description: String { return self.rawValue }
    }

    public enum Eac3DynamicRangeCompressionLine: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case filmStandard = "FILM_STANDARD"
        case filmLight = "FILM_LIGHT"
        case musicStandard = "MUSIC_STANDARD"
        case musicLight = "MUSIC_LIGHT"
        case speech = "SPEECH"
        public var description: String { return self.rawValue }
    }

    public enum H265ParControl: String, CustomStringConvertible, Codable {
        case initializeFromSource = "INITIALIZE_FROM_SOURCE"
        case specified = "SPECIFIED"
        public var description: String { return self.rawValue }
    }

    public enum H265AlternateTransferFunctionSei: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum SccDestinationFramerate: String, CustomStringConvertible, Codable {
        case framerate2397 = "FRAMERATE_23_97"
        case framerate24 = "FRAMERATE_24"
        case framerate2997Dropframe = "FRAMERATE_29_97_DROPFRAME"
        case framerate2997NonDropframe = "FRAMERATE_29_97_NON_DROPFRAME"
        public var description: String { return self.rawValue }
    }

    public enum MotionImageInsertionMode: String, CustomStringConvertible, Codable {
        case mov = "MOV"
        case png = "PNG"
        public var description: String { return self.rawValue }
    }

    public enum HlsOutputSelection: String, CustomStringConvertible, Codable {
        case manifestsAndSegments = "MANIFESTS_AND_SEGMENTS"
        case segmentsOnly = "SEGMENTS_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum PricingPlan: String, CustomStringConvertible, Codable {
        case onDemand = "ON_DEMAND"
        case reserved = "RESERVED"
        public var description: String { return self.rawValue }
    }

    public enum Mpeg2SpatialAdaptiveQuantization: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum H265QualityTuningLevel: String, CustomStringConvertible, Codable {
        case singlePass = "SINGLE_PASS"
        case singlePassHq = "SINGLE_PASS_HQ"
        case multiPassHq = "MULTI_PASS_HQ"
        public var description: String { return self.rawValue }
    }

    public struct Mp4Settings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MoovPlacement", location: .body(locationName: "moovPlacement"), required: false, type: .enum), 
            AWSShapeMember(label: "FreeSpaceBox", location: .body(locationName: "freeSpaceBox"), required: false, type: .enum), 
            AWSShapeMember(label: "Mp4MajorBrand", location: .body(locationName: "mp4MajorBrand"), required: false, type: .string), 
            AWSShapeMember(label: "CslgAtom", location: .body(locationName: "cslgAtom"), required: false, type: .enum)
        ]
        public let moovPlacement: Mp4MoovPlacement?
        public let freeSpaceBox: Mp4FreeSpaceBox?
        /// Overrides the "Major Brand" field in the output file. Usually not necessary to specify.
        public let mp4MajorBrand: String?
        public let cslgAtom: Mp4CslgAtom?

        public init(moovPlacement: Mp4MoovPlacement? = nil, freeSpaceBox: Mp4FreeSpaceBox? = nil, mp4MajorBrand: String? = nil, cslgAtom: Mp4CslgAtom? = nil) {
            self.moovPlacement = moovPlacement
            self.freeSpaceBox = freeSpaceBox
            self.mp4MajorBrand = mp4MajorBrand
            self.cslgAtom = cslgAtom
        }

        private enum CodingKeys: String, CodingKey {
            case moovPlacement = "moovPlacement"
            case freeSpaceBox = "freeSpaceBox"
            case mp4MajorBrand = "mp4MajorBrand"
            case cslgAtom = "cslgAtom"
        }
    }

    public enum DeinterlacerMode: String, CustomStringConvertible, Codable {
        case deinterlace = "DEINTERLACE"
        case inverseTelecine = "INVERSE_TELECINE"
        case adaptive = "ADAPTIVE"
        public var description: String { return self.rawValue }
    }

    public enum VideoTimecodeInsertion: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case picTimingSei = "PIC_TIMING_SEI"
        public var description: String { return self.rawValue }
    }

    public struct VideoCodecSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Codec", location: .body(locationName: "codec"), required: false, type: .enum), 
            AWSShapeMember(label: "Mpeg2Settings", location: .body(locationName: "mpeg2Settings"), required: false, type: .structure), 
            AWSShapeMember(label: "H265Settings", location: .body(locationName: "h265Settings"), required: false, type: .structure), 
            AWSShapeMember(label: "H264Settings", location: .body(locationName: "h264Settings"), required: false, type: .structure), 
            AWSShapeMember(label: "FrameCaptureSettings", location: .body(locationName: "frameCaptureSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "ProresSettings", location: .body(locationName: "proresSettings"), required: false, type: .structure)
        ]
        /// Specifies the video codec. This must be equal to one of the enum values defined by the object  VideoCodec.
        public let codec: VideoCodec?
        public let mpeg2Settings: Mpeg2Settings?
        public let h265Settings: H265Settings?
        public let h264Settings: H264Settings?
        public let frameCaptureSettings: FrameCaptureSettings?
        public let proresSettings: ProresSettings?

        public init(codec: VideoCodec? = nil, mpeg2Settings: Mpeg2Settings? = nil, h265Settings: H265Settings? = nil, h264Settings: H264Settings? = nil, frameCaptureSettings: FrameCaptureSettings? = nil, proresSettings: ProresSettings? = nil) {
            self.codec = codec
            self.mpeg2Settings = mpeg2Settings
            self.h265Settings = h265Settings
            self.h264Settings = h264Settings
            self.frameCaptureSettings = frameCaptureSettings
            self.proresSettings = proresSettings
        }

        private enum CodingKeys: String, CodingKey {
            case codec = "codec"
            case mpeg2Settings = "mpeg2Settings"
            case h265Settings = "h265Settings"
            case h264Settings = "h264Settings"
            case frameCaptureSettings = "frameCaptureSettings"
            case proresSettings = "proresSettings"
        }
    }

    public enum H264Telecine: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case soft = "SOFT"
        case hard = "HARD"
        public var description: String { return self.rawValue }
    }

    public enum Ac3CodingMode: String, CustomStringConvertible, Codable {
        case codingMode10 = "CODING_MODE_1_0"
        case codingMode11 = "CODING_MODE_1_1"
        case codingMode20 = "CODING_MODE_2_0"
        case codingMode32Lfe = "CODING_MODE_3_2_LFE"
        public var description: String { return self.rawValue }
    }

    public struct TeletextSourceSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PageNumber", location: .body(locationName: "pageNumber"), required: false, type: .string)
        ]
        /// Use Page Number (PageNumber) to specify the three-digit hexadecimal page number that will be used for Teletext captions. Do not use this setting if you are passing through teletext from the input source to output.
        public let pageNumber: String?

        public init(pageNumber: String? = nil) {
            self.pageNumber = pageNumber
        }

        private enum CodingKeys: String, CodingKey {
            case pageNumber = "pageNumber"
        }
    }

    public enum ProresFramerateConversionAlgorithm: String, CustomStringConvertible, Codable {
        case duplicateDrop = "DUPLICATE_DROP"
        case interpolate = "INTERPOLATE"
        public var description: String { return self.rawValue }
    }

    public struct Job: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UserMetadata", location: .body(locationName: "userMetadata"), required: false, type: .map), 
            AWSShapeMember(label: "Status", location: .body(locationName: "status"), required: false, type: .enum), 
            AWSShapeMember(label: "ErrorCode", location: .body(locationName: "errorCode"), required: false, type: .integer), 
            AWSShapeMember(label: "OutputGroupDetails", location: .body(locationName: "outputGroupDetails"), required: false, type: .list), 
            AWSShapeMember(label: "ErrorMessage", location: .body(locationName: "errorMessage"), required: false, type: .string), 
            AWSShapeMember(label: "Role", location: .body(locationName: "role"), required: true, type: .string), 
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "BillingTagsSource", location: .body(locationName: "billingTagsSource"), required: false, type: .enum), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: false, type: .string), 
            AWSShapeMember(label: "Queue", location: .body(locationName: "queue"), required: false, type: .string), 
            AWSShapeMember(label: "JobTemplate", location: .body(locationName: "jobTemplate"), required: false, type: .string), 
            AWSShapeMember(label: "CreatedAt", location: .body(locationName: "createdAt"), required: false, type: .timestamp), 
            AWSShapeMember(label: "Timing", location: .body(locationName: "timing"), required: false, type: .structure), 
            AWSShapeMember(label: "Settings", location: .body(locationName: "settings"), required: true, type: .structure)
        ]
        /// User-defined metadata that you want to associate with an MediaConvert job. You specify metadata in key/value pairs.
        public let userMetadata: [String: String]?
        public let status: JobStatus?
        /// Error code for the job
        public let errorCode: Int32?
        /// List of output group details
        public let outputGroupDetails: [OutputGroupDetail]?
        /// Error message of Job
        public let errorMessage: String?
        /// The IAM role you use for creating this job. For details about permissions, see the User Guide topic at the User Guide at http://docs.aws.amazon.com/mediaconvert/latest/ug/iam-role.html
        public let role: String
        /// An identifier for this resource that is unique within all of AWS.
        public let arn: String?
        public let billingTagsSource: BillingTagsSource?
        /// A portion of the job's ARN, unique within your AWS Elemental MediaConvert resources
        public let id: String?
        /// Optional. When you create a job, you can specify a queue to send it to. If you don't specify, the job will go to the default queue. For more about queues, see the User Guide topic at http://docs.aws.amazon.com/mediaconvert/latest/ug/what-is.html
        public let queue: String?
        /// The job template that the job is created from, if it is created from a job template.
        public let jobTemplate: String?
        /// The time, in Unix epoch format in seconds, when the job got created.
        public let createdAt: TimeStamp?
        public let timing: Timing?
        public let settings: JobSettings

        public init(userMetadata: [String: String]? = nil, status: JobStatus? = nil, errorCode: Int32? = nil, outputGroupDetails: [OutputGroupDetail]? = nil, errorMessage: String? = nil, role: String, arn: String? = nil, billingTagsSource: BillingTagsSource? = nil, id: String? = nil, queue: String? = nil, jobTemplate: String? = nil, createdAt: TimeStamp? = nil, timing: Timing? = nil, settings: JobSettings) {
            self.userMetadata = userMetadata
            self.status = status
            self.errorCode = errorCode
            self.outputGroupDetails = outputGroupDetails
            self.errorMessage = errorMessage
            self.role = role
            self.arn = arn
            self.billingTagsSource = billingTagsSource
            self.id = id
            self.queue = queue
            self.jobTemplate = jobTemplate
            self.createdAt = createdAt
            self.timing = timing
            self.settings = settings
        }

        private enum CodingKeys: String, CodingKey {
            case userMetadata = "userMetadata"
            case status = "status"
            case errorCode = "errorCode"
            case outputGroupDetails = "outputGroupDetails"
            case errorMessage = "errorMessage"
            case role = "role"
            case arn = "arn"
            case billingTagsSource = "billingTagsSource"
            case id = "id"
            case queue = "queue"
            case jobTemplate = "jobTemplate"
            case createdAt = "createdAt"
            case timing = "timing"
            case settings = "settings"
        }
    }

    public enum DashIsoHbbtvCompliance: String, CustomStringConvertible, Codable {
        case hbbtv15 = "HBBTV_1_5"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum Mpeg2FramerateConversionAlgorithm: String, CustomStringConvertible, Codable {
        case duplicateDrop = "DUPLICATE_DROP"
        case interpolate = "INTERPOLATE"
        public var description: String { return self.rawValue }
    }

    public enum ColorMetadata: String, CustomStringConvertible, Codable {
        case ignore = "IGNORE"
        case insert = "INSERT"
        public var description: String { return self.rawValue }
    }

    public enum BurninSubtitleOutlineColor: String, CustomStringConvertible, Codable {
        case black = "BLACK"
        case white = "WHITE"
        case yellow = "YELLOW"
        case red = "RED"
        case green = "GREEN"
        case blue = "BLUE"
        public var description: String { return self.rawValue }
    }

    public enum CmafManifestDurationFormat: String, CustomStringConvertible, Codable {
        case floatingPoint = "FLOATING_POINT"
        case integer = "INTEGER"
        public var description: String { return self.rawValue }
    }

    public enum H264GopBReference: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum Eac3StereoDownmix: String, CustomStringConvertible, Codable {
        case notIndicated = "NOT_INDICATED"
        case loRo = "LO_RO"
        case ltRt = "LT_RT"
        case dpl2 = "DPL2"
        public var description: String { return self.rawValue }
    }

    public struct DvbNitSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NetworkId", location: .body(locationName: "networkId"), required: false, type: .integer), 
            AWSShapeMember(label: "NitInterval", location: .body(locationName: "nitInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "NetworkName", location: .body(locationName: "networkName"), required: false, type: .string)
        ]
        /// The numeric value placed in the Network Information Table (NIT).
        public let networkId: Int32?
        /// The number of milliseconds between instances of this table in the output transport stream.
        public let nitInterval: Int32?
        /// The network name text placed in the network_name_descriptor inside the Network Information Table. Maximum length is 256 characters.
        public let networkName: String?

        public init(networkId: Int32? = nil, nitInterval: Int32? = nil, networkName: String? = nil) {
            self.networkId = networkId
            self.nitInterval = nitInterval
            self.networkName = networkName
        }

        private enum CodingKeys: String, CodingKey {
            case networkId = "networkId"
            case nitInterval = "nitInterval"
            case networkName = "networkName"
        }
    }

    public struct CreatePresetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: true, type: .string), 
            AWSShapeMember(label: "Category", location: .body(locationName: "category"), required: false, type: .string), 
            AWSShapeMember(label: "Settings", location: .body(locationName: "settings"), required: true, type: .structure)
        ]
        /// The tags that you want to add to the resource. You can tag resources with a key-value pair or with only a key.
        public let tags: [String: String]?
        /// Optional. A description of the preset you are creating.
        public let description: String?
        /// The name of the preset you are creating.
        public let name: String
        /// Optional. A category for the preset you are creating.
        public let category: String?
        public let settings: PresetSettings

        public init(tags: [String: String]? = nil, description: String? = nil, name: String, category: String? = nil, settings: PresetSettings) {
            self.tags = tags
            self.description = description
            self.name = name
            self.category = category
            self.settings = settings
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
            case description = "description"
            case name = "name"
            case category = "category"
            case settings = "settings"
        }
    }

    public enum HlsManifestCompression: String, CustomStringConvertible, Codable {
        case gzip = "GZIP"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public struct OutputChannelMapping: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InputChannels", location: .body(locationName: "inputChannels"), required: false, type: .list)
        ]
        /// List of input channels
        public let inputChannels: [Int32]?

        public init(inputChannels: [Int32]? = nil) {
            self.inputChannels = inputChannels
        }

        private enum CodingKeys: String, CodingKey {
            case inputChannels = "inputChannels"
        }
    }

    public enum QueueListBy: String, CustomStringConvertible, Codable {
        case name = "NAME"
        case creationDate = "CREATION_DATE"
        public var description: String { return self.rawValue }
    }

    public struct UpdateQueueResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Queue", location: .body(locationName: "queue"), required: false, type: .structure)
        ]
        public let queue: Queue?

        public init(queue: Queue? = nil) {
            self.queue = queue
        }

        private enum CodingKeys: String, CodingKey {
            case queue = "queue"
        }
    }

    public enum TimecodeSource: String, CustomStringConvertible, Codable {
        case embedded = "EMBEDDED"
        case zerobased = "ZEROBASED"
        case specifiedstart = "SPECIFIEDSTART"
        public var description: String { return self.rawValue }
    }

    public struct AudioSelector: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DefaultSelection", location: .body(locationName: "defaultSelection"), required: false, type: .enum), 
            AWSShapeMember(label: "Offset", location: .body(locationName: "offset"), required: false, type: .integer), 
            AWSShapeMember(label: "Pids", location: .body(locationName: "pids"), required: false, type: .list), 
            AWSShapeMember(label: "ProgramSelection", location: .body(locationName: "programSelection"), required: false, type: .integer), 
            AWSShapeMember(label: "RemixSettings", location: .body(locationName: "remixSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "ExternalAudioFileInput", location: .body(locationName: "externalAudioFileInput"), required: false, type: .string), 
            AWSShapeMember(label: "Tracks", location: .body(locationName: "tracks"), required: false, type: .list), 
            AWSShapeMember(label: "CustomLanguageCode", location: .body(locationName: "customLanguageCode"), required: false, type: .string), 
            AWSShapeMember(label: "SelectorType", location: .body(locationName: "selectorType"), required: false, type: .enum), 
            AWSShapeMember(label: "LanguageCode", location: .body(locationName: "languageCode"), required: false, type: .enum)
        ]
        public let defaultSelection: AudioDefaultSelection?
        /// Specifies a time delta in milliseconds to offset the audio from the input video.
        public let offset: Int32?
        /// Selects a specific PID from within an audio source (e.g. 257 selects PID 0x101).
        public let pids: [Int32]?
        /// Use this setting for input streams that contain Dolby E, to have the service extract specific program data from the track. To select multiple programs, create multiple selectors with the same Track and different Program numbers. In the console, this setting is visible when you set Selector type to Track. Choose the program number from the dropdown list. If you are sending a JSON file, provide the program ID, which is part of the audio metadata. If your input file has incorrect metadata, you can choose All channels instead of a program number to have the service ignore the program IDs and include all the programs in the track.
        public let programSelection: Int32?
        /// Use these settings to reorder the audio channels of one input to match those of another input. This allows you to combine the two files into a single output, one after the other.
        public let remixSettings: RemixSettings?
        /// Specifies audio data from an external file source.
        public let externalAudioFileInput: String?
        /// Identify a track from the input audio to include in this selector by entering the track index number. To include several tracks in a single audio selector, specify multiple tracks as follows. Using the console, enter a comma-separated list. For examle, type "1,2,3" to include tracks 1 through 3. Specifying directly in your JSON job file, provide the track numbers in an array. For example, "tracks": [1,2,3].
        public let tracks: [Int32]?
        /// Selects a specific language code from within an audio source, using the ISO 639-2 or ISO 639-3 three-letter language code
        public let customLanguageCode: String?
        public let selectorType: AudioSelectorType?
        /// Selects a specific language code from within an audio source.
        public let languageCode: LanguageCode?

        public init(defaultSelection: AudioDefaultSelection? = nil, offset: Int32? = nil, pids: [Int32]? = nil, programSelection: Int32? = nil, remixSettings: RemixSettings? = nil, externalAudioFileInput: String? = nil, tracks: [Int32]? = nil, customLanguageCode: String? = nil, selectorType: AudioSelectorType? = nil, languageCode: LanguageCode? = nil) {
            self.defaultSelection = defaultSelection
            self.offset = offset
            self.pids = pids
            self.programSelection = programSelection
            self.remixSettings = remixSettings
            self.externalAudioFileInput = externalAudioFileInput
            self.tracks = tracks
            self.customLanguageCode = customLanguageCode
            self.selectorType = selectorType
            self.languageCode = languageCode
        }

        private enum CodingKeys: String, CodingKey {
            case defaultSelection = "defaultSelection"
            case offset = "offset"
            case pids = "pids"
            case programSelection = "programSelection"
            case remixSettings = "remixSettings"
            case externalAudioFileInput = "externalAudioFileInput"
            case tracks = "tracks"
            case customLanguageCode = "customLanguageCode"
            case selectorType = "selectorType"
            case languageCode = "languageCode"
        }
    }

    public enum Mpeg2Syntax: String, CustomStringConvertible, Codable {
        case `default` = "DEFAULT"
        case d10 = "D_10"
        public var description: String { return self.rawValue }
    }

    public enum HlsCodecSpecification: String, CustomStringConvertible, Codable {
        case rfc6381 = "RFC_6381"
        case rfc4281 = "RFC_4281"
        public var description: String { return self.rawValue }
    }

    public enum AacSpecification: String, CustomStringConvertible, Codable {
        case mpeg2 = "MPEG2"
        case mpeg4 = "MPEG4"
        public var description: String { return self.rawValue }
    }

    public struct ContainerSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "F4vSettings", location: .body(locationName: "f4vSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "Container", location: .body(locationName: "container"), required: false, type: .enum), 
            AWSShapeMember(label: "M2tsSettings", location: .body(locationName: "m2tsSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "Mp4Settings", location: .body(locationName: "mp4Settings"), required: false, type: .structure), 
            AWSShapeMember(label: "M3u8Settings", location: .body(locationName: "m3u8Settings"), required: false, type: .structure), 
            AWSShapeMember(label: "MovSettings", location: .body(locationName: "movSettings"), required: false, type: .structure)
        ]
        public let f4vSettings: F4vSettings?
        public let container: ContainerType?
        public let m2tsSettings: M2tsSettings?
        public let mp4Settings: Mp4Settings?
        public let m3u8Settings: M3u8Settings?
        public let movSettings: MovSettings?

        public init(f4vSettings: F4vSettings? = nil, container: ContainerType? = nil, m2tsSettings: M2tsSettings? = nil, mp4Settings: Mp4Settings? = nil, m3u8Settings: M3u8Settings? = nil, movSettings: MovSettings? = nil) {
            self.f4vSettings = f4vSettings
            self.container = container
            self.m2tsSettings = m2tsSettings
            self.mp4Settings = mp4Settings
            self.m3u8Settings = m3u8Settings
            self.movSettings = movSettings
        }

        private enum CodingKeys: String, CodingKey {
            case f4vSettings = "f4vSettings"
            case container = "container"
            case m2tsSettings = "m2tsSettings"
            case mp4Settings = "mp4Settings"
            case m3u8Settings = "m3u8Settings"
            case movSettings = "movSettings"
        }
    }

    public enum ProresSlowPal: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct OutputGroupSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HlsGroupSettings", location: .body(locationName: "hlsGroupSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "CmafGroupSettings", location: .body(locationName: "cmafGroupSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "Type", location: .body(locationName: "type"), required: false, type: .enum), 
            AWSShapeMember(label: "DashIsoGroupSettings", location: .body(locationName: "dashIsoGroupSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "FileGroupSettings", location: .body(locationName: "fileGroupSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "MsSmoothGroupSettings", location: .body(locationName: "msSmoothGroupSettings"), required: false, type: .structure)
        ]
        public let hlsGroupSettings: HlsGroupSettings?
        public let cmafGroupSettings: CmafGroupSettings?
        public let `type`: OutputGroupType?
        public let dashIsoGroupSettings: DashIsoGroupSettings?
        public let fileGroupSettings: FileGroupSettings?
        public let msSmoothGroupSettings: MsSmoothGroupSettings?

        public init(hlsGroupSettings: HlsGroupSettings? = nil, cmafGroupSettings: CmafGroupSettings? = nil, type: OutputGroupType? = nil, dashIsoGroupSettings: DashIsoGroupSettings? = nil, fileGroupSettings: FileGroupSettings? = nil, msSmoothGroupSettings: MsSmoothGroupSettings? = nil) {
            self.hlsGroupSettings = hlsGroupSettings
            self.cmafGroupSettings = cmafGroupSettings
            self.`type` = `type`
            self.dashIsoGroupSettings = dashIsoGroupSettings
            self.fileGroupSettings = fileGroupSettings
            self.msSmoothGroupSettings = msSmoothGroupSettings
        }

        private enum CodingKeys: String, CodingKey {
            case hlsGroupSettings = "hlsGroupSettings"
            case cmafGroupSettings = "cmafGroupSettings"
            case `type` = "type"
            case dashIsoGroupSettings = "dashIsoGroupSettings"
            case fileGroupSettings = "fileGroupSettings"
            case msSmoothGroupSettings = "msSmoothGroupSettings"
        }
    }

    public struct ListJobsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Jobs", location: .body(locationName: "jobs"), required: false, type: .list), 
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string)
        ]
        /// List of jobs
        public let jobs: [Job]?
        /// Use this string to request the next batch of jobs.
        public let nextToken: String?

        public init(jobs: [Job]? = nil, nextToken: String? = nil) {
            self.jobs = jobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "jobs"
            case nextToken = "nextToken"
        }
    }

    public enum H264SpatialAdaptiveQuantization: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct InputTemplate: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ProgramNumber", location: .body(locationName: "programNumber"), required: false, type: .integer), 
            AWSShapeMember(label: "FilterStrength", location: .body(locationName: "filterStrength"), required: false, type: .integer), 
            AWSShapeMember(label: "InputClippings", location: .body(locationName: "inputClippings"), required: false, type: .list), 
            AWSShapeMember(label: "TimecodeSource", location: .body(locationName: "timecodeSource"), required: false, type: .enum), 
            AWSShapeMember(label: "DeblockFilter", location: .body(locationName: "deblockFilter"), required: false, type: .enum), 
            AWSShapeMember(label: "FilterEnable", location: .body(locationName: "filterEnable"), required: false, type: .enum), 
            AWSShapeMember(label: "VideoSelector", location: .body(locationName: "videoSelector"), required: false, type: .structure), 
            AWSShapeMember(label: "AudioSelectorGroups", location: .body(locationName: "audioSelectorGroups"), required: false, type: .map), 
            AWSShapeMember(label: "AudioSelectors", location: .body(locationName: "audioSelectors"), required: false, type: .map), 
            AWSShapeMember(label: "ImageInserter", location: .body(locationName: "imageInserter"), required: false, type: .structure), 
            AWSShapeMember(label: "CaptionSelectors", location: .body(locationName: "captionSelectors"), required: false, type: .map), 
            AWSShapeMember(label: "DenoiseFilter", location: .body(locationName: "denoiseFilter"), required: false, type: .enum), 
            AWSShapeMember(label: "PsiControl", location: .body(locationName: "psiControl"), required: false, type: .enum)
        ]
        /// Use Program (programNumber) to select a specific program from within a multi-program transport stream. Note that Quad 4K is not currently supported. Default is the first program within the transport stream. If the program you specify doesn't exist, the transcoding service will use this default.
        public let programNumber: Int32?
        /// Use Filter strength (FilterStrength) to adjust the magnitude the input filter settings (Deblock and Denoise). The range is -5 to 5. Default is 0.
        public let filterStrength: Int32?
        /// (InputClippings) contains sets of start and end times that together specify a portion of the input to be used in the outputs. If you provide only a start time, the clip will be the entire input from that point to the end. If you provide only an end time, it will be the entire input up to that point. When you specify more than one input clip, the transcoding service creates the job outputs by stringing the clips together in the order you specify them.
        public let inputClippings: [InputClipping]?
        public let timecodeSource: InputTimecodeSource?
        public let deblockFilter: InputDeblockFilter?
        public let filterEnable: InputFilterEnable?
        public let videoSelector: VideoSelector?
        /// Specifies set of audio selectors within an input to combine. An input may have multiple audio selector groups. See "Audio Selector Group":#inputs-audio_selector_group for more information.
        public let audioSelectorGroups: [String: AudioSelectorGroup]?
        /// Use Audio selectors (AudioSelectors) to specify a track or set of tracks from the input that you will use in your outputs. You can use mutiple Audio selectors per input.
        public let audioSelectors: [String: AudioSelector]?
        /// Enable the Image inserter (ImageInserter) feature to include a graphic overlay on your video. Enable or disable this feature for each input individually. This setting is disabled by default.
        public let imageInserter: ImageInserter?
        /// Use Captions selectors (CaptionSelectors) to specify the captions data from the input that you will use in your outputs. You can use mutiple captions selectors per input.
        public let captionSelectors: [String: CaptionSelector]?
        public let denoiseFilter: InputDenoiseFilter?
        public let psiControl: InputPsiControl?

        public init(programNumber: Int32? = nil, filterStrength: Int32? = nil, inputClippings: [InputClipping]? = nil, timecodeSource: InputTimecodeSource? = nil, deblockFilter: InputDeblockFilter? = nil, filterEnable: InputFilterEnable? = nil, videoSelector: VideoSelector? = nil, audioSelectorGroups: [String: AudioSelectorGroup]? = nil, audioSelectors: [String: AudioSelector]? = nil, imageInserter: ImageInserter? = nil, captionSelectors: [String: CaptionSelector]? = nil, denoiseFilter: InputDenoiseFilter? = nil, psiControl: InputPsiControl? = nil) {
            self.programNumber = programNumber
            self.filterStrength = filterStrength
            self.inputClippings = inputClippings
            self.timecodeSource = timecodeSource
            self.deblockFilter = deblockFilter
            self.filterEnable = filterEnable
            self.videoSelector = videoSelector
            self.audioSelectorGroups = audioSelectorGroups
            self.audioSelectors = audioSelectors
            self.imageInserter = imageInserter
            self.captionSelectors = captionSelectors
            self.denoiseFilter = denoiseFilter
            self.psiControl = psiControl
        }

        private enum CodingKeys: String, CodingKey {
            case programNumber = "programNumber"
            case filterStrength = "filterStrength"
            case inputClippings = "inputClippings"
            case timecodeSource = "timecodeSource"
            case deblockFilter = "deblockFilter"
            case filterEnable = "filterEnable"
            case videoSelector = "videoSelector"
            case audioSelectorGroups = "audioSelectorGroups"
            case audioSelectors = "audioSelectors"
            case imageInserter = "imageInserter"
            case captionSelectors = "captionSelectors"
            case denoiseFilter = "denoiseFilter"
            case psiControl = "psiControl"
        }
    }

    public enum M2tsSegmentationMarkers: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case raiSegstart = "RAI_SEGSTART"
        case raiAdapt = "RAI_ADAPT"
        case psiSegstart = "PSI_SEGSTART"
        case ebp = "EBP"
        case ebpLegacy = "EBP_LEGACY"
        public var description: String { return self.rawValue }
    }

    public enum H264ParControl: String, CustomStringConvertible, Codable {
        case initializeFromSource = "INITIALIZE_FROM_SOURCE"
        case specified = "SPECIFIED"
        public var description: String { return self.rawValue }
    }

    public enum AudioNormalizationAlgorithm: String, CustomStringConvertible, Codable {
        case ituBs17701 = "ITU_BS_1770_1"
        case ituBs17702 = "ITU_BS_1770_2"
        public var description: String { return self.rawValue }
    }

    public struct DvbSubSourceSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Pid", location: .body(locationName: "pid"), required: false, type: .integer)
        ]
        /// When using DVB-Sub with Burn-In or SMPTE-TT, use this PID for the source content. Unused for DVB-Sub passthrough. All DVB-Sub content is passed through, regardless of selectors.
        public let pid: Int32?

        public init(pid: Int32? = nil) {
            self.pid = pid
        }

        private enum CodingKeys: String, CodingKey {
            case pid = "pid"
        }
    }

    public struct UpdateQueueRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", location: .uri(locationName: "name"), required: true, type: .string), 
            AWSShapeMember(label: "Status", location: .body(locationName: "status"), required: false, type: .enum), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "ReservationPlanSettings", location: .body(locationName: "reservationPlanSettings"), required: false, type: .structure)
        ]
        /// The name of the queue that you are modifying.
        public let name: String
        /// Pause or activate a queue by changing its status between ACTIVE and PAUSED. If you pause a queue, jobs in that queue won't begin. Jobs that are running when you pause the queue continue to run until they finish or result in an error.
        public let status: QueueStatus?
        /// The new description for the queue, if you are changing it.
        public let description: String?
        /// The new details of your pricing plan for your reserved queue. When you set up a new pricing plan to replace an expired one, you enter into another 12-month commitment. When you add capacity to your queue by increasing the number of RTS, you extend the term of your commitment to 12 months from when you add capacity. After you make these commitments, you can't cancel them.
        public let reservationPlanSettings: ReservationPlanSettings?

        public init(name: String, status: QueueStatus? = nil, description: String? = nil, reservationPlanSettings: ReservationPlanSettings? = nil) {
            self.name = name
            self.status = status
            self.description = description
            self.reservationPlanSettings = reservationPlanSettings
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case status = "status"
            case description = "description"
            case reservationPlanSettings = "reservationPlanSettings"
        }
    }

    public enum H264RepeatPps: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct DisassociateCertificateRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: true, type: .string)
        ]
        /// The ARN of the ACM certificate that you want to disassociate from your MediaConvert resource.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public enum AudioNormalizationPeakCalculation: String, CustomStringConvertible, Codable {
        case truePeak = "TRUE_PEAK"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum CmafKeyProviderType: String, CustomStringConvertible, Codable {
        case staticKey = "STATIC_KEY"
        public var description: String { return self.rawValue }
    }

    public struct DashIsoEncryptionSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SpekeKeyProvider", location: .body(locationName: "spekeKeyProvider"), required: false, type: .structure)
        ]
        public let spekeKeyProvider: SpekeKeyProvider?

        public init(spekeKeyProvider: SpekeKeyProvider? = nil) {
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case spekeKeyProvider = "spekeKeyProvider"
        }
    }

    public struct GetJobTemplateRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", location: .uri(locationName: "name"), required: true, type: .string)
        ]
        /// The name of the job template.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public enum H265RateControlMode: String, CustomStringConvertible, Codable {
        case vbr = "VBR"
        case cbr = "CBR"
        case qvbr = "QVBR"
        public var description: String { return self.rawValue }
    }

    public struct VideoSelector: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ColorSpace", location: .body(locationName: "colorSpace"), required: false, type: .enum), 
            AWSShapeMember(label: "ProgramNumber", location: .body(locationName: "programNumber"), required: false, type: .integer), 
            AWSShapeMember(label: "Hdr10Metadata", location: .body(locationName: "hdr10Metadata"), required: false, type: .structure), 
            AWSShapeMember(label: "ColorSpaceUsage", location: .body(locationName: "colorSpaceUsage"), required: false, type: .enum), 
            AWSShapeMember(label: "Pid", location: .body(locationName: "pid"), required: false, type: .integer)
        ]
        public let colorSpace: ColorSpace?
        /// Selects a specific program from within a multi-program transport stream. Note that Quad 4K is not currently supported.
        public let programNumber: Int32?
        public let hdr10Metadata: Hdr10Metadata?
        public let colorSpaceUsage: ColorSpaceUsage?
        /// Use PID (Pid) to select specific video data from an input file. Specify this value as an integer; the system automatically converts it to the hexidecimal value. For example, 257 selects PID 0x101. A PID, or packet identifier, is an identifier for a set of data in an MPEG-2 transport stream container.
        public let pid: Int32?

        public init(colorSpace: ColorSpace? = nil, programNumber: Int32? = nil, hdr10Metadata: Hdr10Metadata? = nil, colorSpaceUsage: ColorSpaceUsage? = nil, pid: Int32? = nil) {
            self.colorSpace = colorSpace
            self.programNumber = programNumber
            self.hdr10Metadata = hdr10Metadata
            self.colorSpaceUsage = colorSpaceUsage
            self.pid = pid
        }

        private enum CodingKeys: String, CodingKey {
            case colorSpace = "colorSpace"
            case programNumber = "programNumber"
            case hdr10Metadata = "hdr10Metadata"
            case colorSpaceUsage = "colorSpaceUsage"
            case pid = "pid"
        }
    }

    public struct StaticKeyProvider: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StaticKeyValue", location: .body(locationName: "staticKeyValue"), required: false, type: .string), 
            AWSShapeMember(label: "Url", location: .body(locationName: "url"), required: false, type: .string), 
            AWSShapeMember(label: "KeyFormat", location: .body(locationName: "keyFormat"), required: false, type: .string), 
            AWSShapeMember(label: "KeyFormatVersions", location: .body(locationName: "keyFormatVersions"), required: false, type: .string)
        ]
        /// Relates to DRM implementation. Use a 32-character hexidecimal string to specify Key Value (StaticKeyValue).
        public let staticKeyValue: String?
        /// Relates to DRM implementation. The location of the license server used for protecting content.
        public let url: String?
        /// Relates to DRM implementation. Sets the value of the KEYFORMAT attribute. Must be 'identity' or a reverse DNS string. May be omitted to indicate an implicit value of 'identity'.
        public let keyFormat: String?
        /// Relates to DRM implementation. Either a single positive integer version value or a slash delimited list of version values (1/2/3).
        public let keyFormatVersions: String?

        public init(staticKeyValue: String? = nil, url: String? = nil, keyFormat: String? = nil, keyFormatVersions: String? = nil) {
            self.staticKeyValue = staticKeyValue
            self.url = url
            self.keyFormat = keyFormat
            self.keyFormatVersions = keyFormatVersions
        }

        private enum CodingKeys: String, CodingKey {
            case staticKeyValue = "staticKeyValue"
            case url = "url"
            case keyFormat = "keyFormat"
            case keyFormatVersions = "keyFormatVersions"
        }
    }

    public struct Preset: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: true, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "CreatedAt", location: .body(locationName: "createdAt"), required: false, type: .timestamp), 
            AWSShapeMember(label: "Type", location: .body(locationName: "type"), required: false, type: .enum), 
            AWSShapeMember(label: "LastUpdated", location: .body(locationName: "lastUpdated"), required: false, type: .timestamp), 
            AWSShapeMember(label: "Settings", location: .body(locationName: "settings"), required: true, type: .structure), 
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "Category", location: .body(locationName: "category"), required: false, type: .string)
        ]
        /// A name you create for each preset. Each name must be unique within your account.
        public let name: String
        /// An optional description you create for each preset.
        public let description: String?
        /// The timestamp in epoch seconds for preset creation.
        public let createdAt: TimeStamp?
        /// A preset can be of two types: system or custom. System or built-in preset can't be modified or deleted by the user.
        public let `type`: `Type`?
        /// The timestamp in epoch seconds when the preset was last updated.
        public let lastUpdated: TimeStamp?
        public let settings: PresetSettings
        /// An identifier for this resource that is unique within all of AWS.
        public let arn: String?
        /// An optional category you create to organize your presets.
        public let category: String?

        public init(name: String, description: String? = nil, createdAt: TimeStamp? = nil, type: `Type`? = nil, lastUpdated: TimeStamp? = nil, settings: PresetSettings, arn: String? = nil, category: String? = nil) {
            self.name = name
            self.description = description
            self.createdAt = createdAt
            self.`type` = `type`
            self.lastUpdated = lastUpdated
            self.settings = settings
            self.arn = arn
            self.category = category
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case description = "description"
            case createdAt = "createdAt"
            case `type` = "type"
            case lastUpdated = "lastUpdated"
            case settings = "settings"
            case arn = "arn"
            case category = "category"
        }
    }

    public enum F4vMoovPlacement: String, CustomStringConvertible, Codable {
        case progressiveDownload = "PROGRESSIVE_DOWNLOAD"
        case normal = "NORMAL"
        public var description: String { return self.rawValue }
    }

    public struct Timing: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FinishTime", location: .body(locationName: "finishTime"), required: false, type: .timestamp), 
            AWSShapeMember(label: "SubmitTime", location: .body(locationName: "submitTime"), required: false, type: .timestamp), 
            AWSShapeMember(label: "StartTime", location: .body(locationName: "startTime"), required: false, type: .timestamp)
        ]
        /// The time, in Unix epoch format, that the transcoding job finished
        public let finishTime: TimeStamp?
        /// The time, in Unix epoch format, that you submitted the job.
        public let submitTime: TimeStamp?
        /// The time, in Unix epoch format, that transcoding for the job began.
        public let startTime: TimeStamp?

        public init(finishTime: TimeStamp? = nil, submitTime: TimeStamp? = nil, startTime: TimeStamp? = nil) {
            self.finishTime = finishTime
            self.submitTime = submitTime
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case finishTime = "finishTime"
            case submitTime = "submitTime"
            case startTime = "startTime"
        }
    }

    public enum Eac3PhaseControl: String, CustomStringConvertible, Codable {
        case shift90Degrees = "SHIFT_90_DEGREES"
        case noShift = "NO_SHIFT"
        public var description: String { return self.rawValue }
    }

    public struct CreateJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClientRequestToken", location: .body(locationName: "clientRequestToken"), required: false, type: .string), 
            AWSShapeMember(label: "UserMetadata", location: .body(locationName: "userMetadata"), required: false, type: .map), 
            AWSShapeMember(label: "Queue", location: .body(locationName: "queue"), required: false, type: .string), 
            AWSShapeMember(label: "Settings", location: .body(locationName: "settings"), required: true, type: .structure), 
            AWSShapeMember(label: "JobTemplate", location: .body(locationName: "jobTemplate"), required: false, type: .string), 
            AWSShapeMember(label: "BillingTagsSource", location: .body(locationName: "billingTagsSource"), required: false, type: .enum), 
            AWSShapeMember(label: "Role", location: .body(locationName: "role"), required: true, type: .string)
        ]
        /// Idempotency token for CreateJob operation.
        public let clientRequestToken: String?
        /// User-defined metadata that you want to associate with an MediaConvert job. You specify metadata in key/value pairs.
        public let userMetadata: [String: String]?
        /// Optional. When you create a job, you can specify a queue to send it to. If you don't specify, the job will go to the default queue. For more about queues, see the User Guide topic at http://docs.aws.amazon.com/mediaconvert/latest/ug/what-is.html.
        public let queue: String?
        public let settings: JobSettings
        /// When you create a job, you can either specify a job template or specify the transcoding settings individually
        public let jobTemplate: String?
        public let billingTagsSource: BillingTagsSource?
        /// Required. The IAM role you use for creating this job. For details about permissions, see the User Guide topic at the User Guide at http://docs.aws.amazon.com/mediaconvert/latest/ug/iam-role.html.
        public let role: String

        public init(clientRequestToken: String? = nil, userMetadata: [String: String]? = nil, queue: String? = nil, settings: JobSettings, jobTemplate: String? = nil, billingTagsSource: BillingTagsSource? = nil, role: String) {
            self.clientRequestToken = clientRequestToken
            self.userMetadata = userMetadata
            self.queue = queue
            self.settings = settings
            self.jobTemplate = jobTemplate
            self.billingTagsSource = billingTagsSource
            self.role = role
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "clientRequestToken"
            case userMetadata = "userMetadata"
            case queue = "queue"
            case settings = "settings"
            case jobTemplate = "jobTemplate"
            case billingTagsSource = "billingTagsSource"
            case role = "role"
        }
    }

    public struct CreateJobTemplateResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobTemplate", location: .body(locationName: "jobTemplate"), required: false, type: .structure)
        ]
        public let jobTemplate: JobTemplate?

        public init(jobTemplate: JobTemplate? = nil) {
            self.jobTemplate = jobTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case jobTemplate = "jobTemplate"
        }
    }

    public enum TtmlStylePassthrough: String, CustomStringConvertible, Codable {
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public enum M2tsEsRateInPes: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public enum ReservationPlanStatus: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case expired = "EXPIRED"
        public var description: String { return self.rawValue }
    }

    public enum AacCodingMode: String, CustomStringConvertible, Codable {
        case adReceiverMix = "AD_RECEIVER_MIX"
        case codingMode10 = "CODING_MODE_1_0"
        case codingMode11 = "CODING_MODE_1_1"
        case codingMode20 = "CODING_MODE_2_0"
        case codingMode51 = "CODING_MODE_5_1"
        public var description: String { return self.rawValue }
    }

    public enum ProresParControl: String, CustomStringConvertible, Codable {
        case initializeFromSource = "INITIALIZE_FROM_SOURCE"
        case specified = "SPECIFIED"
        public var description: String { return self.rawValue }
    }

    public enum Mpeg2DynamicSubGop: String, CustomStringConvertible, Codable {
        case adaptive = "ADAPTIVE"
        case `static` = "STATIC"
        public var description: String { return self.rawValue }
    }

    public struct ListPresetsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "Presets", location: .body(locationName: "presets"), required: false, type: .list)
        ]
        /// Use this string to request the next batch of presets.
        public let nextToken: String?
        /// List of presets
        public let presets: [Preset]?

        public init(nextToken: String? = nil, presets: [Preset]? = nil) {
            self.nextToken = nextToken
            self.presets = presets
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case presets = "presets"
        }
    }

    public enum H265Telecine: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case soft = "SOFT"
        case hard = "HARD"
        public var description: String { return self.rawValue }
    }

    public struct TimedMetadataInsertion: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id3Insertions", location: .body(locationName: "id3Insertions"), required: false, type: .list)
        ]
        /// Id3Insertions contains the array of Id3Insertion instances.
        public let id3Insertions: [Id3Insertion]?

        public init(id3Insertions: [Id3Insertion]? = nil) {
            self.id3Insertions = id3Insertions
        }

        private enum CodingKeys: String, CodingKey {
            case id3Insertions = "id3Insertions"
        }
    }

    public enum AudioLanguageCodeControl: String, CustomStringConvertible, Codable {
        case followInput = "FOLLOW_INPUT"
        case useConfigured = "USE_CONFIGURED"
        public var description: String { return self.rawValue }
    }

    public enum H265Tiles: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum HlsManifestDurationFormat: String, CustomStringConvertible, Codable {
        case floatingPoint = "FLOATING_POINT"
        case integer = "INTEGER"
        public var description: String { return self.rawValue }
    }

    public struct Mpeg2Settings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Syntax", location: .body(locationName: "syntax"), required: false, type: .enum), 
            AWSShapeMember(label: "AdaptiveQuantization", location: .body(locationName: "adaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "InterlaceMode", location: .body(locationName: "interlaceMode"), required: false, type: .enum), 
            AWSShapeMember(label: "TemporalAdaptiveQuantization", location: .body(locationName: "temporalAdaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "CodecLevel", location: .body(locationName: "codecLevel"), required: false, type: .enum), 
            AWSShapeMember(label: "HrdBufferInitialFillPercentage", location: .body(locationName: "hrdBufferInitialFillPercentage"), required: false, type: .integer), 
            AWSShapeMember(label: "MaxBitrate", location: .body(locationName: "maxBitrate"), required: false, type: .integer), 
            AWSShapeMember(label: "GopSize", location: .body(locationName: "gopSize"), required: false, type: .double), 
            AWSShapeMember(label: "Telecine", location: .body(locationName: "telecine"), required: false, type: .enum), 
            AWSShapeMember(label: "DynamicSubGop", location: .body(locationName: "dynamicSubGop"), required: false, type: .enum), 
            AWSShapeMember(label: "RateControlMode", location: .body(locationName: "rateControlMode"), required: false, type: .enum), 
            AWSShapeMember(label: "SlowPal", location: .body(locationName: "slowPal"), required: false, type: .enum), 
            AWSShapeMember(label: "MinIInterval", location: .body(locationName: "minIInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "FramerateControl", location: .body(locationName: "framerateControl"), required: false, type: .enum), 
            AWSShapeMember(label: "FramerateDenominator", location: .body(locationName: "framerateDenominator"), required: false, type: .integer), 
            AWSShapeMember(label: "IntraDcPrecision", location: .body(locationName: "intraDcPrecision"), required: false, type: .enum), 
            AWSShapeMember(label: "ParControl", location: .body(locationName: "parControl"), required: false, type: .enum), 
            AWSShapeMember(label: "GopSizeUnits", location: .body(locationName: "gopSizeUnits"), required: false, type: .enum), 
            AWSShapeMember(label: "Softness", location: .body(locationName: "softness"), required: false, type: .integer), 
            AWSShapeMember(label: "ParDenominator", location: .body(locationName: "parDenominator"), required: false, type: .integer), 
            AWSShapeMember(label: "ParNumerator", location: .body(locationName: "parNumerator"), required: false, type: .integer), 
            AWSShapeMember(label: "QualityTuningLevel", location: .body(locationName: "qualityTuningLevel"), required: false, type: .enum), 
            AWSShapeMember(label: "NumberBFramesBetweenReferenceFrames", location: .body(locationName: "numberBFramesBetweenReferenceFrames"), required: false, type: .integer), 
            AWSShapeMember(label: "GopClosedCadence", location: .body(locationName: "gopClosedCadence"), required: false, type: .integer), 
            AWSShapeMember(label: "FramerateNumerator", location: .body(locationName: "framerateNumerator"), required: false, type: .integer), 
            AWSShapeMember(label: "FramerateConversionAlgorithm", location: .body(locationName: "framerateConversionAlgorithm"), required: false, type: .enum), 
            AWSShapeMember(label: "HrdBufferSize", location: .body(locationName: "hrdBufferSize"), required: false, type: .integer), 
            AWSShapeMember(label: "Bitrate", location: .body(locationName: "bitrate"), required: false, type: .integer), 
            AWSShapeMember(label: "SpatialAdaptiveQuantization", location: .body(locationName: "spatialAdaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "CodecProfile", location: .body(locationName: "codecProfile"), required: false, type: .enum), 
            AWSShapeMember(label: "SceneChangeDetect", location: .body(locationName: "sceneChangeDetect"), required: false, type: .enum)
        ]
        public let syntax: Mpeg2Syntax?
        public let adaptiveQuantization: Mpeg2AdaptiveQuantization?
        public let interlaceMode: Mpeg2InterlaceMode?
        public let temporalAdaptiveQuantization: Mpeg2TemporalAdaptiveQuantization?
        public let codecLevel: Mpeg2CodecLevel?
        /// Percentage of the buffer that should initially be filled (HRD buffer model).
        public let hrdBufferInitialFillPercentage: Int32?
        /// Maximum bitrate in bits/second. For example, enter five megabits per second as 5000000.
        public let maxBitrate: Int32?
        /// GOP Length (keyframe interval) in frames or seconds. Must be greater than zero.
        public let gopSize: Double?
        public let telecine: Mpeg2Telecine?
        /// Choose Adaptive to improve subjective video quality for high-motion content. This will cause the service to use fewer B-frames (which infer information based on other frames) for high-motion portions of the video and more B-frames for low-motion portions. The maximum number of B-frames is limited by the value you provide for the setting B frames between reference frames (numberBFramesBetweenReferenceFrames).
        public let dynamicSubGop: Mpeg2DynamicSubGop?
        public let rateControlMode: Mpeg2RateControlMode?
        public let slowPal: Mpeg2SlowPal?
        /// Enforces separation between repeated (cadence) I-frames and I-frames inserted by Scene Change Detection. If a scene change I-frame is within I-interval frames of a cadence I-frame, the GOP is shrunk and/or stretched to the scene change I-frame. GOP stretch requires enabling lookahead as well as setting I-interval. The normal cadence resumes for the next GOP. This setting is only used when Scene Change Detect is enabled. Note: Maximum GOP stretch = GOP size + Min-I-interval - 1
        public let minIInterval: Int32?
        public let framerateControl: Mpeg2FramerateControl?
        /// Framerate denominator.
        public let framerateDenominator: Int32?
        public let intraDcPrecision: Mpeg2IntraDcPrecision?
        public let parControl: Mpeg2ParControl?
        public let gopSizeUnits: Mpeg2GopSizeUnits?
        /// Softness. Selects quantizer matrix, larger values reduce high-frequency content in the encoded image.
        public let softness: Int32?
        /// Pixel Aspect Ratio denominator.
        public let parDenominator: Int32?
        /// Pixel Aspect Ratio numerator.
        public let parNumerator: Int32?
        public let qualityTuningLevel: Mpeg2QualityTuningLevel?
        /// Number of B-frames between reference frames.
        public let numberBFramesBetweenReferenceFrames: Int32?
        /// Frequency of closed GOPs. In streaming applications, it is recommended that this be set to 1 so a decoder joining mid-stream will receive an IDR frame as quickly as possible. Setting this value to 0 will break output segmenting.
        public let gopClosedCadence: Int32?
        /// Framerate numerator - framerate is a fraction, e.g. 24000 / 1001 = 23.976 fps.
        public let framerateNumerator: Int32?
        public let framerateConversionAlgorithm: Mpeg2FramerateConversionAlgorithm?
        /// Size of buffer (HRD buffer model) in bits. For example, enter five megabits as 5000000.
        public let hrdBufferSize: Int32?
        /// Average bitrate in bits/second. Required for VBR and CBR. For MS Smooth outputs, bitrates must be unique when rounded down to the nearest multiple of 1000.
        public let bitrate: Int32?
        public let spatialAdaptiveQuantization: Mpeg2SpatialAdaptiveQuantization?
        public let codecProfile: Mpeg2CodecProfile?
        public let sceneChangeDetect: Mpeg2SceneChangeDetect?

        public init(syntax: Mpeg2Syntax? = nil, adaptiveQuantization: Mpeg2AdaptiveQuantization? = nil, interlaceMode: Mpeg2InterlaceMode? = nil, temporalAdaptiveQuantization: Mpeg2TemporalAdaptiveQuantization? = nil, codecLevel: Mpeg2CodecLevel? = nil, hrdBufferInitialFillPercentage: Int32? = nil, maxBitrate: Int32? = nil, gopSize: Double? = nil, telecine: Mpeg2Telecine? = nil, dynamicSubGop: Mpeg2DynamicSubGop? = nil, rateControlMode: Mpeg2RateControlMode? = nil, slowPal: Mpeg2SlowPal? = nil, minIInterval: Int32? = nil, framerateControl: Mpeg2FramerateControl? = nil, framerateDenominator: Int32? = nil, intraDcPrecision: Mpeg2IntraDcPrecision? = nil, parControl: Mpeg2ParControl? = nil, gopSizeUnits: Mpeg2GopSizeUnits? = nil, softness: Int32? = nil, parDenominator: Int32? = nil, parNumerator: Int32? = nil, qualityTuningLevel: Mpeg2QualityTuningLevel? = nil, numberBFramesBetweenReferenceFrames: Int32? = nil, gopClosedCadence: Int32? = nil, framerateNumerator: Int32? = nil, framerateConversionAlgorithm: Mpeg2FramerateConversionAlgorithm? = nil, hrdBufferSize: Int32? = nil, bitrate: Int32? = nil, spatialAdaptiveQuantization: Mpeg2SpatialAdaptiveQuantization? = nil, codecProfile: Mpeg2CodecProfile? = nil, sceneChangeDetect: Mpeg2SceneChangeDetect? = nil) {
            self.syntax = syntax
            self.adaptiveQuantization = adaptiveQuantization
            self.interlaceMode = interlaceMode
            self.temporalAdaptiveQuantization = temporalAdaptiveQuantization
            self.codecLevel = codecLevel
            self.hrdBufferInitialFillPercentage = hrdBufferInitialFillPercentage
            self.maxBitrate = maxBitrate
            self.gopSize = gopSize
            self.telecine = telecine
            self.dynamicSubGop = dynamicSubGop
            self.rateControlMode = rateControlMode
            self.slowPal = slowPal
            self.minIInterval = minIInterval
            self.framerateControl = framerateControl
            self.framerateDenominator = framerateDenominator
            self.intraDcPrecision = intraDcPrecision
            self.parControl = parControl
            self.gopSizeUnits = gopSizeUnits
            self.softness = softness
            self.parDenominator = parDenominator
            self.parNumerator = parNumerator
            self.qualityTuningLevel = qualityTuningLevel
            self.numberBFramesBetweenReferenceFrames = numberBFramesBetweenReferenceFrames
            self.gopClosedCadence = gopClosedCadence
            self.framerateNumerator = framerateNumerator
            self.framerateConversionAlgorithm = framerateConversionAlgorithm
            self.hrdBufferSize = hrdBufferSize
            self.bitrate = bitrate
            self.spatialAdaptiveQuantization = spatialAdaptiveQuantization
            self.codecProfile = codecProfile
            self.sceneChangeDetect = sceneChangeDetect
        }

        private enum CodingKeys: String, CodingKey {
            case syntax = "syntax"
            case adaptiveQuantization = "adaptiveQuantization"
            case interlaceMode = "interlaceMode"
            case temporalAdaptiveQuantization = "temporalAdaptiveQuantization"
            case codecLevel = "codecLevel"
            case hrdBufferInitialFillPercentage = "hrdBufferInitialFillPercentage"
            case maxBitrate = "maxBitrate"
            case gopSize = "gopSize"
            case telecine = "telecine"
            case dynamicSubGop = "dynamicSubGop"
            case rateControlMode = "rateControlMode"
            case slowPal = "slowPal"
            case minIInterval = "minIInterval"
            case framerateControl = "framerateControl"
            case framerateDenominator = "framerateDenominator"
            case intraDcPrecision = "intraDcPrecision"
            case parControl = "parControl"
            case gopSizeUnits = "gopSizeUnits"
            case softness = "softness"
            case parDenominator = "parDenominator"
            case parNumerator = "parNumerator"
            case qualityTuningLevel = "qualityTuningLevel"
            case numberBFramesBetweenReferenceFrames = "numberBFramesBetweenReferenceFrames"
            case gopClosedCadence = "gopClosedCadence"
            case framerateNumerator = "framerateNumerator"
            case framerateConversionAlgorithm = "framerateConversionAlgorithm"
            case hrdBufferSize = "hrdBufferSize"
            case bitrate = "bitrate"
            case spatialAdaptiveQuantization = "spatialAdaptiveQuantization"
            case codecProfile = "codecProfile"
            case sceneChangeDetect = "sceneChangeDetect"
        }
    }

    public enum MsSmoothManifestEncoding: String, CustomStringConvertible, Codable {
        case utf8 = "UTF8"
        case utf16 = "UTF16"
        public var description: String { return self.rawValue }
    }

    public enum H264SlowPal: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum DecryptionMode: String, CustomStringConvertible, Codable {
        case aesCtr = "AES_CTR"
        case aesCbc = "AES_CBC"
        case aesGcm = "AES_GCM"
        public var description: String { return self.rawValue }
    }

    public enum TimedMetadata: String, CustomStringConvertible, Codable {
        case passthrough = "PASSTHROUGH"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public struct DeletePresetResponse: AWSShape {

    }

    public enum AacVbrQuality: String, CustomStringConvertible, Codable {
        case low = "LOW"
        case mediumLow = "MEDIUM_LOW"
        case mediumHigh = "MEDIUM_HIGH"
        case high = "HIGH"
        public var description: String { return self.rawValue }
    }

    public enum NoiseReducerFilter: String, CustomStringConvertible, Codable {
        case bilateral = "BILATERAL"
        case mean = "MEAN"
        case gaussian = "GAUSSIAN"
        case lanczos = "LANCZOS"
        case sharpen = "SHARPEN"
        case conserve = "CONSERVE"
        case spatial = "SPATIAL"
        public var description: String { return self.rawValue }
    }

    public enum H265SpatialAdaptiveQuantization: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct UpdateJobTemplateRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", location: .uri(locationName: "name"), required: true, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "Category", location: .body(locationName: "category"), required: false, type: .string), 
            AWSShapeMember(label: "Queue", location: .body(locationName: "queue"), required: false, type: .string), 
            AWSShapeMember(label: "Settings", location: .body(locationName: "settings"), required: false, type: .structure)
        ]
        /// The name of the job template you are modifying
        public let name: String
        /// The new description for the job template, if you are changing it.
        public let description: String?
        /// The new category for the job template, if you are changing it.
        public let category: String?
        /// The new queue for the job template, if you are changing it.
        public let queue: String?
        public let settings: JobTemplateSettings?

        public init(name: String, description: String? = nil, category: String? = nil, queue: String? = nil, settings: JobTemplateSettings? = nil) {
            self.name = name
            self.description = description
            self.category = category
            self.queue = queue
            self.settings = settings
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case description = "description"
            case category = "category"
            case queue = "queue"
            case settings = "settings"
        }
    }

    public enum MovMpeg2FourCCControl: String, CustomStringConvertible, Codable {
        case xdcam = "XDCAM"
        case mpeg = "MPEG"
        public var description: String { return self.rawValue }
    }

    public struct AssociateCertificateRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: true, type: .string)
        ]
        /// The ARN of the ACM certificate that you want to associate with your MediaConvert resource.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public enum CaptionSourceType: String, CustomStringConvertible, Codable {
        case ancillary = "ANCILLARY"
        case dvbSub = "DVB_SUB"
        case embedded = "EMBEDDED"
        case scte20 = "SCTE20"
        case scc = "SCC"
        case ttml = "TTML"
        case stl = "STL"
        case srt = "SRT"
        case smi = "SMI"
        case teletext = "TELETEXT"
        case nullSource = "NULL_SOURCE"
        public var description: String { return self.rawValue }
    }

    public struct DvbSubDestinationSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FontSize", location: .body(locationName: "fontSize"), required: false, type: .integer), 
            AWSShapeMember(label: "XPosition", location: .body(locationName: "xPosition"), required: false, type: .integer), 
            AWSShapeMember(label: "FontResolution", location: .body(locationName: "fontResolution"), required: false, type: .integer), 
            AWSShapeMember(label: "ShadowOpacity", location: .body(locationName: "shadowOpacity"), required: false, type: .integer), 
            AWSShapeMember(label: "Alignment", location: .body(locationName: "alignment"), required: false, type: .enum), 
            AWSShapeMember(label: "FontColor", location: .body(locationName: "fontColor"), required: false, type: .enum), 
            AWSShapeMember(label: "FontOpacity", location: .body(locationName: "fontOpacity"), required: false, type: .integer), 
            AWSShapeMember(label: "ShadowColor", location: .body(locationName: "shadowColor"), required: false, type: .enum), 
            AWSShapeMember(label: "BackgroundColor", location: .body(locationName: "backgroundColor"), required: false, type: .enum), 
            AWSShapeMember(label: "OutlineSize", location: .body(locationName: "outlineSize"), required: false, type: .integer), 
            AWSShapeMember(label: "ShadowXOffset", location: .body(locationName: "shadowXOffset"), required: false, type: .integer), 
            AWSShapeMember(label: "YPosition", location: .body(locationName: "yPosition"), required: false, type: .integer), 
            AWSShapeMember(label: "TeletextSpacing", location: .body(locationName: "teletextSpacing"), required: false, type: .enum), 
            AWSShapeMember(label: "BackgroundOpacity", location: .body(locationName: "backgroundOpacity"), required: false, type: .integer), 
            AWSShapeMember(label: "ShadowYOffset", location: .body(locationName: "shadowYOffset"), required: false, type: .integer), 
            AWSShapeMember(label: "OutlineColor", location: .body(locationName: "outlineColor"), required: false, type: .enum)
        ]
        /// A positive integer indicates the exact font size in points. Set to 0 for automatic font size selection. All burn-in and DVB-Sub font settings must match.
        public let fontSize: Int32?
        /// Specifies the horizontal position of the caption relative to the left side of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the left of the output. If no explicit x_position is provided, the horizontal caption position will be determined by the alignment parameter. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        public let xPosition: Int32?
        /// Font resolution in DPI (dots per inch); default is 96 dpi.
        /// All burn-in and DVB-Sub font settings must match.
        public let fontResolution: Int32?
        /// Specifies the opacity of the shadow. 255 is opaque; 0 is transparent. Leaving this parameter blank is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
        public let shadowOpacity: Int32?
        public let alignment: DvbSubtitleAlignment?
        public let fontColor: DvbSubtitleFontColor?
        /// Specifies the opacity of the burned-in captions. 255 is opaque; 0 is transparent.
        /// All burn-in and DVB-Sub font settings must match.
        public let fontOpacity: Int32?
        public let shadowColor: DvbSubtitleShadowColor?
        public let backgroundColor: DvbSubtitleBackgroundColor?
        /// Specifies font outline size in pixels. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        public let outlineSize: Int32?
        /// Specifies the horizontal offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels to the left. All burn-in and DVB-Sub font settings must match.
        public let shadowXOffset: Int32?
        /// Specifies the vertical position of the caption relative to the top of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the top of the output. If no explicit y_position is provided, the caption will be positioned towards the bottom of the output. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        public let yPosition: Int32?
        public let teletextSpacing: DvbSubtitleTeletextSpacing?
        /// Specifies the opacity of the background rectangle. 255 is opaque; 0 is transparent. Leaving this parameter blank is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
        public let backgroundOpacity: Int32?
        /// Specifies the vertical offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels above the text. All burn-in and DVB-Sub font settings must match.
        public let shadowYOffset: Int32?
        public let outlineColor: DvbSubtitleOutlineColor?

        public init(fontSize: Int32? = nil, xPosition: Int32? = nil, fontResolution: Int32? = nil, shadowOpacity: Int32? = nil, alignment: DvbSubtitleAlignment? = nil, fontColor: DvbSubtitleFontColor? = nil, fontOpacity: Int32? = nil, shadowColor: DvbSubtitleShadowColor? = nil, backgroundColor: DvbSubtitleBackgroundColor? = nil, outlineSize: Int32? = nil, shadowXOffset: Int32? = nil, yPosition: Int32? = nil, teletextSpacing: DvbSubtitleTeletextSpacing? = nil, backgroundOpacity: Int32? = nil, shadowYOffset: Int32? = nil, outlineColor: DvbSubtitleOutlineColor? = nil) {
            self.fontSize = fontSize
            self.xPosition = xPosition
            self.fontResolution = fontResolution
            self.shadowOpacity = shadowOpacity
            self.alignment = alignment
            self.fontColor = fontColor
            self.fontOpacity = fontOpacity
            self.shadowColor = shadowColor
            self.backgroundColor = backgroundColor
            self.outlineSize = outlineSize
            self.shadowXOffset = shadowXOffset
            self.yPosition = yPosition
            self.teletextSpacing = teletextSpacing
            self.backgroundOpacity = backgroundOpacity
            self.shadowYOffset = shadowYOffset
            self.outlineColor = outlineColor
        }

        private enum CodingKeys: String, CodingKey {
            case fontSize = "fontSize"
            case xPosition = "xPosition"
            case fontResolution = "fontResolution"
            case shadowOpacity = "shadowOpacity"
            case alignment = "alignment"
            case fontColor = "fontColor"
            case fontOpacity = "fontOpacity"
            case shadowColor = "shadowColor"
            case backgroundColor = "backgroundColor"
            case outlineSize = "outlineSize"
            case shadowXOffset = "shadowXOffset"
            case yPosition = "yPosition"
            case teletextSpacing = "teletextSpacing"
            case backgroundOpacity = "backgroundOpacity"
            case shadowYOffset = "shadowYOffset"
            case outlineColor = "outlineColor"
        }
    }

    public enum JobTemplateListBy: String, CustomStringConvertible, Codable {
        case name = "NAME"
        case creationDate = "CREATION_DATE"
        case system = "SYSTEM"
        public var description: String { return self.rawValue }
    }

    public struct CaptionSelector: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LanguageCode", location: .body(locationName: "languageCode"), required: false, type: .enum), 
            AWSShapeMember(label: "SourceSettings", location: .body(locationName: "sourceSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "CustomLanguageCode", location: .body(locationName: "customLanguageCode"), required: false, type: .string)
        ]
        /// The specific language to extract from source. If input is SCTE-27, complete this field and/or PID to select the caption language to extract. If input is DVB-Sub and output is Burn-in or SMPTE-TT, complete this field and/or PID to select the caption language to extract. If input is DVB-Sub that is being passed through, omit this field (and PID field); there is no way to extract a specific language with pass-through captions.
        public let languageCode: LanguageCode?
        public let sourceSettings: CaptionSourceSettings?
        /// The specific language to extract from source, using the ISO 639-2 or ISO 639-3 three-letter language code. If input is SCTE-27, complete this field and/or PID to select the caption language to extract. If input is DVB-Sub and output is Burn-in or SMPTE-TT, complete this field and/or PID to select the caption language to extract. If input is DVB-Sub that is being passed through, omit this field (and PID field); there is no way to extract a specific language with pass-through captions.
        public let customLanguageCode: String?

        public init(languageCode: LanguageCode? = nil, sourceSettings: CaptionSourceSettings? = nil, customLanguageCode: String? = nil) {
            self.languageCode = languageCode
            self.sourceSettings = sourceSettings
            self.customLanguageCode = customLanguageCode
        }

        private enum CodingKeys: String, CodingKey {
            case languageCode = "languageCode"
            case sourceSettings = "sourceSettings"
            case customLanguageCode = "customLanguageCode"
        }
    }

    public enum Eac3MetadataControl: String, CustomStringConvertible, Codable {
        case followInput = "FOLLOW_INPUT"
        case useConfigured = "USE_CONFIGURED"
        public var description: String { return self.rawValue }
    }

    public enum CmafCodecSpecification: String, CustomStringConvertible, Codable {
        case rfc6381 = "RFC_6381"
        case rfc4281 = "RFC_4281"
        public var description: String { return self.rawValue }
    }

    public enum RenewalType: String, CustomStringConvertible, Codable {
        case autoRenew = "AUTO_RENEW"
        case expire = "EXPIRE"
        public var description: String { return self.rawValue }
    }

    public struct ChannelMapping: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "OutputChannels", location: .body(locationName: "outputChannels"), required: false, type: .list)
        ]
        /// List of output channels
        public let outputChannels: [OutputChannelMapping]?

        public init(outputChannels: [OutputChannelMapping]? = nil) {
            self.outputChannels = outputChannels
        }

        private enum CodingKeys: String, CodingKey {
            case outputChannels = "outputChannels"
        }
    }

    public struct CaptionDescription: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LanguageDescription", location: .body(locationName: "languageDescription"), required: false, type: .string), 
            AWSShapeMember(label: "LanguageCode", location: .body(locationName: "languageCode"), required: false, type: .enum), 
            AWSShapeMember(label: "CaptionSelectorName", location: .body(locationName: "captionSelectorName"), required: false, type: .string), 
            AWSShapeMember(label: "CustomLanguageCode", location: .body(locationName: "customLanguageCode"), required: false, type: .string), 
            AWSShapeMember(label: "DestinationSettings", location: .body(locationName: "destinationSettings"), required: false, type: .structure)
        ]
        /// Human readable information to indicate captions available for players (eg. English, or Spanish). Alphanumeric characters, spaces, and underscore are legal.
        public let languageDescription: String?
        /// Indicates the language of the caption output track.
        public let languageCode: LanguageCode?
        /// Specifies which "Caption Selector":#inputs-caption_selector to use from each input when generating captions. The name should be of the format "Caption Selector ", which denotes that the Nth Caption Selector will be used from each input.
        public let captionSelectorName: String?
        /// Indicates the language of the caption output track, using the ISO 639-2 or ISO 639-3 three-letter language code
        public let customLanguageCode: String?
        public let destinationSettings: CaptionDestinationSettings?

        public init(languageDescription: String? = nil, languageCode: LanguageCode? = nil, captionSelectorName: String? = nil, customLanguageCode: String? = nil, destinationSettings: CaptionDestinationSettings? = nil) {
            self.languageDescription = languageDescription
            self.languageCode = languageCode
            self.captionSelectorName = captionSelectorName
            self.customLanguageCode = customLanguageCode
            self.destinationSettings = destinationSettings
        }

        private enum CodingKeys: String, CodingKey {
            case languageDescription = "languageDescription"
            case languageCode = "languageCode"
            case captionSelectorName = "captionSelectorName"
            case customLanguageCode = "customLanguageCode"
            case destinationSettings = "destinationSettings"
        }
    }

    public enum MovPaddingControl: String, CustomStringConvertible, Codable {
        case omneon = "OMNEON"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public struct AssociateCertificateResponse: AWSShape {

    }

    public struct CreateQueueResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Queue", location: .body(locationName: "queue"), required: false, type: .structure)
        ]
        public let queue: Queue?

        public init(queue: Queue? = nil) {
            self.queue = queue
        }

        private enum CodingKeys: String, CodingKey {
            case queue = "queue"
        }
    }

    public enum Eac3SurroundExMode: String, CustomStringConvertible, Codable {
        case notIndicated = "NOT_INDICATED"
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public struct InputClipping: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StartTimecode", location: .body(locationName: "startTimecode"), required: false, type: .string), 
            AWSShapeMember(label: "EndTimecode", location: .body(locationName: "endTimecode"), required: false, type: .string)
        ]
        /// Set Start timecode (StartTimecode) to the beginning of the portion of the input you are clipping. The frame corresponding to the Start timecode value is included in the clip. Start timecode or End timecode may be left blank, but not both. Use the format HH:MM:SS:FF or HH:MM:SS;FF, where HH is the hour, MM is the minute, SS is the second, and FF is the frame number. When choosing this value, take into account your setting for Input timecode source. For example, if you have embedded timecodes that start at 01:00:00:00 and you want your clip to begin five minutes into the video, use 01:05:00:00.
        public let startTimecode: String?
        /// Set End timecode (EndTimecode) to the end of the portion of the input you are clipping. The frame corresponding to the End timecode value is included in the clip. Start timecode or End timecode may be left blank, but not both. Use the format HH:MM:SS:FF or HH:MM:SS;FF, where HH is the hour, MM is the minute, SS is the second, and FF is the frame number. When choosing this value, take into account your setting for timecode source under input settings (InputTimecodeSource). For example, if you have embedded timecodes that start at 01:00:00:00 and you want your clip to end six minutes into the video, use 01:06:00:00.
        public let endTimecode: String?

        public init(startTimecode: String? = nil, endTimecode: String? = nil) {
            self.startTimecode = startTimecode
            self.endTimecode = endTimecode
        }

        private enum CodingKeys: String, CodingKey {
            case startTimecode = "startTimecode"
            case endTimecode = "endTimecode"
        }
    }

    public struct ResourceTags: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map), 
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string)
        ]
        /// The tags for the resource.
        public let tags: [String: String]?
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?

        public init(tags: [String: String]? = nil, arn: String? = nil) {
            self.tags = tags
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
            case arn = "arn"
        }
    }

    public struct OutputGroup: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "OutputGroupSettings", location: .body(locationName: "outputGroupSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: false, type: .string), 
            AWSShapeMember(label: "CustomName", location: .body(locationName: "customName"), required: false, type: .string), 
            AWSShapeMember(label: "Outputs", location: .body(locationName: "outputs"), required: false, type: .list)
        ]
        public let outputGroupSettings: OutputGroupSettings?
        /// Name of the output group
        public let name: String?
        /// Use Custom Group Name (CustomName) to specify a name for the output group. This value is displayed on the console and can make your job settings JSON more human-readable. It does not affect your outputs. Use up to twelve characters that are either letters, numbers, spaces, or underscores.
        public let customName: String?
        /// This object holds groups of encoding settings, one group of settings per output.
        public let outputs: [Output]?

        public init(outputGroupSettings: OutputGroupSettings? = nil, name: String? = nil, customName: String? = nil, outputs: [Output]? = nil) {
            self.outputGroupSettings = outputGroupSettings
            self.name = name
            self.customName = customName
            self.outputs = outputs
        }

        private enum CodingKeys: String, CodingKey {
            case outputGroupSettings = "outputGroupSettings"
            case name = "name"
            case customName = "customName"
            case outputs = "outputs"
        }
    }

    public struct GetJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Job", location: .body(locationName: "job"), required: false, type: .structure)
        ]
        public let job: Job?

        public init(job: Job? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job = "job"
        }
    }

    public struct TtmlDestinationSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StylePassthrough", location: .body(locationName: "stylePassthrough"), required: false, type: .enum)
        ]
        public let stylePassthrough: TtmlStylePassthrough?

        public init(stylePassthrough: TtmlStylePassthrough? = nil) {
            self.stylePassthrough = stylePassthrough
        }

        private enum CodingKeys: String, CodingKey {
            case stylePassthrough = "stylePassthrough"
        }
    }

    public enum Mpeg2AdaptiveQuantization: String, CustomStringConvertible, Codable {
        case off = "OFF"
        case low = "LOW"
        case medium = "MEDIUM"
        case high = "HIGH"
        public var description: String { return self.rawValue }
    }

    public enum H265CodecLevel: String, CustomStringConvertible, Codable {
        case auto = "AUTO"
        case level1 = "LEVEL_1"
        case level2 = "LEVEL_2"
        case level21 = "LEVEL_2_1"
        case level3 = "LEVEL_3"
        case level31 = "LEVEL_3_1"
        case level4 = "LEVEL_4"
        case level41 = "LEVEL_4_1"
        case level5 = "LEVEL_5"
        case level51 = "LEVEL_5_1"
        case level52 = "LEVEL_5_2"
        case level6 = "LEVEL_6"
        case level61 = "LEVEL_6_1"
        case level62 = "LEVEL_6_2"
        public var description: String { return self.rawValue }
    }

    public enum Eac3PassthroughControl: String, CustomStringConvertible, Codable {
        case whenPossible = "WHEN_POSSIBLE"
        case noPassthrough = "NO_PASSTHROUGH"
        public var description: String { return self.rawValue }
    }

    public enum Mpeg2TemporalAdaptiveQuantization: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum H264UnregisteredSeiTimecode: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum H265AdaptiveQuantization: String, CustomStringConvertible, Codable {
        case off = "OFF"
        case low = "LOW"
        case medium = "MEDIUM"
        case high = "HIGH"
        case higher = "HIGHER"
        case max = "MAX"
        public var description: String { return self.rawValue }
    }

    public enum M2tsAudioBufferModel: String, CustomStringConvertible, Codable {
        case dvb = "DVB"
        case atsc = "ATSC"
        public var description: String { return self.rawValue }
    }

    public enum Mpeg2FramerateControl: String, CustomStringConvertible, Codable {
        case initializeFromSource = "INITIALIZE_FROM_SOURCE"
        case specified = "SPECIFIED"
        public var description: String { return self.rawValue }
    }

    public enum Mpeg2ParControl: String, CustomStringConvertible, Codable {
        case initializeFromSource = "INITIALIZE_FROM_SOURCE"
        case specified = "SPECIFIED"
        public var description: String { return self.rawValue }
    }

    public enum AacRawFormat: String, CustomStringConvertible, Codable {
        case latmLoas = "LATM_LOAS"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum DvbSubtitleAlignment: String, CustomStringConvertible, Codable {
        case centered = "CENTERED"
        case left = "LEFT"
        public var description: String { return self.rawValue }
    }

    public struct CancelJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", location: .uri(locationName: "id"), required: true, type: .string)
        ]
        /// The Job ID of the job to be cancelled.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public enum Ac3DynamicRangeCompressionProfile: String, CustomStringConvertible, Codable {
        case filmStandard = "FILM_STANDARD"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum H264FieldEncoding: String, CustomStringConvertible, Codable {
        case paff = "PAFF"
        case forceField = "FORCE_FIELD"
        public var description: String { return self.rawValue }
    }

    public struct Id3Insertion: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id3", location: .body(locationName: "id3"), required: false, type: .string), 
            AWSShapeMember(label: "Timecode", location: .body(locationName: "timecode"), required: false, type: .string)
        ]
        /// Use ID3 tag (Id3) to provide a tag value in base64-encode format.
        public let id3: String?
        /// Provide a Timecode (TimeCode) in HH:MM:SS:FF or HH:MM:SS;FF format.
        public let timecode: String?

        public init(id3: String? = nil, timecode: String? = nil) {
            self.id3 = id3
            self.timecode = timecode
        }

        private enum CodingKeys: String, CodingKey {
            case id3 = "id3"
            case timecode = "timecode"
        }
    }

    public struct ListTagsForResourceResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceTags", location: .body(locationName: "resourceTags"), required: false, type: .structure)
        ]
        public let resourceTags: ResourceTags?

        public init(resourceTags: ResourceTags? = nil) {
            self.resourceTags = resourceTags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceTags = "resourceTags"
        }
    }

    public struct MotionImageInsertionOffset: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ImageY", location: .body(locationName: "imageY"), required: false, type: .integer), 
            AWSShapeMember(label: "ImageX", location: .body(locationName: "imageX"), required: false, type: .integer)
        ]
        /// Set the distance, in pixels, between the overlay and the top edge of the video frame.
        public let imageY: Int32?
        /// Set the distance, in pixels, between the overlay and the left edge of the video frame.
        public let imageX: Int32?

        public init(imageY: Int32? = nil, imageX: Int32? = nil) {
            self.imageY = imageY
            self.imageX = imageX
        }

        private enum CodingKeys: String, CodingKey {
            case imageY = "imageY"
            case imageX = "imageX"
        }
    }

    public enum MovReference: String, CustomStringConvertible, Codable {
        case selfContained = "SELF_CONTAINED"
        case external = "EXTERNAL"
        public var description: String { return self.rawValue }
    }

    public struct CreateJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Job", location: .body(locationName: "job"), required: false, type: .structure)
        ]
        public let job: Job?

        public init(job: Job? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job = "job"
        }
    }

    public enum ColorSpaceUsage: String, CustomStringConvertible, Codable {
        case force = "FORCE"
        case fallback = "FALLBACK"
        public var description: String { return self.rawValue }
    }

    public enum ProresFramerateControl: String, CustomStringConvertible, Codable {
        case initializeFromSource = "INITIALIZE_FROM_SOURCE"
        case specified = "SPECIFIED"
        public var description: String { return self.rawValue }
    }

    public enum AacCodecProfile: String, CustomStringConvertible, Codable {
        case lc = "LC"
        case hev1 = "HEV1"
        case hev2 = "HEV2"
        public var description: String { return self.rawValue }
    }

    public enum AfdSignaling: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case auto = "AUTO"
        case fixed = "FIXED"
        public var description: String { return self.rawValue }
    }

    public enum DvbSubtitleTeletextSpacing: String, CustomStringConvertible, Codable {
        case fixedGrid = "FIXED_GRID"
        case proportional = "PROPORTIONAL"
        public var description: String { return self.rawValue }
    }

    public struct ColorCorrector: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Brightness", location: .body(locationName: "brightness"), required: false, type: .integer), 
            AWSShapeMember(label: "Hdr10Metadata", location: .body(locationName: "hdr10Metadata"), required: false, type: .structure), 
            AWSShapeMember(label: "Contrast", location: .body(locationName: "contrast"), required: false, type: .integer), 
            AWSShapeMember(label: "ColorSpaceConversion", location: .body(locationName: "colorSpaceConversion"), required: false, type: .enum), 
            AWSShapeMember(label: "Hue", location: .body(locationName: "hue"), required: false, type: .integer), 
            AWSShapeMember(label: "Saturation", location: .body(locationName: "saturation"), required: false, type: .integer)
        ]
        /// Brightness level.
        public let brightness: Int32?
        public let hdr10Metadata: Hdr10Metadata?
        /// Contrast level.
        public let contrast: Int32?
        public let colorSpaceConversion: ColorSpaceConversion?
        /// Hue in degrees.
        public let hue: Int32?
        /// Saturation level.
        public let saturation: Int32?

        public init(brightness: Int32? = nil, hdr10Metadata: Hdr10Metadata? = nil, contrast: Int32? = nil, colorSpaceConversion: ColorSpaceConversion? = nil, hue: Int32? = nil, saturation: Int32? = nil) {
            self.brightness = brightness
            self.hdr10Metadata = hdr10Metadata
            self.contrast = contrast
            self.colorSpaceConversion = colorSpaceConversion
            self.hue = hue
            self.saturation = saturation
        }

        private enum CodingKeys: String, CodingKey {
            case brightness = "brightness"
            case hdr10Metadata = "hdr10Metadata"
            case contrast = "contrast"
            case colorSpaceConversion = "colorSpaceConversion"
            case hue = "hue"
            case saturation = "saturation"
        }
    }

    public struct DisassociateCertificateResponse: AWSShape {

    }

    public struct HlsSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AudioRenditionSets", location: .body(locationName: "audioRenditionSets"), required: false, type: .string), 
            AWSShapeMember(label: "AudioTrackType", location: .body(locationName: "audioTrackType"), required: false, type: .enum), 
            AWSShapeMember(label: "IFrameOnlyManifest", location: .body(locationName: "iFrameOnlyManifest"), required: false, type: .enum), 
            AWSShapeMember(label: "AudioGroupId", location: .body(locationName: "audioGroupId"), required: false, type: .string), 
            AWSShapeMember(label: "SegmentModifier", location: .body(locationName: "segmentModifier"), required: false, type: .string)
        ]
        /// List all the audio groups that are used with the video output stream. Input all the audio GROUP-IDs that are associated to the video, separate by ','.
        public let audioRenditionSets: String?
        public let audioTrackType: HlsAudioTrackType?
        public let iFrameOnlyManifest: HlsIFrameOnlyManifest?
        /// Specifies the group to which the audio Rendition belongs.
        public let audioGroupId: String?
        /// String concatenated to end of segment filenames. Accepts "Format Identifiers":#format_identifier_parameters.
        public let segmentModifier: String?

        public init(audioRenditionSets: String? = nil, audioTrackType: HlsAudioTrackType? = nil, iFrameOnlyManifest: HlsIFrameOnlyManifest? = nil, audioGroupId: String? = nil, segmentModifier: String? = nil) {
            self.audioRenditionSets = audioRenditionSets
            self.audioTrackType = audioTrackType
            self.iFrameOnlyManifest = iFrameOnlyManifest
            self.audioGroupId = audioGroupId
            self.segmentModifier = segmentModifier
        }

        private enum CodingKeys: String, CodingKey {
            case audioRenditionSets = "audioRenditionSets"
            case audioTrackType = "audioTrackType"
            case iFrameOnlyManifest = "iFrameOnlyManifest"
            case audioGroupId = "audioGroupId"
            case segmentModifier = "segmentModifier"
        }
    }

    public struct Output: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CaptionDescriptions", location: .body(locationName: "captionDescriptions"), required: false, type: .list), 
            AWSShapeMember(label: "VideoDescription", location: .body(locationName: "videoDescription"), required: false, type: .structure), 
            AWSShapeMember(label: "AudioDescriptions", location: .body(locationName: "audioDescriptions"), required: false, type: .list), 
            AWSShapeMember(label: "Extension", location: .body(locationName: "extension"), required: false, type: .string), 
            AWSShapeMember(label: "NameModifier", location: .body(locationName: "nameModifier"), required: false, type: .string), 
            AWSShapeMember(label: "Preset", location: .body(locationName: "preset"), required: false, type: .string), 
            AWSShapeMember(label: "OutputSettings", location: .body(locationName: "outputSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "ContainerSettings", location: .body(locationName: "containerSettings"), required: false, type: .structure)
        ]
        /// (CaptionDescriptions) contains groups of captions settings. For each output that has captions, include one instance of (CaptionDescriptions). (CaptionDescriptions) can contain multiple groups of captions settings.
        public let captionDescriptions: [CaptionDescription]?
        /// (VideoDescription) contains a group of video encoding settings. The specific video settings depend on the video codec you choose when you specify a value for Video codec (codec). Include one instance of (VideoDescription) per output.
        public let videoDescription: VideoDescription?
        /// (AudioDescriptions) contains groups of audio encoding settings organized by audio codec. Include one instance of (AudioDescriptions) per output. (AudioDescriptions) can contain multiple groups of encoding settings.
        public let audioDescriptions: [AudioDescription]?
        /// Use Extension (Extension) to specify the file extension for outputs in File output groups. If you do not specify a value, the service will use default extensions by container type as follows * MPEG-2 transport stream, m2ts * Quicktime, mov * MXF container, mxf * MPEG-4 container, mp4 * No Container, the service will use codec extensions (e.g. AAC, H265, H265, AC3)
        public let `extension`: String?
        /// Use Name modifier (NameModifier) to have the service add a string to the end of each output filename. You specify the base filename as part of your destination URI. When you create multiple outputs in the same output group, Name modifier (NameModifier) is required. Name modifier also accepts format identifiers. For DASH ISO outputs, if you use the format identifiers $Number$ or $Time$ in one output, you must use them in the same way in all outputs of the output group.
        public let nameModifier: String?
        /// Use Preset (Preset) to specifiy a preset for your transcoding settings. Provide the system or custom preset name. You can specify either Preset (Preset) or Container settings (ContainerSettings), but not both.
        public let preset: String?
        public let outputSettings: OutputSettings?
        public let containerSettings: ContainerSettings?

        public init(captionDescriptions: [CaptionDescription]? = nil, videoDescription: VideoDescription? = nil, audioDescriptions: [AudioDescription]? = nil, extension: String? = nil, nameModifier: String? = nil, preset: String? = nil, outputSettings: OutputSettings? = nil, containerSettings: ContainerSettings? = nil) {
            self.captionDescriptions = captionDescriptions
            self.videoDescription = videoDescription
            self.audioDescriptions = audioDescriptions
            self.`extension` = `extension`
            self.nameModifier = nameModifier
            self.preset = preset
            self.outputSettings = outputSettings
            self.containerSettings = containerSettings
        }

        private enum CodingKeys: String, CodingKey {
            case captionDescriptions = "captionDescriptions"
            case videoDescription = "videoDescription"
            case audioDescriptions = "audioDescriptions"
            case `extension` = "extension"
            case nameModifier = "nameModifier"
            case preset = "preset"
            case outputSettings = "outputSettings"
            case containerSettings = "containerSettings"
        }
    }

    public struct GetJobTemplateResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobTemplate", location: .body(locationName: "jobTemplate"), required: false, type: .structure)
        ]
        public let jobTemplate: JobTemplate?

        public init(jobTemplate: JobTemplate? = nil) {
            self.jobTemplate = jobTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case jobTemplate = "jobTemplate"
        }
    }

    public enum H265InterlaceMode: String, CustomStringConvertible, Codable {
        case progressive = "PROGRESSIVE"
        case topField = "TOP_FIELD"
        case bottomField = "BOTTOM_FIELD"
        case followTopField = "FOLLOW_TOP_FIELD"
        case followBottomField = "FOLLOW_BOTTOM_FIELD"
        public var description: String { return self.rawValue }
    }

    public struct CmafEncryptionSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StaticKeyProvider", location: .body(locationName: "staticKeyProvider"), required: false, type: .structure), 
            AWSShapeMember(label: "InitializationVectorInManifest", location: .body(locationName: "initializationVectorInManifest"), required: false, type: .enum), 
            AWSShapeMember(label: "EncryptionMethod", location: .body(locationName: "encryptionMethod"), required: false, type: .enum), 
            AWSShapeMember(label: "ConstantInitializationVector", location: .body(locationName: "constantInitializationVector"), required: false, type: .string), 
            AWSShapeMember(label: "Type", location: .body(locationName: "type"), required: false, type: .enum)
        ]
        public let staticKeyProvider: StaticKeyProvider?
        public let initializationVectorInManifest: CmafInitializationVectorInManifest?
        public let encryptionMethod: CmafEncryptionType?
        /// This is a 128-bit, 16-byte hex value represented by a 32-character text string. If this parameter is not set then the Initialization Vector will follow the segment number by default.
        public let constantInitializationVector: String?
        public let `type`: CmafKeyProviderType?

        public init(staticKeyProvider: StaticKeyProvider? = nil, initializationVectorInManifest: CmafInitializationVectorInManifest? = nil, encryptionMethod: CmafEncryptionType? = nil, constantInitializationVector: String? = nil, type: CmafKeyProviderType? = nil) {
            self.staticKeyProvider = staticKeyProvider
            self.initializationVectorInManifest = initializationVectorInManifest
            self.encryptionMethod = encryptionMethod
            self.constantInitializationVector = constantInitializationVector
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case staticKeyProvider = "staticKeyProvider"
            case initializationVectorInManifest = "initializationVectorInManifest"
            case encryptionMethod = "encryptionMethod"
            case constantInitializationVector = "constantInitializationVector"
            case `type` = "type"
        }
    }

    public enum Ac3MetadataControl: String, CustomStringConvertible, Codable {
        case followInput = "FOLLOW_INPUT"
        case useConfigured = "USE_CONFIGURED"
        public var description: String { return self.rawValue }
    }

    public struct TagResourceResponse: AWSShape {

    }

    public enum Ac3LfeFilter: String, CustomStringConvertible, Codable {
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public struct EmbeddedSourceSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Source608TrackNumber", location: .body(locationName: "source608TrackNumber"), required: false, type: .integer), 
            AWSShapeMember(label: "Source608ChannelNumber", location: .body(locationName: "source608ChannelNumber"), required: false, type: .integer), 
            AWSShapeMember(label: "Convert608To708", location: .body(locationName: "convert608To708"), required: false, type: .enum)
        ]
        /// Specifies the video track index used for extracting captions. The system only supports one input video track, so this should always be set to '1'.
        public let source608TrackNumber: Int32?
        /// Specifies the 608/708 channel number within the video track from which to extract captions. Unused for passthrough.
        public let source608ChannelNumber: Int32?
        public let convert608To708: EmbeddedConvert608To708?

        public init(source608TrackNumber: Int32? = nil, source608ChannelNumber: Int32? = nil, convert608To708: EmbeddedConvert608To708? = nil) {
            self.source608TrackNumber = source608TrackNumber
            self.source608ChannelNumber = source608ChannelNumber
            self.convert608To708 = convert608To708
        }

        private enum CodingKeys: String, CodingKey {
            case source608TrackNumber = "source608TrackNumber"
            case source608ChannelNumber = "source608ChannelNumber"
            case convert608To708 = "convert608To708"
        }
    }

    public struct GetQueueRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", location: .uri(locationName: "name"), required: true, type: .string)
        ]
        /// The name of the queue that you want information about.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct Rectangle: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Height", location: .body(locationName: "height"), required: false, type: .integer), 
            AWSShapeMember(label: "Y", location: .body(locationName: "y"), required: false, type: .integer), 
            AWSShapeMember(label: "Width", location: .body(locationName: "width"), required: false, type: .integer), 
            AWSShapeMember(label: "X", location: .body(locationName: "x"), required: false, type: .integer)
        ]
        /// Height of rectangle in pixels. Specify only even numbers.
        public let height: Int32?
        /// The distance, in pixels, between the rectangle and the top edge of the video frame. Specify only even numbers.
        public let y: Int32?
        /// Width of rectangle in pixels. Specify only even numbers.
        public let width: Int32?
        /// The distance, in pixels, between the rectangle and the left edge of the video frame. Specify only even numbers.
        public let x: Int32?

        public init(height: Int32? = nil, y: Int32? = nil, width: Int32? = nil, x: Int32? = nil) {
            self.height = height
            self.y = y
            self.width = width
            self.x = x
        }

        private enum CodingKeys: String, CodingKey {
            case height = "height"
            case y = "y"
            case width = "width"
            case x = "x"
        }
    }

    public enum CmafEncryptionType: String, CustomStringConvertible, Codable {
        case sampleAes = "SAMPLE_AES"
        public var description: String { return self.rawValue }
    }

    public struct BurninDestinationSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BackgroundOpacity", location: .body(locationName: "backgroundOpacity"), required: false, type: .integer), 
            AWSShapeMember(label: "ShadowColor", location: .body(locationName: "shadowColor"), required: false, type: .enum), 
            AWSShapeMember(label: "OutlineColor", location: .body(locationName: "outlineColor"), required: false, type: .enum), 
            AWSShapeMember(label: "YPosition", location: .body(locationName: "yPosition"), required: false, type: .integer), 
            AWSShapeMember(label: "FontSize", location: .body(locationName: "fontSize"), required: false, type: .integer), 
            AWSShapeMember(label: "FontColor", location: .body(locationName: "fontColor"), required: false, type: .enum), 
            AWSShapeMember(label: "BackgroundColor", location: .body(locationName: "backgroundColor"), required: false, type: .enum), 
            AWSShapeMember(label: "ShadowYOffset", location: .body(locationName: "shadowYOffset"), required: false, type: .integer), 
            AWSShapeMember(label: "ShadowXOffset", location: .body(locationName: "shadowXOffset"), required: false, type: .integer), 
            AWSShapeMember(label: "OutlineSize", location: .body(locationName: "outlineSize"), required: false, type: .integer), 
            AWSShapeMember(label: "ShadowOpacity", location: .body(locationName: "shadowOpacity"), required: false, type: .integer), 
            AWSShapeMember(label: "TeletextSpacing", location: .body(locationName: "teletextSpacing"), required: false, type: .enum), 
            AWSShapeMember(label: "FontOpacity", location: .body(locationName: "fontOpacity"), required: false, type: .integer), 
            AWSShapeMember(label: "Alignment", location: .body(locationName: "alignment"), required: false, type: .enum), 
            AWSShapeMember(label: "XPosition", location: .body(locationName: "xPosition"), required: false, type: .integer), 
            AWSShapeMember(label: "FontResolution", location: .body(locationName: "fontResolution"), required: false, type: .integer)
        ]
        /// Specifies the opacity of the background rectangle. 255 is opaque; 0 is transparent. Leaving this parameter blank is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
        public let backgroundOpacity: Int32?
        public let shadowColor: BurninSubtitleShadowColor?
        public let outlineColor: BurninSubtitleOutlineColor?
        /// Specifies the vertical position of the caption relative to the top of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the top of the output. If no explicit y_position is provided, the caption will be positioned towards the bottom of the output. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        public let yPosition: Int32?
        /// A positive integer indicates the exact font size in points. Set to 0 for automatic font size selection. All burn-in and DVB-Sub font settings must match.
        public let fontSize: Int32?
        public let fontColor: BurninSubtitleFontColor?
        public let backgroundColor: BurninSubtitleBackgroundColor?
        /// Specifies the vertical offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels above the text. All burn-in and DVB-Sub font settings must match.
        public let shadowYOffset: Int32?
        /// Specifies the horizontal offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels to the left. All burn-in and DVB-Sub font settings must match.
        public let shadowXOffset: Int32?
        /// Specifies font outline size in pixels. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        public let outlineSize: Int32?
        /// Specifies the opacity of the shadow. 255 is opaque; 0 is transparent. Leaving this parameter blank is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
        public let shadowOpacity: Int32?
        public let teletextSpacing: BurninSubtitleTeletextSpacing?
        /// Specifies the opacity of the burned-in captions. 255 is opaque; 0 is transparent.
        /// All burn-in and DVB-Sub font settings must match.
        public let fontOpacity: Int32?
        public let alignment: BurninSubtitleAlignment?
        /// Specifies the horizontal position of the caption relative to the left side of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the left of the output. If no explicit x_position is provided, the horizontal caption position will be determined by the alignment parameter. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        public let xPosition: Int32?
        /// Font resolution in DPI (dots per inch); default is 96 dpi.
        /// All burn-in and DVB-Sub font settings must match.
        public let fontResolution: Int32?

        public init(backgroundOpacity: Int32? = nil, shadowColor: BurninSubtitleShadowColor? = nil, outlineColor: BurninSubtitleOutlineColor? = nil, yPosition: Int32? = nil, fontSize: Int32? = nil, fontColor: BurninSubtitleFontColor? = nil, backgroundColor: BurninSubtitleBackgroundColor? = nil, shadowYOffset: Int32? = nil, shadowXOffset: Int32? = nil, outlineSize: Int32? = nil, shadowOpacity: Int32? = nil, teletextSpacing: BurninSubtitleTeletextSpacing? = nil, fontOpacity: Int32? = nil, alignment: BurninSubtitleAlignment? = nil, xPosition: Int32? = nil, fontResolution: Int32? = nil) {
            self.backgroundOpacity = backgroundOpacity
            self.shadowColor = shadowColor
            self.outlineColor = outlineColor
            self.yPosition = yPosition
            self.fontSize = fontSize
            self.fontColor = fontColor
            self.backgroundColor = backgroundColor
            self.shadowYOffset = shadowYOffset
            self.shadowXOffset = shadowXOffset
            self.outlineSize = outlineSize
            self.shadowOpacity = shadowOpacity
            self.teletextSpacing = teletextSpacing
            self.fontOpacity = fontOpacity
            self.alignment = alignment
            self.xPosition = xPosition
            self.fontResolution = fontResolution
        }

        private enum CodingKeys: String, CodingKey {
            case backgroundOpacity = "backgroundOpacity"
            case shadowColor = "shadowColor"
            case outlineColor = "outlineColor"
            case yPosition = "yPosition"
            case fontSize = "fontSize"
            case fontColor = "fontColor"
            case backgroundColor = "backgroundColor"
            case shadowYOffset = "shadowYOffset"
            case shadowXOffset = "shadowXOffset"
            case outlineSize = "outlineSize"
            case shadowOpacity = "shadowOpacity"
            case teletextSpacing = "teletextSpacing"
            case fontOpacity = "fontOpacity"
            case alignment = "alignment"
            case xPosition = "xPosition"
            case fontResolution = "fontResolution"
        }
    }

    public enum H265WriteMp4PackagingType: String, CustomStringConvertible, Codable {
        case hvc1 = "HVC1"
        case hev1 = "HEV1"
        public var description: String { return self.rawValue }
    }

    public enum H265SampleAdaptiveOffsetFilterMode: String, CustomStringConvertible, Codable {
        case `default` = "DEFAULT"
        case adaptive = "ADAPTIVE"
        case off = "OFF"
        public var description: String { return self.rawValue }
    }

    public struct Deinterlacer: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Algorithm", location: .body(locationName: "algorithm"), required: false, type: .enum), 
            AWSShapeMember(label: "Mode", location: .body(locationName: "mode"), required: false, type: .enum), 
            AWSShapeMember(label: "Control", location: .body(locationName: "control"), required: false, type: .enum)
        ]
        public let algorithm: DeinterlaceAlgorithm?
        public let mode: DeinterlacerMode?
        public let control: DeinterlacerControl?

        public init(algorithm: DeinterlaceAlgorithm? = nil, mode: DeinterlacerMode? = nil, control: DeinterlacerControl? = nil) {
            self.algorithm = algorithm
            self.mode = mode
            self.control = control
        }

        private enum CodingKeys: String, CodingKey {
            case algorithm = "algorithm"
            case mode = "mode"
            case control = "control"
        }
    }

    public enum HlsSegmentControl: String, CustomStringConvertible, Codable {
        case singleFile = "SINGLE_FILE"
        case segmentedFiles = "SEGMENTED_FILES"
        public var description: String { return self.rawValue }
    }

    public enum H264QualityTuningLevel: String, CustomStringConvertible, Codable {
        case singlePass = "SINGLE_PASS"
        case singlePassHq = "SINGLE_PASS_HQ"
        case multiPassHq = "MULTI_PASS_HQ"
        public var description: String { return self.rawValue }
    }

    public enum AudioNormalizationLoudnessLogging: String, CustomStringConvertible, Codable {
        case log = "LOG"
        case dontLog = "DONT_LOG"
        public var description: String { return self.rawValue }
    }

    public struct WavSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BitDepth", location: .body(locationName: "bitDepth"), required: false, type: .integer), 
            AWSShapeMember(label: "Format", location: .body(locationName: "format"), required: false, type: .enum), 
            AWSShapeMember(label: "SampleRate", location: .body(locationName: "sampleRate"), required: false, type: .integer), 
            AWSShapeMember(label: "Channels", location: .body(locationName: "channels"), required: false, type: .integer)
        ]
        /// Specify Bit depth (BitDepth), in bits per sample, to choose the encoding quality for this audio track.
        public let bitDepth: Int32?
        public let format: WavFormat?
        /// Sample rate in Hz.
        public let sampleRate: Int32?
        /// Set Channels to specify the number of channels in this output audio track. With WAV, valid values 1, 2, 4, and 8. In the console, these values are Mono, Stereo, 4-Channel, and 8-Channel, respectively.
        public let channels: Int32?

        public init(bitDepth: Int32? = nil, format: WavFormat? = nil, sampleRate: Int32? = nil, channels: Int32? = nil) {
            self.bitDepth = bitDepth
            self.format = format
            self.sampleRate = sampleRate
            self.channels = channels
        }

        private enum CodingKeys: String, CodingKey {
            case bitDepth = "bitDepth"
            case format = "format"
            case sampleRate = "sampleRate"
            case channels = "channels"
        }
    }

    public enum H264CodecLevel: String, CustomStringConvertible, Codable {
        case auto = "AUTO"
        case level1 = "LEVEL_1"
        case level11 = "LEVEL_1_1"
        case level12 = "LEVEL_1_2"
        case level13 = "LEVEL_1_3"
        case level2 = "LEVEL_2"
        case level21 = "LEVEL_2_1"
        case level22 = "LEVEL_2_2"
        case level3 = "LEVEL_3"
        case level31 = "LEVEL_3_1"
        case level32 = "LEVEL_3_2"
        case level4 = "LEVEL_4"
        case level41 = "LEVEL_4_1"
        case level42 = "LEVEL_4_2"
        case level5 = "LEVEL_5"
        case level51 = "LEVEL_5_1"
        case level52 = "LEVEL_5_2"
        public var description: String { return self.rawValue }
    }

    public enum H265SceneChangeDetect: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct MsSmoothEncryptionSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SpekeKeyProvider", location: .body(locationName: "spekeKeyProvider"), required: false, type: .structure)
        ]
        public let spekeKeyProvider: SpekeKeyProvider?

        public init(spekeKeyProvider: SpekeKeyProvider? = nil) {
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case spekeKeyProvider = "spekeKeyProvider"
        }
    }

    public enum Eac3CodingMode: String, CustomStringConvertible, Codable {
        case codingMode10 = "CODING_MODE_1_0"
        case codingMode20 = "CODING_MODE_2_0"
        case codingMode32 = "CODING_MODE_3_2"
        public var description: String { return self.rawValue }
    }

    public enum HlsAudioTrackType: String, CustomStringConvertible, Codable {
        case alternateAudioAutoSelectDefault = "ALTERNATE_AUDIO_AUTO_SELECT_DEFAULT"
        case alternateAudioAutoSelect = "ALTERNATE_AUDIO_AUTO_SELECT"
        case alternateAudioNotAutoSelect = "ALTERNATE_AUDIO_NOT_AUTO_SELECT"
        case audioOnlyVariantStream = "AUDIO_ONLY_VARIANT_STREAM"
        public var description: String { return self.rawValue }
    }

    public enum OutputGroupType: String, CustomStringConvertible, Codable {
        case hlsGroupSettings = "HLS_GROUP_SETTINGS"
        case dashIsoGroupSettings = "DASH_ISO_GROUP_SETTINGS"
        case fileGroupSettings = "FILE_GROUP_SETTINGS"
        case msSmoothGroupSettings = "MS_SMOOTH_GROUP_SETTINGS"
        case cmafGroupSettings = "CMAF_GROUP_SETTINGS"
        public var description: String { return self.rawValue }
    }

    public struct DescribeEndpointsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Mode", location: .body(locationName: "mode"), required: false, type: .enum), 
            AWSShapeMember(label: "MaxResults", location: .body(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string)
        ]
        public let mode: DescribeEndpointsMode?
        /// Optional. Max number of endpoints, up to twenty, that will be returned at one time.
        public let maxResults: Int32?
        /// Use this string, provided with the response to a previous request, to request the next batch of endpoints.
        public let nextToken: String?

        public init(mode: DescribeEndpointsMode? = nil, maxResults: Int32? = nil, nextToken: String? = nil) {
            self.mode = mode
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case mode = "mode"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ReservationPlanSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "RenewalType", location: .body(locationName: "renewalType"), required: true, type: .enum), 
            AWSShapeMember(label: "ReservedSlots", location: .body(locationName: "reservedSlots"), required: true, type: .integer), 
            AWSShapeMember(label: "Commitment", location: .body(locationName: "commitment"), required: true, type: .enum)
        ]
        /// Specifies whether the term of your reserved queue pricing plan is automatically extended (AUTO_RENEW) or expires (EXPIRE) at the end of the term. When your term is auto renewed, you extend your commitment by 12 months from the auto renew date. You can cancel this commitment.
        public let renewalType: RenewalType
        /// Specifies the number of reserved transcode slots (RTS) for this queue. The number of RTS determines how many jobs the queue can process in parallel; each RTS can process one job at a time. You can't decrease the number of RTS in your reserved queue. You can increase the number of RTS by extending your existing commitment with a new 12-month commitment for the larger number. The new commitment begins when you purchase the additional capacity. You can't cancel your commitment or revert to your original commitment after you increase the capacity.
        public let reservedSlots: Int32
        /// The length of the term of your reserved queue pricing plan commitment.
        public let commitment: Commitment

        public init(renewalType: RenewalType, reservedSlots: Int32, commitment: Commitment) {
            self.renewalType = renewalType
            self.reservedSlots = reservedSlots
            self.commitment = commitment
        }

        private enum CodingKeys: String, CodingKey {
            case renewalType = "renewalType"
            case reservedSlots = "reservedSlots"
            case commitment = "commitment"
        }
    }

    public enum Eac3AttenuationControl: String, CustomStringConvertible, Codable {
        case attenuate3Db = "ATTENUATE_3_DB"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum H265UnregisteredSeiTimecode: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum H264FramerateConversionAlgorithm: String, CustomStringConvertible, Codable {
        case duplicateDrop = "DUPLICATE_DROP"
        case interpolate = "INTERPOLATE"
        public var description: String { return self.rawValue }
    }

    public struct Input: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AudioSelectorGroups", location: .body(locationName: "audioSelectorGroups"), required: false, type: .map), 
            AWSShapeMember(label: "DeblockFilter", location: .body(locationName: "deblockFilter"), required: false, type: .enum), 
            AWSShapeMember(label: "PsiControl", location: .body(locationName: "psiControl"), required: false, type: .enum), 
            AWSShapeMember(label: "InputClippings", location: .body(locationName: "inputClippings"), required: false, type: .list), 
            AWSShapeMember(label: "ImageInserter", location: .body(locationName: "imageInserter"), required: false, type: .structure), 
            AWSShapeMember(label: "CaptionSelectors", location: .body(locationName: "captionSelectors"), required: false, type: .map), 
            AWSShapeMember(label: "FileInput", location: .body(locationName: "fileInput"), required: false, type: .string), 
            AWSShapeMember(label: "FilterStrength", location: .body(locationName: "filterStrength"), required: false, type: .integer), 
            AWSShapeMember(label: "DenoiseFilter", location: .body(locationName: "denoiseFilter"), required: false, type: .enum), 
            AWSShapeMember(label: "AudioSelectors", location: .body(locationName: "audioSelectors"), required: false, type: .map), 
            AWSShapeMember(label: "FilterEnable", location: .body(locationName: "filterEnable"), required: false, type: .enum), 
            AWSShapeMember(label: "ProgramNumber", location: .body(locationName: "programNumber"), required: false, type: .integer), 
            AWSShapeMember(label: "TimecodeSource", location: .body(locationName: "timecodeSource"), required: false, type: .enum), 
            AWSShapeMember(label: "VideoSelector", location: .body(locationName: "videoSelector"), required: false, type: .structure), 
            AWSShapeMember(label: "DecryptionSettings", location: .body(locationName: "decryptionSettings"), required: false, type: .structure)
        ]
        /// Specifies set of audio selectors within an input to combine. An input may have multiple audio selector groups. See "Audio Selector Group":#inputs-audio_selector_group for more information.
        public let audioSelectorGroups: [String: AudioSelectorGroup]?
        public let deblockFilter: InputDeblockFilter?
        public let psiControl: InputPsiControl?
        /// (InputClippings) contains sets of start and end times that together specify a portion of the input to be used in the outputs. If you provide only a start time, the clip will be the entire input from that point to the end. If you provide only an end time, it will be the entire input up to that point. When you specify more than one input clip, the transcoding service creates the job outputs by stringing the clips together in the order you specify them.
        public let inputClippings: [InputClipping]?
        /// Enable the Image inserter (ImageInserter) feature to include a graphic overlay on your video. Enable or disable this feature for each input individually. This setting is disabled by default.
        public let imageInserter: ImageInserter?
        /// Use Captions selectors (CaptionSelectors) to specify the captions data from the input that you will use in your outputs. You can use mutiple captions selectors per input.
        public let captionSelectors: [String: CaptionSelector]?
        /// Use Input (fileInput) to define the source file used in the transcode job. There can be multiple inputs in a job. These inputs are concantenated, in the order they are specified in the job, to create the output.
        public let fileInput: String?
        /// Use Filter strength (FilterStrength) to adjust the magnitude the input filter settings (Deblock and Denoise). The range is -5 to 5. Default is 0.
        public let filterStrength: Int32?
        public let denoiseFilter: InputDenoiseFilter?
        /// Use Audio selectors (AudioSelectors) to specify a track or set of tracks from the input that you will use in your outputs. You can use mutiple Audio selectors per input.
        public let audioSelectors: [String: AudioSelector]?
        public let filterEnable: InputFilterEnable?
        /// Use Program (programNumber) to select a specific program from within a multi-program transport stream. Note that Quad 4K is not currently supported. Default is the first program within the transport stream. If the program you specify doesn't exist, the transcoding service will use this default.
        public let programNumber: Int32?
        public let timecodeSource: InputTimecodeSource?
        public let videoSelector: VideoSelector?
        /// If the input file is encrypted, decryption settings to decrypt the media file
        public let decryptionSettings: InputDecryptionSettings?

        public init(audioSelectorGroups: [String: AudioSelectorGroup]? = nil, deblockFilter: InputDeblockFilter? = nil, psiControl: InputPsiControl? = nil, inputClippings: [InputClipping]? = nil, imageInserter: ImageInserter? = nil, captionSelectors: [String: CaptionSelector]? = nil, fileInput: String? = nil, filterStrength: Int32? = nil, denoiseFilter: InputDenoiseFilter? = nil, audioSelectors: [String: AudioSelector]? = nil, filterEnable: InputFilterEnable? = nil, programNumber: Int32? = nil, timecodeSource: InputTimecodeSource? = nil, videoSelector: VideoSelector? = nil, decryptionSettings: InputDecryptionSettings? = nil) {
            self.audioSelectorGroups = audioSelectorGroups
            self.deblockFilter = deblockFilter
            self.psiControl = psiControl
            self.inputClippings = inputClippings
            self.imageInserter = imageInserter
            self.captionSelectors = captionSelectors
            self.fileInput = fileInput
            self.filterStrength = filterStrength
            self.denoiseFilter = denoiseFilter
            self.audioSelectors = audioSelectors
            self.filterEnable = filterEnable
            self.programNumber = programNumber
            self.timecodeSource = timecodeSource
            self.videoSelector = videoSelector
            self.decryptionSettings = decryptionSettings
        }

        private enum CodingKeys: String, CodingKey {
            case audioSelectorGroups = "audioSelectorGroups"
            case deblockFilter = "deblockFilter"
            case psiControl = "psiControl"
            case inputClippings = "inputClippings"
            case imageInserter = "imageInserter"
            case captionSelectors = "captionSelectors"
            case fileInput = "fileInput"
            case filterStrength = "filterStrength"
            case denoiseFilter = "denoiseFilter"
            case audioSelectors = "audioSelectors"
            case filterEnable = "filterEnable"
            case programNumber = "programNumber"
            case timecodeSource = "timecodeSource"
            case videoSelector = "videoSelector"
            case decryptionSettings = "decryptionSettings"
        }
    }

    public enum Mpeg2InterlaceMode: String, CustomStringConvertible, Codable {
        case progressive = "PROGRESSIVE"
        case topField = "TOP_FIELD"
        case bottomField = "BOTTOM_FIELD"
        case followTopField = "FOLLOW_TOP_FIELD"
        case followBottomField = "FOLLOW_BOTTOM_FIELD"
        public var description: String { return self.rawValue }
    }

    public enum MovClapAtom: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public enum RespondToAfd: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case respond = "RESPOND"
        case passthrough = "PASSTHROUGH"
        public var description: String { return self.rawValue }
    }

    public struct CaptionSourceSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TeletextSourceSettings", location: .body(locationName: "teletextSourceSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "AncillarySourceSettings", location: .body(locationName: "ancillarySourceSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "FileSourceSettings", location: .body(locationName: "fileSourceSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "SourceType", location: .body(locationName: "sourceType"), required: false, type: .enum), 
            AWSShapeMember(label: "DvbSubSourceSettings", location: .body(locationName: "dvbSubSourceSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "EmbeddedSourceSettings", location: .body(locationName: "embeddedSourceSettings"), required: false, type: .structure)
        ]
        public let teletextSourceSettings: TeletextSourceSettings?
        public let ancillarySourceSettings: AncillarySourceSettings?
        public let fileSourceSettings: FileSourceSettings?
        public let sourceType: CaptionSourceType?
        public let dvbSubSourceSettings: DvbSubSourceSettings?
        public let embeddedSourceSettings: EmbeddedSourceSettings?

        public init(teletextSourceSettings: TeletextSourceSettings? = nil, ancillarySourceSettings: AncillarySourceSettings? = nil, fileSourceSettings: FileSourceSettings? = nil, sourceType: CaptionSourceType? = nil, dvbSubSourceSettings: DvbSubSourceSettings? = nil, embeddedSourceSettings: EmbeddedSourceSettings? = nil) {
            self.teletextSourceSettings = teletextSourceSettings
            self.ancillarySourceSettings = ancillarySourceSettings
            self.fileSourceSettings = fileSourceSettings
            self.sourceType = sourceType
            self.dvbSubSourceSettings = dvbSubSourceSettings
            self.embeddedSourceSettings = embeddedSourceSettings
        }

        private enum CodingKeys: String, CodingKey {
            case teletextSourceSettings = "teletextSourceSettings"
            case ancillarySourceSettings = "ancillarySourceSettings"
            case fileSourceSettings = "fileSourceSettings"
            case sourceType = "sourceType"
            case dvbSubSourceSettings = "dvbSubSourceSettings"
            case embeddedSourceSettings = "embeddedSourceSettings"
        }
    }

    public struct CancelJobResponse: AWSShape {

    }

    public struct DeleteQueueResponse: AWSShape {

    }

    public struct ListJobTemplatesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "Order", location: .querystring(locationName: "order"), required: false, type: .enum), 
            AWSShapeMember(label: "Category", location: .querystring(locationName: "category"), required: false, type: .string), 
            AWSShapeMember(label: "ListBy", location: .querystring(locationName: "listBy"), required: false, type: .enum)
        ]
        /// Optional. Number of job templates, up to twenty, that will be returned at one time.
        public let maxResults: Int32?
        /// Use this string, provided with the response to a previous request, to request the next batch of job templates.
        public let nextToken: String?
        public let order: Order?
        /// Optionally, specify a job template category to limit responses to only job templates from that category.
        public let category: String?
        public let listBy: JobTemplateListBy?

        public init(maxResults: Int32? = nil, nextToken: String? = nil, order: Order? = nil, category: String? = nil, listBy: JobTemplateListBy? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.order = order
            self.category = category
            self.listBy = listBy
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case order = "order"
            case category = "category"
            case listBy = "listBy"
        }
    }

    public enum InputTimecodeSource: String, CustomStringConvertible, Codable {
        case embedded = "EMBEDDED"
        case zerobased = "ZEROBASED"
        case specifiedstart = "SPECIFIEDSTART"
        public var description: String { return self.rawValue }
    }

    public struct H264QvbrSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "QvbrQualityLevel", location: .body(locationName: "qvbrQualityLevel"), required: false, type: .integer), 
            AWSShapeMember(label: "MaxAverageBitrate", location: .body(locationName: "maxAverageBitrate"), required: false, type: .integer)
        ]
        /// Required when you use QVBR rate control mode. That is, when you specify qvbrSettings within h264Settings. Specify the target quality level for this output, from 1 to 10. Use higher numbers for greater quality. Level 10 results in nearly lossless compression. The quality level for most broadcast-quality transcodes is between 6 and 9.
        public let qvbrQualityLevel: Int32?
        /// Use this setting only when Rate control mode is QVBR and Quality tuning level is Multi-pass HQ. For Max average bitrate values suited to the complexity of your input video, the service limits the average bitrate of the video part of this output to the value you choose. That is, the total size of the video element is less than or equal to the value you set multiplied by the number of seconds of encoded output.
        public let maxAverageBitrate: Int32?

        public init(qvbrQualityLevel: Int32? = nil, maxAverageBitrate: Int32? = nil) {
            self.qvbrQualityLevel = qvbrQualityLevel
            self.maxAverageBitrate = maxAverageBitrate
        }

        private enum CodingKeys: String, CodingKey {
            case qvbrQualityLevel = "qvbrQualityLevel"
            case maxAverageBitrate = "maxAverageBitrate"
        }
    }

    public enum H265CodecProfile: String, CustomStringConvertible, Codable {
        case mainMain = "MAIN_MAIN"
        case mainHigh = "MAIN_HIGH"
        case main10Main = "MAIN10_MAIN"
        case main10High = "MAIN10_HIGH"
        case main4228BitMain = "MAIN_422_8BIT_MAIN"
        case main4228BitHigh = "MAIN_422_8BIT_HIGH"
        case main42210BitMain = "MAIN_422_10BIT_MAIN"
        case main42210BitHigh = "MAIN_422_10BIT_HIGH"
        public var description: String { return self.rawValue }
    }

    public struct DescribeEndpointsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Endpoints", location: .body(locationName: "endpoints"), required: false, type: .list), 
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string)
        ]
        /// List of endpoints
        public let endpoints: [Endpoint]?
        /// Use this string to request the next batch of endpoints.
        public let nextToken: String?

        public init(endpoints: [Endpoint]? = nil, nextToken: String? = nil) {
            self.endpoints = endpoints
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case endpoints = "endpoints"
            case nextToken = "nextToken"
        }
    }

    public enum AntiAlias: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct UpdateJobTemplateResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobTemplate", location: .body(locationName: "jobTemplate"), required: false, type: .structure)
        ]
        public let jobTemplate: JobTemplate?

        public init(jobTemplate: JobTemplate? = nil) {
            self.jobTemplate = jobTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case jobTemplate = "jobTemplate"
        }
    }

    public struct HlsEncryptionSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SpekeKeyProvider", location: .body(locationName: "spekeKeyProvider"), required: false, type: .structure), 
            AWSShapeMember(label: "EncryptionMethod", location: .body(locationName: "encryptionMethod"), required: false, type: .enum), 
            AWSShapeMember(label: "ConstantInitializationVector", location: .body(locationName: "constantInitializationVector"), required: false, type: .string), 
            AWSShapeMember(label: "Type", location: .body(locationName: "type"), required: false, type: .enum), 
            AWSShapeMember(label: "StaticKeyProvider", location: .body(locationName: "staticKeyProvider"), required: false, type: .structure), 
            AWSShapeMember(label: "InitializationVectorInManifest", location: .body(locationName: "initializationVectorInManifest"), required: false, type: .enum)
        ]
        public let spekeKeyProvider: SpekeKeyProvider?
        public let encryptionMethod: HlsEncryptionType?
        /// This is a 128-bit, 16-byte hex value represented by a 32-character text string. If this parameter is not set then the Initialization Vector will follow the segment number by default.
        public let constantInitializationVector: String?
        public let `type`: HlsKeyProviderType?
        public let staticKeyProvider: StaticKeyProvider?
        public let initializationVectorInManifest: HlsInitializationVectorInManifest?

        public init(spekeKeyProvider: SpekeKeyProvider? = nil, encryptionMethod: HlsEncryptionType? = nil, constantInitializationVector: String? = nil, type: HlsKeyProviderType? = nil, staticKeyProvider: StaticKeyProvider? = nil, initializationVectorInManifest: HlsInitializationVectorInManifest? = nil) {
            self.spekeKeyProvider = spekeKeyProvider
            self.encryptionMethod = encryptionMethod
            self.constantInitializationVector = constantInitializationVector
            self.`type` = `type`
            self.staticKeyProvider = staticKeyProvider
            self.initializationVectorInManifest = initializationVectorInManifest
        }

        private enum CodingKeys: String, CodingKey {
            case spekeKeyProvider = "spekeKeyProvider"
            case encryptionMethod = "encryptionMethod"
            case constantInitializationVector = "constantInitializationVector"
            case `type` = "type"
            case staticKeyProvider = "staticKeyProvider"
            case initializationVectorInManifest = "initializationVectorInManifest"
        }
    }

    public struct OutputSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HlsSettings", location: .body(locationName: "hlsSettings"), required: false, type: .structure)
        ]
        public let hlsSettings: HlsSettings?

        public init(hlsSettings: HlsSettings? = nil) {
            self.hlsSettings = hlsSettings
        }

        private enum CodingKeys: String, CodingKey {
            case hlsSettings = "hlsSettings"
        }
    }

    public enum DashIsoSegmentControl: String, CustomStringConvertible, Codable {
        case singleFile = "SINGLE_FILE"
        case segmentedFiles = "SEGMENTED_FILES"
        public var description: String { return self.rawValue }
    }

    public struct InsertableImage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Height", location: .body(locationName: "height"), required: false, type: .integer), 
            AWSShapeMember(label: "ImageY", location: .body(locationName: "imageY"), required: false, type: .integer), 
            AWSShapeMember(label: "Layer", location: .body(locationName: "layer"), required: false, type: .integer), 
            AWSShapeMember(label: "Width", location: .body(locationName: "width"), required: false, type: .integer), 
            AWSShapeMember(label: "ImageX", location: .body(locationName: "imageX"), required: false, type: .integer), 
            AWSShapeMember(label: "FadeOut", location: .body(locationName: "fadeOut"), required: false, type: .integer), 
            AWSShapeMember(label: "FadeIn", location: .body(locationName: "fadeIn"), required: false, type: .integer), 
            AWSShapeMember(label: "Opacity", location: .body(locationName: "opacity"), required: false, type: .integer), 
            AWSShapeMember(label: "Duration", location: .body(locationName: "duration"), required: false, type: .integer), 
            AWSShapeMember(label: "StartTime", location: .body(locationName: "startTime"), required: false, type: .string), 
            AWSShapeMember(label: "ImageInserterInput", location: .body(locationName: "imageInserterInput"), required: false, type: .string)
        ]
        /// Specify the height of the inserted image in pixels. If you specify a value that's larger than the video resolution height, the service will crop your overlaid image to fit. To use the native height of the image, keep this setting blank.
        public let height: Int32?
        /// Use Top (ImageY) to set the distance, in pixels, between the overlaid image and the top edge of the video frame. Required for any image overlay that you specify.
        public let imageY: Int32?
        /// Specify how overlapping inserted images appear. Images with higher values for Layer appear on top of images with lower values for Layer.
        public let layer: Int32?
        /// Specify the width of the inserted image in pixels. If you specify a value that's larger than the video resolution width, the service will crop your overlaid image to fit. To use the native width of the image, keep this setting blank.
        public let width: Int32?
        /// Use Left (ImageX) to set the distance, in pixels, between the inserted image and the left edge of the video frame. Required for any image overlay that you specify.
        public let imageX: Int32?
        /// Specify the length of time, in milliseconds, between the end of the time that you have specified for the image overlay Duration and when the overlaid image has faded to total transparency. If you don't specify a value for Fade-out, the image will disappear abruptly at the end of the inserted image duration.
        public let fadeOut: Int32?
        /// Set the length of time, in milliseconds, between the Start time that you specify for the image insertion and the time that the image appears at full opacity. Full opacity is the level that you specify for the opacity setting. If you don't specify a value for Fade-in, the image will appear abruptly at the overlay start time.
        public let fadeIn: Int32?
        /// Use Opacity (Opacity) to specify how much of the underlying video shows through the inserted image. 0 is transparent and 100 is fully opaque. Default is 50.
        public let opacity: Int32?
        /// Set the time, in milliseconds, for the image to remain on the output video.
        public let duration: Int32?
        /// Use Start time (StartTime) to specify the video timecode when the image is inserted in the output. This must be in timecode (HH:MM:SS:FF or HH:MM:SS;FF) format.
        public let startTime: String?
        /// Use Image location (imageInserterInput) to specify the Amazon S3 location of the image to be inserted into the output. Use a PNG or TGA file that fits inside the video frame.
        public let imageInserterInput: String?

        public init(height: Int32? = nil, imageY: Int32? = nil, layer: Int32? = nil, width: Int32? = nil, imageX: Int32? = nil, fadeOut: Int32? = nil, fadeIn: Int32? = nil, opacity: Int32? = nil, duration: Int32? = nil, startTime: String? = nil, imageInserterInput: String? = nil) {
            self.height = height
            self.imageY = imageY
            self.layer = layer
            self.width = width
            self.imageX = imageX
            self.fadeOut = fadeOut
            self.fadeIn = fadeIn
            self.opacity = opacity
            self.duration = duration
            self.startTime = startTime
            self.imageInserterInput = imageInserterInput
        }

        private enum CodingKeys: String, CodingKey {
            case height = "height"
            case imageY = "imageY"
            case layer = "layer"
            case width = "width"
            case imageX = "imageX"
            case fadeOut = "fadeOut"
            case fadeIn = "fadeIn"
            case opacity = "opacity"
            case duration = "duration"
            case startTime = "startTime"
            case imageInserterInput = "imageInserterInput"
        }
    }

    public struct Mp2Settings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SampleRate", location: .body(locationName: "sampleRate"), required: false, type: .integer), 
            AWSShapeMember(label: "Channels", location: .body(locationName: "channels"), required: false, type: .integer), 
            AWSShapeMember(label: "Bitrate", location: .body(locationName: "bitrate"), required: false, type: .integer)
        ]
        /// Sample rate in hz.
        public let sampleRate: Int32?
        /// Set Channels to specify the number of channels in this output audio track. Choosing Mono in the console will give you 1 output channel; choosing Stereo will give you 2. In the API, valid values are 1 and 2.
        public let channels: Int32?
        /// Average bitrate in bits/second.
        public let bitrate: Int32?

        public init(sampleRate: Int32? = nil, channels: Int32? = nil, bitrate: Int32? = nil) {
            self.sampleRate = sampleRate
            self.channels = channels
            self.bitrate = bitrate
        }

        private enum CodingKeys: String, CodingKey {
            case sampleRate = "sampleRate"
            case channels = "channels"
            case bitrate = "bitrate"
        }
    }

    public enum AacAudioDescriptionBroadcasterMix: String, CustomStringConvertible, Codable {
        case broadcasterMixedAd = "BROADCASTER_MIXED_AD"
        case normal = "NORMAL"
        public var description: String { return self.rawValue }
    }

    public enum BillingTagsSource: String, CustomStringConvertible, Codable {
        case queue = "QUEUE"
        case preset = "PRESET"
        case jobTemplate = "JOB_TEMPLATE"
        public var description: String { return self.rawValue }
    }

    public struct Eac3Settings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LfeControl", location: .body(locationName: "lfeControl"), required: false, type: .enum), 
            AWSShapeMember(label: "CodingMode", location: .body(locationName: "codingMode"), required: false, type: .enum), 
            AWSShapeMember(label: "PhaseControl", location: .body(locationName: "phaseControl"), required: false, type: .enum), 
            AWSShapeMember(label: "LtRtCenterMixLevel", location: .body(locationName: "ltRtCenterMixLevel"), required: false, type: .double), 
            AWSShapeMember(label: "BitstreamMode", location: .body(locationName: "bitstreamMode"), required: false, type: .enum), 
            AWSShapeMember(label: "DcFilter", location: .body(locationName: "dcFilter"), required: false, type: .enum), 
            AWSShapeMember(label: "PassthroughControl", location: .body(locationName: "passthroughControl"), required: false, type: .enum), 
            AWSShapeMember(label: "SurroundMode", location: .body(locationName: "surroundMode"), required: false, type: .enum), 
            AWSShapeMember(label: "StereoDownmix", location: .body(locationName: "stereoDownmix"), required: false, type: .enum), 
            AWSShapeMember(label: "SampleRate", location: .body(locationName: "sampleRate"), required: false, type: .integer), 
            AWSShapeMember(label: "DynamicRangeCompressionRf", location: .body(locationName: "dynamicRangeCompressionRf"), required: false, type: .enum), 
            AWSShapeMember(label: "MetadataControl", location: .body(locationName: "metadataControl"), required: false, type: .enum), 
            AWSShapeMember(label: "LfeFilter", location: .body(locationName: "lfeFilter"), required: false, type: .enum), 
            AWSShapeMember(label: "DynamicRangeCompressionLine", location: .body(locationName: "dynamicRangeCompressionLine"), required: false, type: .enum), 
            AWSShapeMember(label: "Bitrate", location: .body(locationName: "bitrate"), required: false, type: .integer), 
            AWSShapeMember(label: "LoRoSurroundMixLevel", location: .body(locationName: "loRoSurroundMixLevel"), required: false, type: .double), 
            AWSShapeMember(label: "SurroundExMode", location: .body(locationName: "surroundExMode"), required: false, type: .enum), 
            AWSShapeMember(label: "AttenuationControl", location: .body(locationName: "attenuationControl"), required: false, type: .enum), 
            AWSShapeMember(label: "LtRtSurroundMixLevel", location: .body(locationName: "ltRtSurroundMixLevel"), required: false, type: .double), 
            AWSShapeMember(label: "Dialnorm", location: .body(locationName: "dialnorm"), required: false, type: .integer), 
            AWSShapeMember(label: "LoRoCenterMixLevel", location: .body(locationName: "loRoCenterMixLevel"), required: false, type: .double)
        ]
        public let lfeControl: Eac3LfeControl?
        public let codingMode: Eac3CodingMode?
        public let phaseControl: Eac3PhaseControl?
        /// Left total/Right total center mix level. Only used for 3/2 coding mode.
        /// Valid values: 3.0, 1.5, 0.0, -1.5 -3.0 -4.5 -6.0 -60
        public let ltRtCenterMixLevel: Double?
        public let bitstreamMode: Eac3BitstreamMode?
        public let dcFilter: Eac3DcFilter?
        public let passthroughControl: Eac3PassthroughControl?
        public let surroundMode: Eac3SurroundMode?
        public let stereoDownmix: Eac3StereoDownmix?
        /// Sample rate in hz. Sample rate is always 48000.
        public let sampleRate: Int32?
        public let dynamicRangeCompressionRf: Eac3DynamicRangeCompressionRf?
        public let metadataControl: Eac3MetadataControl?
        public let lfeFilter: Eac3LfeFilter?
        public let dynamicRangeCompressionLine: Eac3DynamicRangeCompressionLine?
        /// Average bitrate in bits/second. Valid bitrates depend on the coding mode.
        public let bitrate: Int32?
        /// Left only/Right only surround mix level. Only used for 3/2 coding mode.
        /// Valid values: -1.5 -3.0 -4.5 -6.0 -60
        public let loRoSurroundMixLevel: Double?
        public let surroundExMode: Eac3SurroundExMode?
        public let attenuationControl: Eac3AttenuationControl?
        /// Left total/Right total surround mix level. Only used for 3/2 coding mode.
        /// Valid values: -1.5 -3.0 -4.5 -6.0 -60
        public let ltRtSurroundMixLevel: Double?
        /// Sets the dialnorm for the output. If blank and input audio is Dolby Digital Plus, dialnorm will be passed through.
        public let dialnorm: Int32?
        /// Left only/Right only center mix level. Only used for 3/2 coding mode.
        /// Valid values: 3.0, 1.5, 0.0, -1.5 -3.0 -4.5 -6.0 -60
        public let loRoCenterMixLevel: Double?

        public init(lfeControl: Eac3LfeControl? = nil, codingMode: Eac3CodingMode? = nil, phaseControl: Eac3PhaseControl? = nil, ltRtCenterMixLevel: Double? = nil, bitstreamMode: Eac3BitstreamMode? = nil, dcFilter: Eac3DcFilter? = nil, passthroughControl: Eac3PassthroughControl? = nil, surroundMode: Eac3SurroundMode? = nil, stereoDownmix: Eac3StereoDownmix? = nil, sampleRate: Int32? = nil, dynamicRangeCompressionRf: Eac3DynamicRangeCompressionRf? = nil, metadataControl: Eac3MetadataControl? = nil, lfeFilter: Eac3LfeFilter? = nil, dynamicRangeCompressionLine: Eac3DynamicRangeCompressionLine? = nil, bitrate: Int32? = nil, loRoSurroundMixLevel: Double? = nil, surroundExMode: Eac3SurroundExMode? = nil, attenuationControl: Eac3AttenuationControl? = nil, ltRtSurroundMixLevel: Double? = nil, dialnorm: Int32? = nil, loRoCenterMixLevel: Double? = nil) {
            self.lfeControl = lfeControl
            self.codingMode = codingMode
            self.phaseControl = phaseControl
            self.ltRtCenterMixLevel = ltRtCenterMixLevel
            self.bitstreamMode = bitstreamMode
            self.dcFilter = dcFilter
            self.passthroughControl = passthroughControl
            self.surroundMode = surroundMode
            self.stereoDownmix = stereoDownmix
            self.sampleRate = sampleRate
            self.dynamicRangeCompressionRf = dynamicRangeCompressionRf
            self.metadataControl = metadataControl
            self.lfeFilter = lfeFilter
            self.dynamicRangeCompressionLine = dynamicRangeCompressionLine
            self.bitrate = bitrate
            self.loRoSurroundMixLevel = loRoSurroundMixLevel
            self.surroundExMode = surroundExMode
            self.attenuationControl = attenuationControl
            self.ltRtSurroundMixLevel = ltRtSurroundMixLevel
            self.dialnorm = dialnorm
            self.loRoCenterMixLevel = loRoCenterMixLevel
        }

        private enum CodingKeys: String, CodingKey {
            case lfeControl = "lfeControl"
            case codingMode = "codingMode"
            case phaseControl = "phaseControl"
            case ltRtCenterMixLevel = "ltRtCenterMixLevel"
            case bitstreamMode = "bitstreamMode"
            case dcFilter = "dcFilter"
            case passthroughControl = "passthroughControl"
            case surroundMode = "surroundMode"
            case stereoDownmix = "stereoDownmix"
            case sampleRate = "sampleRate"
            case dynamicRangeCompressionRf = "dynamicRangeCompressionRf"
            case metadataControl = "metadataControl"
            case lfeFilter = "lfeFilter"
            case dynamicRangeCompressionLine = "dynamicRangeCompressionLine"
            case bitrate = "bitrate"
            case loRoSurroundMixLevel = "loRoSurroundMixLevel"
            case surroundExMode = "surroundExMode"
            case attenuationControl = "attenuationControl"
            case ltRtSurroundMixLevel = "ltRtSurroundMixLevel"
            case dialnorm = "dialnorm"
            case loRoCenterMixLevel = "loRoCenterMixLevel"
        }
    }

    public struct OutputDetail: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "VideoDetails", location: .body(locationName: "videoDetails"), required: false, type: .structure), 
            AWSShapeMember(label: "DurationInMs", location: .body(locationName: "durationInMs"), required: false, type: .integer)
        ]
        public let videoDetails: VideoDetail?
        /// Duration in milliseconds
        public let durationInMs: Int32?

        public init(videoDetails: VideoDetail? = nil, durationInMs: Int32? = nil) {
            self.videoDetails = videoDetails
            self.durationInMs = durationInMs
        }

        private enum CodingKeys: String, CodingKey {
            case videoDetails = "videoDetails"
            case durationInMs = "durationInMs"
        }
    }

    public struct ListQueuesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "Queues", location: .body(locationName: "queues"), required: false, type: .list)
        ]
        /// Use this string to request the next batch of queues.
        public let nextToken: String?
        /// List of queues.
        public let queues: [Queue]?

        public init(nextToken: String? = nil, queues: [Queue]? = nil) {
            self.nextToken = nextToken
            self.queues = queues
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case queues = "queues"
        }
    }

    public enum InputDenoiseFilter: String, CustomStringConvertible, Codable {
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public struct PresetSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContainerSettings", location: .body(locationName: "containerSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "CaptionDescriptions", location: .body(locationName: "captionDescriptions"), required: false, type: .list), 
            AWSShapeMember(label: "AudioDescriptions", location: .body(locationName: "audioDescriptions"), required: false, type: .list), 
            AWSShapeMember(label: "VideoDescription", location: .body(locationName: "videoDescription"), required: false, type: .structure)
        ]
        public let containerSettings: ContainerSettings?
        /// Caption settings for this preset. There can be multiple caption settings in a single output.
        public let captionDescriptions: [CaptionDescriptionPreset]?
        /// (AudioDescriptions) contains groups of audio encoding settings organized by audio codec. Include one instance of (AudioDescriptions) per output. (AudioDescriptions) can contain multiple groups of encoding settings.
        public let audioDescriptions: [AudioDescription]?
        /// (VideoDescription) contains a group of video encoding settings. The specific video settings depend on the video codec you choose when you specify a value for Video codec (codec). Include one instance of (VideoDescription) per output.
        public let videoDescription: VideoDescription?

        public init(containerSettings: ContainerSettings? = nil, captionDescriptions: [CaptionDescriptionPreset]? = nil, audioDescriptions: [AudioDescription]? = nil, videoDescription: VideoDescription? = nil) {
            self.containerSettings = containerSettings
            self.captionDescriptions = captionDescriptions
            self.audioDescriptions = audioDescriptions
            self.videoDescription = videoDescription
        }

        private enum CodingKeys: String, CodingKey {
            case containerSettings = "containerSettings"
            case captionDescriptions = "captionDescriptions"
            case audioDescriptions = "audioDescriptions"
            case videoDescription = "videoDescription"
        }
    }

    public struct AudioCodecSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AiffSettings", location: .body(locationName: "aiffSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "WavSettings", location: .body(locationName: "wavSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "Eac3Settings", location: .body(locationName: "eac3Settings"), required: false, type: .structure), 
            AWSShapeMember(label: "Codec", location: .body(locationName: "codec"), required: false, type: .enum), 
            AWSShapeMember(label: "Mp2Settings", location: .body(locationName: "mp2Settings"), required: false, type: .structure), 
            AWSShapeMember(label: "AacSettings", location: .body(locationName: "aacSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "Ac3Settings", location: .body(locationName: "ac3Settings"), required: false, type: .structure)
        ]
        public let aiffSettings: AiffSettings?
        public let wavSettings: WavSettings?
        public let eac3Settings: Eac3Settings?
        public let codec: AudioCodec?
        public let mp2Settings: Mp2Settings?
        public let aacSettings: AacSettings?
        public let ac3Settings: Ac3Settings?

        public init(aiffSettings: AiffSettings? = nil, wavSettings: WavSettings? = nil, eac3Settings: Eac3Settings? = nil, codec: AudioCodec? = nil, mp2Settings: Mp2Settings? = nil, aacSettings: AacSettings? = nil, ac3Settings: Ac3Settings? = nil) {
            self.aiffSettings = aiffSettings
            self.wavSettings = wavSettings
            self.eac3Settings = eac3Settings
            self.codec = codec
            self.mp2Settings = mp2Settings
            self.aacSettings = aacSettings
            self.ac3Settings = ac3Settings
        }

        private enum CodingKeys: String, CodingKey {
            case aiffSettings = "aiffSettings"
            case wavSettings = "wavSettings"
            case eac3Settings = "eac3Settings"
            case codec = "codec"
            case mp2Settings = "mp2Settings"
            case aacSettings = "aacSettings"
            case ac3Settings = "ac3Settings"
        }
    }

    public enum CmafInitializationVectorInManifest: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public enum HlsInitializationVectorInManifest: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public struct AudioSelectorGroup: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AudioSelectorNames", location: .body(locationName: "audioSelectorNames"), required: false, type: .list)
        ]
        /// Name of an Audio Selector within the same input to include in the group.  Audio selector names are standardized, based on their order within the input (e.g., "Audio Selector 1"). The audio selector name parameter can be repeated to add any number of audio selectors to the group.
        public let audioSelectorNames: [String]?

        public init(audioSelectorNames: [String]? = nil) {
            self.audioSelectorNames = audioSelectorNames
        }

        private enum CodingKeys: String, CodingKey {
            case audioSelectorNames = "audioSelectorNames"
        }
    }

    public enum AudioTypeControl: String, CustomStringConvertible, Codable {
        case followInput = "FOLLOW_INPUT"
        case useConfigured = "USE_CONFIGURED"
        public var description: String { return self.rawValue }
    }

    public enum CmafClientCache: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum CaptionDestinationType: String, CustomStringConvertible, Codable {
        case burnIn = "BURN_IN"
        case dvbSub = "DVB_SUB"
        case embedded = "EMBEDDED"
        case embeddedPlusScte20 = "EMBEDDED_PLUS_SCTE20"
        case scte20PlusEmbedded = "SCTE20_PLUS_EMBEDDED"
        case scc = "SCC"
        case srt = "SRT"
        case smi = "SMI"
        case teletext = "TELETEXT"
        case ttml = "TTML"
        case webvtt = "WEBVTT"
        public var description: String { return self.rawValue }
    }

    public struct GetPresetResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Preset", location: .body(locationName: "preset"), required: false, type: .structure)
        ]
        public let preset: Preset?

        public init(preset: Preset? = nil) {
            self.preset = preset
        }

        private enum CodingKeys: String, CodingKey {
            case preset = "preset"
        }
    }

    public struct AiffSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BitDepth", location: .body(locationName: "bitDepth"), required: false, type: .integer), 
            AWSShapeMember(label: "SampleRate", location: .body(locationName: "sampleRate"), required: false, type: .integer), 
            AWSShapeMember(label: "Channels", location: .body(locationName: "channels"), required: false, type: .integer)
        ]
        /// Specify Bit depth (BitDepth), in bits per sample, to choose the encoding quality for this audio track.
        public let bitDepth: Int32?
        /// Sample rate in hz.
        public let sampleRate: Int32?
        /// Set Channels to specify the number of channels in this output audio track. Choosing Mono in the console will give you 1 output channel; choosing Stereo will give you 2. In the API, valid values are 1 and 2.
        public let channels: Int32?

        public init(bitDepth: Int32? = nil, sampleRate: Int32? = nil, channels: Int32? = nil) {
            self.bitDepth = bitDepth
            self.sampleRate = sampleRate
            self.channels = channels
        }

        private enum CodingKeys: String, CodingKey {
            case bitDepth = "bitDepth"
            case sampleRate = "sampleRate"
            case channels = "channels"
        }
    }

    public enum OutputSdt: String, CustomStringConvertible, Codable {
        case sdtFollow = "SDT_FOLLOW"
        case sdtFollowIfPresent = "SDT_FOLLOW_IF_PRESENT"
        case sdtManual = "SDT_MANUAL"
        case sdtNone = "SDT_NONE"
        public var description: String { return self.rawValue }
    }

    public struct ReservationPlan: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Commitment", location: .body(locationName: "commitment"), required: false, type: .enum), 
            AWSShapeMember(label: "PurchasedAt", location: .body(locationName: "purchasedAt"), required: false, type: .timestamp), 
            AWSShapeMember(label: "Status", location: .body(locationName: "status"), required: false, type: .enum), 
            AWSShapeMember(label: "RenewalType", location: .body(locationName: "renewalType"), required: false, type: .enum), 
            AWSShapeMember(label: "ExpiresAt", location: .body(locationName: "expiresAt"), required: false, type: .timestamp), 
            AWSShapeMember(label: "ReservedSlots", location: .body(locationName: "reservedSlots"), required: false, type: .integer)
        ]
        /// The length of the term of your reserved queue pricing plan commitment.
        public let commitment: Commitment?
        /// The timestamp in epoch seconds for when you set up the current pricing plan for this reserved queue.
        public let purchasedAt: TimeStamp?
        /// Specifies whether the pricing plan for your reserved queue is ACTIVE or EXPIRED.
        public let status: ReservationPlanStatus?
        /// Specifies whether the term of your reserved queue pricing plan is automatically extended (AUTO_RENEW) or expires (EXPIRE) at the end of the term.
        public let renewalType: RenewalType?
        /// The timestamp in epoch seconds for when the current pricing plan term for this reserved queue expires.
        public let expiresAt: TimeStamp?
        /// Specifies the number of reserved transcode slots (RTS) for this queue. The number of RTS determines how many jobs the queue can process in parallel; each RTS can process one job at a time. When you increase this number, you extend your existing commitment with a new 12-month commitment for a larger number of RTS. The new commitment begins when you purchase the additional capacity. You can't decrease the number of RTS in your reserved queue.
        public let reservedSlots: Int32?

        public init(commitment: Commitment? = nil, purchasedAt: TimeStamp? = nil, status: ReservationPlanStatus? = nil, renewalType: RenewalType? = nil, expiresAt: TimeStamp? = nil, reservedSlots: Int32? = nil) {
            self.commitment = commitment
            self.purchasedAt = purchasedAt
            self.status = status
            self.renewalType = renewalType
            self.expiresAt = expiresAt
            self.reservedSlots = reservedSlots
        }

        private enum CodingKeys: String, CodingKey {
            case commitment = "commitment"
            case purchasedAt = "purchasedAt"
            case status = "status"
            case renewalType = "renewalType"
            case expiresAt = "expiresAt"
            case reservedSlots = "reservedSlots"
        }
    }

    public enum Mpeg2CodecLevel: String, CustomStringConvertible, Codable {
        case auto = "AUTO"
        case low = "LOW"
        case main = "MAIN"
        case high1440 = "HIGH1440"
        case high = "HIGH"
        public var description: String { return self.rawValue }
    }

    public enum Eac3LfeControl: String, CustomStringConvertible, Codable {
        case lfe = "LFE"
        case noLfe = "NO_LFE"
        public var description: String { return self.rawValue }
    }

    public struct RemixSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChannelMapping", location: .body(locationName: "channelMapping"), required: false, type: .structure), 
            AWSShapeMember(label: "ChannelsOut", location: .body(locationName: "channelsOut"), required: false, type: .integer), 
            AWSShapeMember(label: "ChannelsIn", location: .body(locationName: "channelsIn"), required: false, type: .integer)
        ]
        public let channelMapping: ChannelMapping?
        /// Specify the number of channels in this output after remixing. Valid values: 1, 2, 4, 6, 8
        public let channelsOut: Int32?
        /// Specify the number of audio channels from your input that you want to use in your output. With remixing, you might combine or split the data in these channels, so the number of channels in your final output might be different.
        public let channelsIn: Int32?

        public init(channelMapping: ChannelMapping? = nil, channelsOut: Int32? = nil, channelsIn: Int32? = nil) {
            self.channelMapping = channelMapping
            self.channelsOut = channelsOut
            self.channelsIn = channelsIn
        }

        private enum CodingKeys: String, CodingKey {
            case channelMapping = "channelMapping"
            case channelsOut = "channelsOut"
            case channelsIn = "channelsIn"
        }
    }

    public struct UntagResourceResponse: AWSShape {

    }

    public struct UntagResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TagKeys", location: .body(locationName: "tagKeys"), required: false, type: .list), 
            AWSShapeMember(label: "Arn", location: .uri(locationName: "arn"), required: true, type: .string)
        ]
        /// The keys of the tags that you want to remove from the resource.
        public let tagKeys: [String]?
        /// The Amazon Resource Name (ARN) of the resource that you want to remove tags from. To get the ARN, send a GET request with the resource name.
        public let arn: String

        public init(tagKeys: [String]? = nil, arn: String) {
            self.tagKeys = tagKeys
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case tagKeys = "tagKeys"
            case arn = "arn"
        }
    }

    public enum ProresCodecProfile: String, CustomStringConvertible, Codable {
        case appleProres422 = "APPLE_PRORES_422"
        case appleProres422Hq = "APPLE_PRORES_422_HQ"
        case appleProres422Lt = "APPLE_PRORES_422_LT"
        case appleProres422Proxy = "APPLE_PRORES_422_PROXY"
        public var description: String { return self.rawValue }
    }

    public enum HlsProgramDateTime: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public struct UpdatePresetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", location: .uri(locationName: "name"), required: true, type: .string), 
            AWSShapeMember(label: "Settings", location: .body(locationName: "settings"), required: false, type: .structure), 
            AWSShapeMember(label: "Category", location: .body(locationName: "category"), required: false, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string)
        ]
        /// The name of the preset you are modifying.
        public let name: String
        public let settings: PresetSettings?
        /// The new category for the preset, if you are changing it.
        public let category: String?
        /// The new description for the preset, if you are changing it.
        public let description: String?

        public init(name: String, settings: PresetSettings? = nil, category: String? = nil, description: String? = nil) {
            self.name = name
            self.settings = settings
            self.category = category
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case settings = "settings"
            case category = "category"
            case description = "description"
        }
    }

}