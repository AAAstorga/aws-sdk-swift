// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Inspector {

    public struct DescribeRulesPackagesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN that specifies the rules package that you want to describe.
        public let rulesPackageArns: [String]
        /// The locale that you want to translate a rules package description into.
        public let locale: Locale?

        public init(rulesPackageArns: [String], locale: Locale? = nil) {
            self.rulesPackageArns = rulesPackageArns
            self.locale = locale
        }

        public init(dictionary: [String: Any]) throws {
            guard let rulesPackageArns = dictionary["rulesPackageArns"] as? [String] else { throw InitializableError.missingRequiredParam("rulesPackageArns") }
            self.rulesPackageArns = rulesPackageArns
            if let locale = dictionary["locale"] as? String { self.locale = Locale(rawValue: locale) } else { self.locale = nil }
        }
    }

    public enum InspectorEvent: String, CustomStringConvertible {
        case assessment_run_started = "ASSESSMENT_RUN_STARTED"
        case assessment_run_completed = "ASSESSMENT_RUN_COMPLETED"
        case assessment_run_state_changed = "ASSESSMENT_RUN_STATE_CHANGED"
        case finding_reported = "FINDING_REPORTED"
        case other = "OTHER"
        public var description: String { return self.rawValue }
    }

    public struct RemoveAttributesFromFindingsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Attributes details that cannot be described. An error code is provided for each failed item.
        public let failedItems: [String: FailedItemDetails]

        public init(failedItems: [String: FailedItemDetails]) {
            self.failedItems = failedItems
        }

        public init(dictionary: [String: Any]) throws {
            guard let failedItems = dictionary["failedItems"] as? [String: Any] else { throw InitializableError.missingRequiredParam("failedItems") }
            var failedItemsDict: [String: FailedItemDetails] = [:]
            for (key, value) in failedItems {
                guard let failedItemDetailsDict = value as? [String: Any] else { throw InitializableError.convertingError }
                failedItemsDict[key] = try FailedItemDetails(dictionary: failedItemDetailsDict)
            }
            self.failedItems = failedItemsDict
        }
    }

    public enum AccessDeniedErrorCode: String, CustomStringConvertible {
        case access_denied_to_assessment_target = "ACCESS_DENIED_TO_ASSESSMENT_TARGET"
        case access_denied_to_assessment_template = "ACCESS_DENIED_TO_ASSESSMENT_TEMPLATE"
        case access_denied_to_assessment_run = "ACCESS_DENIED_TO_ASSESSMENT_RUN"
        case access_denied_to_finding = "ACCESS_DENIED_TO_FINDING"
        case access_denied_to_resource_group = "ACCESS_DENIED_TO_RESOURCE_GROUP"
        case access_denied_to_rules_package = "ACCESS_DENIED_TO_RULES_PACKAGE"
        case access_denied_to_sns_topic = "ACCESS_DENIED_TO_SNS_TOPIC"
        case access_denied_to_iam_role = "ACCESS_DENIED_TO_IAM_ROLE"
        public var description: String { return self.rawValue }
    }

    public struct DescribeResourceGroupsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN that specifies the resource group that you want to describe.
        public let resourceGroupArns: [String]

        public init(resourceGroupArns: [String]) {
            self.resourceGroupArns = resourceGroupArns
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceGroupArns = dictionary["resourceGroupArns"] as? [String] else { throw InitializableError.missingRequiredParam("resourceGroupArns") }
            self.resourceGroupArns = resourceGroupArns
        }
    }

    public struct ListFindingsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 10. The maximum value is 500.
        public let maxResults: Int32?
        /// You can use this parameter to specify a subset of data to be included in the action's response. For a record to match a filter, all specified filter attributes must match. When multiple values are specified for a filter attribute, any of the values can match.
        public let filter: FindingFilter?
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the ListFindings action. Subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?
        /// The ARNs of the assessment runs that generate the findings that you want to list.
        public let assessmentRunArns: [String]?

        public init(maxResults: Int32? = nil, filter: FindingFilter? = nil, nextToken: String? = nil, assessmentRunArns: [String]? = nil) {
            self.maxResults = maxResults
            self.filter = filter
            self.nextToken = nextToken
            self.assessmentRunArns = assessmentRunArns
        }

        public init(dictionary: [String: Any]) throws {
            self.maxResults = dictionary["maxResults"] as? Int32
            if let filter = dictionary["filter"] as? [String: Any] { self.filter = try Inspector.FindingFilter(dictionary: filter) } else { self.filter = nil }
            self.nextToken = dictionary["nextToken"] as? String
            self.assessmentRunArns = dictionary["assessmentRunArns"] as? [String]
        }
    }

    public struct DescribeCrossAccountAccessRoleResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A Boolean value that specifies whether the IAM role has the necessary policies attached to enable Amazon Inspector to access your AWS account.
        public let valid: Bool
        /// The ARN that specifies the IAM role that Amazon Inspector uses to access your AWS account.
        public let roleArn: String
        /// The date when the cross-account access role was registered.
        public let registeredAt: Date

        public init(valid: Bool, roleArn: String, registeredAt: Date) {
            self.valid = valid
            self.roleArn = roleArn
            self.registeredAt = registeredAt
        }

        public init(dictionary: [String: Any]) throws {
            guard let valid = dictionary["valid"] as? Bool else { throw InitializableError.missingRequiredParam("valid") }
            self.valid = valid
            guard let roleArn = dictionary["roleArn"] as? String else { throw InitializableError.missingRequiredParam("roleArn") }
            self.roleArn = roleArn
            guard let registeredAt = dictionary["registeredAt"] as? Date else { throw InitializableError.missingRequiredParam("registeredAt") }
            self.registeredAt = registeredAt
        }
    }

    public struct PreviewAgentsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the assessment target whose agents you want to preview.
        public let previewAgentsArn: String
        /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 10. The maximum value is 500.
        public let maxResults: Int32?
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the PreviewAgents action. Subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?

        public init(previewAgentsArn: String, maxResults: Int32? = nil, nextToken: String? = nil) {
            self.previewAgentsArn = previewAgentsArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            guard let previewAgentsArn = dictionary["previewAgentsArn"] as? String else { throw InitializableError.missingRequiredParam("previewAgentsArn") }
            self.previewAgentsArn = previewAgentsArn
            self.maxResults = dictionary["maxResults"] as? Int32
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct DescribeRulesPackagesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the rules package.
        public let rulesPackages: [RulesPackage]
        /// Rules package details that cannot be described. An error code is provided for each failed item.
        public let failedItems: [String: FailedItemDetails]

        public init(rulesPackages: [RulesPackage], failedItems: [String: FailedItemDetails]) {
            self.rulesPackages = rulesPackages
            self.failedItems = failedItems
        }

        public init(dictionary: [String: Any]) throws {
            guard let rulesPackages = dictionary["rulesPackages"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("rulesPackages") }
            self.rulesPackages = try rulesPackages.map({ try RulesPackage(dictionary: $0) })
            guard let failedItems = dictionary["failedItems"] as? [String: Any] else { throw InitializableError.missingRequiredParam("failedItems") }
            var failedItemsDict: [String: FailedItemDetails] = [:]
            for (key, value) in failedItems {
                guard let failedItemDetailsDict = value as? [String: Any] else { throw InitializableError.convertingError }
                failedItemsDict[key] = try FailedItemDetails(dictionary: failedItemDetailsDict)
            }
            self.failedItems = failedItemsDict
        }
    }

    public struct Subscription: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the assessment template that is used during the event for which the SNS notification is sent.
        public let resourceArn: String
        /// The list of existing event subscriptions.
        public let eventSubscriptions: [EventSubscription]
        /// The ARN of the Amazon Simple Notification Service (SNS) topic to which the SNS notifications are sent.
        public let topicArn: String

        public init(resourceArn: String, eventSubscriptions: [EventSubscription], topicArn: String) {
            self.resourceArn = resourceArn
            self.eventSubscriptions = eventSubscriptions
            self.topicArn = topicArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceArn = dictionary["resourceArn"] as? String else { throw InitializableError.missingRequiredParam("resourceArn") }
            self.resourceArn = resourceArn
            guard let eventSubscriptions = dictionary["eventSubscriptions"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("eventSubscriptions") }
            self.eventSubscriptions = try eventSubscriptions.map({ try EventSubscription(dictionary: $0) })
            guard let topicArn = dictionary["topicArn"] as? String else { throw InitializableError.missingRequiredParam("topicArn") }
            self.topicArn = topicArn
        }
    }

    public struct AssessmentTarget: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN that specifies the resource group that is associated with the assessment target.
        public let resourceGroupArn: String
        /// The name of the Amazon Inspector assessment target.
        public let name: String
        /// The time at which UpdateAssessmentTarget is called.
        public let updatedAt: Date
        /// The time at which the assessment target is created.
        public let createdAt: Date
        /// The ARN that specifies the Amazon Inspector assessment target.
        public let arn: String

        public init(resourceGroupArn: String, name: String, updatedAt: Date, createdAt: Date, arn: String) {
            self.resourceGroupArn = resourceGroupArn
            self.name = name
            self.updatedAt = updatedAt
            self.createdAt = createdAt
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceGroupArn = dictionary["resourceGroupArn"] as? String else { throw InitializableError.missingRequiredParam("resourceGroupArn") }
            self.resourceGroupArn = resourceGroupArn
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
            guard let updatedAt = dictionary["updatedAt"] as? Date else { throw InitializableError.missingRequiredParam("updatedAt") }
            self.updatedAt = updatedAt
            guard let createdAt = dictionary["createdAt"] as? Date else { throw InitializableError.missingRequiredParam("createdAt") }
            self.createdAt = createdAt
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct DescribeAssessmentTemplatesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let assessmentTemplateArns: [String]

        public init(assessmentTemplateArns: [String]) {
            self.assessmentTemplateArns = assessmentTemplateArns
        }

        public init(dictionary: [String: Any]) throws {
            guard let assessmentTemplateArns = dictionary["assessmentTemplateArns"] as? [String] else { throw InitializableError.missingRequiredParam("assessmentTemplateArns") }
            self.assessmentTemplateArns = assessmentTemplateArns
        }
    }

    public struct AddAttributesToFindingsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The array of attributes that you want to assign to specified findings.
        public let attributes: [Attribute]
        /// The ARNs that specify the findings that you want to assign attributes to.
        public let findingArns: [String]

        public init(attributes: [Attribute], findingArns: [String]) {
            self.attributes = attributes
            self.findingArns = findingArns
        }

        public init(dictionary: [String: Any]) throws {
            guard let attributes = dictionary["attributes"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("attributes") }
            self.attributes = try attributes.map({ try Attribute(dictionary: $0) })
            guard let findingArns = dictionary["findingArns"] as? [String] else { throw InitializableError.missingRequiredParam("findingArns") }
            self.findingArns = findingArns
        }
    }

    public struct PreviewAgentsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        ///  When a response is generated, if there is more data to be listed, this parameter is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
        public let nextToken: String?
        /// The resulting list of agents.
        public let agentPreviews: [AgentPreview]

        public init(nextToken: String? = nil, agentPreviews: [AgentPreview]) {
            self.nextToken = nextToken
            self.agentPreviews = agentPreviews
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            guard let agentPreviews = dictionary["agentPreviews"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("agentPreviews") }
            self.agentPreviews = try agentPreviews.map({ try AgentPreview(dictionary: $0) })
        }
    }

    public struct DescribeAssessmentRunsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Assessment run details that cannot be described. An error code is provided for each failed item.
        public let failedItems: [String: FailedItemDetails]
        /// Information about the assessment run.
        public let assessmentRuns: [AssessmentRun]

        public init(failedItems: [String: FailedItemDetails], assessmentRuns: [AssessmentRun]) {
            self.failedItems = failedItems
            self.assessmentRuns = assessmentRuns
        }

        public init(dictionary: [String: Any]) throws {
            guard let failedItems = dictionary["failedItems"] as? [String: Any] else { throw InitializableError.missingRequiredParam("failedItems") }
            var failedItemsDict: [String: FailedItemDetails] = [:]
            for (key, value) in failedItems {
                guard let failedItemDetailsDict = value as? [String: Any] else { throw InitializableError.convertingError }
                failedItemsDict[key] = try FailedItemDetails(dictionary: failedItemDetailsDict)
            }
            self.failedItems = failedItemsDict
            guard let assessmentRuns = dictionary["assessmentRuns"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("assessmentRuns") }
            self.assessmentRuns = try assessmentRuns.map({ try AssessmentRun(dictionary: $0) })
        }
    }

    public struct EventSubscription: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The event for which Amazon Simple Notification Service (SNS) notifications are sent.
        public let event: InspectorEvent
        /// The time at which SubscribeToEvent is called.
        public let subscribedAt: Date

        public init(event: InspectorEvent, subscribedAt: Date) {
            self.event = event
            self.subscribedAt = subscribedAt
        }

        public init(dictionary: [String: Any]) throws {
            guard let rawevent = dictionary["event"] as? String, let event = InspectorEvent(rawValue: rawevent) else { throw InitializableError.missingRequiredParam("event") }
            self.event = event
            guard let subscribedAt = dictionary["subscribedAt"] as? Date else { throw InitializableError.missingRequiredParam("subscribedAt") }
            self.subscribedAt = subscribedAt
        }
    }

    public struct CreateResourceGroupResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN that specifies the resource group that is created.
        public let resourceGroupArn: String

        public init(resourceGroupArn: String) {
            self.resourceGroupArn = resourceGroupArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceGroupArn = dictionary["resourceGroupArn"] as? String else { throw InitializableError.missingRequiredParam("resourceGroupArn") }
            self.resourceGroupArn = resourceGroupArn
        }
    }

    public struct ResourceGroupTag: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A tag key.
        public let key: String
        /// The value assigned to a tag key.
        public let value: String?

        public init(key: String, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public init(dictionary: [String: Any]) throws {
            guard let key = dictionary["key"] as? String else { throw InitializableError.missingRequiredParam("key") }
            self.key = key
            self.value = dictionary["value"] as? String
        }
    }

    public struct RemoveAttributesFromFindingsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The array of attribute keys that you want to remove from specified findings.
        public let attributeKeys: [String]
        /// The ARNs that specify the findings that you want to remove attributes from.
        public let findingArns: [String]

        public init(attributeKeys: [String], findingArns: [String]) {
            self.attributeKeys = attributeKeys
            self.findingArns = findingArns
        }

        public init(dictionary: [String: Any]) throws {
            guard let attributeKeys = dictionary["attributeKeys"] as? [String] else { throw InitializableError.missingRequiredParam("attributeKeys") }
            self.attributeKeys = attributeKeys
            guard let findingArns = dictionary["findingArns"] as? [String] else { throw InitializableError.missingRequiredParam("findingArns") }
            self.findingArns = findingArns
        }
    }

    public struct DescribeAssessmentRunsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN that specifies the assessment run that you want to describe.
        public let assessmentRunArns: [String]

        public init(assessmentRunArns: [String]) {
            self.assessmentRunArns = assessmentRunArns
        }

        public init(dictionary: [String: Any]) throws {
            guard let assessmentRunArns = dictionary["assessmentRunArns"] as? [String] else { throw InitializableError.missingRequiredParam("assessmentRunArns") }
            self.assessmentRunArns = assessmentRunArns
        }
    }

    public struct ListAssessmentTemplatesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of ARNs that specifies the assessment templates returned by the action.
        public let assessmentTemplateArns: [String]
        ///  When a response is generated, if there is more data to be listed, this parameter is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
        public let nextToken: String?

        public init(assessmentTemplateArns: [String], nextToken: String? = nil) {
            self.assessmentTemplateArns = assessmentTemplateArns
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            guard let assessmentTemplateArns = dictionary["assessmentTemplateArns"] as? [String] else { throw InitializableError.missingRequiredParam("assessmentTemplateArns") }
            self.assessmentTemplateArns = assessmentTemplateArns
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct DescribeAssessmentTemplatesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Assessment template details that cannot be described. An error code is provided for each failed item.
        public let failedItems: [String: FailedItemDetails]
        /// Information about the assessment templates.
        public let assessmentTemplates: [AssessmentTemplate]

        public init(failedItems: [String: FailedItemDetails], assessmentTemplates: [AssessmentTemplate]) {
            self.failedItems = failedItems
            self.assessmentTemplates = assessmentTemplates
        }

        public init(dictionary: [String: Any]) throws {
            guard let failedItems = dictionary["failedItems"] as? [String: Any] else { throw InitializableError.missingRequiredParam("failedItems") }
            var failedItemsDict: [String: FailedItemDetails] = [:]
            for (key, value) in failedItems {
                guard let failedItemDetailsDict = value as? [String: Any] else { throw InitializableError.convertingError }
                failedItemsDict[key] = try FailedItemDetails(dictionary: failedItemDetailsDict)
            }
            self.failedItems = failedItemsDict
            guard let assessmentTemplates = dictionary["assessmentTemplates"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("assessmentTemplates") }
            self.assessmentTemplates = try assessmentTemplates.map({ try AssessmentTemplate(dictionary: $0) })
        }
    }

    public enum AssetType: String, CustomStringConvertible {
        case ec2_instance = "ec2-instance"
        public var description: String { return self.rawValue }
    }

    public struct StartAssessmentRunResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the assessment run that has been started.
        public let assessmentRunArn: String

        public init(assessmentRunArn: String) {
            self.assessmentRunArn = assessmentRunArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let assessmentRunArn = dictionary["assessmentRunArn"] as? String else { throw InitializableError.missingRequiredParam("assessmentRunArn") }
            self.assessmentRunArn = assessmentRunArn
        }
    }

    public struct Tag: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A tag key.
        public let key: String
        /// A value assigned to a tag key.
        public let value: String?

        public init(key: String, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public init(dictionary: [String: Any]) throws {
            guard let key = dictionary["key"] as? String else { throw InitializableError.missingRequiredParam("key") }
            self.key = key
            self.value = dictionary["value"] as? String
        }
    }

    public enum LimitExceededErrorCode: String, CustomStringConvertible {
        case assessment_target_limit_exceeded = "ASSESSMENT_TARGET_LIMIT_EXCEEDED"
        case assessment_template_limit_exceeded = "ASSESSMENT_TEMPLATE_LIMIT_EXCEEDED"
        case assessment_run_limit_exceeded = "ASSESSMENT_RUN_LIMIT_EXCEEDED"
        case resource_group_limit_exceeded = "RESOURCE_GROUP_LIMIT_EXCEEDED"
        case event_subscription_limit_exceeded = "EVENT_SUBSCRIPTION_LIMIT_EXCEEDED"
        public var description: String { return self.rawValue }
    }

    public struct ListAssessmentTargetsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        ///  When a response is generated, if there is more data to be listed, this parameter is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
        public let nextToken: String?
        /// A list of ARNs that specifies the assessment targets that are returned by the action.
        public let assessmentTargetArns: [String]

        public init(nextToken: String? = nil, assessmentTargetArns: [String]) {
            self.nextToken = nextToken
            self.assessmentTargetArns = assessmentTargetArns
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            guard let assessmentTargetArns = dictionary["assessmentTargetArns"] as? [String] else { throw InitializableError.missingRequiredParam("assessmentTargetArns") }
            self.assessmentTargetArns = assessmentTargetArns
        }
    }

    public struct ResourceGroup: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The tags (key and value pairs) of the resource group. This data type property is used in the CreateResourceGroup action.
        public let tags: [ResourceGroupTag]
        /// The time at which resource group is created.
        public let createdAt: Date
        /// The ARN of the resource group.
        public let arn: String

        public init(tags: [ResourceGroupTag], createdAt: Date, arn: String) {
            self.tags = tags
            self.createdAt = createdAt
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let tags = dictionary["tags"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("tags") }
            self.tags = try tags.map({ try ResourceGroupTag(dictionary: $0) })
            guard let createdAt = dictionary["createdAt"] as? Date else { throw InitializableError.missingRequiredParam("createdAt") }
            self.createdAt = createdAt
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct UnsubscribeFromEventRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the assessment template that is used during the event for which you want to stop receiving SNS notifications.
        public let resourceArn: String
        /// The event for which you want to stop receiving SNS notifications.
        public let event: InspectorEvent
        /// The ARN of the SNS topic to which SNS notifications are sent.
        public let topicArn: String

        public init(resourceArn: String, event: InspectorEvent, topicArn: String) {
            self.resourceArn = resourceArn
            self.event = event
            self.topicArn = topicArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceArn = dictionary["resourceArn"] as? String else { throw InitializableError.missingRequiredParam("resourceArn") }
            self.resourceArn = resourceArn
            guard let rawevent = dictionary["event"] as? String, let event = InspectorEvent(rawValue: rawevent) else { throw InitializableError.missingRequiredParam("event") }
            self.event = event
            guard let topicArn = dictionary["topicArn"] as? String else { throw InitializableError.missingRequiredParam("topicArn") }
            self.topicArn = topicArn
        }
    }

    public struct Attribute: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The attribute key.
        public let key: String
        /// The value assigned to the attribute key.
        public let value: String?

        public init(key: String, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public init(dictionary: [String: Any]) throws {
            guard let key = dictionary["key"] as? String else { throw InitializableError.missingRequiredParam("key") }
            self.key = key
            self.value = dictionary["value"] as? String
        }
    }

    public struct DeleteAssessmentTemplateRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN that specifies the assessment template that you want to delete.
        public let assessmentTemplateArn: String

        public init(assessmentTemplateArn: String) {
            self.assessmentTemplateArn = assessmentTemplateArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let assessmentTemplateArn = dictionary["assessmentTemplateArn"] as? String else { throw InitializableError.missingRequiredParam("assessmentTemplateArn") }
            self.assessmentTemplateArn = assessmentTemplateArn
        }
    }

    public struct DescribeAssessmentTargetsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARNs that specifies the assessment targets that you want to describe.
        public let assessmentTargetArns: [String]

        public init(assessmentTargetArns: [String]) {
            self.assessmentTargetArns = assessmentTargetArns
        }

        public init(dictionary: [String: Any]) throws {
            guard let assessmentTargetArns = dictionary["assessmentTargetArns"] as? [String] else { throw InitializableError.missingRequiredParam("assessmentTargetArns") }
            self.assessmentTargetArns = assessmentTargetArns
        }
    }

    public struct DeleteAssessmentRunRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN that specifies the assessment run that you want to delete.
        public let assessmentRunArn: String

        public init(assessmentRunArn: String) {
            self.assessmentRunArn = assessmentRunArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let assessmentRunArn = dictionary["assessmentRunArn"] as? String else { throw InitializableError.missingRequiredParam("assessmentRunArn") }
            self.assessmentRunArn = assessmentRunArn
        }
    }

    public struct FindingFilter: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the ruleName property of the Finding data type.
        public let ruleNames: [String]?
        /// For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the severity property of the Finding data type.
        public let severities: [Severity]?
        /// For a record to match a filter, the list of values that are specified for this data type property must be contained in the list of values of the attributes property of the Finding data type.
        public let attributes: [Attribute]?
        /// For a record to match a filter, the value that is specified for this data type property must be contained in the list of values of the userAttributes property of the Finding data type.
        public let userAttributes: [Attribute]?
        /// For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the agentId property of the Finding data type.
        public let agentIds: [String]?
        /// For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the rulesPackageArn property of the Finding data type.
        public let rulesPackageArns: [String]?
        /// The time range during which the finding is generated.
        public let creationTimeRange: TimestampRange?
        /// For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the autoScalingGroup property of the Finding data type.
        public let autoScalingGroups: [String]?

        public init(ruleNames: [String]? = nil, severities: [Severity]? = nil, attributes: [Attribute]? = nil, userAttributes: [Attribute]? = nil, agentIds: [String]? = nil, rulesPackageArns: [String]? = nil, creationTimeRange: TimestampRange? = nil, autoScalingGroups: [String]? = nil) {
            self.ruleNames = ruleNames
            self.severities = severities
            self.attributes = attributes
            self.userAttributes = userAttributes
            self.agentIds = agentIds
            self.rulesPackageArns = rulesPackageArns
            self.creationTimeRange = creationTimeRange
            self.autoScalingGroups = autoScalingGroups
        }

        public init(dictionary: [String: Any]) throws {
            self.ruleNames = dictionary["ruleNames"] as? [String]
            if let severities = dictionary["severities"] as? [String] { self.severities = severities.flatMap({ Severity(rawValue: $0)}) } else { self.severities = nil }
            if let attributes = dictionary["attributes"] as? [[String: Any]] {
                self.attributes = try attributes.map({ try Attribute(dictionary: $0) })
            } else { 
                self.attributes = nil
            }
            if let userAttributes = dictionary["userAttributes"] as? [[String: Any]] {
                self.userAttributes = try userAttributes.map({ try Attribute(dictionary: $0) })
            } else { 
                self.userAttributes = nil
            }
            self.agentIds = dictionary["agentIds"] as? [String]
            self.rulesPackageArns = dictionary["rulesPackageArns"] as? [String]
            if let creationTimeRange = dictionary["creationTimeRange"] as? [String: Any] { self.creationTimeRange = try Inspector.TimestampRange(dictionary: creationTimeRange) } else { self.creationTimeRange = nil }
            self.autoScalingGroups = dictionary["autoScalingGroups"] as? [String]
        }
    }

    public enum InvalidInputErrorCode: String, CustomStringConvertible {
        case invalid_assessment_target_arn = "INVALID_ASSESSMENT_TARGET_ARN"
        case invalid_assessment_template_arn = "INVALID_ASSESSMENT_TEMPLATE_ARN"
        case invalid_assessment_run_arn = "INVALID_ASSESSMENT_RUN_ARN"
        case invalid_finding_arn = "INVALID_FINDING_ARN"
        case invalid_resource_group_arn = "INVALID_RESOURCE_GROUP_ARN"
        case invalid_rules_package_arn = "INVALID_RULES_PACKAGE_ARN"
        case invalid_resource_arn = "INVALID_RESOURCE_ARN"
        case invalid_sns_topic_arn = "INVALID_SNS_TOPIC_ARN"
        case invalid_iam_role_arn = "INVALID_IAM_ROLE_ARN"
        case invalid_assessment_target_name = "INVALID_ASSESSMENT_TARGET_NAME"
        case invalid_assessment_target_name_pattern = "INVALID_ASSESSMENT_TARGET_NAME_PATTERN"
        case invalid_assessment_template_name = "INVALID_ASSESSMENT_TEMPLATE_NAME"
        case invalid_assessment_template_name_pattern = "INVALID_ASSESSMENT_TEMPLATE_NAME_PATTERN"
        case invalid_assessment_template_duration = "INVALID_ASSESSMENT_TEMPLATE_DURATION"
        case invalid_assessment_template_duration_range = "INVALID_ASSESSMENT_TEMPLATE_DURATION_RANGE"
        case invalid_assessment_run_duration_range = "INVALID_ASSESSMENT_RUN_DURATION_RANGE"
        case invalid_assessment_run_start_time_range = "INVALID_ASSESSMENT_RUN_START_TIME_RANGE"
        case invalid_assessment_run_completion_time_range = "INVALID_ASSESSMENT_RUN_COMPLETION_TIME_RANGE"
        case invalid_assessment_run_state_change_time_range = "INVALID_ASSESSMENT_RUN_STATE_CHANGE_TIME_RANGE"
        case invalid_assessment_run_state = "INVALID_ASSESSMENT_RUN_STATE"
        case invalid_tag = "INVALID_TAG"
        case invalid_tag_key = "INVALID_TAG_KEY"
        case invalid_tag_value = "INVALID_TAG_VALUE"
        case invalid_resource_group_tag_key = "INVALID_RESOURCE_GROUP_TAG_KEY"
        case invalid_resource_group_tag_value = "INVALID_RESOURCE_GROUP_TAG_VALUE"
        case invalid_attribute = "INVALID_ATTRIBUTE"
        case invalid_user_attribute = "INVALID_USER_ATTRIBUTE"
        case invalid_user_attribute_key = "INVALID_USER_ATTRIBUTE_KEY"
        case invalid_user_attribute_value = "INVALID_USER_ATTRIBUTE_VALUE"
        case invalid_pagination_token = "INVALID_PAGINATION_TOKEN"
        case invalid_max_results = "INVALID_MAX_RESULTS"
        case invalid_agent_id = "INVALID_AGENT_ID"
        case invalid_auto_scaling_group = "INVALID_AUTO_SCALING_GROUP"
        case invalid_rule_name = "INVALID_RULE_NAME"
        case invalid_severity = "INVALID_SEVERITY"
        case invalid_locale = "INVALID_LOCALE"
        case invalid_event = "INVALID_EVENT"
        case assessment_target_name_already_taken = "ASSESSMENT_TARGET_NAME_ALREADY_TAKEN"
        case assessment_template_name_already_taken = "ASSESSMENT_TEMPLATE_NAME_ALREADY_TAKEN"
        case invalid_number_of_assessment_target_arns = "INVALID_NUMBER_OF_ASSESSMENT_TARGET_ARNS"
        case invalid_number_of_assessment_template_arns = "INVALID_NUMBER_OF_ASSESSMENT_TEMPLATE_ARNS"
        case invalid_number_of_assessment_run_arns = "INVALID_NUMBER_OF_ASSESSMENT_RUN_ARNS"
        case invalid_number_of_finding_arns = "INVALID_NUMBER_OF_FINDING_ARNS"
        case invalid_number_of_resource_group_arns = "INVALID_NUMBER_OF_RESOURCE_GROUP_ARNS"
        case invalid_number_of_rules_package_arns = "INVALID_NUMBER_OF_RULES_PACKAGE_ARNS"
        case invalid_number_of_assessment_run_states = "INVALID_NUMBER_OF_ASSESSMENT_RUN_STATES"
        case invalid_number_of_tags = "INVALID_NUMBER_OF_TAGS"
        case invalid_number_of_resource_group_tags = "INVALID_NUMBER_OF_RESOURCE_GROUP_TAGS"
        case invalid_number_of_attributes = "INVALID_NUMBER_OF_ATTRIBUTES"
        case invalid_number_of_user_attributes = "INVALID_NUMBER_OF_USER_ATTRIBUTES"
        case invalid_number_of_agent_ids = "INVALID_NUMBER_OF_AGENT_IDS"
        case invalid_number_of_auto_scaling_groups = "INVALID_NUMBER_OF_AUTO_SCALING_GROUPS"
        case invalid_number_of_rule_names = "INVALID_NUMBER_OF_RULE_NAMES"
        case invalid_number_of_severities = "INVALID_NUMBER_OF_SEVERITIES"
        public var description: String { return self.rawValue }
    }

    public enum NoSuchEntityErrorCode: String, CustomStringConvertible {
        case assessment_target_does_not_exist = "ASSESSMENT_TARGET_DOES_NOT_EXIST"
        case assessment_template_does_not_exist = "ASSESSMENT_TEMPLATE_DOES_NOT_EXIST"
        case assessment_run_does_not_exist = "ASSESSMENT_RUN_DOES_NOT_EXIST"
        case finding_does_not_exist = "FINDING_DOES_NOT_EXIST"
        case resource_group_does_not_exist = "RESOURCE_GROUP_DOES_NOT_EXIST"
        case rules_package_does_not_exist = "RULES_PACKAGE_DOES_NOT_EXIST"
        case sns_topic_does_not_exist = "SNS_TOPIC_DOES_NOT_EXIST"
        case iam_role_does_not_exist = "IAM_ROLE_DOES_NOT_EXIST"
        public var description: String { return self.rawValue }
    }

    public enum Severity: String, CustomStringConvertible {
        case low = "Low"
        case medium = "Medium"
        case high = "High"
        case informational = "Informational"
        case undefined = "Undefined"
        public var description: String { return self.rawValue }
    }

    public struct RulesPackage: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The description of the rules package.
        public let description: String?
        /// The name of the rules package.
        public let name: String
        /// The version ID of the rules package.
        public let version: String
        /// The provider of the rules package.
        public let provider: String
        /// The ARN of the rules package.
        public let arn: String

        public init(description: String? = nil, name: String, version: String, provider: String, arn: String) {
            self.description = description
            self.name = name
            self.version = version
            self.provider = provider
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.description = dictionary["description"] as? String
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
            guard let version = dictionary["version"] as? String else { throw InitializableError.missingRequiredParam("version") }
            self.version = version
            guard let provider = dictionary["provider"] as? String else { throw InitializableError.missingRequiredParam("provider") }
            self.provider = provider
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct AssessmentRunStateChange: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The assessment run state.
        public let state: AssessmentRunState
        /// The last time the assessment run state changed.
        public let stateChangedAt: Date

        public init(state: AssessmentRunState, stateChangedAt: Date) {
            self.state = state
            self.stateChangedAt = stateChangedAt
        }

        public init(dictionary: [String: Any]) throws {
            guard let rawstate = dictionary["state"] as? String, let state = AssessmentRunState(rawValue: rawstate) else { throw InitializableError.missingRequiredParam("state") }
            self.state = state
            guard let stateChangedAt = dictionary["stateChangedAt"] as? Date else { throw InitializableError.missingRequiredParam("stateChangedAt") }
            self.stateChangedAt = stateChangedAt
        }
    }

    public struct ListFindingsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        ///  When a response is generated, if there is more data to be listed, this parameter is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
        public let nextToken: String?
        /// A list of ARNs that specifies the findings returned by the action.
        public let findingArns: [String]

        public init(nextToken: String? = nil, findingArns: [String]) {
            self.nextToken = nextToken
            self.findingArns = findingArns
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            guard let findingArns = dictionary["findingArns"] as? [String] else { throw InitializableError.missingRequiredParam("findingArns") }
            self.findingArns = findingArns
        }
    }

    public struct ListAssessmentRunsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 10. The maximum value is 500.
        public let maxResults: Int32?
        /// You can use this parameter to specify a subset of data to be included in the action's response. For a record to match a filter, all specified filter attributes must match. When multiple values are specified for a filter attribute, any of the values can match.
        public let filter: AssessmentRunFilter?
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the ListAssessmentRuns action. Subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?
        /// The ARNs that specify the assessment templates whose assessment runs you want to list.
        public let assessmentTemplateArns: [String]?

        public init(maxResults: Int32? = nil, filter: AssessmentRunFilter? = nil, nextToken: String? = nil, assessmentTemplateArns: [String]? = nil) {
            self.maxResults = maxResults
            self.filter = filter
            self.nextToken = nextToken
            self.assessmentTemplateArns = assessmentTemplateArns
        }

        public init(dictionary: [String: Any]) throws {
            self.maxResults = dictionary["maxResults"] as? Int32
            if let filter = dictionary["filter"] as? [String: Any] { self.filter = try Inspector.AssessmentRunFilter(dictionary: filter) } else { self.filter = nil }
            self.nextToken = dictionary["nextToken"] as? String
            self.assessmentTemplateArns = dictionary["assessmentTemplateArns"] as? [String]
        }
    }

    public struct AgentPreview: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Auto Scaling group for the EC2 instance where the agent is installed.
        public let autoScalingGroup: String?
        /// The ID of the EC2 instance where the agent is installed.
        public let agentId: String

        public init(autoScalingGroup: String? = nil, agentId: String) {
            self.autoScalingGroup = autoScalingGroup
            self.agentId = agentId
        }

        public init(dictionary: [String: Any]) throws {
            self.autoScalingGroup = dictionary["autoScalingGroup"] as? String
            guard let agentId = dictionary["agentId"] as? String else { throw InitializableError.missingRequiredParam("agentId") }
            self.agentId = agentId
        }
    }

    public struct ListRulesPackagesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the ListRulesPackages action. Subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?
        /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 10. The maximum value is 500.
        public let maxResults: Int32?

        public init(nextToken: String? = nil, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            self.maxResults = dictionary["maxResults"] as? Int32
        }
    }

    public struct AssessmentRunFilter: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// For a record to match a filter, an explicit value or a string containing a wildcard that is specified for this data type property must match the value of the assessmentRunName property of the AssessmentRun data type.
        public let namePattern: String?
        /// For a record to match a filter, one of the values specified for this data type property must be the exact match of the value of the assessmentRunState property of the AssessmentRun data type.
        public let states: [AssessmentRunState]?
        /// For a record to match a filter, the value that is specified for this data type property must inclusively match any value between the specified minimum and maximum values of the startTime property of the AssessmentRun data type.
        public let startTimeRange: TimestampRange?
        /// For a record to match a filter, the value that is specified for this data type property must inclusively match any value between the specified minimum and maximum values of the durationInSeconds property of the AssessmentRun data type.
        public let durationRange: DurationRange?
        /// For a record to match a filter, the value that is specified for this data type property must be contained in the list of values of the rulesPackages property of the AssessmentRun data type.
        public let rulesPackageArns: [String]?
        /// For a record to match a filter, the value that is specified for this data type property must inclusively match any value between the specified minimum and maximum values of the completedAt property of the AssessmentRun data type.
        public let completionTimeRange: TimestampRange?
        /// For a record to match a filter, the value that is specified for this data type property must match the stateChangedAt property of the AssessmentRun data type.
        public let stateChangeTimeRange: TimestampRange?

        public init(namePattern: String? = nil, states: [AssessmentRunState]? = nil, startTimeRange: TimestampRange? = nil, durationRange: DurationRange? = nil, rulesPackageArns: [String]? = nil, completionTimeRange: TimestampRange? = nil, stateChangeTimeRange: TimestampRange? = nil) {
            self.namePattern = namePattern
            self.states = states
            self.startTimeRange = startTimeRange
            self.durationRange = durationRange
            self.rulesPackageArns = rulesPackageArns
            self.completionTimeRange = completionTimeRange
            self.stateChangeTimeRange = stateChangeTimeRange
        }

        public init(dictionary: [String: Any]) throws {
            self.namePattern = dictionary["namePattern"] as? String
            if let states = dictionary["states"] as? [String] { self.states = states.flatMap({ AssessmentRunState(rawValue: $0)}) } else { self.states = nil }
            if let startTimeRange = dictionary["startTimeRange"] as? [String: Any] { self.startTimeRange = try Inspector.TimestampRange(dictionary: startTimeRange) } else { self.startTimeRange = nil }
            if let durationRange = dictionary["durationRange"] as? [String: Any] { self.durationRange = try Inspector.DurationRange(dictionary: durationRange) } else { self.durationRange = nil }
            self.rulesPackageArns = dictionary["rulesPackageArns"] as? [String]
            if let completionTimeRange = dictionary["completionTimeRange"] as? [String: Any] { self.completionTimeRange = try Inspector.TimestampRange(dictionary: completionTimeRange) } else { self.completionTimeRange = nil }
            if let stateChangeTimeRange = dictionary["stateChangeTimeRange"] as? [String: Any] { self.stateChangeTimeRange = try Inspector.TimestampRange(dictionary: stateChangeTimeRange) } else { self.stateChangeTimeRange = nil }
        }
    }

    public struct GetTelemetryMetadataRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN that specifies the assessment run that has the telemetry data that you want to obtain.
        public let assessmentRunArn: String

        public init(assessmentRunArn: String) {
            self.assessmentRunArn = assessmentRunArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let assessmentRunArn = dictionary["assessmentRunArn"] as? String else { throw InitializableError.missingRequiredParam("assessmentRunArn") }
            self.assessmentRunArn = assessmentRunArn
        }
    }

    public struct AssessmentTargetFilter: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// For a record to match a filter, an explicit value or a string that contains a wildcard that is specified for this data type property must match the value of the assessmentTargetName property of the AssessmentTarget data type.
        public let assessmentTargetNamePattern: String?

        public init(assessmentTargetNamePattern: String? = nil) {
            self.assessmentTargetNamePattern = assessmentTargetNamePattern
        }

        public init(dictionary: [String: Any]) throws {
            self.assessmentTargetNamePattern = dictionary["assessmentTargetNamePattern"] as? String
        }
    }

    public struct AssessmentRun: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The state of the assessment run.
        public let state: AssessmentRunState
        /// The auto-generated name for the assessment run.
        public let name: String
        /// The time when StartAssessmentRun was called.
        public let createdAt: Date
        /// The time when StartAssessmentRun was called.
        public let startedAt: Date?
        /// A list of notifications for the event subscriptions. A notification about a particular generated finding is added to this list only once.
        public let notifications: [AssessmentRunNotification]
        /// A Boolean value (true or false) that specifies whether the process of collecting data from the agents is completed.
        public let dataCollected: Bool
        /// The rules packages selected for the assessment run.
        public let rulesPackageArns: [String]
        /// The last time when the assessment run's state changed.
        public let stateChangedAt: Date
        /// The user-defined attributes that are assigned to every generated finding.
        public let userAttributesForFindings: [Attribute]
        /// The ARN of the assessment run.
        public let arn: String
        /// A list of the assessment run state changes.
        public let stateChanges: [AssessmentRunStateChange]
        /// The assessment run completion time that corresponds to the rules packages evaluation completion time or failure.
        public let completedAt: Date?
        /// The duration of the assessment run.
        public let durationInSeconds: Int32
        /// The ARN of the assessment template that is associated with the assessment run.
        public let assessmentTemplateArn: String

        public init(state: AssessmentRunState, name: String, createdAt: Date, startedAt: Date? = nil, notifications: [AssessmentRunNotification], dataCollected: Bool, rulesPackageArns: [String], stateChangedAt: Date, userAttributesForFindings: [Attribute], arn: String, stateChanges: [AssessmentRunStateChange], completedAt: Date? = nil, durationInSeconds: Int32, assessmentTemplateArn: String) {
            self.state = state
            self.name = name
            self.createdAt = createdAt
            self.startedAt = startedAt
            self.notifications = notifications
            self.dataCollected = dataCollected
            self.rulesPackageArns = rulesPackageArns
            self.stateChangedAt = stateChangedAt
            self.userAttributesForFindings = userAttributesForFindings
            self.arn = arn
            self.stateChanges = stateChanges
            self.completedAt = completedAt
            self.durationInSeconds = durationInSeconds
            self.assessmentTemplateArn = assessmentTemplateArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let rawstate = dictionary["state"] as? String, let state = AssessmentRunState(rawValue: rawstate) else { throw InitializableError.missingRequiredParam("state") }
            self.state = state
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
            guard let createdAt = dictionary["createdAt"] as? Date else { throw InitializableError.missingRequiredParam("createdAt") }
            self.createdAt = createdAt
            self.startedAt = dictionary["startedAt"] as? Date
            guard let notifications = dictionary["notifications"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("notifications") }
            self.notifications = try notifications.map({ try AssessmentRunNotification(dictionary: $0) })
            guard let dataCollected = dictionary["dataCollected"] as? Bool else { throw InitializableError.missingRequiredParam("dataCollected") }
            self.dataCollected = dataCollected
            guard let rulesPackageArns = dictionary["rulesPackageArns"] as? [String] else { throw InitializableError.missingRequiredParam("rulesPackageArns") }
            self.rulesPackageArns = rulesPackageArns
            guard let stateChangedAt = dictionary["stateChangedAt"] as? Date else { throw InitializableError.missingRequiredParam("stateChangedAt") }
            self.stateChangedAt = stateChangedAt
            guard let userAttributesForFindings = dictionary["userAttributesForFindings"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("userAttributesForFindings") }
            self.userAttributesForFindings = try userAttributesForFindings.map({ try Attribute(dictionary: $0) })
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
            guard let stateChanges = dictionary["stateChanges"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("stateChanges") }
            self.stateChanges = try stateChanges.map({ try AssessmentRunStateChange(dictionary: $0) })
            self.completedAt = dictionary["completedAt"] as? Date
            guard let durationInSeconds = dictionary["durationInSeconds"] as? Int32 else { throw InitializableError.missingRequiredParam("durationInSeconds") }
            self.durationInSeconds = durationInSeconds
            guard let assessmentTemplateArn = dictionary["assessmentTemplateArn"] as? String else { throw InitializableError.missingRequiredParam("assessmentTemplateArn") }
            self.assessmentTemplateArn = assessmentTemplateArn
        }
    }

    public struct ListEventSubscriptionsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Details of the returned event subscriptions.
        public let subscriptions: [Subscription]
        ///  When a response is generated, if there is more data to be listed, this parameter is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
        public let nextToken: String?

        public init(subscriptions: [Subscription], nextToken: String? = nil) {
            self.subscriptions = subscriptions
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            guard let subscriptions = dictionary["subscriptions"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("subscriptions") }
            self.subscriptions = try subscriptions.map({ try Subscription(dictionary: $0) })
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct DeleteAssessmentTargetRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN that specifies the assessment target that you want to delete.
        public let assessmentTargetArn: String

        public init(assessmentTargetArn: String) {
            self.assessmentTargetArn = assessmentTargetArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let assessmentTargetArn = dictionary["assessmentTargetArn"] as? String else { throw InitializableError.missingRequiredParam("assessmentTargetArn") }
            self.assessmentTargetArn = assessmentTargetArn
        }
    }

    public enum AgentHealth: String, CustomStringConvertible {
        case healthy = "HEALTHY"
        case unhealthy = "UNHEALTHY"
        public var description: String { return self.rawValue }
    }

    public struct CreateAssessmentTemplateResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN that specifies the assessment template that is created.
        public let assessmentTemplateArn: String

        public init(assessmentTemplateArn: String) {
            self.assessmentTemplateArn = assessmentTemplateArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let assessmentTemplateArn = dictionary["assessmentTemplateArn"] as? String else { throw InitializableError.missingRequiredParam("assessmentTemplateArn") }
            self.assessmentTemplateArn = assessmentTemplateArn
        }
    }

    public enum AssessmentRunState: String, CustomStringConvertible {
        case created = "CREATED"
        case start_data_collection_pending = "START_DATA_COLLECTION_PENDING"
        case start_data_collection_in_progress = "START_DATA_COLLECTION_IN_PROGRESS"
        case collecting_data = "COLLECTING_DATA"
        case stop_data_collection_pending = "STOP_DATA_COLLECTION_PENDING"
        case data_collected = "DATA_COLLECTED"
        case evaluating_rules = "EVALUATING_RULES"
        case failed = "FAILED"
        case completed = "COMPLETED"
        case completed_with_errors = "COMPLETED_WITH_ERRORS"
        public var description: String { return self.rawValue }
    }

    public struct Finding: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The type of the host from which the finding is generated.
        public let assetType: AssetType?
        /// The schema version of this data type.
        public let schemaVersion: Int32?
        /// The user-defined attributes that are assigned to the finding.
        public let userAttributes: [Attribute]
        /// The recommendation for the finding.
        public let recommendation: String?
        /// The time when the finding was generated.
        public let createdAt: Date
        /// The description of the finding.
        public let description: String?
        public let serviceAttributes: InspectorServiceAttributes?
        /// This data element is currently not used.
        public let indicatorOfCompromise: Bool?
        /// The finding severity. Values can be set to High, Medium, Low, and Informational.
        public let severity: Severity?
        /// A collection of attributes of the host from which the finding is generated.
        public let assetAttributes: AssetAttributes?
        /// The numeric value of the finding severity.
        public let numericSeverity: Double?
        /// The data element is set to "Inspector".
        public let service: String?
        /// The ARN that specifies the finding.
        public let arn: String
        /// The system-defined attributes for the finding.
        public let attributes: [Attribute]
        /// The ID of the finding.
        public let id: String?
        /// The time when AddAttributesToFindings is called.
        public let updatedAt: Date
        /// The name of the finding.
        public let title: String?
        /// This data element is currently not used.
        public let confidence: Int32?

        public init(assetType: AssetType? = nil, schemaVersion: Int32? = nil, userAttributes: [Attribute], recommendation: String? = nil, createdAt: Date, description: String? = nil, serviceAttributes: InspectorServiceAttributes? = nil, indicatorOfCompromise: Bool? = nil, severity: Severity? = nil, assetAttributes: AssetAttributes? = nil, numericSeverity: Double? = nil, service: String? = nil, arn: String, attributes: [Attribute], id: String? = nil, updatedAt: Date, title: String? = nil, confidence: Int32? = nil) {
            self.assetType = assetType
            self.schemaVersion = schemaVersion
            self.userAttributes = userAttributes
            self.recommendation = recommendation
            self.createdAt = createdAt
            self.description = description
            self.serviceAttributes = serviceAttributes
            self.indicatorOfCompromise = indicatorOfCompromise
            self.severity = severity
            self.assetAttributes = assetAttributes
            self.numericSeverity = numericSeverity
            self.service = service
            self.arn = arn
            self.attributes = attributes
            self.id = id
            self.updatedAt = updatedAt
            self.title = title
            self.confidence = confidence
        }

        public init(dictionary: [String: Any]) throws {
            if let assetType = dictionary["assetType"] as? String { self.assetType = AssetType(rawValue: assetType) } else { self.assetType = nil }
            self.schemaVersion = dictionary["schemaVersion"] as? Int32
            guard let userAttributes = dictionary["userAttributes"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("userAttributes") }
            self.userAttributes = try userAttributes.map({ try Attribute(dictionary: $0) })
            self.recommendation = dictionary["recommendation"] as? String
            guard let createdAt = dictionary["createdAt"] as? Date else { throw InitializableError.missingRequiredParam("createdAt") }
            self.createdAt = createdAt
            self.description = dictionary["description"] as? String
            if let serviceAttributes = dictionary["serviceAttributes"] as? [String: Any] { self.serviceAttributes = try Inspector.InspectorServiceAttributes(dictionary: serviceAttributes) } else { self.serviceAttributes = nil }
            self.indicatorOfCompromise = dictionary["indicatorOfCompromise"] as? Bool
            if let severity = dictionary["severity"] as? String { self.severity = Severity(rawValue: severity) } else { self.severity = nil }
            if let assetAttributes = dictionary["assetAttributes"] as? [String: Any] { self.assetAttributes = try Inspector.AssetAttributes(dictionary: assetAttributes) } else { self.assetAttributes = nil }
            self.numericSeverity = dictionary["numericSeverity"] as? Double
            self.service = dictionary["service"] as? String
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
            guard let attributes = dictionary["attributes"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("attributes") }
            self.attributes = try attributes.map({ try Attribute(dictionary: $0) })
            self.id = dictionary["id"] as? String
            guard let updatedAt = dictionary["updatedAt"] as? Date else { throw InitializableError.missingRequiredParam("updatedAt") }
            self.updatedAt = updatedAt
            self.title = dictionary["title"] as? String
            self.confidence = dictionary["confidence"] as? Int32
        }
    }

    public struct ListAssessmentRunAgentsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 10. The maximum value is 500.
        public let maxResults: Int32?
        /// You can use this parameter to specify a subset of data to be included in the action's response. For a record to match a filter, all specified filter attributes must match. When multiple values are specified for a filter attribute, any of the values can match.
        public let filter: AgentFilter?
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the ListAssessmentRunAgents action. Subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?
        /// The ARN that specifies the assessment run whose agents you want to list.
        public let assessmentRunArn: String

        public init(maxResults: Int32? = nil, filter: AgentFilter? = nil, nextToken: String? = nil, assessmentRunArn: String) {
            self.maxResults = maxResults
            self.filter = filter
            self.nextToken = nextToken
            self.assessmentRunArn = assessmentRunArn
        }

        public init(dictionary: [String: Any]) throws {
            self.maxResults = dictionary["maxResults"] as? Int32
            if let filter = dictionary["filter"] as? [String: Any] { self.filter = try Inspector.AgentFilter(dictionary: filter) } else { self.filter = nil }
            self.nextToken = dictionary["nextToken"] as? String
            guard let assessmentRunArn = dictionary["assessmentRunArn"] as? String else { throw InitializableError.missingRequiredParam("assessmentRunArn") }
            self.assessmentRunArn = assessmentRunArn
        }
    }

    public struct ListTagsForResourceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN that specifies the assessment template whose tags you want to list.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceArn = dictionary["resourceArn"] as? String else { throw InitializableError.missingRequiredParam("resourceArn") }
            self.resourceArn = resourceArn
        }
    }

    public struct ListEventSubscriptionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the assessment template for which you want to list the existing event subscriptions.
        public let resourceArn: String?
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the ListEventSubscriptions action. Subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?
        /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 10. The maximum value is 500.
        public let maxResults: Int32?

        public init(resourceArn: String? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.resourceArn = resourceArn
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.resourceArn = dictionary["resourceArn"] as? String
            self.nextToken = dictionary["nextToken"] as? String
            self.maxResults = dictionary["maxResults"] as? Int32
        }
    }

    public struct UpdateAssessmentTargetRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the resource group that is used to specify the new resource group to associate with the assessment target.
        public let resourceGroupArn: String
        /// The ARN of the assessment target that you want to update.
        public let assessmentTargetArn: String
        /// The name of the assessment target that you want to update.
        public let assessmentTargetName: String

        public init(resourceGroupArn: String, assessmentTargetArn: String, assessmentTargetName: String) {
            self.resourceGroupArn = resourceGroupArn
            self.assessmentTargetArn = assessmentTargetArn
            self.assessmentTargetName = assessmentTargetName
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceGroupArn = dictionary["resourceGroupArn"] as? String else { throw InitializableError.missingRequiredParam("resourceGroupArn") }
            self.resourceGroupArn = resourceGroupArn
            guard let assessmentTargetArn = dictionary["assessmentTargetArn"] as? String else { throw InitializableError.missingRequiredParam("assessmentTargetArn") }
            self.assessmentTargetArn = assessmentTargetArn
            guard let assessmentTargetName = dictionary["assessmentTargetName"] as? String else { throw InitializableError.missingRequiredParam("assessmentTargetName") }
            self.assessmentTargetName = assessmentTargetName
        }
    }

    public struct AddAttributesToFindingsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Attribute details that cannot be described. An error code is provided for each failed item.
        public let failedItems: [String: FailedItemDetails]

        public init(failedItems: [String: FailedItemDetails]) {
            self.failedItems = failedItems
        }

        public init(dictionary: [String: Any]) throws {
            guard let failedItems = dictionary["failedItems"] as? [String: Any] else { throw InitializableError.missingRequiredParam("failedItems") }
            var failedItemsDict: [String: FailedItemDetails] = [:]
            for (key, value) in failedItems {
                guard let failedItemDetailsDict = value as? [String: Any] else { throw InitializableError.convertingError }
                failedItemsDict[key] = try FailedItemDetails(dictionary: failedItemDetailsDict)
            }
            self.failedItems = failedItemsDict
        }
    }

    public enum InvalidCrossAccountRoleErrorCode: String, CustomStringConvertible {
        case role_does_not_exist_or_invalid_trust_relationship = "ROLE_DOES_NOT_EXIST_OR_INVALID_TRUST_RELATIONSHIP"
        case role_does_not_have_correct_policy = "ROLE_DOES_NOT_HAVE_CORRECT_POLICY"
        public var description: String { return self.rawValue }
    }

    public enum Locale: String, CustomStringConvertible {
        case en_us = "EN_US"
        public var description: String { return self.rawValue }
    }

    public struct CreateAssessmentTargetResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN that specifies the assessment target that is created.
        public let assessmentTargetArn: String

        public init(assessmentTargetArn: String) {
            self.assessmentTargetArn = assessmentTargetArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let assessmentTargetArn = dictionary["assessmentTargetArn"] as? String else { throw InitializableError.missingRequiredParam("assessmentTargetArn") }
            self.assessmentTargetArn = assessmentTargetArn
        }
    }

    public struct ListAssessmentRunsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        ///  When a response is generated, if there is more data to be listed, this parameter is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
        public let nextToken: String?
        /// A list of ARNs that specifies the assessment runs that are returned by the action.
        public let assessmentRunArns: [String]

        public init(nextToken: String? = nil, assessmentRunArns: [String]) {
            self.nextToken = nextToken
            self.assessmentRunArns = assessmentRunArns
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            guard let assessmentRunArns = dictionary["assessmentRunArns"] as? [String] else { throw InitializableError.missingRequiredParam("assessmentRunArns") }
            self.assessmentRunArns = assessmentRunArns
        }
    }

    public struct AssessmentRunAgent: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Amazon Inspector application data metrics that are collected by the agent.
        public let telemetryMetadata: [TelemetryMetadata]
        /// The Auto Scaling group of the EC2 instance that is specified by the agent ID.
        public let autoScalingGroup: String?
        /// The current health state of the agent.
        public let agentHealth: AgentHealth
        /// The description for the agent health code.
        public let agentHealthDetails: String?
        /// The ARN of the assessment run that is associated with the agent.
        public let assessmentRunArn: String
        /// The detailed health state of the agent.
        public let agentHealthCode: AgentHealthCode
        /// The AWS account of the EC2 instance where the agent is installed.
        public let agentId: String

        public init(telemetryMetadata: [TelemetryMetadata], autoScalingGroup: String? = nil, agentHealth: AgentHealth, agentHealthDetails: String? = nil, assessmentRunArn: String, agentHealthCode: AgentHealthCode, agentId: String) {
            self.telemetryMetadata = telemetryMetadata
            self.autoScalingGroup = autoScalingGroup
            self.agentHealth = agentHealth
            self.agentHealthDetails = agentHealthDetails
            self.assessmentRunArn = assessmentRunArn
            self.agentHealthCode = agentHealthCode
            self.agentId = agentId
        }

        public init(dictionary: [String: Any]) throws {
            guard let telemetryMetadata = dictionary["telemetryMetadata"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("telemetryMetadata") }
            self.telemetryMetadata = try telemetryMetadata.map({ try TelemetryMetadata(dictionary: $0) })
            self.autoScalingGroup = dictionary["autoScalingGroup"] as? String
            guard let rawagentHealth = dictionary["agentHealth"] as? String, let agentHealth = AgentHealth(rawValue: rawagentHealth) else { throw InitializableError.missingRequiredParam("agentHealth") }
            self.agentHealth = agentHealth
            self.agentHealthDetails = dictionary["agentHealthDetails"] as? String
            guard let assessmentRunArn = dictionary["assessmentRunArn"] as? String else { throw InitializableError.missingRequiredParam("assessmentRunArn") }
            self.assessmentRunArn = assessmentRunArn
            guard let rawagentHealthCode = dictionary["agentHealthCode"] as? String, let agentHealthCode = AgentHealthCode(rawValue: rawagentHealthCode) else { throw InitializableError.missingRequiredParam("agentHealthCode") }
            self.agentHealthCode = agentHealthCode
            guard let agentId = dictionary["agentId"] as? String else { throw InitializableError.missingRequiredParam("agentId") }
            self.agentId = agentId
        }
    }

    public struct DescribeResourceGroupsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Resource group details that cannot be described. An error code is provided for each failed item.
        public let failedItems: [String: FailedItemDetails]
        /// Information about a resource group.
        public let resourceGroups: [ResourceGroup]

        public init(failedItems: [String: FailedItemDetails], resourceGroups: [ResourceGroup]) {
            self.failedItems = failedItems
            self.resourceGroups = resourceGroups
        }

        public init(dictionary: [String: Any]) throws {
            guard let failedItems = dictionary["failedItems"] as? [String: Any] else { throw InitializableError.missingRequiredParam("failedItems") }
            var failedItemsDict: [String: FailedItemDetails] = [:]
            for (key, value) in failedItems {
                guard let failedItemDetailsDict = value as? [String: Any] else { throw InitializableError.convertingError }
                failedItemsDict[key] = try FailedItemDetails(dictionary: failedItemDetailsDict)
            }
            self.failedItems = failedItemsDict
            guard let resourceGroups = dictionary["resourceGroups"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("resourceGroups") }
            self.resourceGroups = try resourceGroups.map({ try ResourceGroup(dictionary: $0) })
        }
    }

    public struct AssessmentTemplateFilter: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// For a record to match a filter, an explicit value or a string that contains a wildcard that is specified for this data type property must match the value of the assessmentTemplateName property of the AssessmentTemplate data type.
        public let namePattern: String?
        /// For a record to match a filter, the values that are specified for this data type property must be contained in the list of values of the rulesPackageArns property of the AssessmentTemplate data type.
        public let rulesPackageArns: [String]?
        /// For a record to match a filter, the value specified for this data type property must inclusively match any value between the specified minimum and maximum values of the durationInSeconds property of the AssessmentTemplate data type.
        public let durationRange: DurationRange?

        public init(namePattern: String? = nil, rulesPackageArns: [String]? = nil, durationRange: DurationRange? = nil) {
            self.namePattern = namePattern
            self.rulesPackageArns = rulesPackageArns
            self.durationRange = durationRange
        }

        public init(dictionary: [String: Any]) throws {
            self.namePattern = dictionary["namePattern"] as? String
            self.rulesPackageArns = dictionary["rulesPackageArns"] as? [String]
            if let durationRange = dictionary["durationRange"] as? [String: Any] { self.durationRange = try Inspector.DurationRange(dictionary: durationRange) } else { self.durationRange = nil }
        }
    }

    public struct ListTagsForResourceResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A collection of key and value pairs.
        public let tags: [Tag]

        public init(tags: [Tag]) {
            self.tags = tags
        }

        public init(dictionary: [String: Any]) throws {
            guard let tags = dictionary["tags"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("tags") }
            self.tags = try tags.map({ try Tag(dictionary: $0) })
        }
    }

    public struct AgentAlreadyRunningAssessment: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// ID of the agent that is running on an EC2 instance that is already participating in another started assessment run.
        public let agentId: String
        /// The ARN of the assessment run that has already been started.
        public let assessmentRunArn: String

        public init(agentId: String, assessmentRunArn: String) {
            self.agentId = agentId
            self.assessmentRunArn = assessmentRunArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let agentId = dictionary["agentId"] as? String else { throw InitializableError.missingRequiredParam("agentId") }
            self.agentId = agentId
            guard let assessmentRunArn = dictionary["assessmentRunArn"] as? String else { throw InitializableError.missingRequiredParam("assessmentRunArn") }
            self.assessmentRunArn = assessmentRunArn
        }
    }

    public struct DurationRange: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The maximum value of the duration range. Must be less than or equal to 604800 seconds (1 week).
        public let maxSeconds: Int32?
        /// The minimum value of the duration range. Must be greater than zero.
        public let minSeconds: Int32?

        public init(maxSeconds: Int32? = nil, minSeconds: Int32? = nil) {
            self.maxSeconds = maxSeconds
            self.minSeconds = minSeconds
        }

        public init(dictionary: [String: Any]) throws {
            self.maxSeconds = dictionary["maxSeconds"] as? Int32
            self.minSeconds = dictionary["minSeconds"] as? Int32
        }
    }

    public enum FailedItemErrorCode: String, CustomStringConvertible {
        case invalid_arn = "INVALID_ARN"
        case duplicate_arn = "DUPLICATE_ARN"
        case item_does_not_exist = "ITEM_DOES_NOT_EXIST"
        case access_denied = "ACCESS_DENIED"
        case limit_exceeded = "LIMIT_EXCEEDED"
        case internal_error = "INTERNAL_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum AgentHealthCode: String, CustomStringConvertible {
        case idle = "IDLE"
        case running = "RUNNING"
        case shutdown = "SHUTDOWN"
        case unhealthy = "UNHEALTHY"
        case throttled = "THROTTLED"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public struct TimestampRange: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The minimum value of the timestamp range.
        public let beginDate: Date?
        /// The maximum value of the timestamp range.
        public let endDate: Date?

        public init(beginDate: Date? = nil, endDate: Date? = nil) {
            self.beginDate = beginDate
            self.endDate = endDate
        }

        public init(dictionary: [String: Any]) throws {
            self.beginDate = dictionary["beginDate"] as? Date
            self.endDate = dictionary["endDate"] as? Date
        }
    }

    public struct TelemetryMetadata: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The data size of messages that the agent sends to the Amazon Inspector service.
        public let dataSize: Int64?
        /// The count of messages that the agent sends to the Amazon Inspector service.
        public let count: Int64
        /// A specific type of behavioral data that is collected by the agent.
        public let messageType: String

        public init(dataSize: Int64? = nil, count: Int64, messageType: String) {
            self.dataSize = dataSize
            self.count = count
            self.messageType = messageType
        }

        public init(dictionary: [String: Any]) throws {
            self.dataSize = dictionary["dataSize"] as? Int64
            guard let count = dictionary["count"] as? Int64 else { throw InitializableError.missingRequiredParam("count") }
            self.count = count
            guard let messageType = dictionary["messageType"] as? String else { throw InitializableError.missingRequiredParam("messageType") }
            self.messageType = messageType
        }
    }

    public struct AssessmentTemplate: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the assessment target that corresponds to this assessment template.
        public let assessmentTargetArn: String
        /// The name of the assessment template.
        public let name: String
        /// The time at which the assessment template is created.
        public let createdAt: Date
        /// The rules packages that are specified for this assessment template.
        public let rulesPackageArns: [String]
        /// The duration in seconds specified for this assessment tempate. The default value is 3600 seconds (one hour). The maximum value is 86400 seconds (one day).
        public let durationInSeconds: Int32
        /// The user-defined attributes that are assigned to every generated finding from the assessment run that uses this assessment template.
        public let userAttributesForFindings: [Attribute]
        /// The ARN of the assessment template.
        public let arn: String

        public init(assessmentTargetArn: String, name: String, createdAt: Date, rulesPackageArns: [String], durationInSeconds: Int32, userAttributesForFindings: [Attribute], arn: String) {
            self.assessmentTargetArn = assessmentTargetArn
            self.name = name
            self.createdAt = createdAt
            self.rulesPackageArns = rulesPackageArns
            self.durationInSeconds = durationInSeconds
            self.userAttributesForFindings = userAttributesForFindings
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let assessmentTargetArn = dictionary["assessmentTargetArn"] as? String else { throw InitializableError.missingRequiredParam("assessmentTargetArn") }
            self.assessmentTargetArn = assessmentTargetArn
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
            guard let createdAt = dictionary["createdAt"] as? Date else { throw InitializableError.missingRequiredParam("createdAt") }
            self.createdAt = createdAt
            guard let rulesPackageArns = dictionary["rulesPackageArns"] as? [String] else { throw InitializableError.missingRequiredParam("rulesPackageArns") }
            self.rulesPackageArns = rulesPackageArns
            guard let durationInSeconds = dictionary["durationInSeconds"] as? Int32 else { throw InitializableError.missingRequiredParam("durationInSeconds") }
            self.durationInSeconds = durationInSeconds
            guard let userAttributesForFindings = dictionary["userAttributesForFindings"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("userAttributesForFindings") }
            self.userAttributesForFindings = try userAttributesForFindings.map({ try Attribute(dictionary: $0) })
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct RegisterCrossAccountAccessRoleRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the IAM role that Amazon Inspector uses to list your EC2 instances during the assessment run or when you call the PreviewAgents action. 
        public let roleArn: String

        public init(roleArn: String) {
            self.roleArn = roleArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let roleArn = dictionary["roleArn"] as? String else { throw InitializableError.missingRequiredParam("roleArn") }
            self.roleArn = roleArn
        }
    }

    public struct AssetAttributes: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Auto Scaling group of the EC2 instance where the finding is generated.
        public let autoScalingGroup: String?
        /// The hostname of the EC2 instance where the finding is generated.
        public let hostname: String?
        /// The ID of the Amazon Machine Image (AMI) that is installed on the EC2 instance where the finding is generated.
        public let amiId: String?
        /// The ID of the agent that is installed on the EC2 instance where the finding is generated.
        public let agentId: String?
        /// The schema version of this data type.
        public let schemaVersion: Int32
        /// The list of IP v4 addresses of the EC2 instance where the finding is generated.
        public let ipv4Addresses: [String]?

        public init(autoScalingGroup: String? = nil, hostname: String? = nil, amiId: String? = nil, agentId: String? = nil, schemaVersion: Int32, ipv4Addresses: [String]? = nil) {
            self.autoScalingGroup = autoScalingGroup
            self.hostname = hostname
            self.amiId = amiId
            self.agentId = agentId
            self.schemaVersion = schemaVersion
            self.ipv4Addresses = ipv4Addresses
        }

        public init(dictionary: [String: Any]) throws {
            self.autoScalingGroup = dictionary["autoScalingGroup"] as? String
            self.hostname = dictionary["hostname"] as? String
            self.amiId = dictionary["amiId"] as? String
            self.agentId = dictionary["agentId"] as? String
            guard let schemaVersion = dictionary["schemaVersion"] as? Int32 else { throw InitializableError.missingRequiredParam("schemaVersion") }
            self.schemaVersion = schemaVersion
            self.ipv4Addresses = dictionary["ipv4Addresses"] as? [String]
        }
    }

    public struct ListAssessmentRunAgentsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        ///  When a response is generated, if there is more data to be listed, this parameter is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
        public let nextToken: String?
        /// A list of ARNs that specifies the agents returned by the action.
        public let assessmentRunAgents: [AssessmentRunAgent]

        public init(nextToken: String? = nil, assessmentRunAgents: [AssessmentRunAgent]) {
            self.nextToken = nextToken
            self.assessmentRunAgents = assessmentRunAgents
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            guard let assessmentRunAgents = dictionary["assessmentRunAgents"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("assessmentRunAgents") }
            self.assessmentRunAgents = try assessmentRunAgents.map({ try AssessmentRunAgent(dictionary: $0) })
        }
    }

    public struct ListAssessmentTargetsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the ListAssessmentTargets action. Subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?
        /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 10. The maximum value is 500.
        public let maxResults: Int32?
        /// You can use this parameter to specify a subset of data to be included in the action's response. For a record to match a filter, all specified filter attributes must match. When multiple values are specified for a filter attribute, any of the values can match.
        public let filter: AssessmentTargetFilter?

        public init(nextToken: String? = nil, maxResults: Int32? = nil, filter: AssessmentTargetFilter? = nil) {
            self.nextToken = nextToken
            self.maxResults = maxResults
            self.filter = filter
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            self.maxResults = dictionary["maxResults"] as? Int32
            if let filter = dictionary["filter"] as? [String: Any] { self.filter = try Inspector.AssessmentTargetFilter(dictionary: filter) } else { self.filter = nil }
        }
    }

    public struct GetTelemetryMetadataResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Telemetry details.
        public let telemetryMetadata: [TelemetryMetadata]

        public init(telemetryMetadata: [TelemetryMetadata]) {
            self.telemetryMetadata = telemetryMetadata
        }

        public init(dictionary: [String: Any]) throws {
            guard let telemetryMetadata = dictionary["telemetryMetadata"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("telemetryMetadata") }
            self.telemetryMetadata = try telemetryMetadata.map({ try TelemetryMetadata(dictionary: $0) })
        }
    }

    public struct CreateAssessmentTemplateRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The user-defined name that identifies the assessment template that you want to create. You can create several assessment templates for an assessment target. The names of the assessment templates that correspond to a particular assessment target must be unique.
        public let assessmentTemplateName: String
        /// The ARN that specifies the assessment target for which you want to create the assessment template.
        public let assessmentTargetArn: String
        /// The duration of the assessment run in seconds. The default value is 3600 seconds (one hour).
        public let durationInSeconds: Int32
        /// The ARNs that specify the rules packages that you want to attach to the assessment template.
        public let rulesPackageArns: [String]
        /// The user-defined attributes that are assigned to every finding that is generated by the assessment run that uses this assessment template.
        public let userAttributesForFindings: [Attribute]?

        public init(assessmentTemplateName: String, assessmentTargetArn: String, durationInSeconds: Int32, rulesPackageArns: [String], userAttributesForFindings: [Attribute]? = nil) {
            self.assessmentTemplateName = assessmentTemplateName
            self.assessmentTargetArn = assessmentTargetArn
            self.durationInSeconds = durationInSeconds
            self.rulesPackageArns = rulesPackageArns
            self.userAttributesForFindings = userAttributesForFindings
        }

        public init(dictionary: [String: Any]) throws {
            guard let assessmentTemplateName = dictionary["assessmentTemplateName"] as? String else { throw InitializableError.missingRequiredParam("assessmentTemplateName") }
            self.assessmentTemplateName = assessmentTemplateName
            guard let assessmentTargetArn = dictionary["assessmentTargetArn"] as? String else { throw InitializableError.missingRequiredParam("assessmentTargetArn") }
            self.assessmentTargetArn = assessmentTargetArn
            guard let durationInSeconds = dictionary["durationInSeconds"] as? Int32 else { throw InitializableError.missingRequiredParam("durationInSeconds") }
            self.durationInSeconds = durationInSeconds
            guard let rulesPackageArns = dictionary["rulesPackageArns"] as? [String] else { throw InitializableError.missingRequiredParam("rulesPackageArns") }
            self.rulesPackageArns = rulesPackageArns
            if let userAttributesForFindings = dictionary["userAttributesForFindings"] as? [[String: Any]] {
                self.userAttributesForFindings = try userAttributesForFindings.map({ try Attribute(dictionary: $0) })
            } else { 
                self.userAttributesForFindings = nil
            }
        }
    }

    public struct StartAssessmentRunRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// You can specify the name for the assessment run. The name must be unique for the assessment template whose ARN is used to start the assessment run.
        public let assessmentRunName: String?
        /// The ARN of the assessment template of the assessment run that you want to start.
        public let assessmentTemplateArn: String

        public init(assessmentRunName: String? = nil, assessmentTemplateArn: String) {
            self.assessmentRunName = assessmentRunName
            self.assessmentTemplateArn = assessmentTemplateArn
        }

        public init(dictionary: [String: Any]) throws {
            self.assessmentRunName = dictionary["assessmentRunName"] as? String
            guard let assessmentTemplateArn = dictionary["assessmentTemplateArn"] as? String else { throw InitializableError.missingRequiredParam("assessmentTemplateArn") }
            self.assessmentTemplateArn = assessmentTemplateArn
        }
    }

    public struct AgentFilter: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The detailed health state of the agent. Values can be set to IDLE, RUNNING, SHUTDOWN, UNHEALTHY, THROTTLED, and UNKNOWN. 
        public let agentHealthCodes: [AgentHealthCode]
        /// The current health state of the agent. Values can be set to HEALTHY or UNHEALTHY.
        public let agentHealths: [AgentHealth]

        public init(agentHealthCodes: [AgentHealthCode], agentHealths: [AgentHealth]) {
            self.agentHealthCodes = agentHealthCodes
            self.agentHealths = agentHealths
        }

        public init(dictionary: [String: Any]) throws {
            guard let agentHealthCodes = dictionary["agentHealthCodes"] as? [String] else { throw InitializableError.missingRequiredParam("agentHealthCodes") }
            self.agentHealthCodes = agentHealthCodes.flatMap({ AgentHealthCode(rawValue: $0)})
            guard let agentHealths = dictionary["agentHealths"] as? [String] else { throw InitializableError.missingRequiredParam("agentHealths") }
            self.agentHealths = agentHealths.flatMap({ AgentHealth(rawValue: $0)})
        }
    }

    public struct SubscribeToEventRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the assessment template that is used during the event for which you want to receive SNS notifications.
        public let resourceArn: String
        /// The event for which you want to receive SNS notifications.
        public let event: InspectorEvent
        /// The ARN of the SNS topic to which the SNS notifications are sent.
        public let topicArn: String

        public init(resourceArn: String, event: InspectorEvent, topicArn: String) {
            self.resourceArn = resourceArn
            self.event = event
            self.topicArn = topicArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceArn = dictionary["resourceArn"] as? String else { throw InitializableError.missingRequiredParam("resourceArn") }
            self.resourceArn = resourceArn
            guard let rawevent = dictionary["event"] as? String, let event = InspectorEvent(rawValue: rawevent) else { throw InitializableError.missingRequiredParam("event") }
            self.event = event
            guard let topicArn = dictionary["topicArn"] as? String else { throw InitializableError.missingRequiredParam("topicArn") }
            self.topicArn = topicArn
        }
    }

    public enum AssessmentRunNotificationSnsStatusCode: String, CustomStringConvertible {
        case success = "SUCCESS"
        case topic_does_not_exist = "TOPIC_DOES_NOT_EXIST"
        case access_denied = "ACCESS_DENIED"
        case internal_error = "INTERNAL_ERROR"
        public var description: String { return self.rawValue }
    }

    public struct CreateResourceGroupRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A collection of keys and an array of possible values, '[{"key":"key1","values":["Value1","Value2"]},{"key":"Key2","values":["Value3"]}]'. For example,'[{"key":"Name","values":["TestEC2Instance"]}]'.
        public let resourceGroupTags: [ResourceGroupTag]

        public init(resourceGroupTags: [ResourceGroupTag]) {
            self.resourceGroupTags = resourceGroupTags
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceGroupTags = dictionary["resourceGroupTags"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("resourceGroupTags") }
            self.resourceGroupTags = try resourceGroupTags.map({ try ResourceGroupTag(dictionary: $0) })
        }
    }

    public struct DescribeFindingsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the finding.
        public let findings: [Finding]
        /// Finding details that cannot be described. An error code is provided for each failed item.
        public let failedItems: [String: FailedItemDetails]

        public init(findings: [Finding], failedItems: [String: FailedItemDetails]) {
            self.findings = findings
            self.failedItems = failedItems
        }

        public init(dictionary: [String: Any]) throws {
            guard let findings = dictionary["findings"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("findings") }
            self.findings = try findings.map({ try Finding(dictionary: $0) })
            guard let failedItems = dictionary["failedItems"] as? [String: Any] else { throw InitializableError.missingRequiredParam("failedItems") }
            var failedItemsDict: [String: FailedItemDetails] = [:]
            for (key, value) in failedItems {
                guard let failedItemDetailsDict = value as? [String: Any] else { throw InitializableError.convertingError }
                failedItemsDict[key] = try FailedItemDetails(dictionary: failedItemDetailsDict)
            }
            self.failedItems = failedItemsDict
        }
    }

    public struct SetTagsForResourceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the assessment template that you want to set tags to.
        public let resourceArn: String
        /// A collection of key and value pairs that you want to set to the assessment template.
        public let tags: [Tag]?

        public init(resourceArn: String, tags: [Tag]? = nil) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceArn = dictionary["resourceArn"] as? String else { throw InitializableError.missingRequiredParam("resourceArn") }
            self.resourceArn = resourceArn
            if let tags = dictionary["tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            } else { 
                self.tags = nil
            }
        }
    }

    public struct FailedItemDetails: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The status code of a failed item.
        public let failureCode: FailedItemErrorCode
        /// Indicates whether you can immediately retry a request for this item for a specified resource.
        public let retryable: Bool

        public init(failureCode: FailedItemErrorCode, retryable: Bool) {
            self.failureCode = failureCode
            self.retryable = retryable
        }

        public init(dictionary: [String: Any]) throws {
            guard let rawfailureCode = dictionary["failureCode"] as? String, let failureCode = FailedItemErrorCode(rawValue: rawfailureCode) else { throw InitializableError.missingRequiredParam("failureCode") }
            self.failureCode = failureCode
            guard let retryable = dictionary["retryable"] as? Bool else { throw InitializableError.missingRequiredParam("retryable") }
            self.retryable = retryable
        }
    }

    public struct AssessmentRunNotification: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The SNS topic to which the SNS notification is sent.
        public let snsTopicArn: String?
        /// The status code of the SNS notification.
        public let snsPublishStatusCode: AssessmentRunNotificationSnsStatusCode?
        /// The event for which a notification is sent.
        public let event: InspectorEvent
        public let message: String?
        /// The date of the notification.
        public let date: Date
        /// The Boolean value that specifies whether the notification represents an error.
        public let error: Bool

        public init(snsTopicArn: String? = nil, snsPublishStatusCode: AssessmentRunNotificationSnsStatusCode? = nil, event: InspectorEvent, message: String? = nil, date: Date, error: Bool) {
            self.snsTopicArn = snsTopicArn
            self.snsPublishStatusCode = snsPublishStatusCode
            self.event = event
            self.message = message
            self.date = date
            self.error = error
        }

        public init(dictionary: [String: Any]) throws {
            self.snsTopicArn = dictionary["snsTopicArn"] as? String
            if let snsPublishStatusCode = dictionary["snsPublishStatusCode"] as? String { self.snsPublishStatusCode = AssessmentRunNotificationSnsStatusCode(rawValue: snsPublishStatusCode) } else { self.snsPublishStatusCode = nil }
            guard let rawevent = dictionary["event"] as? String, let event = InspectorEvent(rawValue: rawevent) else { throw InitializableError.missingRequiredParam("event") }
            self.event = event
            self.message = dictionary["message"] as? String
            guard let date = dictionary["date"] as? Date else { throw InitializableError.missingRequiredParam("date") }
            self.date = date
            guard let error = dictionary["error"] as? Bool else { throw InitializableError.missingRequiredParam("error") }
            self.error = error
        }
    }

    public struct ListAssessmentTemplatesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 10. The maximum value is 500.
        public let maxResults: Int32?
        /// You can use this parameter to specify a subset of data to be included in the action's response. For a record to match a filter, all specified filter attributes must match. When multiple values are specified for a filter attribute, any of the values can match.
        public let filter: AssessmentTemplateFilter?
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the ListAssessmentTemplates action. Subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?
        /// A list of ARNs that specifies the assessment targets whose assessment templates you want to list.
        public let assessmentTargetArns: [String]?

        public init(maxResults: Int32? = nil, filter: AssessmentTemplateFilter? = nil, nextToken: String? = nil, assessmentTargetArns: [String]? = nil) {
            self.maxResults = maxResults
            self.filter = filter
            self.nextToken = nextToken
            self.assessmentTargetArns = assessmentTargetArns
        }

        public init(dictionary: [String: Any]) throws {
            self.maxResults = dictionary["maxResults"] as? Int32
            if let filter = dictionary["filter"] as? [String: Any] { self.filter = try Inspector.AssessmentTemplateFilter(dictionary: filter) } else { self.filter = nil }
            self.nextToken = dictionary["nextToken"] as? String
            self.assessmentTargetArns = dictionary["assessmentTargetArns"] as? [String]
        }
    }

    public struct StopAssessmentRunRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the assessment run that you want to stop.
        public let assessmentRunArn: String

        public init(assessmentRunArn: String) {
            self.assessmentRunArn = assessmentRunArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let assessmentRunArn = dictionary["assessmentRunArn"] as? String else { throw InitializableError.missingRequiredParam("assessmentRunArn") }
            self.assessmentRunArn = assessmentRunArn
        }
    }

    public struct ListRulesPackagesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The list of ARNs that specifies the rules packages returned by the action.
        public let rulesPackageArns: [String]
        ///  When a response is generated, if there is more data to be listed, this parameter is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
        public let nextToken: String?

        public init(rulesPackageArns: [String], nextToken: String? = nil) {
            self.rulesPackageArns = rulesPackageArns
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            guard let rulesPackageArns = dictionary["rulesPackageArns"] as? [String] else { throw InitializableError.missingRequiredParam("rulesPackageArns") }
            self.rulesPackageArns = rulesPackageArns
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct CreateAssessmentTargetRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN that specifies the resource group that is used to create the assessment target.
        public let resourceGroupArn: String
        /// The user-defined name that identifies the assessment target that you want to create. The name must be unique within the AWS account.
        public let assessmentTargetName: String

        public init(resourceGroupArn: String, assessmentTargetName: String) {
            self.resourceGroupArn = resourceGroupArn
            self.assessmentTargetName = assessmentTargetName
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceGroupArn = dictionary["resourceGroupArn"] as? String else { throw InitializableError.missingRequiredParam("resourceGroupArn") }
            self.resourceGroupArn = resourceGroupArn
            guard let assessmentTargetName = dictionary["assessmentTargetName"] as? String else { throw InitializableError.missingRequiredParam("assessmentTargetName") }
            self.assessmentTargetName = assessmentTargetName
        }
    }

    public struct InspectorServiceAttributes: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The schema version of this data type.
        public let schemaVersion: Int32
        /// The ARN of the rules package that is used to generate the finding.
        public let rulesPackageArn: String?
        /// The ARN of the assessment run during which the finding is generated.
        public let assessmentRunArn: String?

        public init(schemaVersion: Int32, rulesPackageArn: String? = nil, assessmentRunArn: String? = nil) {
            self.schemaVersion = schemaVersion
            self.rulesPackageArn = rulesPackageArn
            self.assessmentRunArn = assessmentRunArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let schemaVersion = dictionary["schemaVersion"] as? Int32 else { throw InitializableError.missingRequiredParam("schemaVersion") }
            self.schemaVersion = schemaVersion
            self.rulesPackageArn = dictionary["rulesPackageArn"] as? String
            self.assessmentRunArn = dictionary["assessmentRunArn"] as? String
        }
    }

    public struct DescribeAssessmentTargetsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the assessment targets.
        public let assessmentTargets: [AssessmentTarget]
        /// Assessment target details that cannot be described. An error code is provided for each failed item.
        public let failedItems: [String: FailedItemDetails]

        public init(assessmentTargets: [AssessmentTarget], failedItems: [String: FailedItemDetails]) {
            self.assessmentTargets = assessmentTargets
            self.failedItems = failedItems
        }

        public init(dictionary: [String: Any]) throws {
            guard let assessmentTargets = dictionary["assessmentTargets"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("assessmentTargets") }
            self.assessmentTargets = try assessmentTargets.map({ try AssessmentTarget(dictionary: $0) })
            guard let failedItems = dictionary["failedItems"] as? [String: Any] else { throw InitializableError.missingRequiredParam("failedItems") }
            var failedItemsDict: [String: FailedItemDetails] = [:]
            for (key, value) in failedItems {
                guard let failedItemDetailsDict = value as? [String: Any] else { throw InitializableError.convertingError }
                failedItemsDict[key] = try FailedItemDetails(dictionary: failedItemDetailsDict)
            }
            self.failedItems = failedItemsDict
        }
    }

    public struct DescribeFindingsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The locale into which you want to translate a finding description, recommendation, and the short description that identifies the finding.
        public let locale: Locale?
        /// The ARN that specifies the finding that you want to describe.
        public let findingArns: [String]

        public init(locale: Locale? = nil, findingArns: [String]) {
            self.locale = locale
            self.findingArns = findingArns
        }

        public init(dictionary: [String: Any]) throws {
            if let locale = dictionary["locale"] as? String { self.locale = Locale(rawValue: locale) } else { self.locale = nil }
            guard let findingArns = dictionary["findingArns"] as? [String] else { throw InitializableError.missingRequiredParam("findingArns") }
            self.findingArns = findingArns
        }
    }

}