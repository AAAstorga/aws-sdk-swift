// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Workdocs {

    public struct DescribeDocumentVersionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["fields": "Fields", "marker": "Marker", "limit": "Limit", "include": "Include"]
        }
        public static var pathParams: [String: String] {
            return ["DocumentId": "DocumentId"]
        }
        /// Specify "SOURCE" to include initialized versions and a URL for the source document.
        public let fields: String?
        /// The maximum number of versions to return with this call.
        public let limit: Int32?
        /// The marker for the next set of results. (You received this marker from a previous call.)
        public let marker: String?
        /// The ID of the document.
        public let documentId: String
        /// A comma-separated list of values. Specify "INITIALIZED" to include incomplete versions.
        public let include: String?

        public init(fields: String? = nil, limit: Int32? = nil, marker: String? = nil, documentId: String, include: String? = nil) {
            self.fields = fields
            self.limit = limit
            self.marker = marker
            self.documentId = documentId
            self.include = include
        }

        public init(dictionary: [String: Any]) throws {
            self.fields = dictionary["Fields"] as? String
            self.limit = dictionary["Limit"] as? Int32
            self.marker = dictionary["Marker"] as? String
            guard let documentId = dictionary["DocumentId"] as? String else { throw InitializableError.missingRequiredParam("DocumentId") }
            self.documentId = documentId
            self.include = dictionary["Include"] as? String
        }
    }

    public enum DocumentThumbnailType: String, CustomStringConvertible {
        case small = "SMALL"
        case small_hq = "SMALL_HQ"
        case large = "LARGE"
        public var description: String { return self.rawValue }
    }

    public struct CreateNotificationSubscriptionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["OrganizationId": "OrganizationId"]
        }
        /// The ID of the organization.
        public let organizationId: String
        /// The notification type.
        public let subscriptionType: SubscriptionType
        /// The protocol to use. The supported value is https, which delivers JSON-encoded messasges using HTTPS POST.
        public let `protocol`: SubscriptionProtocolType
        /// The endpoint to receive the notifications. If the protocol is HTTPS, the endpoint is a URL that begins with "https://".
        public let endpoint: String

        public init(organizationId: String, subscriptionType: SubscriptionType, protocol: SubscriptionProtocolType, endpoint: String) {
            self.organizationId = organizationId
            self.subscriptionType = subscriptionType
            self.`protocol` = `protocol`
            self.endpoint = endpoint
        }

        public init(dictionary: [String: Any]) throws {
            guard let organizationId = dictionary["OrganizationId"] as? String else { throw InitializableError.missingRequiredParam("OrganizationId") }
            self.organizationId = organizationId
            guard let rawSubscriptionType = dictionary["SubscriptionType"] as? String, let subscriptionType = SubscriptionType(rawValue: rawSubscriptionType) else { throw InitializableError.missingRequiredParam("SubscriptionType") }
            self.subscriptionType = subscriptionType
            guard let rawProtocol = dictionary["Protocol"] as? String, let `protocol` = SubscriptionProtocolType(rawValue: rawProtocol) else { throw InitializableError.missingRequiredParam("Protocol") }
            self.`protocol` = `protocol`
            guard let endpoint = dictionary["Endpoint"] as? String else { throw InitializableError.missingRequiredParam("Endpoint") }
            self.endpoint = endpoint
        }
    }

    public struct ShareResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The role.
        public let role: RoleType?
        /// The status.
        public let status: ShareStatusType?
        /// The ID of the principal.
        public let principalId: String?
        /// The status message.
        public let statusMessage: String?
        /// The ID of the resource that was shared.
        public let shareId: String?

        public init(role: RoleType? = nil, status: ShareStatusType? = nil, principalId: String? = nil, statusMessage: String? = nil, shareId: String? = nil) {
            self.role = role
            self.status = status
            self.principalId = principalId
            self.statusMessage = statusMessage
            self.shareId = shareId
        }

        public init(dictionary: [String: Any]) throws {
            if let role = dictionary["Role"] as? String { self.role = RoleType(rawValue: role) } else { self.role = nil }
            if let status = dictionary["Status"] as? String { self.status = ShareStatusType(rawValue: status) } else { self.status = nil }
            self.principalId = dictionary["PrincipalId"] as? String
            self.statusMessage = dictionary["StatusMessage"] as? String
            self.shareId = dictionary["ShareId"] as? String
        }
    }

    public struct GetDocumentVersionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["fields": "Fields"]
        }
        public static var pathParams: [String: String] {
            return ["VersionId": "VersionId", "DocumentId": "DocumentId"]
        }
        /// A comma-separated list of values. Specify "SOURCE" to include a URL for the source document.
        public let fields: String?
        /// The version ID of the document.
        public let versionId: String
        /// The ID of the document.
        public let documentId: String

        public init(fields: String? = nil, versionId: String, documentId: String) {
            self.fields = fields
            self.versionId = versionId
            self.documentId = documentId
        }

        public init(dictionary: [String: Any]) throws {
            self.fields = dictionary["Fields"] as? String
            guard let versionId = dictionary["VersionId"] as? String else { throw InitializableError.missingRequiredParam("VersionId") }
            self.versionId = versionId
            guard let documentId = dictionary["DocumentId"] as? String else { throw InitializableError.missingRequiredParam("DocumentId") }
            self.documentId = documentId
        }
    }

    public struct PermissionInfo: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The type of permissions.
        public let `type`: RolePermissionType?
        /// The role of the user.
        public let role: RoleType?

        public init(type: RolePermissionType? = nil, role: RoleType? = nil) {
            self.`type` = `type`
            self.role = role
        }

        public init(dictionary: [String: Any]) throws {
            if let `type` = dictionary["Type"] as? String { self.`type` = RolePermissionType(rawValue: `type`) } else { self.`type` = nil }
            if let role = dictionary["Role"] as? String { self.role = RoleType(rawValue: role) } else { self.role = nil }
        }
    }

    public struct UpdateUserResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The user information.
        public let user: User?

        public init(user: User? = nil) {
            self.user = user
        }

        public init(dictionary: [String: Any]) throws {
            if let user = dictionary["User"] as? [String: Any] { self.user = try Workdocs.User(dictionary: user) } else { self.user = nil }
        }
    }

    public struct DescribeUsersResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
        public let marker: String?
        /// The users.
        public let users: [User]?
        /// The total number of users included in the results.
        public let totalNumberOfUsers: Int64?

        public init(marker: String? = nil, users: [User]? = nil, totalNumberOfUsers: Int64? = nil) {
            self.marker = marker
            self.users = users
            self.totalNumberOfUsers = totalNumberOfUsers
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["Marker"] as? String
            if let users = dictionary["Users"] as? [[String: Any]] {
                self.users = try users.map({ try User(dictionary: $0) })
            } else { 
                self.users = nil
            }
            self.totalNumberOfUsers = dictionary["TotalNumberOfUsers"] as? Int64
        }
    }

    public enum PrincipalType: String, CustomStringConvertible {
        case user = "USER"
        case group = "GROUP"
        case invite = "INVITE"
        case anonymous = "ANONYMOUS"
        case organization = "ORGANIZATION"
        public var description: String { return self.rawValue }
    }

    public struct Subscription: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the subscription.
        public let subscriptionId: String?
        /// The endpoint of the subscription.
        public let endPoint: String?
        /// The protocol of the subscription.
        public let `protocol`: SubscriptionProtocolType?

        public init(subscriptionId: String? = nil, endPoint: String? = nil, protocol: SubscriptionProtocolType? = nil) {
            self.subscriptionId = subscriptionId
            self.endPoint = endPoint
            self.`protocol` = `protocol`
        }

        public init(dictionary: [String: Any]) throws {
            self.subscriptionId = dictionary["SubscriptionId"] as? String
            self.endPoint = dictionary["EndPoint"] as? String
            if let `protocol` = dictionary["Protocol"] as? String { self.`protocol` = SubscriptionProtocolType(rawValue: `protocol`) } else { self.`protocol` = nil }
        }
    }

    public struct DescribeFolderContentsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
        public let marker: String?
        /// The documents in the specified folder.
        public let documents: [DocumentMetadata]?
        /// The sub-folders in the specified folder.
        public let folders: [FolderMetadata]?

        public init(marker: String? = nil, documents: [DocumentMetadata]? = nil, folders: [FolderMetadata]? = nil) {
            self.marker = marker
            self.documents = documents
            self.folders = folders
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["Marker"] as? String
            if let documents = dictionary["Documents"] as? [[String: Any]] {
                self.documents = try documents.map({ try DocumentMetadata(dictionary: $0) })
            } else { 
                self.documents = nil
            }
            if let folders = dictionary["Folders"] as? [[String: Any]] {
                self.folders = try folders.map({ try FolderMetadata(dictionary: $0) })
            } else { 
                self.folders = nil
            }
        }
    }

    public struct ResourcePathComponent: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the resource path.
        public let name: String?
        /// The ID of the resource path.
        public let id: String?

        public init(name: String? = nil, id: String? = nil) {
            self.name = name
            self.id = id
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["Name"] as? String
            self.id = dictionary["Id"] as? String
        }
    }

    public enum DocumentStatusType: String, CustomStringConvertible {
        case initialized = "INITIALIZED"
        case active = "ACTIVE"
        public var description: String { return self.rawValue }
    }

    public struct DescribeResourcePermissionsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
        public let marker: String?
        /// The principals.
        public let principals: [Principal]?

        public init(marker: String? = nil, principals: [Principal]? = nil) {
            self.marker = marker
            self.principals = principals
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["Marker"] as? String
            if let principals = dictionary["Principals"] as? [[String: Any]] {
                self.principals = try principals.map({ try Principal(dictionary: $0) })
            } else { 
                self.principals = nil
            }
        }
    }

    public struct DeleteDocumentRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["DocumentId": "DocumentId"]
        }
        /// The ID of the document.
        public let documentId: String

        public init(documentId: String) {
            self.documentId = documentId
        }

        public init(dictionary: [String: Any]) throws {
            guard let documentId = dictionary["DocumentId"] as? String else { throw InitializableError.missingRequiredParam("DocumentId") }
            self.documentId = documentId
        }
    }

    public struct UpdateDocumentRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["DocumentId": "DocumentId"]
        }
        /// The ID of the parent folder.
        public let parentFolderId: String?
        /// The resource state of the document. Note that only ACTIVE and RECYCLED are supported.
        public let resourceState: ResourceStateType?
        /// The ID of the document.
        public let documentId: String
        /// The name of the document.
        public let name: String?

        public init(parentFolderId: String? = nil, resourceState: ResourceStateType? = nil, documentId: String, name: String? = nil) {
            self.parentFolderId = parentFolderId
            self.resourceState = resourceState
            self.documentId = documentId
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            self.parentFolderId = dictionary["ParentFolderId"] as? String
            if let resourceState = dictionary["ResourceState"] as? String { self.resourceState = ResourceStateType(rawValue: resourceState) } else { self.resourceState = nil }
            guard let documentId = dictionary["DocumentId"] as? String else { throw InitializableError.missingRequiredParam("DocumentId") }
            self.documentId = documentId
            self.name = dictionary["Name"] as? String
        }
    }

    public struct GetDocumentRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["DocumentId": "DocumentId"]
        }
        /// The ID of the document object.
        public let documentId: String

        public init(documentId: String) {
            self.documentId = documentId
        }

        public init(dictionary: [String: Any]) throws {
            guard let documentId = dictionary["DocumentId"] as? String else { throw InitializableError.missingRequiredParam("DocumentId") }
            self.documentId = documentId
        }
    }

    public struct InitiateDocumentVersionUploadRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the document.
        public let id: String?
        /// The time stamp when the content of the document was modified.
        public let contentModifiedTimestamp: Date?
        /// The name of the document.
        public let name: String?
        /// The content type of the document.
        public let contentType: String?
        /// The ID of the parent folder.
        public let parentFolderId: String
        /// The time stamp when the content of the document was originally created.
        public let contentCreatedTimestamp: Date?
        /// The size of the document, in bytes.
        public let documentSizeInBytes: Int64?

        public init(id: String? = nil, contentModifiedTimestamp: Date? = nil, name: String? = nil, contentType: String? = nil, parentFolderId: String, contentCreatedTimestamp: Date? = nil, documentSizeInBytes: Int64? = nil) {
            self.id = id
            self.contentModifiedTimestamp = contentModifiedTimestamp
            self.name = name
            self.contentType = contentType
            self.parentFolderId = parentFolderId
            self.contentCreatedTimestamp = contentCreatedTimestamp
            self.documentSizeInBytes = documentSizeInBytes
        }

        public init(dictionary: [String: Any]) throws {
            self.id = dictionary["Id"] as? String
            self.contentModifiedTimestamp = dictionary["ContentModifiedTimestamp"] as? Date
            self.name = dictionary["Name"] as? String
            self.contentType = dictionary["ContentType"] as? String
            guard let parentFolderId = dictionary["ParentFolderId"] as? String else { throw InitializableError.missingRequiredParam("ParentFolderId") }
            self.parentFolderId = parentFolderId
            self.contentCreatedTimestamp = dictionary["ContentCreatedTimestamp"] as? Date
            self.documentSizeInBytes = dictionary["DocumentSizeInBytes"] as? Int64
        }
    }

    public enum RolePermissionType: String, CustomStringConvertible {
        case direct = "DIRECT"
        case inherited = "INHERITED"
        public var description: String { return self.rawValue }
    }

    public struct AddResourcePermissionsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The share results.
        public let shareResults: [ShareResult]?

        public init(shareResults: [ShareResult]? = nil) {
            self.shareResults = shareResults
        }

        public init(dictionary: [String: Any]) throws {
            if let shareResults = dictionary["ShareResults"] as? [[String: Any]] {
                self.shareResults = try shareResults.map({ try ShareResult(dictionary: $0) })
            } else { 
                self.shareResults = nil
            }
        }
    }

    public struct FolderMetadata: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The unique identifier created from the subfolders and documents of the folder.
        public let signature: String?
        /// The resource state of the folder.
        public let resourceState: ResourceStateType?
        /// The name of the folder.
        public let name: String?
        /// The ID of the creator.
        public let creatorId: String?
        /// The time when the folder was updated.
        public let modifiedTimestamp: Date?
        /// The ID of the parent folder.
        public let parentFolderId: String?
        /// The time when the folder was created.
        public let createdTimestamp: Date?
        /// The ID of the folder.
        public let id: String?

        public init(signature: String? = nil, resourceState: ResourceStateType? = nil, name: String? = nil, creatorId: String? = nil, modifiedTimestamp: Date? = nil, parentFolderId: String? = nil, createdTimestamp: Date? = nil, id: String? = nil) {
            self.signature = signature
            self.resourceState = resourceState
            self.name = name
            self.creatorId = creatorId
            self.modifiedTimestamp = modifiedTimestamp
            self.parentFolderId = parentFolderId
            self.createdTimestamp = createdTimestamp
            self.id = id
        }

        public init(dictionary: [String: Any]) throws {
            self.signature = dictionary["Signature"] as? String
            if let resourceState = dictionary["ResourceState"] as? String { self.resourceState = ResourceStateType(rawValue: resourceState) } else { self.resourceState = nil }
            self.name = dictionary["Name"] as? String
            self.creatorId = dictionary["CreatorId"] as? String
            self.modifiedTimestamp = dictionary["ModifiedTimestamp"] as? Date
            self.parentFolderId = dictionary["ParentFolderId"] as? String
            self.createdTimestamp = dictionary["CreatedTimestamp"] as? Date
            self.id = dictionary["Id"] as? String
        }
    }

    public struct DocumentVersionMetadata: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The time stamp when the content of the document was modified.
        public let contentModifiedTimestamp: Date?
        /// The signature of the document.
        public let signature: String?
        /// The time stamp when the document was last uploaded.
        public let modifiedTimestamp: Date?
        /// The source of the document.
        public let source: [DocumentSourceType: String]?
        /// The time stamp when the document was first uploaded.
        public let createdTimestamp: Date?
        /// The ID of the version.
        public let id: String?
        /// The status of the document.
        public let status: DocumentStatusType?
        /// The name of the version.
        public let name: String?
        /// The size of the document, in bytes.
        public let size: Int64?
        /// The content type of the document.
        public let contentType: String?
        /// The ID of the creator.
        public let creatorId: String?
        /// The thumbnail of the document.
        public let thumbnail: [DocumentThumbnailType: String]?
        /// The time stamp when the content of the document was originally created.
        public let contentCreatedTimestamp: Date?

        public init(contentModifiedTimestamp: Date? = nil, signature: String? = nil, modifiedTimestamp: Date? = nil, source: [DocumentSourceType: String]? = nil, createdTimestamp: Date? = nil, id: String? = nil, status: DocumentStatusType? = nil, name: String? = nil, size: Int64? = nil, contentType: String? = nil, creatorId: String? = nil, thumbnail: [DocumentThumbnailType: String]? = nil, contentCreatedTimestamp: Date? = nil) {
            self.contentModifiedTimestamp = contentModifiedTimestamp
            self.signature = signature
            self.modifiedTimestamp = modifiedTimestamp
            self.source = source
            self.createdTimestamp = createdTimestamp
            self.id = id
            self.status = status
            self.name = name
            self.size = size
            self.contentType = contentType
            self.creatorId = creatorId
            self.thumbnail = thumbnail
            self.contentCreatedTimestamp = contentCreatedTimestamp
        }

        public init(dictionary: [String: Any]) throws {
            self.contentModifiedTimestamp = dictionary["ContentModifiedTimestamp"] as? Date
            self.signature = dictionary["Signature"] as? String
            self.modifiedTimestamp = dictionary["ModifiedTimestamp"] as? Date
            if let source = dictionary["Source"] as? [DocumentSourceType: String] {
                self.source = source
            } else { 
                self.source = nil
            }
            self.createdTimestamp = dictionary["CreatedTimestamp"] as? Date
            self.id = dictionary["Id"] as? String
            if let status = dictionary["Status"] as? String { self.status = DocumentStatusType(rawValue: status) } else { self.status = nil }
            self.name = dictionary["Name"] as? String
            self.size = dictionary["Size"] as? Int64
            self.contentType = dictionary["ContentType"] as? String
            self.creatorId = dictionary["CreatorId"] as? String
            if let thumbnail = dictionary["Thumbnail"] as? [DocumentThumbnailType: String] {
                self.thumbnail = thumbnail
            } else { 
                self.thumbnail = nil
            }
            self.contentCreatedTimestamp = dictionary["ContentCreatedTimestamp"] as? Date
        }
    }

    public struct UserStorageMetadata: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The storage for a user.
        public let storageRule: StorageRuleType?
        /// The amount of storage utilized, in bytes.
        public let storageUtilizedInBytes: Int64?

        public init(storageRule: StorageRuleType? = nil, storageUtilizedInBytes: Int64? = nil) {
            self.storageRule = storageRule
            self.storageUtilizedInBytes = storageUtilizedInBytes
        }

        public init(dictionary: [String: Any]) throws {
            if let storageRule = dictionary["StorageRule"] as? [String: Any] { self.storageRule = try Workdocs.StorageRuleType(dictionary: storageRule) } else { self.storageRule = nil }
            self.storageUtilizedInBytes = dictionary["StorageUtilizedInBytes"] as? Int64
        }
    }

    public struct GetFolderPathResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The path information.
        public let path: ResourcePath?

        public init(path: ResourcePath? = nil) {
            self.path = path
        }

        public init(dictionary: [String: Any]) throws {
            if let path = dictionary["Path"] as? [String: Any] { self.path = try Workdocs.ResourcePath(dictionary: path) } else { self.path = nil }
        }
    }

    public struct GetFolderResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The metadata of the folder.
        public let metadata: FolderMetadata?

        public init(metadata: FolderMetadata? = nil) {
            self.metadata = metadata
        }

        public init(dictionary: [String: Any]) throws {
            if let metadata = dictionary["Metadata"] as? [String: Any] { self.metadata = try Workdocs.FolderMetadata(dictionary: metadata) } else { self.metadata = nil }
        }
    }

    public enum DocumentSourceType: String, CustomStringConvertible {
        case original = "ORIGINAL"
        case with_comments = "WITH_COMMENTS"
        public var description: String { return self.rawValue }
    }

    public enum DocumentVersionStatus: String, CustomStringConvertible {
        case active = "ACTIVE"
        public var description: String { return self.rawValue }
    }

    public struct CreateUserRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The time zone ID of the user.
        public let timeZoneId: String?
        /// The given name of the user.
        public let givenName: String
        /// The login name of the user.
        public let username: String
        /// The surname of the user.
        public let surname: String
        /// The ID of the organization.
        public let organizationId: String?
        /// The password of the user.
        public let password: String
        /// The amount of storage for the user.
        public let storageRule: StorageRuleType?

        public init(timeZoneId: String? = nil, givenName: String, username: String, surname: String, organizationId: String? = nil, password: String, storageRule: StorageRuleType? = nil) {
            self.timeZoneId = timeZoneId
            self.givenName = givenName
            self.username = username
            self.surname = surname
            self.organizationId = organizationId
            self.password = password
            self.storageRule = storageRule
        }

        public init(dictionary: [String: Any]) throws {
            self.timeZoneId = dictionary["TimeZoneId"] as? String
            guard let givenName = dictionary["GivenName"] as? String else { throw InitializableError.missingRequiredParam("GivenName") }
            self.givenName = givenName
            guard let username = dictionary["Username"] as? String else { throw InitializableError.missingRequiredParam("Username") }
            self.username = username
            guard let surname = dictionary["Surname"] as? String else { throw InitializableError.missingRequiredParam("Surname") }
            self.surname = surname
            self.organizationId = dictionary["OrganizationId"] as? String
            guard let password = dictionary["Password"] as? String else { throw InitializableError.missingRequiredParam("Password") }
            self.password = password
            if let storageRule = dictionary["StorageRule"] as? [String: Any] { self.storageRule = try Workdocs.StorageRuleType(dictionary: storageRule) } else { self.storageRule = nil }
        }
    }

    public struct ActivateUserResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The user information.
        public let user: User?

        public init(user: User? = nil) {
            self.user = user
        }

        public init(dictionary: [String: Any]) throws {
            if let user = dictionary["User"] as? [String: Any] { self.user = try Workdocs.User(dictionary: user) } else { self.user = nil }
        }
    }

    public struct GetFolderRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["FolderId": "FolderId"]
        }
        /// The ID of the folder.
        public let folderId: String

        public init(folderId: String) {
            self.folderId = folderId
        }

        public init(dictionary: [String: Any]) throws {
            guard let folderId = dictionary["FolderId"] as? String else { throw InitializableError.missingRequiredParam("FolderId") }
            self.folderId = folderId
        }
    }

    public struct GetDocumentResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The document object.
        public let metadata: DocumentMetadata?

        public init(metadata: DocumentMetadata? = nil) {
            self.metadata = metadata
        }

        public init(dictionary: [String: Any]) throws {
            if let metadata = dictionary["Metadata"] as? [String: Any] { self.metadata = try Workdocs.DocumentMetadata(dictionary: metadata) } else { self.metadata = nil }
        }
    }

    public struct AddResourcePermissionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["ResourceId": "ResourceId"]
        }
        /// The ID of the resource.
        public let resourceId: String
        /// The users, groups, or organization being granted permission.
        public let principals: [SharePrincipal]

        public init(resourceId: String, principals: [SharePrincipal]) {
            self.resourceId = resourceId
            self.principals = principals
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceId = dictionary["ResourceId"] as? String else { throw InitializableError.missingRequiredParam("ResourceId") }
            self.resourceId = resourceId
            guard let principals = dictionary["Principals"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("Principals") }
            self.principals = try principals.map({ try SharePrincipal(dictionary: $0) })
        }
    }

    public enum OrderType: String, CustomStringConvertible {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public struct DeleteUserRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["UserId": "UserId"]
        }
        /// The ID of the user.
        public let userId: String

        public init(userId: String) {
            self.userId = userId
        }

        public init(dictionary: [String: Any]) throws {
            guard let userId = dictionary["UserId"] as? String else { throw InitializableError.missingRequiredParam("UserId") }
            self.userId = userId
        }
    }

    public struct UploadMetadata: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The URL of the upload.
        public let uploadUrl: String?
        /// The signed headers.
        public let signedHeaders: [String: String]?

        public init(uploadUrl: String? = nil, signedHeaders: [String: String]? = nil) {
            self.uploadUrl = uploadUrl
            self.signedHeaders = signedHeaders
        }

        public init(dictionary: [String: Any]) throws {
            self.uploadUrl = dictionary["UploadUrl"] as? String
            if let signedHeaders = dictionary["SignedHeaders"] as? [String: String] {
                self.signedHeaders = signedHeaders
            } else { 
                self.signedHeaders = nil
            }
        }
    }

    public struct CreateNotificationSubscriptionResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The subscription.
        public let subscription: Subscription?

        public init(subscription: Subscription? = nil) {
            self.subscription = subscription
        }

        public init(dictionary: [String: Any]) throws {
            if let subscription = dictionary["Subscription"] as? [String: Any] { self.subscription = try Workdocs.Subscription(dictionary: subscription) } else { self.subscription = nil }
        }
    }

    public struct UpdateFolderRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["FolderId": "FolderId"]
        }
        /// The ID of the parent folder.
        public let parentFolderId: String?
        /// The ID of the folder.
        public let folderId: String
        /// The resource state of the folder. Note that only ACTIVE and RECYCLED are accepted values from the API.
        public let resourceState: ResourceStateType?
        /// The name of the folder.
        public let name: String?

        public init(parentFolderId: String? = nil, folderId: String, resourceState: ResourceStateType? = nil, name: String? = nil) {
            self.parentFolderId = parentFolderId
            self.folderId = folderId
            self.resourceState = resourceState
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            self.parentFolderId = dictionary["ParentFolderId"] as? String
            guard let folderId = dictionary["FolderId"] as? String else { throw InitializableError.missingRequiredParam("FolderId") }
            self.folderId = folderId
            if let resourceState = dictionary["ResourceState"] as? String { self.resourceState = ResourceStateType(rawValue: resourceState) } else { self.resourceState = nil }
            self.name = dictionary["Name"] as? String
        }
    }

    public struct DescribeNotificationSubscriptionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["marker": "Marker", "limit": "Limit"]
        }
        public static var pathParams: [String: String] {
            return ["OrganizationId": "OrganizationId"]
        }
        /// The ID of the organization.
        public let organizationId: String
        /// The marker for the next set of results. (You received this marker from a previous call.)
        public let marker: String?
        /// The maximum number of items to return with this call.
        public let limit: Int32?

        public init(organizationId: String, marker: String? = nil, limit: Int32? = nil) {
            self.organizationId = organizationId
            self.marker = marker
            self.limit = limit
        }

        public init(dictionary: [String: Any]) throws {
            guard let organizationId = dictionary["OrganizationId"] as? String else { throw InitializableError.missingRequiredParam("OrganizationId") }
            self.organizationId = organizationId
            self.marker = dictionary["Marker"] as? String
            self.limit = dictionary["Limit"] as? Int32
        }
    }

    public enum LocaleType: String, CustomStringConvertible {
        case en = "en"
        case fr = "fr"
        case ko = "ko"
        case de = "de"
        case es = "es"
        case ja = "ja"
        case ru = "ru"
        case zh_cn = "zh_CN"
        case zh_tw = "zh_TW"
        case pt_br = "pt_BR"
        case `default` = "default"
        public var description: String { return self.rawValue }
    }

    public struct RemoveAllResourcePermissionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["ResourceId": "ResourceId"]
        }
        /// The ID of the resource.
        public let resourceId: String

        public init(resourceId: String) {
            self.resourceId = resourceId
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceId = dictionary["ResourceId"] as? String else { throw InitializableError.missingRequiredParam("ResourceId") }
            self.resourceId = resourceId
        }
    }

    public struct GetDocumentPathResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The path information.
        public let path: ResourcePath?

        public init(path: ResourcePath? = nil) {
            self.path = path
        }

        public init(dictionary: [String: Any]) throws {
            if let path = dictionary["Path"] as? [String: Any] { self.path = try Workdocs.ResourcePath(dictionary: path) } else { self.path = nil }
        }
    }

    public struct UpdateUserRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["UserId": "UserId"]
        }
        /// The locale of the user.
        public let locale: LocaleType?
        /// The ID of the user.
        public let userId: String
        /// The given name of the user.
        public let givenName: String?
        /// The time zone ID of the user.
        public let timeZoneId: String?
        /// The surname of the user.
        public let surname: String?
        /// The type of the user.
        public let `type`: UserType?
        /// The amount of storage for the user.
        public let storageRule: StorageRuleType?

        public init(locale: LocaleType? = nil, userId: String, givenName: String? = nil, timeZoneId: String? = nil, surname: String? = nil, type: UserType? = nil, storageRule: StorageRuleType? = nil) {
            self.locale = locale
            self.userId = userId
            self.givenName = givenName
            self.timeZoneId = timeZoneId
            self.surname = surname
            self.`type` = `type`
            self.storageRule = storageRule
        }

        public init(dictionary: [String: Any]) throws {
            if let locale = dictionary["Locale"] as? String { self.locale = LocaleType(rawValue: locale) } else { self.locale = nil }
            guard let userId = dictionary["UserId"] as? String else { throw InitializableError.missingRequiredParam("UserId") }
            self.userId = userId
            self.givenName = dictionary["GivenName"] as? String
            self.timeZoneId = dictionary["TimeZoneId"] as? String
            self.surname = dictionary["Surname"] as? String
            if let `type` = dictionary["Type"] as? String { self.`type` = UserType(rawValue: `type`) } else { self.`type` = nil }
            if let storageRule = dictionary["StorageRule"] as? [String: Any] { self.storageRule = try Workdocs.StorageRuleType(dictionary: storageRule) } else { self.storageRule = nil }
        }
    }

    public struct DeleteFolderRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["FolderId": "FolderId"]
        }
        /// The ID of the folder.
        public let folderId: String

        public init(folderId: String) {
            self.folderId = folderId
        }

        public init(dictionary: [String: Any]) throws {
            guard let folderId = dictionary["FolderId"] as? String else { throw InitializableError.missingRequiredParam("FolderId") }
            self.folderId = folderId
        }
    }

    public struct CreateFolderRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the new folder.
        public let name: String?
        /// The ID of the parent folder.
        public let parentFolderId: String

        public init(name: String? = nil, parentFolderId: String) {
            self.name = name
            self.parentFolderId = parentFolderId
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["Name"] as? String
            guard let parentFolderId = dictionary["ParentFolderId"] as? String else { throw InitializableError.missingRequiredParam("ParentFolderId") }
            self.parentFolderId = parentFolderId
        }
    }

    public enum ResourceStateType: String, CustomStringConvertible {
        case active = "ACTIVE"
        case restoring = "RESTORING"
        case recycling = "RECYCLING"
        case recycled = "RECYCLED"
        public var description: String { return self.rawValue }
    }

    public struct DocumentMetadata: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The resource state.
        public let resourceState: ResourceStateType?
        /// The ID of the creator.
        public let creatorId: String?
        /// The time when the document was updated.
        public let modifiedTimestamp: Date?
        /// The ID of the parent folder.
        public let parentFolderId: String?
        /// The latest version of the document.
        public let latestVersionMetadata: DocumentVersionMetadata?
        /// The time when the document was created.
        public let createdTimestamp: Date?
        /// The ID of the document.
        public let id: String?

        public init(resourceState: ResourceStateType? = nil, creatorId: String? = nil, modifiedTimestamp: Date? = nil, parentFolderId: String? = nil, latestVersionMetadata: DocumentVersionMetadata? = nil, createdTimestamp: Date? = nil, id: String? = nil) {
            self.resourceState = resourceState
            self.creatorId = creatorId
            self.modifiedTimestamp = modifiedTimestamp
            self.parentFolderId = parentFolderId
            self.latestVersionMetadata = latestVersionMetadata
            self.createdTimestamp = createdTimestamp
            self.id = id
        }

        public init(dictionary: [String: Any]) throws {
            if let resourceState = dictionary["ResourceState"] as? String { self.resourceState = ResourceStateType(rawValue: resourceState) } else { self.resourceState = nil }
            self.creatorId = dictionary["CreatorId"] as? String
            self.modifiedTimestamp = dictionary["ModifiedTimestamp"] as? Date
            self.parentFolderId = dictionary["ParentFolderId"] as? String
            if let latestVersionMetadata = dictionary["LatestVersionMetadata"] as? [String: Any] { self.latestVersionMetadata = try Workdocs.DocumentVersionMetadata(dictionary: latestVersionMetadata) } else { self.latestVersionMetadata = nil }
            self.createdTimestamp = dictionary["CreatedTimestamp"] as? Date
            self.id = dictionary["Id"] as? String
        }
    }

    public enum SubscriptionType: String, CustomStringConvertible {
        case all = "ALL"
        public var description: String { return self.rawValue }
    }

    public struct DescribeResourcePermissionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["marker": "Marker", "limit": "Limit"]
        }
        public static var pathParams: [String: String] {
            return ["ResourceId": "ResourceId"]
        }
        /// The ID of the resource.
        public let resourceId: String
        /// The marker for the next set of results. (You received this marker from a previous call)
        public let marker: String?
        /// The maximum number of items to return with this call.
        public let limit: Int32?

        public init(resourceId: String, marker: String? = nil, limit: Int32? = nil) {
            self.resourceId = resourceId
            self.marker = marker
            self.limit = limit
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceId = dictionary["ResourceId"] as? String else { throw InitializableError.missingRequiredParam("ResourceId") }
            self.resourceId = resourceId
            self.marker = dictionary["Marker"] as? String
            self.limit = dictionary["Limit"] as? Int32
        }
    }

    public enum RoleType: String, CustomStringConvertible {
        case viewer = "VIEWER"
        case contributor = "CONTRIBUTOR"
        case owner = "OWNER"
        case coowner = "COOWNER"
        public var description: String { return self.rawValue }
    }

    public enum UserStatusType: String, CustomStringConvertible {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public struct Principal: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The type of resource.
        public let `type`: PrincipalType?
        /// The permission information for the resource.
        public let roles: [PermissionInfo]?
        /// The ID of the resource.
        public let id: String?

        public init(type: PrincipalType? = nil, roles: [PermissionInfo]? = nil, id: String? = nil) {
            self.`type` = `type`
            self.roles = roles
            self.id = id
        }

        public init(dictionary: [String: Any]) throws {
            if let `type` = dictionary["Type"] as? String { self.`type` = PrincipalType(rawValue: `type`) } else { self.`type` = nil }
            if let roles = dictionary["Roles"] as? [[String: Any]] {
                self.roles = try roles.map({ try PermissionInfo(dictionary: $0) })
            } else { 
                self.roles = nil
            }
            self.id = dictionary["Id"] as? String
        }
    }

    public struct DescribeNotificationSubscriptionsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
        public let marker: String?
        /// The subscriptions.
        public let subscriptions: [Subscription]?

        public init(marker: String? = nil, subscriptions: [Subscription]? = nil) {
            self.marker = marker
            self.subscriptions = subscriptions
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["Marker"] as? String
            if let subscriptions = dictionary["Subscriptions"] as? [[String: Any]] {
                self.subscriptions = try subscriptions.map({ try Subscription(dictionary: $0) })
            } else { 
                self.subscriptions = nil
            }
        }
    }

    public enum UserFilterType: String, CustomStringConvertible {
        case all = "ALL"
        case active_pending = "ACTIVE_PENDING"
        public var description: String { return self.rawValue }
    }

    public struct UpdateDocumentVersionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["VersionId": "VersionId", "DocumentId": "DocumentId"]
        }
        /// The status of the version.
        public let versionStatus: DocumentVersionStatus?
        /// The version ID of the document.
        public let versionId: String
        /// The ID of the document.
        public let documentId: String

        public init(versionStatus: DocumentVersionStatus? = nil, versionId: String, documentId: String) {
            self.versionStatus = versionStatus
            self.versionId = versionId
            self.documentId = documentId
        }

        public init(dictionary: [String: Any]) throws {
            if let versionStatus = dictionary["VersionStatus"] as? String { self.versionStatus = DocumentVersionStatus(rawValue: versionStatus) } else { self.versionStatus = nil }
            guard let versionId = dictionary["VersionId"] as? String else { throw InitializableError.missingRequiredParam("VersionId") }
            self.versionId = versionId
            guard let documentId = dictionary["DocumentId"] as? String else { throw InitializableError.missingRequiredParam("DocumentId") }
            self.documentId = documentId
        }
    }

    public enum ShareStatusType: String, CustomStringConvertible {
        case success = "SUCCESS"
        case failure = "FAILURE"
        public var description: String { return self.rawValue }
    }

    public enum FolderContentType: String, CustomStringConvertible {
        case all = "ALL"
        case document = "DOCUMENT"
        case folder = "FOLDER"
        public var description: String { return self.rawValue }
    }

    public struct GetDocumentPathRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["fields": "Fields", "marker": "Marker", "limit": "Limit"]
        }
        public static var pathParams: [String: String] {
            return ["DocumentId": "DocumentId"]
        }
        /// A comma-separated list of values. Specify "NAME" to include the names of the parent folders.
        public let fields: String?
        /// The ID of the document.
        public let documentId: String
        /// This value is not supported.
        public let marker: String?
        /// The maximum number of levels in the hierarchy to return.
        public let limit: Int32?

        public init(fields: String? = nil, documentId: String, marker: String? = nil, limit: Int32? = nil) {
            self.fields = fields
            self.documentId = documentId
            self.marker = marker
            self.limit = limit
        }

        public init(dictionary: [String: Any]) throws {
            self.fields = dictionary["Fields"] as? String
            guard let documentId = dictionary["DocumentId"] as? String else { throw InitializableError.missingRequiredParam("DocumentId") }
            self.documentId = documentId
            self.marker = dictionary["Marker"] as? String
            self.limit = dictionary["Limit"] as? Int32
        }
    }

    public struct RemoveResourcePermissionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["type": "PrincipalType"]
        }
        public static var pathParams: [String: String] {
            return ["ResourceId": "ResourceId", "PrincipalId": "PrincipalId"]
        }
        /// The ID of the resource.
        public let resourceId: String
        /// The principal type of the resource.
        public let principalType: PrincipalType?
        /// The principal ID of the resource.
        public let principalId: String

        public init(resourceId: String, principalType: PrincipalType? = nil, principalId: String) {
            self.resourceId = resourceId
            self.principalType = principalType
            self.principalId = principalId
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceId = dictionary["ResourceId"] as? String else { throw InitializableError.missingRequiredParam("ResourceId") }
            self.resourceId = resourceId
            if let principalType = dictionary["Type"] as? String { self.principalType = PrincipalType(rawValue: principalType) } else { self.principalType = nil }
            guard let principalId = dictionary["PrincipalId"] as? String else { throw InitializableError.missingRequiredParam("PrincipalId") }
            self.principalId = principalId
        }
    }

    public struct CreateUserResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The user information.
        public let user: User?

        public init(user: User? = nil) {
            self.user = user
        }

        public init(dictionary: [String: Any]) throws {
            if let user = dictionary["User"] as? [String: Any] { self.user = try Workdocs.User(dictionary: user) } else { self.user = nil }
        }
    }

    public enum ResourceSortType: String, CustomStringConvertible {
        case date = "DATE"
        case name = "NAME"
        public var description: String { return self.rawValue }
    }

    public struct DescribeDocumentVersionsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The document versions.
        public let documentVersions: [DocumentVersionMetadata]?
        /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
        public let marker: String?

        public init(documentVersions: [DocumentVersionMetadata]? = nil, marker: String? = nil) {
            self.documentVersions = documentVersions
            self.marker = marker
        }

        public init(dictionary: [String: Any]) throws {
            if let documentVersions = dictionary["DocumentVersions"] as? [[String: Any]] {
                self.documentVersions = try documentVersions.map({ try DocumentVersionMetadata(dictionary: $0) })
            } else { 
                self.documentVersions = nil
            }
            self.marker = dictionary["Marker"] as? String
        }
    }

    public enum UserType: String, CustomStringConvertible {
        case user = "USER"
        case admin = "ADMIN"
        public var description: String { return self.rawValue }
    }

    public struct User: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The email address of the user.
        public let emailAddress: String?
        /// The ID of the recycle bin folder.
        public let recycleBinFolderId: String?
        /// The login name of the user.
        public let username: String?
        /// The time when the user was modified.
        public let modifiedTimestamp: Date?
        /// The ID of the organization.
        public let organizationId: String?
        /// The time when the user was created.
        public let createdTimestamp: Date?
        /// The ID of the user.
        public let id: String?
        /// The time zone ID of the user.
        public let timeZoneId: String?
        /// The locale of the user.
        public let locale: LocaleType?
        /// The status of the user.
        public let status: UserStatusType?
        /// The given name of the user.
        public let givenName: String?
        /// The storage for the user.
        public let storage: UserStorageMetadata?
        /// The surname of the user.
        public let surname: String?
        /// The ID of the root folder.
        public let rootFolderId: String?
        /// The type of user.
        public let `type`: UserType?

        public init(emailAddress: String? = nil, recycleBinFolderId: String? = nil, username: String? = nil, modifiedTimestamp: Date? = nil, organizationId: String? = nil, createdTimestamp: Date? = nil, id: String? = nil, timeZoneId: String? = nil, locale: LocaleType? = nil, status: UserStatusType? = nil, givenName: String? = nil, storage: UserStorageMetadata? = nil, surname: String? = nil, rootFolderId: String? = nil, type: UserType? = nil) {
            self.emailAddress = emailAddress
            self.recycleBinFolderId = recycleBinFolderId
            self.username = username
            self.modifiedTimestamp = modifiedTimestamp
            self.organizationId = organizationId
            self.createdTimestamp = createdTimestamp
            self.id = id
            self.timeZoneId = timeZoneId
            self.locale = locale
            self.status = status
            self.givenName = givenName
            self.storage = storage
            self.surname = surname
            self.rootFolderId = rootFolderId
            self.`type` = `type`
        }

        public init(dictionary: [String: Any]) throws {
            self.emailAddress = dictionary["EmailAddress"] as? String
            self.recycleBinFolderId = dictionary["RecycleBinFolderId"] as? String
            self.username = dictionary["Username"] as? String
            self.modifiedTimestamp = dictionary["ModifiedTimestamp"] as? Date
            self.organizationId = dictionary["OrganizationId"] as? String
            self.createdTimestamp = dictionary["CreatedTimestamp"] as? Date
            self.id = dictionary["Id"] as? String
            self.timeZoneId = dictionary["TimeZoneId"] as? String
            if let locale = dictionary["Locale"] as? String { self.locale = LocaleType(rawValue: locale) } else { self.locale = nil }
            if let status = dictionary["Status"] as? String { self.status = UserStatusType(rawValue: status) } else { self.status = nil }
            self.givenName = dictionary["GivenName"] as? String
            if let storage = dictionary["Storage"] as? [String: Any] { self.storage = try Workdocs.UserStorageMetadata(dictionary: storage) } else { self.storage = nil }
            self.surname = dictionary["Surname"] as? String
            self.rootFolderId = dictionary["RootFolderId"] as? String
            if let `type` = dictionary["Type"] as? String { self.`type` = UserType(rawValue: `type`) } else { self.`type` = nil }
        }
    }

    public enum SubscriptionProtocolType: String, CustomStringConvertible {
        case https = "HTTPS"
        public var description: String { return self.rawValue }
    }

    public struct StorageRuleType: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The type of storage.
        public let storageType: StorageType?
        /// The amount of storage allocated, in bytes.
        public let storageAllocatedInBytes: Int64?

        public init(storageType: StorageType? = nil, storageAllocatedInBytes: Int64? = nil) {
            self.storageType = storageType
            self.storageAllocatedInBytes = storageAllocatedInBytes
        }

        public init(dictionary: [String: Any]) throws {
            if let storageType = dictionary["StorageType"] as? String { self.storageType = StorageType(rawValue: storageType) } else { self.storageType = nil }
            self.storageAllocatedInBytes = dictionary["StorageAllocatedInBytes"] as? Int64
        }
    }

    public struct CreateFolderResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The metadata of the folder.
        public let metadata: FolderMetadata?

        public init(metadata: FolderMetadata? = nil) {
            self.metadata = metadata
        }

        public init(dictionary: [String: Any]) throws {
            if let metadata = dictionary["Metadata"] as? [String: Any] { self.metadata = try Workdocs.FolderMetadata(dictionary: metadata) } else { self.metadata = nil }
        }
    }

    public struct SharePrincipal: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The role of the recipient.
        public let role: RoleType
        /// The type of the recipient.
        public let `type`: PrincipalType
        /// The ID of the recipient.
        public let id: String

        public init(role: RoleType, type: PrincipalType, id: String) {
            self.role = role
            self.`type` = `type`
            self.id = id
        }

        public init(dictionary: [String: Any]) throws {
            guard let rawRole = dictionary["Role"] as? String, let role = RoleType(rawValue: rawRole) else { throw InitializableError.missingRequiredParam("Role") }
            self.role = role
            guard let rawType = dictionary["Type"] as? String, let `type` = PrincipalType(rawValue: rawType) else { throw InitializableError.missingRequiredParam("Type") }
            self.`type` = `type`
            guard let id = dictionary["Id"] as? String else { throw InitializableError.missingRequiredParam("Id") }
            self.id = id
        }
    }

    public struct GetFolderPathRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["fields": "Fields", "marker": "Marker", "limit": "Limit"]
        }
        public static var pathParams: [String: String] {
            return ["FolderId": "FolderId"]
        }
        /// A comma-separated list of values. Specify "NAME" to include the names of the parent folders.
        public let fields: String?
        /// The ID of the folder.
        public let folderId: String
        /// The maximum number of levels in the hierarchy to return.
        public let limit: Int32?
        /// This value is not supported.
        public let marker: String?

        public init(fields: String? = nil, folderId: String, limit: Int32? = nil, marker: String? = nil) {
            self.fields = fields
            self.folderId = folderId
            self.limit = limit
            self.marker = marker
        }

        public init(dictionary: [String: Any]) throws {
            self.fields = dictionary["Fields"] as? String
            guard let folderId = dictionary["FolderId"] as? String else { throw InitializableError.missingRequiredParam("FolderId") }
            self.folderId = folderId
            self.limit = dictionary["Limit"] as? Int32
            self.marker = dictionary["Marker"] as? String
        }
    }

    public struct DeactivateUserRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["UserId": "UserId"]
        }
        /// The ID of the user.
        public let userId: String

        public init(userId: String) {
            self.userId = userId
        }

        public init(dictionary: [String: Any]) throws {
            guard let userId = dictionary["UserId"] as? String else { throw InitializableError.missingRequiredParam("UserId") }
            self.userId = userId
        }
    }

    public struct ResourcePath: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The components of the resource path.
        public let components: [ResourcePathComponent]?

        public init(components: [ResourcePathComponent]? = nil) {
            self.components = components
        }

        public init(dictionary: [String: Any]) throws {
            if let components = dictionary["Components"] as? [[String: Any]] {
                self.components = try components.map({ try ResourcePathComponent(dictionary: $0) })
            } else { 
                self.components = nil
            }
        }
    }

    public struct DeleteFolderContentsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["FolderId": "FolderId"]
        }
        /// The ID of the folder.
        public let folderId: String

        public init(folderId: String) {
            self.folderId = folderId
        }

        public init(dictionary: [String: Any]) throws {
            guard let folderId = dictionary["FolderId"] as? String else { throw InitializableError.missingRequiredParam("FolderId") }
            self.folderId = folderId
        }
    }

    public struct DescribeUsersRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["fields": "Fields", "marker": "Marker", "userIds": "UserIds", "limit": "Limit", "organizationId": "OrganizationId", "sort": "Sort", "include": "Include", "query": "Query", "order": "Order"]
        }
        /// A comma-separated list of values. Specify "STORAGE_METADATA" to include the user storage quota and utilization information.
        public let fields: String?
        /// The IDs of the users.
        public let userIds: String?
        /// The sorting criteria.
        public let sort: UserSortType?
        /// The marker for the next set of results. (You received this marker from a previous call.)
        public let marker: String?
        /// A query to filter users by user name.
        public let query: String?
        /// The maximum number of items to return.
        public let limit: Int32?
        /// The ID of the organization.
        public let organizationId: String?
        /// The order for the results.
        public let order: OrderType?
        /// The state of the users. Specify "ALL" to include inactive users.
        public let include: UserFilterType?

        public init(fields: String? = nil, userIds: String? = nil, sort: UserSortType? = nil, marker: String? = nil, query: String? = nil, limit: Int32? = nil, organizationId: String? = nil, order: OrderType? = nil, include: UserFilterType? = nil) {
            self.fields = fields
            self.userIds = userIds
            self.sort = sort
            self.marker = marker
            self.query = query
            self.limit = limit
            self.organizationId = organizationId
            self.order = order
            self.include = include
        }

        public init(dictionary: [String: Any]) throws {
            self.fields = dictionary["Fields"] as? String
            self.userIds = dictionary["UserIds"] as? String
            if let sort = dictionary["Sort"] as? String { self.sort = UserSortType(rawValue: sort) } else { self.sort = nil }
            self.marker = dictionary["Marker"] as? String
            self.query = dictionary["Query"] as? String
            self.limit = dictionary["Limit"] as? Int32
            self.organizationId = dictionary["OrganizationId"] as? String
            if let order = dictionary["Order"] as? String { self.order = OrderType(rawValue: order) } else { self.order = nil }
            if let include = dictionary["Include"] as? String { self.include = UserFilterType(rawValue: include) } else { self.include = nil }
        }
    }

    public struct InitiateDocumentVersionUploadResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The document metadata.
        public let metadata: DocumentMetadata?
        /// The upload metadata.
        public let uploadMetadata: UploadMetadata?

        public init(metadata: DocumentMetadata? = nil, uploadMetadata: UploadMetadata? = nil) {
            self.metadata = metadata
            self.uploadMetadata = uploadMetadata
        }

        public init(dictionary: [String: Any]) throws {
            if let metadata = dictionary["Metadata"] as? [String: Any] { self.metadata = try Workdocs.DocumentMetadata(dictionary: metadata) } else { self.metadata = nil }
            if let uploadMetadata = dictionary["UploadMetadata"] as? [String: Any] { self.uploadMetadata = try Workdocs.UploadMetadata(dictionary: uploadMetadata) } else { self.uploadMetadata = nil }
        }
    }

    public struct DescribeFolderContentsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["marker": "Marker", "include": "Include", "limit": "Limit", "type": "Type", "sort": "Sort", "order": "Order"]
        }
        public static var pathParams: [String: String] {
            return ["FolderId": "FolderId"]
        }
        /// The sorting criteria.
        public let sort: ResourceSortType?
        /// The marker for the next set of results. (You received this marker from a previous call.)
        public let marker: String?
        /// The ID of the folder.
        public let folderId: String
        /// The maximum number of items to return with this call.
        public let limit: Int32?
        /// The order for the contents of the folder.
        public let order: OrderType?
        /// The type of items.
        public let `type`: FolderContentType?
        /// The contents to include. Specify "INITIALIZED" to include initialized documents.
        public let include: String?

        public init(sort: ResourceSortType? = nil, marker: String? = nil, folderId: String, limit: Int32? = nil, order: OrderType? = nil, type: FolderContentType? = nil, include: String? = nil) {
            self.sort = sort
            self.marker = marker
            self.folderId = folderId
            self.limit = limit
            self.order = order
            self.`type` = `type`
            self.include = include
        }

        public init(dictionary: [String: Any]) throws {
            if let sort = dictionary["Sort"] as? String { self.sort = ResourceSortType(rawValue: sort) } else { self.sort = nil }
            self.marker = dictionary["Marker"] as? String
            guard let folderId = dictionary["FolderId"] as? String else { throw InitializableError.missingRequiredParam("FolderId") }
            self.folderId = folderId
            self.limit = dictionary["Limit"] as? Int32
            if let order = dictionary["Order"] as? String { self.order = OrderType(rawValue: order) } else { self.order = nil }
            if let `type` = dictionary["Type"] as? String { self.`type` = FolderContentType(rawValue: `type`) } else { self.`type` = nil }
            self.include = dictionary["Include"] as? String
        }
    }

    public enum UserSortType: String, CustomStringConvertible {
        case user_name = "USER_NAME"
        case full_name = "FULL_NAME"
        case storage_limit = "STORAGE_LIMIT"
        case user_status = "USER_STATUS"
        case storage_used = "STORAGE_USED"
        public var description: String { return self.rawValue }
    }

    public struct AbortDocumentVersionUploadRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["VersionId": "VersionId", "DocumentId": "DocumentId"]
        }
        /// The ID of the version.
        public let versionId: String
        /// The ID of the document.
        public let documentId: String

        public init(versionId: String, documentId: String) {
            self.versionId = versionId
            self.documentId = documentId
        }

        public init(dictionary: [String: Any]) throws {
            guard let versionId = dictionary["VersionId"] as? String else { throw InitializableError.missingRequiredParam("VersionId") }
            self.versionId = versionId
            guard let documentId = dictionary["DocumentId"] as? String else { throw InitializableError.missingRequiredParam("DocumentId") }
            self.documentId = documentId
        }
    }

    public struct GetDocumentVersionResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The version metadata.
        public let metadata: DocumentVersionMetadata?

        public init(metadata: DocumentVersionMetadata? = nil) {
            self.metadata = metadata
        }

        public init(dictionary: [String: Any]) throws {
            if let metadata = dictionary["Metadata"] as? [String: Any] { self.metadata = try Workdocs.DocumentVersionMetadata(dictionary: metadata) } else { self.metadata = nil }
        }
    }

    public enum StorageType: String, CustomStringConvertible {
        case unlimited = "UNLIMITED"
        case quota = "QUOTA"
        public var description: String { return self.rawValue }
    }

    public struct DeleteNotificationSubscriptionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["OrganizationId": "OrganizationId", "SubscriptionId": "SubscriptionId"]
        }
        /// The ID of the organization.
        public let organizationId: String
        /// The ID of the subscription.
        public let subscriptionId: String

        public init(organizationId: String, subscriptionId: String) {
            self.organizationId = organizationId
            self.subscriptionId = subscriptionId
        }

        public init(dictionary: [String: Any]) throws {
            guard let organizationId = dictionary["OrganizationId"] as? String else { throw InitializableError.missingRequiredParam("OrganizationId") }
            self.organizationId = organizationId
            guard let subscriptionId = dictionary["SubscriptionId"] as? String else { throw InitializableError.missingRequiredParam("SubscriptionId") }
            self.subscriptionId = subscriptionId
        }
    }

    public struct ActivateUserRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["UserId": "UserId"]
        }
        /// The ID of the user.
        public let userId: String

        public init(userId: String) {
            self.userId = userId
        }

        public init(dictionary: [String: Any]) throws {
            guard let userId = dictionary["UserId"] as? String else { throw InitializableError.missingRequiredParam("UserId") }
            self.userId = userId
        }
    }

}