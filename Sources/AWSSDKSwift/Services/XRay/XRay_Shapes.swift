// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension XRay {

    public struct GetGroupRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GroupARN", required: false, type: .string), 
            AWSShapeMember(label: "GroupName", required: false, type: .string)
        ]
        /// The ARN of the group that was generated on creation.
        public let groupARN: String?
        /// The case-sensitive name of the group.
        public let groupName: String?

        public init(groupARN: String? = nil, groupName: String? = nil) {
            self.groupARN = groupARN
            self.groupName = groupName
        }

        private enum CodingKeys: String, CodingKey {
            case groupARN = "GroupARN"
            case groupName = "GroupName"
        }
    }

    public struct PutEncryptionConfigRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Type", required: true, type: .enum), 
            AWSShapeMember(label: "KeyId", required: false, type: .string)
        ]
        /// The type of encryption. Set to KMS to use your own key for encryption. Set to NONE for default encryption.
        public let `type`: EncryptionType
        /// An AWS KMS customer master key (CMK) in one of the following formats:    Alias - The name of the key. For example, alias/MyKey.    Key ID - The KMS key ID of the key. For example, ae4aa6d49-a4d8-9df9-a475-4ff6d7898456.    ARN - The full Amazon Resource Name of the key ID or alias. For example, arn:aws:kms:us-east-2:123456789012:key/ae4aa6d49-a4d8-9df9-a475-4ff6d7898456. Use this format to specify a key in a different account.   Omit this key if you set Type to NONE.
        public let keyId: String?

        public init(type: EncryptionType, keyId: String? = nil) {
            self.`type` = `type`
            self.keyId = keyId
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "Type"
            case keyId = "KeyId"
        }
    }

    public struct FaultRootCause: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Services", required: false, type: .list)
        ]
        /// A list of corresponding services. A service identifies a segment and it contains a name, account ID, type, and inferred flag.
        public let services: [FaultRootCauseService]?

        public init(services: [FaultRootCauseService]? = nil) {
            self.services = services
        }

        private enum CodingKeys: String, CodingKey {
            case services = "Services"
        }
    }

    public struct Edge: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SummaryStatistics", required: false, type: .structure), 
            AWSShapeMember(label: "ReferenceId", required: false, type: .integer), 
            AWSShapeMember(label: "EndTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "ResponseTimeHistogram", required: false, type: .list), 
            AWSShapeMember(label: "StartTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Aliases", required: false, type: .list)
        ]
        /// Response statistics for segments on the edge.
        public let summaryStatistics: EdgeStatistics?
        /// Identifier of the edge. Unique within a service map.
        public let referenceId: Int32?
        /// The end time of the last segment on the edge.
        public let endTime: TimeStamp?
        /// A histogram that maps the spread of client response times on an edge.
        public let responseTimeHistogram: [HistogramEntry]?
        /// The start time of the first segment on the edge.
        public let startTime: TimeStamp?
        /// Aliases for the edge.
        public let aliases: [Alias]?

        public init(summaryStatistics: EdgeStatistics? = nil, referenceId: Int32? = nil, endTime: TimeStamp? = nil, responseTimeHistogram: [HistogramEntry]? = nil, startTime: TimeStamp? = nil, aliases: [Alias]? = nil) {
            self.summaryStatistics = summaryStatistics
            self.referenceId = referenceId
            self.endTime = endTime
            self.responseTimeHistogram = responseTimeHistogram
            self.startTime = startTime
            self.aliases = aliases
        }

        private enum CodingKeys: String, CodingKey {
            case summaryStatistics = "SummaryStatistics"
            case referenceId = "ReferenceId"
            case endTime = "EndTime"
            case responseTimeHistogram = "ResponseTimeHistogram"
            case startTime = "StartTime"
            case aliases = "Aliases"
        }
    }

    public struct CreateSamplingRuleRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SamplingRule", required: true, type: .structure)
        ]
        /// The rule definition.
        public let samplingRule: SamplingRule

        public init(samplingRule: SamplingRule) {
            self.samplingRule = samplingRule
        }

        private enum CodingKeys: String, CodingKey {
            case samplingRule = "SamplingRule"
        }
    }

    public struct FaultRootCauseService: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EntityPath", required: false, type: .list), 
            AWSShapeMember(label: "Type", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Inferred", required: false, type: .boolean), 
            AWSShapeMember(label: "Names", required: false, type: .list), 
            AWSShapeMember(label: "AccountId", required: false, type: .string)
        ]
        /// The path of root cause entities found on the service. 
        public let entityPath: [FaultRootCauseEntity]?
        /// The type associated to the service.
        public let `type`: String?
        /// The service name.
        public let name: String?
        /// A Boolean value indicating if the service is inferred from the trace.
        public let inferred: Bool?
        /// A collection of associated service names.
        public let names: [String]?
        /// The account ID associated to the service.
        public let accountId: String?

        public init(entityPath: [FaultRootCauseEntity]? = nil, type: String? = nil, name: String? = nil, inferred: Bool? = nil, names: [String]? = nil, accountId: String? = nil) {
            self.entityPath = entityPath
            self.`type` = `type`
            self.name = name
            self.inferred = inferred
            self.names = names
            self.accountId = accountId
        }

        private enum CodingKeys: String, CodingKey {
            case entityPath = "EntityPath"
            case `type` = "Type"
            case name = "Name"
            case inferred = "Inferred"
            case names = "Names"
            case accountId = "AccountId"
        }
    }

    public struct PutTelemetryRecordsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceARN", required: false, type: .string), 
            AWSShapeMember(label: "TelemetryRecords", required: true, type: .list), 
            AWSShapeMember(label: "EC2InstanceId", required: false, type: .string), 
            AWSShapeMember(label: "Hostname", required: false, type: .string)
        ]
        public let resourceARN: String?
        public let telemetryRecords: [TelemetryRecord]
        public let eC2InstanceId: String?
        public let hostname: String?

        public init(resourceARN: String? = nil, telemetryRecords: [TelemetryRecord], eC2InstanceId: String? = nil, hostname: String? = nil) {
            self.resourceARN = resourceARN
            self.telemetryRecords = telemetryRecords
            self.eC2InstanceId = eC2InstanceId
            self.hostname = hostname
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case telemetryRecords = "TelemetryRecords"
            case eC2InstanceId = "EC2InstanceId"
            case hostname = "Hostname"
        }
    }

    public struct BackendConnectionErrors: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "OtherCount", required: false, type: .integer), 
            AWSShapeMember(label: "ConnectionRefusedCount", required: false, type: .integer), 
            AWSShapeMember(label: "HTTPCode4XXCount", required: false, type: .integer), 
            AWSShapeMember(label: "HTTPCode5XXCount", required: false, type: .integer), 
            AWSShapeMember(label: "UnknownHostCount", required: false, type: .integer), 
            AWSShapeMember(label: "TimeoutCount", required: false, type: .integer)
        ]
        public let otherCount: Int32?
        public let connectionRefusedCount: Int32?
        public let hTTPCode4XXCount: Int32?
        public let hTTPCode5XXCount: Int32?
        public let unknownHostCount: Int32?
        public let timeoutCount: Int32?

        public init(otherCount: Int32? = nil, connectionRefusedCount: Int32? = nil, hTTPCode4XXCount: Int32? = nil, hTTPCode5XXCount: Int32? = nil, unknownHostCount: Int32? = nil, timeoutCount: Int32? = nil) {
            self.otherCount = otherCount
            self.connectionRefusedCount = connectionRefusedCount
            self.hTTPCode4XXCount = hTTPCode4XXCount
            self.hTTPCode5XXCount = hTTPCode5XXCount
            self.unknownHostCount = unknownHostCount
            self.timeoutCount = timeoutCount
        }

        private enum CodingKeys: String, CodingKey {
            case otherCount = "OtherCount"
            case connectionRefusedCount = "ConnectionRefusedCount"
            case hTTPCode4XXCount = "HTTPCode4XXCount"
            case hTTPCode5XXCount = "HTTPCode5XXCount"
            case unknownHostCount = "UnknownHostCount"
            case timeoutCount = "TimeoutCount"
        }
    }

    public struct CreateSamplingRuleResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SamplingRuleRecord", required: false, type: .structure)
        ]
        /// The saved rule definition and metadata.
        public let samplingRuleRecord: SamplingRuleRecord?

        public init(samplingRuleRecord: SamplingRuleRecord? = nil) {
            self.samplingRuleRecord = samplingRuleRecord
        }

        private enum CodingKeys: String, CodingKey {
            case samplingRuleRecord = "SamplingRuleRecord"
        }
    }

    public struct UpdateSamplingRuleResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SamplingRuleRecord", required: false, type: .structure)
        ]
        /// The updated rule definition and metadata.
        public let samplingRuleRecord: SamplingRuleRecord?

        public init(samplingRuleRecord: SamplingRuleRecord? = nil) {
            self.samplingRuleRecord = samplingRuleRecord
        }

        private enum CodingKeys: String, CodingKey {
            case samplingRuleRecord = "SamplingRuleRecord"
        }
    }

    public struct CreateGroupRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GroupName", required: true, type: .string), 
            AWSShapeMember(label: "FilterExpression", required: false, type: .string)
        ]
        /// The case-sensitive name of the new group. Default is a reserved name and names must be unique.
        public let groupName: String
        /// The filter expression defining criteria by which to group traces.
        public let filterExpression: String?

        public init(groupName: String, filterExpression: String? = nil) {
            self.groupName = groupName
            self.filterExpression = filterExpression
        }

        private enum CodingKeys: String, CodingKey {
            case groupName = "GroupName"
            case filterExpression = "FilterExpression"
        }
    }

    public struct GetSamplingRulesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// Pagination token. Not used.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
        }
    }

    public struct ErrorStatistics: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "OtherCount", required: false, type: .long), 
            AWSShapeMember(label: "ThrottleCount", required: false, type: .long), 
            AWSShapeMember(label: "TotalCount", required: false, type: .long)
        ]
        /// The number of requests that failed with untracked 4xx Client Error status codes.
        public let otherCount: Int64?
        /// The number of requests that failed with a 419 throttling status code.
        public let throttleCount: Int64?
        /// The total number of requests that failed with a 4xx Client Error status code.
        public let totalCount: Int64?

        public init(otherCount: Int64? = nil, throttleCount: Int64? = nil, totalCount: Int64? = nil) {
            self.otherCount = otherCount
            self.throttleCount = throttleCount
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case otherCount = "OtherCount"
            case throttleCount = "ThrottleCount"
            case totalCount = "TotalCount"
        }
    }

    public struct GetSamplingRulesResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SamplingRuleRecords", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// Rule definitions and metadata.
        public let samplingRuleRecords: [SamplingRuleRecord]?
        /// Pagination token. Not used.
        public let nextToken: String?

        public init(samplingRuleRecords: [SamplingRuleRecord]? = nil, nextToken: String? = nil) {
            self.samplingRuleRecords = samplingRuleRecords
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case samplingRuleRecords = "SamplingRuleRecords"
            case nextToken = "NextToken"
        }
    }

    public struct GetSamplingStatisticSummariesResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "SamplingStatisticSummaries", required: false, type: .list)
        ]
        /// Pagination token. Not used.
        public let nextToken: String?
        /// Information about the number of requests instrumented for each sampling rule.
        public let samplingStatisticSummaries: [SamplingStatisticSummary]?

        public init(nextToken: String? = nil, samplingStatisticSummaries: [SamplingStatisticSummary]? = nil) {
            self.nextToken = nextToken
            self.samplingStatisticSummaries = samplingStatisticSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case samplingStatisticSummaries = "SamplingStatisticSummaries"
        }
    }

    public struct ResourceARNDetail: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ARN", required: false, type: .string)
        ]
        /// The ARN of a corresponding resource.
        public let arn: String?

        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "ARN"
        }
    }

    public struct GetTraceGraphResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Services", required: false, type: .list)
        ]
        /// Pagination token. Not used.
        public let nextToken: String?
        /// The services that have processed one of the specified requests.
        public let services: [Service]?

        public init(nextToken: String? = nil, services: [Service]? = nil) {
            self.nextToken = nextToken
            self.services = services
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case services = "Services"
        }
    }

    public struct GetGroupResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Group", required: false, type: .structure)
        ]
        /// The group that was requested. Contains the name of the group, the ARN of the group, and the filter expression that assigned to the group.
        public let group: Group?

        public init(group: Group? = nil) {
            self.group = group
        }

        private enum CodingKeys: String, CodingKey {
            case group = "Group"
        }
    }

    public struct BatchGetTracesResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Traces", required: false, type: .list), 
            AWSShapeMember(label: "UnprocessedTraceIds", required: false, type: .list)
        ]
        /// Pagination token. Not used.
        public let nextToken: String?
        /// Full traces for the specified requests.
        public let traces: [Trace]?
        /// Trace IDs of requests that haven't been processed.
        public let unprocessedTraceIds: [String]?

        public init(nextToken: String? = nil, traces: [Trace]? = nil, unprocessedTraceIds: [String]? = nil) {
            self.nextToken = nextToken
            self.traces = traces
            self.unprocessedTraceIds = unprocessedTraceIds
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case traces = "Traces"
            case unprocessedTraceIds = "UnprocessedTraceIds"
        }
    }

    public struct AnnotationValue: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StringValue", required: false, type: .string), 
            AWSShapeMember(label: "NumberValue", required: false, type: .double), 
            AWSShapeMember(label: "BooleanValue", required: false, type: .boolean)
        ]
        /// Value for a String annotation.
        public let stringValue: String?
        /// Value for a Number annotation.
        public let numberValue: Double?
        /// Value for a Boolean annotation.
        public let booleanValue: Bool?

        public init(stringValue: String? = nil, numberValue: Double? = nil, booleanValue: Bool? = nil) {
            self.stringValue = stringValue
            self.numberValue = numberValue
            self.booleanValue = booleanValue
        }

        private enum CodingKeys: String, CodingKey {
            case stringValue = "StringValue"
            case numberValue = "NumberValue"
            case booleanValue = "BooleanValue"
        }
    }

    public enum EncryptionType: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case kms = "KMS"
        public var description: String { return self.rawValue }
    }

    public struct GetGroupsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// Pagination token. Not used.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
        }
    }

    public struct PutTraceSegmentsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TraceSegmentDocuments", required: true, type: .list)
        ]
        /// A string containing a JSON document defining one or more segments or subsegments.
        public let traceSegmentDocuments: [String]

        public init(traceSegmentDocuments: [String]) {
            self.traceSegmentDocuments = traceSegmentDocuments
        }

        private enum CodingKeys: String, CodingKey {
            case traceSegmentDocuments = "TraceSegmentDocuments"
        }
    }

    public struct GetEncryptionConfigRequest: AWSShape {

    }

    public struct Http: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HttpMethod", required: false, type: .string), 
            AWSShapeMember(label: "UserAgent", required: false, type: .string), 
            AWSShapeMember(label: "HttpURL", required: false, type: .string), 
            AWSShapeMember(label: "HttpStatus", required: false, type: .integer), 
            AWSShapeMember(label: "ClientIp", required: false, type: .string)
        ]
        /// The request method.
        public let httpMethod: String?
        /// The request's user agent string.
        public let userAgent: String?
        /// The request URL.
        public let httpURL: String?
        /// The response status.
        public let httpStatus: Int32?
        /// The IP address of the requestor.
        public let clientIp: String?

        public init(httpMethod: String? = nil, userAgent: String? = nil, httpURL: String? = nil, httpStatus: Int32? = nil, clientIp: String? = nil) {
            self.httpMethod = httpMethod
            self.userAgent = userAgent
            self.httpURL = httpURL
            self.httpStatus = httpStatus
            self.clientIp = clientIp
        }

        private enum CodingKeys: String, CodingKey {
            case httpMethod = "HttpMethod"
            case userAgent = "UserAgent"
            case httpURL = "HttpURL"
            case httpStatus = "HttpStatus"
            case clientIp = "ClientIp"
        }
    }

    public struct SamplingStatisticsDocument: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "RequestCount", required: true, type: .integer), 
            AWSShapeMember(label: "ClientID", required: true, type: .string), 
            AWSShapeMember(label: "BorrowCount", required: false, type: .integer), 
            AWSShapeMember(label: "RuleName", required: true, type: .string), 
            AWSShapeMember(label: "Timestamp", required: true, type: .timestamp), 
            AWSShapeMember(label: "SampledCount", required: true, type: .integer)
        ]
        /// The number of requests that matched the rule.
        public let requestCount: Int32
        /// A unique identifier for the service in hexadecimal.
        public let clientID: String
        /// The number of requests recorded with borrowed reservoir quota.
        public let borrowCount: Int32?
        /// The name of the sampling rule.
        public let ruleName: String
        /// The current time.
        public let timestamp: TimeStamp
        /// The number of requests recorded.
        public let sampledCount: Int32

        public init(requestCount: Int32, clientID: String, borrowCount: Int32? = nil, ruleName: String, timestamp: TimeStamp, sampledCount: Int32) {
            self.requestCount = requestCount
            self.clientID = clientID
            self.borrowCount = borrowCount
            self.ruleName = ruleName
            self.timestamp = timestamp
            self.sampledCount = sampledCount
        }

        private enum CodingKeys: String, CodingKey {
            case requestCount = "RequestCount"
            case clientID = "ClientID"
            case borrowCount = "BorrowCount"
            case ruleName = "RuleName"
            case timestamp = "Timestamp"
            case sampledCount = "SampledCount"
        }
    }

    public struct GetServiceGraphResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContainsOldGroupVersions", required: false, type: .boolean), 
            AWSShapeMember(label: "EndTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Services", required: false, type: .list), 
            AWSShapeMember(label: "StartTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// A flag indicating whether the group's filter expression has been consistent, or if the returned service graph may show traces from an older version of the group's filter expression.
        public let containsOldGroupVersions: Bool?
        /// The end of the time frame for which the graph was generated.
        public let endTime: TimeStamp?
        /// The services that have processed a traced request during the specified time frame.
        public let services: [Service]?
        /// The start of the time frame for which the graph was generated.
        public let startTime: TimeStamp?
        /// Pagination token. Not used.
        public let nextToken: String?

        public init(containsOldGroupVersions: Bool? = nil, endTime: TimeStamp? = nil, services: [Service]? = nil, startTime: TimeStamp? = nil, nextToken: String? = nil) {
            self.containsOldGroupVersions = containsOldGroupVersions
            self.endTime = endTime
            self.services = services
            self.startTime = startTime
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case containsOldGroupVersions = "ContainsOldGroupVersions"
            case endTime = "EndTime"
            case services = "Services"
            case startTime = "StartTime"
            case nextToken = "NextToken"
        }
    }

    public struct FaultRootCauseEntity: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Exceptions", required: false, type: .list), 
            AWSShapeMember(label: "Remote", required: false, type: .boolean), 
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]
        /// The types and messages of the exceptions.
        public let exceptions: [RootCauseException]?
        /// A flag that denotes a remote subsegment.
        public let remote: Bool?
        /// The name of the entity.
        public let name: String?

        public init(exceptions: [RootCauseException]? = nil, remote: Bool? = nil, name: String? = nil) {
            self.exceptions = exceptions
            self.remote = remote
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case exceptions = "Exceptions"
            case remote = "Remote"
            case name = "Name"
        }
    }

    public struct GetEncryptionConfigResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EncryptionConfig", required: false, type: .structure)
        ]
        /// The encryption configuration document.
        public let encryptionConfig: EncryptionConfig?

        public init(encryptionConfig: EncryptionConfig? = nil) {
            self.encryptionConfig = encryptionConfig
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfig = "EncryptionConfig"
        }
    }

    public struct SamplingRuleRecord: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ModifiedAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "CreatedAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "SamplingRule", required: false, type: .structure)
        ]
        /// When the rule was last modified.
        public let modifiedAt: TimeStamp?
        /// When the rule was created.
        public let createdAt: TimeStamp?
        /// The sampling rule.
        public let samplingRule: SamplingRule?

        public init(modifiedAt: TimeStamp? = nil, createdAt: TimeStamp? = nil, samplingRule: SamplingRule? = nil) {
            self.modifiedAt = modifiedAt
            self.createdAt = createdAt
            self.samplingRule = samplingRule
        }

        private enum CodingKeys: String, CodingKey {
            case modifiedAt = "ModifiedAt"
            case createdAt = "CreatedAt"
            case samplingRule = "SamplingRule"
        }
    }

    public struct ResponseTimeRootCauseEntity: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Remote", required: false, type: .boolean), 
            AWSShapeMember(label: "Coverage", required: false, type: .double), 
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]
        /// A flag that denotes a remote subsegment.
        public let remote: Bool?
        /// The types and messages of the exceptions.
        public let coverage: Double?
        /// The name of the entity.
        public let name: String?

        public init(remote: Bool? = nil, coverage: Double? = nil, name: String? = nil) {
            self.remote = remote
            self.coverage = coverage
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case remote = "Remote"
            case coverage = "Coverage"
            case name = "Name"
        }
    }

    public struct Service: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResponseTimeHistogram", required: false, type: .list), 
            AWSShapeMember(label: "Names", required: false, type: .list), 
            AWSShapeMember(label: "State", required: false, type: .string), 
            AWSShapeMember(label: "AccountId", required: false, type: .string), 
            AWSShapeMember(label: "DurationHistogram", required: false, type: .list), 
            AWSShapeMember(label: "Type", required: false, type: .string), 
            AWSShapeMember(label: "StartTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Edges", required: false, type: .list), 
            AWSShapeMember(label: "SummaryStatistics", required: false, type: .structure), 
            AWSShapeMember(label: "ReferenceId", required: false, type: .integer), 
            AWSShapeMember(label: "EndTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Root", required: false, type: .boolean)
        ]
        /// A histogram that maps the spread of service response times.
        public let responseTimeHistogram: [HistogramEntry]?
        /// A list of names for the service, including the canonical name.
        public let names: [String]?
        /// The service's state.
        public let state: String?
        /// Identifier of the AWS account in which the service runs.
        public let accountId: String?
        /// A histogram that maps the spread of service durations.
        public let durationHistogram: [HistogramEntry]?
        /// The type of service.   AWS Resource - The type of an AWS resource. For example, AWS::EC2::Instance for a application running on Amazon EC2 or AWS::DynamoDB::Table for an Amazon DynamoDB table that the application used.   AWS Service - The type of an AWS service. For example, AWS::DynamoDB for downstream calls to Amazon DynamoDB that didn't target a specific table.    client - Represents the clients that sent requests to a root service.    remote - A downstream service of indeterminate type.  
        public let `type`: String?
        /// The start time of the first segment that the service generated.
        public let startTime: TimeStamp?
        /// Connections to downstream services.
        public let edges: [Edge]?
        /// Aggregated statistics for the service.
        public let summaryStatistics: ServiceStatistics?
        /// Identifier for the service. Unique within the service map.
        public let referenceId: Int32?
        /// The end time of the last segment that the service generated.
        public let endTime: TimeStamp?
        /// The canonical name of the service.
        public let name: String?
        /// Indicates that the service was the first service to process a request.
        public let root: Bool?

        public init(responseTimeHistogram: [HistogramEntry]? = nil, names: [String]? = nil, state: String? = nil, accountId: String? = nil, durationHistogram: [HistogramEntry]? = nil, type: String? = nil, startTime: TimeStamp? = nil, edges: [Edge]? = nil, summaryStatistics: ServiceStatistics? = nil, referenceId: Int32? = nil, endTime: TimeStamp? = nil, name: String? = nil, root: Bool? = nil) {
            self.responseTimeHistogram = responseTimeHistogram
            self.names = names
            self.state = state
            self.accountId = accountId
            self.durationHistogram = durationHistogram
            self.`type` = `type`
            self.startTime = startTime
            self.edges = edges
            self.summaryStatistics = summaryStatistics
            self.referenceId = referenceId
            self.endTime = endTime
            self.name = name
            self.root = root
        }

        private enum CodingKeys: String, CodingKey {
            case responseTimeHistogram = "ResponseTimeHistogram"
            case names = "Names"
            case state = "State"
            case accountId = "AccountId"
            case durationHistogram = "DurationHistogram"
            case `type` = "Type"
            case startTime = "StartTime"
            case edges = "Edges"
            case summaryStatistics = "SummaryStatistics"
            case referenceId = "ReferenceId"
            case endTime = "EndTime"
            case name = "Name"
            case root = "Root"
        }
    }

    public struct Segment: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Document", required: false, type: .string)
        ]
        /// The segment's ID.
        public let id: String?
        /// The segment document.
        public let document: String?

        public init(id: String? = nil, document: String? = nil) {
            self.id = id
            self.document = document
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case document = "Document"
        }
    }

    public struct DeleteGroupResult: AWSShape {

    }

    public struct RootCauseException: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Message", required: false, type: .string)
        ]
        /// The name of the exception.
        public let name: String?
        /// The message of the exception.
        public let message: String?

        public init(name: String? = nil, message: String? = nil) {
            self.name = name
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case message = "Message"
        }
    }

    public struct CreateGroupResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Group", required: false, type: .structure)
        ]
        /// The group that was created. Contains the name of the group that was created, the ARN of the group that was generated based on the group name, and the filter expression that was assigned to the group.
        public let group: Group?

        public init(group: Group? = nil) {
            self.group = group
        }

        private enum CodingKeys: String, CodingKey {
            case group = "Group"
        }
    }

    public struct ErrorRootCauseService: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Names", required: false, type: .list), 
            AWSShapeMember(label: "Inferred", required: false, type: .boolean), 
            AWSShapeMember(label: "AccountId", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "EntityPath", required: false, type: .list), 
            AWSShapeMember(label: "Type", required: false, type: .string)
        ]
        /// A collection of associated service names.
        public let names: [String]?
        /// A Boolean value indicating if the service is inferred from the trace.
        public let inferred: Bool?
        /// The account ID associated to the service.
        public let accountId: String?
        /// The service name.
        public let name: String?
        /// The path of root cause entities found on the service. 
        public let entityPath: [ErrorRootCauseEntity]?
        /// The type associated to the service.
        public let `type`: String?

        public init(names: [String]? = nil, inferred: Bool? = nil, accountId: String? = nil, name: String? = nil, entityPath: [ErrorRootCauseEntity]? = nil, type: String? = nil) {
            self.names = names
            self.inferred = inferred
            self.accountId = accountId
            self.name = name
            self.entityPath = entityPath
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case names = "Names"
            case inferred = "Inferred"
            case accountId = "AccountId"
            case name = "Name"
            case entityPath = "EntityPath"
            case `type` = "Type"
        }
    }

    public struct UpdateSamplingRuleRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SamplingRuleUpdate", required: true, type: .structure)
        ]
        /// The rule and fields to change.
        public let samplingRuleUpdate: SamplingRuleUpdate

        public init(samplingRuleUpdate: SamplingRuleUpdate) {
            self.samplingRuleUpdate = samplingRuleUpdate
        }

        private enum CodingKeys: String, CodingKey {
            case samplingRuleUpdate = "SamplingRuleUpdate"
        }
    }

    public struct GetSamplingTargetsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LastRuleModification", required: false, type: .timestamp), 
            AWSShapeMember(label: "SamplingTargetDocuments", required: false, type: .list), 
            AWSShapeMember(label: "UnprocessedStatistics", required: false, type: .list)
        ]
        /// The last time a user changed the sampling rule configuration. If the sampling rule configuration changed since the service last retrieved it, the service should call GetSamplingRules to get the latest version.
        public let lastRuleModification: TimeStamp?
        /// Updated rules that the service should use to sample requests.
        public let samplingTargetDocuments: [SamplingTargetDocument]?
        /// Information about SamplingStatisticsDocument that X-Ray could not process.
        public let unprocessedStatistics: [UnprocessedStatistics]?

        public init(lastRuleModification: TimeStamp? = nil, samplingTargetDocuments: [SamplingTargetDocument]? = nil, unprocessedStatistics: [UnprocessedStatistics]? = nil) {
            self.lastRuleModification = lastRuleModification
            self.samplingTargetDocuments = samplingTargetDocuments
            self.unprocessedStatistics = unprocessedStatistics
        }

        private enum CodingKeys: String, CodingKey {
            case lastRuleModification = "LastRuleModification"
            case samplingTargetDocuments = "SamplingTargetDocuments"
            case unprocessedStatistics = "UnprocessedStatistics"
        }
    }

    public struct GetSamplingTargetsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SamplingStatisticsDocuments", required: true, type: .list)
        ]
        /// Information about rules that the service is using to sample requests.
        public let samplingStatisticsDocuments: [SamplingStatisticsDocument]

        public init(samplingStatisticsDocuments: [SamplingStatisticsDocument]) {
            self.samplingStatisticsDocuments = samplingStatisticsDocuments
        }

        private enum CodingKeys: String, CodingKey {
            case samplingStatisticsDocuments = "SamplingStatisticsDocuments"
        }
    }

    public struct SamplingRuleUpdate: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceARN", required: false, type: .string), 
            AWSShapeMember(label: "ServiceType", required: false, type: .string), 
            AWSShapeMember(label: "FixedRate", required: false, type: .double), 
            AWSShapeMember(label: "Host", required: false, type: .string), 
            AWSShapeMember(label: "RuleARN", required: false, type: .string), 
            AWSShapeMember(label: "RuleName", required: false, type: .string), 
            AWSShapeMember(label: "HTTPMethod", required: false, type: .string), 
            AWSShapeMember(label: "ReservoirSize", required: false, type: .integer), 
            AWSShapeMember(label: "URLPath", required: false, type: .string), 
            AWSShapeMember(label: "Priority", required: false, type: .integer), 
            AWSShapeMember(label: "ServiceName", required: false, type: .string), 
            AWSShapeMember(label: "Attributes", required: false, type: .map)
        ]
        /// Matches the ARN of the AWS resource on which the service runs.
        public let resourceARN: String?
        /// Matches the origin that the service uses to identify its type in segments.
        public let serviceType: String?
        /// The percentage of matching requests to instrument, after the reservoir is exhausted.
        public let fixedRate: Double?
        /// Matches the hostname from a request URL.
        public let host: String?
        /// The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.
        public let ruleARN: String?
        /// The name of the sampling rule. Specify a rule by either name or ARN, but not both.
        public let ruleName: String?
        /// Matches the HTTP method of a request.
        public let hTTPMethod: String?
        /// A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.
        public let reservoirSize: Int32?
        /// Matches the path from a request URL.
        public let uRLPath: String?
        /// The priority of the sampling rule.
        public let priority: Int32?
        /// Matches the name that the service uses to identify itself in segments.
        public let serviceName: String?
        /// Matches attributes derived from the request.
        public let attributes: [String: String]?

        public init(resourceARN: String? = nil, serviceType: String? = nil, fixedRate: Double? = nil, host: String? = nil, ruleARN: String? = nil, ruleName: String? = nil, hTTPMethod: String? = nil, reservoirSize: Int32? = nil, uRLPath: String? = nil, priority: Int32? = nil, serviceName: String? = nil, attributes: [String: String]? = nil) {
            self.resourceARN = resourceARN
            self.serviceType = serviceType
            self.fixedRate = fixedRate
            self.host = host
            self.ruleARN = ruleARN
            self.ruleName = ruleName
            self.hTTPMethod = hTTPMethod
            self.reservoirSize = reservoirSize
            self.uRLPath = uRLPath
            self.priority = priority
            self.serviceName = serviceName
            self.attributes = attributes
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case serviceType = "ServiceType"
            case fixedRate = "FixedRate"
            case host = "Host"
            case ruleARN = "RuleARN"
            case ruleName = "RuleName"
            case hTTPMethod = "HTTPMethod"
            case reservoirSize = "ReservoirSize"
            case uRLPath = "URLPath"
            case priority = "Priority"
            case serviceName = "ServiceName"
            case attributes = "Attributes"
        }
    }

    public struct GetTraceSummariesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "EndTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "StartTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "FilterExpression", required: false, type: .string), 
            AWSShapeMember(label: "Sampling", required: false, type: .boolean)
        ]
        /// Specify the pagination token returned by a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The end of the time frame for which to retrieve traces.
        public let endTime: TimeStamp
        /// The start of the time frame for which to retrieve traces.
        public let startTime: TimeStamp
        /// Specify a filter expression to retrieve trace summaries for services or requests that meet certain requirements.
        public let filterExpression: String?
        /// Set to true to get summaries for only a subset of available traces.
        public let sampling: Bool?

        public init(nextToken: String? = nil, endTime: TimeStamp, startTime: TimeStamp, filterExpression: String? = nil, sampling: Bool? = nil) {
            self.nextToken = nextToken
            self.endTime = endTime
            self.startTime = startTime
            self.filterExpression = filterExpression
            self.sampling = sampling
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case endTime = "EndTime"
            case startTime = "StartTime"
            case filterExpression = "FilterExpression"
            case sampling = "Sampling"
        }
    }

    public struct ResponseTimeRootCause: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Services", required: false, type: .list)
        ]
        /// A list of corresponding services. A service identifies a segment and contains a name, account ID, type, and inferred flag.
        public let services: [ResponseTimeRootCauseService]?

        public init(services: [ResponseTimeRootCauseService]? = nil) {
            self.services = services
        }

        private enum CodingKeys: String, CodingKey {
            case services = "Services"
        }
    }

    public struct TraceUser: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ServiceIds", required: false, type: .list), 
            AWSShapeMember(label: "UserName", required: false, type: .string)
        ]
        /// Services that the user's request hit.
        public let serviceIds: [ServiceId]?
        /// The user's name.
        public let userName: String?

        public init(serviceIds: [ServiceId]? = nil, userName: String? = nil) {
            self.serviceIds = serviceIds
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case serviceIds = "ServiceIds"
            case userName = "UserName"
        }
    }

    public struct DeleteSamplingRuleRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "RuleARN", required: false, type: .string), 
            AWSShapeMember(label: "RuleName", required: false, type: .string)
        ]
        /// The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.
        public let ruleARN: String?
        /// The name of the sampling rule. Specify a rule by either name or ARN, but not both.
        public let ruleName: String?

        public init(ruleARN: String? = nil, ruleName: String? = nil) {
            self.ruleARN = ruleARN
            self.ruleName = ruleName
        }

        private enum CodingKeys: String, CodingKey {
            case ruleARN = "RuleARN"
            case ruleName = "RuleName"
        }
    }

    public struct ErrorRootCauseEntity: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Exceptions", required: false, type: .list), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Remote", required: false, type: .boolean)
        ]
        /// The types and messages of the exceptions.
        public let exceptions: [RootCauseException]?
        /// The name of the entity.
        public let name: String?
        /// A flag that denotes a remote subsegment.
        public let remote: Bool?

        public init(exceptions: [RootCauseException]? = nil, name: String? = nil, remote: Bool? = nil) {
            self.exceptions = exceptions
            self.name = name
            self.remote = remote
        }

        private enum CodingKeys: String, CodingKey {
            case exceptions = "Exceptions"
            case name = "Name"
            case remote = "Remote"
        }
    }

    public struct GetServiceGraphRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "EndTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "StartTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "GroupARN", required: false, type: .string), 
            AWSShapeMember(label: "GroupName", required: false, type: .string)
        ]
        /// Pagination token. Not used.
        public let nextToken: String?
        /// The end of the timeframe for which to generate a graph.
        public let endTime: TimeStamp
        /// The start of the time frame for which to generate a graph.
        public let startTime: TimeStamp
        /// The ARN of a group to generate a graph based on.
        public let groupARN: String?
        /// The name of a group to generate a graph based on.
        public let groupName: String?

        public init(nextToken: String? = nil, endTime: TimeStamp, startTime: TimeStamp, groupARN: String? = nil, groupName: String? = nil) {
            self.nextToken = nextToken
            self.endTime = endTime
            self.startTime = startTime
            self.groupARN = groupARN
            self.groupName = groupName
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case endTime = "EndTime"
            case startTime = "StartTime"
            case groupARN = "GroupARN"
            case groupName = "GroupName"
        }
    }

    public struct DeleteSamplingRuleResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SamplingRuleRecord", required: false, type: .structure)
        ]
        /// The deleted rule definition and metadata.
        public let samplingRuleRecord: SamplingRuleRecord?

        public init(samplingRuleRecord: SamplingRuleRecord? = nil) {
            self.samplingRuleRecord = samplingRuleRecord
        }

        private enum CodingKeys: String, CodingKey {
            case samplingRuleRecord = "SamplingRuleRecord"
        }
    }

    public struct ResponseTimeRootCauseService: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Inferred", required: false, type: .boolean), 
            AWSShapeMember(label: "Type", required: false, type: .string), 
            AWSShapeMember(label: "EntityPath", required: false, type: .list), 
            AWSShapeMember(label: "Names", required: false, type: .list), 
            AWSShapeMember(label: "AccountId", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]
        /// A Boolean value indicating if the service is inferred from the trace.
        public let inferred: Bool?
        /// The type associated to the service.
        public let `type`: String?
        /// The path of root cause entities found on the service. 
        public let entityPath: [ResponseTimeRootCauseEntity]?
        /// A collection of associated service names.
        public let names: [String]?
        /// The account ID associated to the service.
        public let accountId: String?
        /// The service name.
        public let name: String?

        public init(inferred: Bool? = nil, type: String? = nil, entityPath: [ResponseTimeRootCauseEntity]? = nil, names: [String]? = nil, accountId: String? = nil, name: String? = nil) {
            self.inferred = inferred
            self.`type` = `type`
            self.entityPath = entityPath
            self.names = names
            self.accountId = accountId
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case inferred = "Inferred"
            case `type` = "Type"
            case entityPath = "EntityPath"
            case names = "Names"
            case accountId = "AccountId"
            case name = "Name"
        }
    }

    public struct Alias: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Type", required: false, type: .string), 
            AWSShapeMember(label: "Names", required: false, type: .list)
        ]
        /// The canonical name of the alias.
        public let name: String?
        /// The type of the alias.
        public let `type`: String?
        /// A list of names for the alias, including the canonical name.
        public let names: [String]?

        public init(name: String? = nil, type: String? = nil, names: [String]? = nil) {
            self.name = name
            self.`type` = `type`
            self.names = names
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case `type` = "Type"
            case names = "Names"
        }
    }

    public struct InstanceIdDetail: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", required: false, type: .string)
        ]
        /// The ID of a corresponding EC2 instance.
        public let id: String?

        public init(id: String? = nil) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
        }
    }

    public struct UpdateGroupRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GroupName", required: false, type: .string), 
            AWSShapeMember(label: "GroupARN", required: false, type: .string), 
            AWSShapeMember(label: "FilterExpression", required: false, type: .string)
        ]
        /// The case-sensitive name of the group.
        public let groupName: String?
        /// The ARN that was generated upon creation.
        public let groupARN: String?
        /// The updated filter expression defining criteria by which to group traces.
        public let filterExpression: String?

        public init(groupName: String? = nil, groupARN: String? = nil, filterExpression: String? = nil) {
            self.groupName = groupName
            self.groupARN = groupARN
            self.filterExpression = filterExpression
        }

        private enum CodingKeys: String, CodingKey {
            case groupName = "GroupName"
            case groupARN = "GroupARN"
            case filterExpression = "FilterExpression"
        }
    }

    public enum EncryptionStatus: String, CustomStringConvertible, Codable {
        case updating = "UPDATING"
        case active = "ACTIVE"
        public var description: String { return self.rawValue }
    }

    public struct EncryptionConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "KeyId", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .enum), 
            AWSShapeMember(label: "Type", required: false, type: .enum)
        ]
        /// The ID of the customer master key (CMK) used for encryption, if applicable.
        public let keyId: String?
        /// The encryption status. While the status is UPDATING, X-Ray may encrypt data with a combination of the new and old settings.
        public let status: EncryptionStatus?
        /// The type of encryption. Set to KMS for encryption with CMKs. Set to NONE for default encryption.
        public let `type`: EncryptionType?

        public init(keyId: String? = nil, status: EncryptionStatus? = nil, type: EncryptionType? = nil) {
            self.keyId = keyId
            self.status = status
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case keyId = "KeyId"
            case status = "Status"
            case `type` = "Type"
        }
    }

    public struct AvailabilityZoneDetail: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]
        /// The name of a corresponding availability zone.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct ValueWithServiceIds: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AnnotationValue", required: false, type: .structure), 
            AWSShapeMember(label: "ServiceIds", required: false, type: .list)
        ]
        /// Values of the annotation.
        public let annotationValue: AnnotationValue?
        /// Services to which the annotation applies.
        public let serviceIds: [ServiceId]?

        public init(annotationValue: AnnotationValue? = nil, serviceIds: [ServiceId]? = nil) {
            self.annotationValue = annotationValue
            self.serviceIds = serviceIds
        }

        private enum CodingKeys: String, CodingKey {
            case annotationValue = "AnnotationValue"
            case serviceIds = "ServiceIds"
        }
    }

    public struct GetTraceGraphRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TraceIds", required: true, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// Trace IDs of requests for which to generate a service graph.
        public let traceIds: [String]
        /// Pagination token. Not used.
        public let nextToken: String?

        public init(traceIds: [String], nextToken: String? = nil) {
            self.traceIds = traceIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case traceIds = "TraceIds"
            case nextToken = "NextToken"
        }
    }

    public struct PutTraceSegmentsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UnprocessedTraceSegments", required: false, type: .list)
        ]
        /// Segments that failed processing.
        public let unprocessedTraceSegments: [UnprocessedTraceSegment]?

        public init(unprocessedTraceSegments: [UnprocessedTraceSegment]? = nil) {
            self.unprocessedTraceSegments = unprocessedTraceSegments
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedTraceSegments = "UnprocessedTraceSegments"
        }
    }

    public struct UnprocessedStatistics: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "RuleName", required: false, type: .string), 
            AWSShapeMember(label: "ErrorCode", required: false, type: .string), 
            AWSShapeMember(label: "Message", required: false, type: .string)
        ]
        /// The name of the sampling rule.
        public let ruleName: String?
        /// The error code.
        public let errorCode: String?
        /// The error message.
        public let message: String?

        public init(ruleName: String? = nil, errorCode: String? = nil, message: String? = nil) {
            self.ruleName = ruleName
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case ruleName = "RuleName"
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct GetTraceSummariesResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TraceSummaries", required: false, type: .list), 
            AWSShapeMember(label: "ApproximateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "TracesProcessedCount", required: false, type: .long), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// Trace IDs and metadata for traces that were found in the specified time frame.
        public let traceSummaries: [TraceSummary]?
        /// The start time of this page of results.
        public let approximateTime: TimeStamp?
        /// The total number of traces processed, including traces that did not match the specified filter expression.
        public let tracesProcessedCount: Int64?
        /// If the requested time frame contained more than one page of results, you can use this token to retrieve the next page. The first page contains the most most recent results, closest to the end of the time frame.
        public let nextToken: String?

        public init(traceSummaries: [TraceSummary]? = nil, approximateTime: TimeStamp? = nil, tracesProcessedCount: Int64? = nil, nextToken: String? = nil) {
            self.traceSummaries = traceSummaries
            self.approximateTime = approximateTime
            self.tracesProcessedCount = tracesProcessedCount
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case traceSummaries = "TraceSummaries"
            case approximateTime = "ApproximateTime"
            case tracesProcessedCount = "TracesProcessedCount"
            case nextToken = "NextToken"
        }
    }

    public struct ServiceStatistics: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TotalCount", required: false, type: .long), 
            AWSShapeMember(label: "TotalResponseTime", required: false, type: .double), 
            AWSShapeMember(label: "FaultStatistics", required: false, type: .structure), 
            AWSShapeMember(label: "ErrorStatistics", required: false, type: .structure), 
            AWSShapeMember(label: "OkCount", required: false, type: .long)
        ]
        /// The total number of completed requests.
        public let totalCount: Int64?
        /// The aggregate response time of completed requests.
        public let totalResponseTime: Double?
        /// Information about requests that failed with a 5xx Server Error status code.
        public let faultStatistics: FaultStatistics?
        /// Information about requests that failed with a 4xx Client Error status code.
        public let errorStatistics: ErrorStatistics?
        /// The number of requests that completed with a 2xx Success status code.
        public let okCount: Int64?

        public init(totalCount: Int64? = nil, totalResponseTime: Double? = nil, faultStatistics: FaultStatistics? = nil, errorStatistics: ErrorStatistics? = nil, okCount: Int64? = nil) {
            self.totalCount = totalCount
            self.totalResponseTime = totalResponseTime
            self.faultStatistics = faultStatistics
            self.errorStatistics = errorStatistics
            self.okCount = okCount
        }

        private enum CodingKeys: String, CodingKey {
            case totalCount = "TotalCount"
            case totalResponseTime = "TotalResponseTime"
            case faultStatistics = "FaultStatistics"
            case errorStatistics = "ErrorStatistics"
            case okCount = "OkCount"
        }
    }

    public struct ServiceId: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountId", required: false, type: .string), 
            AWSShapeMember(label: "Names", required: false, type: .list), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Type", required: false, type: .string)
        ]
        public let accountId: String?
        public let names: [String]?
        public let name: String?
        public let `type`: String?

        public init(accountId: String? = nil, names: [String]? = nil, name: String? = nil, type: String? = nil) {
            self.accountId = accountId
            self.names = names
            self.name = name
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case names = "Names"
            case name = "Name"
            case `type` = "Type"
        }
    }

    public struct SamplingTargetDocument: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Interval", required: false, type: .integer), 
            AWSShapeMember(label: "ReservoirQuota", required: false, type: .integer), 
            AWSShapeMember(label: "RuleName", required: false, type: .string), 
            AWSShapeMember(label: "FixedRate", required: false, type: .double), 
            AWSShapeMember(label: "ReservoirQuotaTTL", required: false, type: .timestamp)
        ]
        /// The number of seconds for the service to wait before getting sampling targets again.
        public let interval: Int32?
        /// The number of requests per second that X-Ray allocated this service.
        public let reservoirQuota: Int32?
        /// The name of the sampling rule.
        public let ruleName: String?
        /// The percentage of matching requests to instrument, after the reservoir is exhausted.
        public let fixedRate: Double?
        /// When the reservoir quota expires.
        public let reservoirQuotaTTL: TimeStamp?

        public init(interval: Int32? = nil, reservoirQuota: Int32? = nil, ruleName: String? = nil, fixedRate: Double? = nil, reservoirQuotaTTL: TimeStamp? = nil) {
            self.interval = interval
            self.reservoirQuota = reservoirQuota
            self.ruleName = ruleName
            self.fixedRate = fixedRate
            self.reservoirQuotaTTL = reservoirQuotaTTL
        }

        private enum CodingKeys: String, CodingKey {
            case interval = "Interval"
            case reservoirQuota = "ReservoirQuota"
            case ruleName = "RuleName"
            case fixedRate = "FixedRate"
            case reservoirQuotaTTL = "ReservoirQuotaTTL"
        }
    }

    public struct Group: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GroupName", required: false, type: .string), 
            AWSShapeMember(label: "GroupARN", required: false, type: .string), 
            AWSShapeMember(label: "FilterExpression", required: false, type: .string)
        ]
        /// The unique case-sensitive name of the group.
        public let groupName: String?
        /// The ARN of the group generated based on the GroupName.
        public let groupARN: String?
        /// The filter expression defining the parameters to include traces.
        public let filterExpression: String?

        public init(groupName: String? = nil, groupARN: String? = nil, filterExpression: String? = nil) {
            self.groupName = groupName
            self.groupARN = groupARN
            self.filterExpression = filterExpression
        }

        private enum CodingKeys: String, CodingKey {
            case groupName = "GroupName"
            case groupARN = "GroupARN"
            case filterExpression = "FilterExpression"
        }
    }

    public struct UpdateGroupResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Group", required: false, type: .structure)
        ]
        /// The group that was updated. Contains the name of the group that was updated, the ARN of the group that was updated, and the updated filter expression assigned to the group.
        public let group: Group?

        public init(group: Group? = nil) {
            self.group = group
        }

        private enum CodingKeys: String, CodingKey {
            case group = "Group"
        }
    }

    public struct GetSamplingStatisticSummariesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// Pagination token. Not used.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
        }
    }

    public struct EdgeStatistics: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FaultStatistics", required: false, type: .structure), 
            AWSShapeMember(label: "TotalResponseTime", required: false, type: .double), 
            AWSShapeMember(label: "TotalCount", required: false, type: .long), 
            AWSShapeMember(label: "ErrorStatistics", required: false, type: .structure), 
            AWSShapeMember(label: "OkCount", required: false, type: .long)
        ]
        /// Information about requests that failed with a 5xx Server Error status code.
        public let faultStatistics: FaultStatistics?
        /// The aggregate response time of completed requests.
        public let totalResponseTime: Double?
        /// The total number of completed requests.
        public let totalCount: Int64?
        /// Information about requests that failed with a 4xx Client Error status code.
        public let errorStatistics: ErrorStatistics?
        /// The number of requests that completed with a 2xx Success status code.
        public let okCount: Int64?

        public init(faultStatistics: FaultStatistics? = nil, totalResponseTime: Double? = nil, totalCount: Int64? = nil, errorStatistics: ErrorStatistics? = nil, okCount: Int64? = nil) {
            self.faultStatistics = faultStatistics
            self.totalResponseTime = totalResponseTime
            self.totalCount = totalCount
            self.errorStatistics = errorStatistics
            self.okCount = okCount
        }

        private enum CodingKeys: String, CodingKey {
            case faultStatistics = "FaultStatistics"
            case totalResponseTime = "TotalResponseTime"
            case totalCount = "TotalCount"
            case errorStatistics = "ErrorStatistics"
            case okCount = "OkCount"
        }
    }

    public struct GroupSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GroupName", required: false, type: .string), 
            AWSShapeMember(label: "GroupARN", required: false, type: .string), 
            AWSShapeMember(label: "FilterExpression", required: false, type: .string)
        ]
        /// The unique case-sensitive name of the group.
        public let groupName: String?
        /// The ARN of the group generated based on the GroupName.
        public let groupARN: String?
        /// The filter expression defining the parameters to include traces.
        public let filterExpression: String?

        public init(groupName: String? = nil, groupARN: String? = nil, filterExpression: String? = nil) {
            self.groupName = groupName
            self.groupARN = groupARN
            self.filterExpression = filterExpression
        }

        private enum CodingKeys: String, CodingKey {
            case groupName = "GroupName"
            case groupARN = "GroupARN"
            case filterExpression = "FilterExpression"
        }
    }

    public struct GetGroupsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Groups", required: false, type: .list)
        ]
        /// Pagination token. Not used.
        public let nextToken: String?
        /// The collection of all active groups.
        public let groups: [GroupSummary]?

        public init(nextToken: String? = nil, groups: [GroupSummary]? = nil) {
            self.nextToken = nextToken
            self.groups = groups
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case groups = "Groups"
        }
    }

    public struct Trace: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Segments", required: false, type: .list), 
            AWSShapeMember(label: "Duration", required: false, type: .double)
        ]
        /// The unique identifier for the request that generated the trace's segments and subsegments.
        public let id: String?
        /// Segment documents for the segments and subsegments that comprise the trace.
        public let segments: [Segment]?
        /// The length of time in seconds between the start time of the root segment and the end time of the last segment that completed.
        public let duration: Double?

        public init(id: String? = nil, segments: [Segment]? = nil, duration: Double? = nil) {
            self.id = id
            self.segments = segments
            self.duration = duration
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case segments = "Segments"
            case duration = "Duration"
        }
    }

    public struct DeleteGroupRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GroupName", required: false, type: .string), 
            AWSShapeMember(label: "GroupARN", required: false, type: .string)
        ]
        /// The case-sensitive name of the group.
        public let groupName: String?
        /// The ARN of the group that was generated on creation.
        public let groupARN: String?

        public init(groupName: String? = nil, groupARN: String? = nil) {
            self.groupName = groupName
            self.groupARN = groupARN
        }

        private enum CodingKeys: String, CodingKey {
            case groupName = "GroupName"
            case groupARN = "GroupARN"
        }
    }

    public struct HistogramEntry: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Count", required: false, type: .integer), 
            AWSShapeMember(label: "Value", required: false, type: .double)
        ]
        /// The prevalence of the entry.
        public let count: Int32?
        /// The value of the entry.
        public let value: Double?

        public init(count: Int32? = nil, value: Double? = nil) {
            self.count = count
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case count = "Count"
            case value = "Value"
        }
    }

    public struct SamplingStatisticSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SampledCount", required: false, type: .integer), 
            AWSShapeMember(label: "Timestamp", required: false, type: .timestamp), 
            AWSShapeMember(label: "RequestCount", required: false, type: .integer), 
            AWSShapeMember(label: "BorrowCount", required: false, type: .integer), 
            AWSShapeMember(label: "RuleName", required: false, type: .string)
        ]
        /// The number of requests recorded.
        public let sampledCount: Int32?
        /// The start time of the reporting window.
        public let timestamp: TimeStamp?
        /// The number of requests that matched the rule.
        public let requestCount: Int32?
        /// The number of requests recorded with borrowed reservoir quota.
        public let borrowCount: Int32?
        /// The name of the sampling rule.
        public let ruleName: String?

        public init(sampledCount: Int32? = nil, timestamp: TimeStamp? = nil, requestCount: Int32? = nil, borrowCount: Int32? = nil, ruleName: String? = nil) {
            self.sampledCount = sampledCount
            self.timestamp = timestamp
            self.requestCount = requestCount
            self.borrowCount = borrowCount
            self.ruleName = ruleName
        }

        private enum CodingKeys: String, CodingKey {
            case sampledCount = "SampledCount"
            case timestamp = "Timestamp"
            case requestCount = "RequestCount"
            case borrowCount = "BorrowCount"
            case ruleName = "RuleName"
        }
    }

    public struct UnprocessedTraceSegment: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ErrorCode", required: false, type: .string), 
            AWSShapeMember(label: "Message", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string)
        ]
        /// The error that caused processing to fail.
        public let errorCode: String?
        /// The error message.
        public let message: String?
        /// The segment's ID.
        public let id: String?

        public init(errorCode: String? = nil, message: String? = nil, id: String? = nil) {
            self.errorCode = errorCode
            self.message = message
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
            case id = "Id"
        }
    }

    public struct BatchGetTracesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "TraceIds", required: true, type: .list)
        ]
        /// Pagination token. Not used.
        public let nextToken: String?
        /// Specify the trace IDs of requests for which to retrieve segments.
        public let traceIds: [String]

        public init(nextToken: String? = nil, traceIds: [String]) {
            self.nextToken = nextToken
            self.traceIds = traceIds
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case traceIds = "TraceIds"
        }
    }

    public struct TelemetryRecord: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BackendConnectionErrors", required: false, type: .structure), 
            AWSShapeMember(label: "SegmentsSentCount", required: false, type: .integer), 
            AWSShapeMember(label: "SegmentsReceivedCount", required: false, type: .integer), 
            AWSShapeMember(label: "Timestamp", required: true, type: .timestamp), 
            AWSShapeMember(label: "SegmentsSpilloverCount", required: false, type: .integer), 
            AWSShapeMember(label: "SegmentsRejectedCount", required: false, type: .integer)
        ]
        public let backendConnectionErrors: BackendConnectionErrors?
        public let segmentsSentCount: Int32?
        public let segmentsReceivedCount: Int32?
        public let timestamp: TimeStamp
        public let segmentsSpilloverCount: Int32?
        public let segmentsRejectedCount: Int32?

        public init(backendConnectionErrors: BackendConnectionErrors? = nil, segmentsSentCount: Int32? = nil, segmentsReceivedCount: Int32? = nil, timestamp: TimeStamp, segmentsSpilloverCount: Int32? = nil, segmentsRejectedCount: Int32? = nil) {
            self.backendConnectionErrors = backendConnectionErrors
            self.segmentsSentCount = segmentsSentCount
            self.segmentsReceivedCount = segmentsReceivedCount
            self.timestamp = timestamp
            self.segmentsSpilloverCount = segmentsSpilloverCount
            self.segmentsRejectedCount = segmentsRejectedCount
        }

        private enum CodingKeys: String, CodingKey {
            case backendConnectionErrors = "BackendConnectionErrors"
            case segmentsSentCount = "SegmentsSentCount"
            case segmentsReceivedCount = "SegmentsReceivedCount"
            case timestamp = "Timestamp"
            case segmentsSpilloverCount = "SegmentsSpilloverCount"
            case segmentsRejectedCount = "SegmentsRejectedCount"
        }
    }

    public struct SamplingRule: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "RuleARN", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: true, type: .integer), 
            AWSShapeMember(label: "FixedRate", required: true, type: .double), 
            AWSShapeMember(label: "ServiceName", required: true, type: .string), 
            AWSShapeMember(label: "Priority", required: true, type: .integer), 
            AWSShapeMember(label: "ResourceARN", required: true, type: .string), 
            AWSShapeMember(label: "ServiceType", required: true, type: .string), 
            AWSShapeMember(label: "HTTPMethod", required: true, type: .string), 
            AWSShapeMember(label: "URLPath", required: true, type: .string), 
            AWSShapeMember(label: "Attributes", required: false, type: .map), 
            AWSShapeMember(label: "RuleName", required: false, type: .string), 
            AWSShapeMember(label: "Host", required: true, type: .string), 
            AWSShapeMember(label: "ReservoirSize", required: true, type: .integer)
        ]
        /// The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.
        public let ruleARN: String?
        /// The version of the sampling rule format (1).
        public let version: Int32
        /// The percentage of matching requests to instrument, after the reservoir is exhausted.
        public let fixedRate: Double
        /// Matches the name that the service uses to identify itself in segments.
        public let serviceName: String
        /// The priority of the sampling rule.
        public let priority: Int32
        /// Matches the ARN of the AWS resource on which the service runs.
        public let resourceARN: String
        /// Matches the origin that the service uses to identify its type in segments.
        public let serviceType: String
        /// Matches the HTTP method of a request.
        public let hTTPMethod: String
        /// Matches the path from a request URL.
        public let uRLPath: String
        /// Matches attributes derived from the request.
        public let attributes: [String: String]?
        /// The name of the sampling rule. Specify a rule by either name or ARN, but not both.
        public let ruleName: String?
        /// Matches the hostname from a request URL.
        public let host: String
        /// A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.
        public let reservoirSize: Int32

        public init(ruleARN: String? = nil, version: Int32, fixedRate: Double, serviceName: String, priority: Int32, resourceARN: String, serviceType: String, hTTPMethod: String, uRLPath: String, attributes: [String: String]? = nil, ruleName: String? = nil, host: String, reservoirSize: Int32) {
            self.ruleARN = ruleARN
            self.version = version
            self.fixedRate = fixedRate
            self.serviceName = serviceName
            self.priority = priority
            self.resourceARN = resourceARN
            self.serviceType = serviceType
            self.hTTPMethod = hTTPMethod
            self.uRLPath = uRLPath
            self.attributes = attributes
            self.ruleName = ruleName
            self.host = host
            self.reservoirSize = reservoirSize
        }

        private enum CodingKeys: String, CodingKey {
            case ruleARN = "RuleARN"
            case version = "Version"
            case fixedRate = "FixedRate"
            case serviceName = "ServiceName"
            case priority = "Priority"
            case resourceARN = "ResourceARN"
            case serviceType = "ServiceType"
            case hTTPMethod = "HTTPMethod"
            case uRLPath = "URLPath"
            case attributes = "Attributes"
            case ruleName = "RuleName"
            case host = "Host"
            case reservoirSize = "ReservoirSize"
        }
    }

    public struct ErrorRootCause: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Services", required: false, type: .list)
        ]
        /// A list of services corresponding to an error. A service identifies a segment and it contains a name, account ID, type, and inferred flag.
        public let services: [ErrorRootCauseService]?

        public init(services: [ErrorRootCauseService]? = nil) {
            self.services = services
        }

        private enum CodingKeys: String, CodingKey {
            case services = "Services"
        }
    }

    public struct FaultStatistics: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TotalCount", required: false, type: .long), 
            AWSShapeMember(label: "OtherCount", required: false, type: .long)
        ]
        /// The total number of requests that failed with a 5xx Server Error status code.
        public let totalCount: Int64?
        /// The number of requests that failed with untracked 5xx Server Error status codes.
        public let otherCount: Int64?

        public init(totalCount: Int64? = nil, otherCount: Int64? = nil) {
            self.totalCount = totalCount
            self.otherCount = otherCount
        }

        private enum CodingKeys: String, CodingKey {
            case totalCount = "TotalCount"
            case otherCount = "OtherCount"
        }
    }

    public struct PutTelemetryRecordsResult: AWSShape {

    }

    public struct TraceSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceARNs", required: false, type: .list), 
            AWSShapeMember(label: "HasFault", required: false, type: .boolean), 
            AWSShapeMember(label: "EntryPoint", required: false, type: .structure), 
            AWSShapeMember(label: "HasThrottle", required: false, type: .boolean), 
            AWSShapeMember(label: "Http", required: false, type: .structure), 
            AWSShapeMember(label: "ResponseTimeRootCauses", required: false, type: .list), 
            AWSShapeMember(label: "AvailabilityZones", required: false, type: .list), 
            AWSShapeMember(label: "FaultRootCauses", required: false, type: .list), 
            AWSShapeMember(label: "Users", required: false, type: .list), 
            AWSShapeMember(label: "IsPartial", required: false, type: .boolean), 
            AWSShapeMember(label: "ServiceIds", required: false, type: .list), 
            AWSShapeMember(label: "ErrorRootCauses", required: false, type: .list), 
            AWSShapeMember(label: "HasError", required: false, type: .boolean), 
            AWSShapeMember(label: "Duration", required: false, type: .double), 
            AWSShapeMember(label: "Revision", required: false, type: .integer), 
            AWSShapeMember(label: "Annotations", required: false, type: .map), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "ResponseTime", required: false, type: .double), 
            AWSShapeMember(label: "InstanceIds", required: false, type: .list)
        ]
        /// A list of resource ARNs for any resource corresponding to the trace segments.
        public let resourceARNs: [ResourceARNDetail]?
        /// One or more of the segment documents has a 500 series error.
        public let hasFault: Bool?
        /// The root of a trace.
        public let entryPoint: ServiceId?
        /// One or more of the segment documents has a 429 throttling error.
        public let hasThrottle: Bool?
        /// Information about the HTTP request served by the trace.
        public let http: Http?
        /// A collection of ResponseTimeRootCause structures corresponding to the trace segments.
        public let responseTimeRootCauses: [ResponseTimeRootCause]?
        /// A list of availability zones for any zone corresponding to the trace segments.
        public let availabilityZones: [AvailabilityZoneDetail]?
        /// A collection of FaultRootCause structures corresponding to the the trace segments.
        public let faultRootCauses: [FaultRootCause]?
        /// Users from the trace's segment documents.
        public let users: [TraceUser]?
        /// One or more of the segment documents is in progress.
        public let isPartial: Bool?
        /// Service IDs from the trace's segment documents.
        public let serviceIds: [ServiceId]?
        /// A collection of ErrorRootCause structures corresponding to the trace segments.
        public let errorRootCauses: [ErrorRootCause]?
        /// One or more of the segment documents has a 400 series error.
        public let hasError: Bool?
        /// The length of time in seconds between the start time of the root segment and the end time of the last segment that completed.
        public let duration: Double?
        /// The revision number of a trace.
        public let revision: Int32?
        /// Annotations from the trace's segment documents.
        public let annotations: [String: [ValueWithServiceIds]]?
        /// The unique identifier for the request that generated the trace's segments and subsegments.
        public let id: String?
        /// The length of time in seconds between the start and end times of the root segment. If the service performs work asynchronously, the response time measures the time before the response is sent to the user, while the duration measures the amount of time before the last traced activity completes.
        public let responseTime: Double?
        /// A list of EC2 instance IDs for any instance corresponding to the trace segments.
        public let instanceIds: [InstanceIdDetail]?

        public init(resourceARNs: [ResourceARNDetail]? = nil, hasFault: Bool? = nil, entryPoint: ServiceId? = nil, hasThrottle: Bool? = nil, http: Http? = nil, responseTimeRootCauses: [ResponseTimeRootCause]? = nil, availabilityZones: [AvailabilityZoneDetail]? = nil, faultRootCauses: [FaultRootCause]? = nil, users: [TraceUser]? = nil, isPartial: Bool? = nil, serviceIds: [ServiceId]? = nil, errorRootCauses: [ErrorRootCause]? = nil, hasError: Bool? = nil, duration: Double? = nil, revision: Int32? = nil, annotations: [String: [ValueWithServiceIds]]? = nil, id: String? = nil, responseTime: Double? = nil, instanceIds: [InstanceIdDetail]? = nil) {
            self.resourceARNs = resourceARNs
            self.hasFault = hasFault
            self.entryPoint = entryPoint
            self.hasThrottle = hasThrottle
            self.http = http
            self.responseTimeRootCauses = responseTimeRootCauses
            self.availabilityZones = availabilityZones
            self.faultRootCauses = faultRootCauses
            self.users = users
            self.isPartial = isPartial
            self.serviceIds = serviceIds
            self.errorRootCauses = errorRootCauses
            self.hasError = hasError
            self.duration = duration
            self.revision = revision
            self.annotations = annotations
            self.id = id
            self.responseTime = responseTime
            self.instanceIds = instanceIds
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARNs = "ResourceARNs"
            case hasFault = "HasFault"
            case entryPoint = "EntryPoint"
            case hasThrottle = "HasThrottle"
            case http = "Http"
            case responseTimeRootCauses = "ResponseTimeRootCauses"
            case availabilityZones = "AvailabilityZones"
            case faultRootCauses = "FaultRootCauses"
            case users = "Users"
            case isPartial = "IsPartial"
            case serviceIds = "ServiceIds"
            case errorRootCauses = "ErrorRootCauses"
            case hasError = "HasError"
            case duration = "Duration"
            case revision = "Revision"
            case annotations = "Annotations"
            case id = "Id"
            case responseTime = "ResponseTime"
            case instanceIds = "InstanceIds"
        }
    }

    public struct PutEncryptionConfigResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EncryptionConfig", required: false, type: .structure)
        ]
        /// The new encryption configuration.
        public let encryptionConfig: EncryptionConfig?

        public init(encryptionConfig: EncryptionConfig? = nil) {
            self.encryptionConfig = encryptionConfig
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfig = "EncryptionConfig"
        }
    }

}