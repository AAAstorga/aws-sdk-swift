// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension Rekognition {

    public struct ListCollectionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// Maximum number of collection IDs to return. 
        public let maxResults: Int32?
        /// Pagination token from the previous response.
        public let nextToken: String?

        public init(maxResults: Int32? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct Pose: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Yaw", required: false, type: .float), 
            AWSShapeMember(label: "Roll", required: false, type: .float), 
            AWSShapeMember(label: "Pitch", required: false, type: .float)
        ]
        /// Value representing the face rotation on the yaw axis.
        public let yaw: Float?
        /// Value representing the face rotation on the roll axis.
        public let roll: Float?
        /// Value representing the face rotation on the pitch axis.
        public let pitch: Float?

        public init(yaw: Float? = nil, roll: Float? = nil, pitch: Float? = nil) {
            self.yaw = yaw
            self.roll = roll
            self.pitch = pitch
        }

        private enum CodingKeys: String, CodingKey {
            case yaw = "Yaw"
            case roll = "Roll"
            case pitch = "Pitch"
        }
    }

    public struct DeleteStreamProcessorRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The name of the stream processor you want to delete.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CompareFacesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TargetImage", required: true, type: .structure), 
            AWSShapeMember(label: "SourceImage", required: true, type: .structure), 
            AWSShapeMember(label: "SimilarityThreshold", required: false, type: .float)
        ]
        /// The target image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call Amazon Rekognition operations, passing base64-encoded image bytes is not supported. 
        public let targetImage: Image
        /// The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call Amazon Rekognition operations, passing base64-encoded image bytes is not supported. 
        public let sourceImage: Image
        /// The minimum level of confidence in the face matches that a match must meet to be included in the FaceMatches array.
        public let similarityThreshold: Float?

        public init(targetImage: Image, sourceImage: Image, similarityThreshold: Float? = nil) {
            self.targetImage = targetImage
            self.sourceImage = sourceImage
            self.similarityThreshold = similarityThreshold
        }

        private enum CodingKeys: String, CodingKey {
            case targetImage = "TargetImage"
            case sourceImage = "SourceImage"
            case similarityThreshold = "SimilarityThreshold"
        }
    }

    public enum FaceAttributes: String, CustomStringConvertible, Codable {
        case `default` = "DEFAULT"
        case all = "ALL"
        public var description: String { return self.rawValue }
    }

    public struct ComparedSourceImageFace: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BoundingBox", required: false, type: .structure), 
            AWSShapeMember(label: "Confidence", required: false, type: .float)
        ]
        /// Bounding box of the face.
        public let boundingBox: BoundingBox?
        /// Confidence level that the selected bounding box contains a face.
        public let confidence: Float?

        public init(boundingBox: BoundingBox? = nil, confidence: Float? = nil) {
            self.boundingBox = boundingBox
            self.confidence = confidence
        }

        private enum CodingKeys: String, CodingKey {
            case boundingBox = "BoundingBox"
            case confidence = "Confidence"
        }
    }

    public struct DeleteCollectionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CollectionId", required: true, type: .string)
        ]
        /// ID of the collection to delete.
        public let collectionId: String

        public init(collectionId: String) {
            self.collectionId = collectionId
        }

        private enum CodingKeys: String, CodingKey {
            case collectionId = "CollectionId"
        }
    }

    public struct GetPersonTrackingResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StatusMessage", required: false, type: .string), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Persons", required: false, type: .list), 
            AWSShapeMember(label: "JobStatus", required: false, type: .enum), 
            AWSShapeMember(label: "VideoMetadata", required: false, type: .structure)
        ]
        /// If the job fails, StatusMessage provides a descriptive error message.
        public let statusMessage: String?
        /// If the response is truncated, Amazon Rekognition Video returns this token that you can use in the subsequent request to retrieve the next set of persons. 
        public let nextToken: String?
        /// An array of the persons detected in the video and the time(s) their path was tracked throughout the video. An array element will exist for each time a person's path is tracked. 
        public let persons: [PersonDetection]?
        /// The current status of the person tracking job.
        public let jobStatus: VideoJobStatus?
        /// Information about a video that Amazon Rekognition Video analyzed. Videometadata is returned in every page of paginated responses from a Amazon Rekognition Video operation.
        public let videoMetadata: VideoMetadata?

        public init(statusMessage: String? = nil, nextToken: String? = nil, persons: [PersonDetection]? = nil, jobStatus: VideoJobStatus? = nil, videoMetadata: VideoMetadata? = nil) {
            self.statusMessage = statusMessage
            self.nextToken = nextToken
            self.persons = persons
            self.jobStatus = jobStatus
            self.videoMetadata = videoMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case statusMessage = "StatusMessage"
            case nextToken = "NextToken"
            case persons = "Persons"
            case jobStatus = "JobStatus"
            case videoMetadata = "VideoMetadata"
        }
    }

    public struct DetectFacesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "OrientationCorrection", required: false, type: .enum), 
            AWSShapeMember(label: "FaceDetails", required: false, type: .list)
        ]
        /// The value of OrientationCorrection is always null. If the input image is in .jpeg format, it might contain exchangeable image file format (Exif) metadata that includes the image's orientation. Amazon Rekognition uses this orientation information to perform image correction. The bounding box coordinates are translated to represent object locations after the orientation information in the Exif metadata is used to correct the image orientation. Images in .png format don't contain Exif metadata. Amazon Rekognition doesnâ€™t perform image correction for images in .png format and .jpeg images without orientation information in the image Exif metadata. The bounding box coordinates aren't translated and represent the object locations before the image is rotated. 
        public let orientationCorrection: OrientationCorrection?
        /// Details of each face found in the image. 
        public let faceDetails: [FaceDetail]?

        public init(orientationCorrection: OrientationCorrection? = nil, faceDetails: [FaceDetail]? = nil) {
            self.orientationCorrection = orientationCorrection
            self.faceDetails = faceDetails
        }

        private enum CodingKeys: String, CodingKey {
            case orientationCorrection = "OrientationCorrection"
            case faceDetails = "FaceDetails"
        }
    }

    public struct StartCelebrityRecognitionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NotificationChannel", required: false, type: .structure), 
            AWSShapeMember(label: "Video", required: true, type: .structure), 
            AWSShapeMember(label: "JobTag", required: false, type: .string), 
            AWSShapeMember(label: "ClientRequestToken", required: false, type: .string)
        ]
        /// The Amazon SNS topic ARN that you want Amazon Rekognition Video to publish the completion status of the celebrity recognition analysis to.
        public let notificationChannel: NotificationChannel?
        /// The video in which you want to recognize celebrities. The video must be stored in an Amazon S3 bucket.
        public let video: Video
        /// Unique identifier you specify to identify the job in the completion status published to the Amazon Simple Notification Service topic. 
        public let jobTag: String?
        /// Idempotent token used to identify the start request. If you use the same token with multiple StartCelebrityRecognition requests, the same JobId is returned. Use ClientRequestToken to prevent the same job from being accidently started more than once. 
        public let clientRequestToken: String?

        public init(notificationChannel: NotificationChannel? = nil, video: Video, jobTag: String? = nil, clientRequestToken: String? = nil) {
            self.notificationChannel = notificationChannel
            self.video = video
            self.jobTag = jobTag
            self.clientRequestToken = clientRequestToken
        }

        private enum CodingKeys: String, CodingKey {
            case notificationChannel = "NotificationChannel"
            case video = "Video"
            case jobTag = "JobTag"
            case clientRequestToken = "ClientRequestToken"
        }
    }

    public enum ContentModerationSortBy: String, CustomStringConvertible, Codable {
        case name = "NAME"
        case timestamp = "TIMESTAMP"
        public var description: String { return self.rawValue }
    }

    public enum CelebrityRecognitionSortBy: String, CustomStringConvertible, Codable {
        case id = "ID"
        case timestamp = "TIMESTAMP"
        public var description: String { return self.rawValue }
    }

    public struct StopStreamProcessorRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The name of a stream processor created by .
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct GetFaceSearchRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SortBy", required: false, type: .enum), 
            AWSShapeMember(label: "JobId", required: true, type: .string), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer)
        ]
        /// Sort to use for grouping faces in the response. Use TIMESTAMP to group faces by the time that they are recognized. Use INDEX to sort by recognized faces. 
        public let sortBy: FaceSearchSortBy?
        /// The job identifer for the search request. You get the job identifier from an initial call to StartFaceSearch.
        public let jobId: String
        /// If the previous response was incomplete (because there is more search results to retrieve), Amazon Rekognition Video returns a pagination token in the response. You can use this pagination token to retrieve the next set of search results. 
        public let nextToken: String?
        /// Maximum number of results to return per paginated call. The largest value you can specify is 1000. If you specify a value greater than 1000, a maximum of 1000 results is returned. The default value is 1000.
        public let maxResults: Int32?

        public init(sortBy: FaceSearchSortBy? = nil, jobId: String, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.sortBy = sortBy
            self.jobId = jobId
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case sortBy = "SortBy"
            case jobId = "JobId"
            case nextToken = "NextToken"
            case maxResults = "MaxResults"
        }
    }

    public enum PersonTrackingSortBy: String, CustomStringConvertible, Codable {
        case index = "INDEX"
        case timestamp = "TIMESTAMP"
        public var description: String { return self.rawValue }
    }

    public struct RecognizeCelebritiesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Image", required: true, type: .structure)
        ]
        /// The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call Amazon Rekognition operations, passing base64-encoded image bytes is not supported. 
        public let image: Image

        public init(image: Image) {
            self.image = image
        }

        private enum CodingKeys: String, CodingKey {
            case image = "Image"
        }
    }

    public struct CreateCollectionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StatusCode", required: false, type: .integer), 
            AWSShapeMember(label: "FaceModelVersion", required: false, type: .string), 
            AWSShapeMember(label: "CollectionArn", required: false, type: .string)
        ]
        /// HTTP status code indicating the result of the operation.
        public let statusCode: Int32?
        /// Version number of the face detection model associated with the collection you are creating.
        public let faceModelVersion: String?
        /// Amazon Resource Name (ARN) of the collection. You can use this to manage permissions on your resources. 
        public let collectionArn: String?

        public init(statusCode: Int32? = nil, faceModelVersion: String? = nil, collectionArn: String? = nil) {
            self.statusCode = statusCode
            self.faceModelVersion = faceModelVersion
            self.collectionArn = collectionArn
        }

        private enum CodingKeys: String, CodingKey {
            case statusCode = "StatusCode"
            case faceModelVersion = "FaceModelVersion"
            case collectionArn = "CollectionArn"
        }
    }

    public struct DescribeStreamProcessorRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// Name of the stream processor for which you want information.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct Mustache: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Confidence", required: false, type: .float), 
            AWSShapeMember(label: "Value", required: false, type: .boolean)
        ]
        /// Level of confidence in the determination.
        public let confidence: Float?
        /// Boolean value that indicates whether the face has mustache or not.
        public let value: Bool?

        public init(confidence: Float? = nil, value: Bool? = nil) {
            self.confidence = confidence
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case value = "Value"
        }
    }

    public struct VideoMetadata: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Codec", required: false, type: .string), 
            AWSShapeMember(label: "FrameHeight", required: false, type: .long), 
            AWSShapeMember(label: "FrameRate", required: false, type: .float), 
            AWSShapeMember(label: "FrameWidth", required: false, type: .long), 
            AWSShapeMember(label: "Format", required: false, type: .string), 
            AWSShapeMember(label: "DurationMillis", required: false, type: .long)
        ]
        /// Type of compression used in the analyzed video. 
        public let codec: String?
        /// Vertical pixel dimension of the video.
        public let frameHeight: Int64?
        /// Number of frames per second in the video.
        public let frameRate: Float?
        /// Horizontal pixel dimension of the video.
        public let frameWidth: Int64?
        /// Format of the analyzed video. Possible values are MP4, MOV and AVI. 
        public let format: String?
        /// Length of the video in milliseconds.
        public let durationMillis: Int64?

        public init(codec: String? = nil, frameHeight: Int64? = nil, frameRate: Float? = nil, frameWidth: Int64? = nil, format: String? = nil, durationMillis: Int64? = nil) {
            self.codec = codec
            self.frameHeight = frameHeight
            self.frameRate = frameRate
            self.frameWidth = frameWidth
            self.format = format
            self.durationMillis = durationMillis
        }

        private enum CodingKeys: String, CodingKey {
            case codec = "Codec"
            case frameHeight = "FrameHeight"
            case frameRate = "FrameRate"
            case frameWidth = "FrameWidth"
            case format = "Format"
            case durationMillis = "DurationMillis"
        }
    }

    public struct DetectTextResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TextDetections", required: false, type: .list)
        ]
        /// An array of text that was detected in the input image.
        public let textDetections: [TextDetection]?

        public init(textDetections: [TextDetection]? = nil) {
            self.textDetections = textDetections
        }

        private enum CodingKeys: String, CodingKey {
            case textDetections = "TextDetections"
        }
    }

    public struct DescribeCollectionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreationTimestamp", required: false, type: .timestamp), 
            AWSShapeMember(label: "FaceCount", required: false, type: .long), 
            AWSShapeMember(label: "CollectionARN", required: false, type: .string), 
            AWSShapeMember(label: "FaceModelVersion", required: false, type: .string)
        ]
        /// The number of milliseconds since the Unix epoch time until the creation of the collection. The Unix epoch time is 00:00:00 Coordinated Universal Time (UTC), Thursday, 1 January 1970.
        public let creationTimestamp: TimeStamp?
        /// The number of faces that are indexed into the collection. To index faces into a collection, use .
        public let faceCount: Int64?
        /// The Amazon Resource Name (ARN) of the collection.
        public let collectionARN: String?
        /// The version of the face model that's used by the collection for face detection. For more information, see Model Versioning in the Amazon Rekognition Developer Guide.
        public let faceModelVersion: String?

        public init(creationTimestamp: TimeStamp? = nil, faceCount: Int64? = nil, collectionARN: String? = nil, faceModelVersion: String? = nil) {
            self.creationTimestamp = creationTimestamp
            self.faceCount = faceCount
            self.collectionARN = collectionARN
            self.faceModelVersion = faceModelVersion
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimestamp = "CreationTimestamp"
            case faceCount = "FaceCount"
            case collectionARN = "CollectionARN"
            case faceModelVersion = "FaceModelVersion"
        }
    }

    public struct AgeRange: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "High", required: false, type: .integer), 
            AWSShapeMember(label: "Low", required: false, type: .integer)
        ]
        /// The highest estimated age.
        public let high: Int32?
        /// The lowest estimated age.
        public let low: Int32?

        public init(high: Int32? = nil, low: Int32? = nil) {
            self.high = high
            self.low = low
        }

        private enum CodingKeys: String, CodingKey {
            case high = "High"
            case low = "Low"
        }
    }

    public struct MouthOpen: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Value", required: false, type: .boolean), 
            AWSShapeMember(label: "Confidence", required: false, type: .float)
        ]
        /// Boolean value that indicates whether the mouth on the face is open or not.
        public let value: Bool?
        /// Level of confidence in the determination.
        public let confidence: Float?

        public init(value: Bool? = nil, confidence: Float? = nil) {
            self.value = value
            self.confidence = confidence
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
            case confidence = "Confidence"
        }
    }

    public struct Image: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Bytes", required: false, type: .blob), 
            AWSShapeMember(label: "S3Object", required: false, type: .structure)
        ]
        /// Blob of image bytes up to 5 MBs.
        public let bytes: Data?
        /// Identifies an S3 object as the image source.
        public let s3Object: S3Object?

        public init(bytes: Data? = nil, s3Object: S3Object? = nil) {
            self.bytes = bytes
            self.s3Object = s3Object
        }

        private enum CodingKeys: String, CodingKey {
            case bytes = "Bytes"
            case s3Object = "S3Object"
        }
    }

    public struct StartPersonTrackingRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NotificationChannel", required: false, type: .structure), 
            AWSShapeMember(label: "ClientRequestToken", required: false, type: .string), 
            AWSShapeMember(label: "JobTag", required: false, type: .string), 
            AWSShapeMember(label: "Video", required: true, type: .structure)
        ]
        /// The Amazon SNS topic ARN you want Amazon Rekognition Video to publish the completion status of the people detection operation to.
        public let notificationChannel: NotificationChannel?
        /// Idempotent token used to identify the start request. If you use the same token with multiple StartPersonTracking requests, the same JobId is returned. Use ClientRequestToken to prevent the same job from being accidently started more than once. 
        public let clientRequestToken: String?
        /// Unique identifier you specify to identify the job in the completion status published to the Amazon Simple Notification Service topic. 
        public let jobTag: String?
        /// The video in which you want to detect people. The video must be stored in an Amazon S3 bucket.
        public let video: Video

        public init(notificationChannel: NotificationChannel? = nil, clientRequestToken: String? = nil, jobTag: String? = nil, video: Video) {
            self.notificationChannel = notificationChannel
            self.clientRequestToken = clientRequestToken
            self.jobTag = jobTag
            self.video = video
        }

        private enum CodingKeys: String, CodingKey {
            case notificationChannel = "NotificationChannel"
            case clientRequestToken = "ClientRequestToken"
            case jobTag = "JobTag"
            case video = "Video"
        }
    }

    public struct StartContentModerationResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobId", required: false, type: .string)
        ]
        /// The identifier for the content moderation analysis job. Use JobId to identify the job in a subsequent call to GetContentModeration.
        public let jobId: String?

        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct DeleteFacesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CollectionId", required: true, type: .string), 
            AWSShapeMember(label: "FaceIds", required: true, type: .list)
        ]
        /// Collection from which to remove the specific faces.
        public let collectionId: String
        /// An array of face IDs to delete.
        public let faceIds: [String]

        public init(collectionId: String, faceIds: [String]) {
            self.collectionId = collectionId
            self.faceIds = faceIds
        }

        private enum CodingKeys: String, CodingKey {
            case collectionId = "CollectionId"
            case faceIds = "FaceIds"
        }
    }

    public struct FaceSearchSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FaceMatchThreshold", required: false, type: .float), 
            AWSShapeMember(label: "CollectionId", required: false, type: .string)
        ]
        /// Minimum face match confidence score that must be met to return a result for a recognized face. Default is 70. 0 is the lowest confidence. 100 is the highest confidence.
        public let faceMatchThreshold: Float?
        /// The ID of a collection that contains faces that you want to search for.
        public let collectionId: String?

        public init(faceMatchThreshold: Float? = nil, collectionId: String? = nil) {
            self.faceMatchThreshold = faceMatchThreshold
            self.collectionId = collectionId
        }

        private enum CodingKeys: String, CodingKey {
            case faceMatchThreshold = "FaceMatchThreshold"
            case collectionId = "CollectionId"
        }
    }

    public struct StartPersonTrackingResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobId", required: false, type: .string)
        ]
        /// The identifier for the person detection job. Use JobId to identify the job in a subsequent call to GetPersonTracking.
        public let jobId: String?

        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct GetCelebrityInfoRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", required: true, type: .string)
        ]
        /// The ID for the celebrity. You get the celebrity ID from a call to the operation, which recognizes celebrities in an image. 
        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
        }
    }

    public struct Gender: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Confidence", required: false, type: .float), 
            AWSShapeMember(label: "Value", required: false, type: .enum)
        ]
        /// Level of confidence in the determination.
        public let confidence: Float?
        /// Gender of the face.
        public let value: GenderType?

        public init(confidence: Float? = nil, value: GenderType? = nil) {
            self.confidence = confidence
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case value = "Value"
        }
    }

    public enum FaceSearchSortBy: String, CustomStringConvertible, Codable {
        case index = "INDEX"
        case timestamp = "TIMESTAMP"
        public var description: String { return self.rawValue }
    }

    public struct NotificationChannel: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "RoleArn", required: true, type: .string), 
            AWSShapeMember(label: "SNSTopicArn", required: true, type: .string)
        ]
        /// The ARN of an IAM role that gives Amazon Rekognition publishing permissions to the Amazon SNS topic. 
        public let roleArn: String
        /// The Amazon SNS topic to which Amazon Rekognition to posts the completion status.
        public let sNSTopicArn: String

        public init(roleArn: String, sNSTopicArn: String) {
            self.roleArn = roleArn
            self.sNSTopicArn = sNSTopicArn
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "RoleArn"
            case sNSTopicArn = "SNSTopicArn"
        }
    }

    public struct StartStreamProcessorResponse: AWSShape {

    }

    public struct StartCelebrityRecognitionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobId", required: false, type: .string)
        ]
        /// The identifier for the celebrity recognition analysis job. Use JobId to identify the job in a subsequent call to GetCelebrityRecognition.
        public let jobId: String?

        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct StartContentModerationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClientRequestToken", required: false, type: .string), 
            AWSShapeMember(label: "NotificationChannel", required: false, type: .structure), 
            AWSShapeMember(label: "Video", required: true, type: .structure), 
            AWSShapeMember(label: "MinConfidence", required: false, type: .float), 
            AWSShapeMember(label: "JobTag", required: false, type: .string)
        ]
        /// Idempotent token used to identify the start request. If you use the same token with multiple StartContentModeration requests, the same JobId is returned. Use ClientRequestToken to prevent the same job from being accidently started more than once. 
        public let clientRequestToken: String?
        /// The Amazon SNS topic ARN that you want Amazon Rekognition Video to publish the completion status of the content moderation analysis to.
        public let notificationChannel: NotificationChannel?
        /// The video in which you want to moderate content. The video must be stored in an Amazon S3 bucket.
        public let video: Video
        /// Specifies the minimum confidence that Amazon Rekognition must have in order to return a moderated content label. Confidence represents how certain Amazon Rekognition is that the moderated content is correctly identified. 0 is the lowest confidence. 100 is the highest confidence. Amazon Rekognition doesn't return any moderated content labels with a confidence level lower than this specified value. If you don't specify MinConfidence, GetContentModeration returns labels with confidence values greater than or equal to 50 percent.
        public let minConfidence: Float?
        /// Unique identifier you specify to identify the job in the completion status published to the Amazon Simple Notification Service topic. 
        public let jobTag: String?

        public init(clientRequestToken: String? = nil, notificationChannel: NotificationChannel? = nil, video: Video, minConfidence: Float? = nil, jobTag: String? = nil) {
            self.clientRequestToken = clientRequestToken
            self.notificationChannel = notificationChannel
            self.video = video
            self.minConfidence = minConfidence
            self.jobTag = jobTag
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case notificationChannel = "NotificationChannel"
            case video = "Video"
            case minConfidence = "MinConfidence"
            case jobTag = "JobTag"
        }
    }

    public enum LandmarkType: String, CustomStringConvertible, Codable {
        case eyeleft = "eyeLeft"
        case eyeright = "eyeRight"
        case nose = "nose"
        case mouthleft = "mouthLeft"
        case mouthright = "mouthRight"
        case lefteyebrowleft = "leftEyeBrowLeft"
        case lefteyebrowright = "leftEyeBrowRight"
        case lefteyebrowup = "leftEyeBrowUp"
        case righteyebrowleft = "rightEyeBrowLeft"
        case righteyebrowright = "rightEyeBrowRight"
        case righteyebrowup = "rightEyeBrowUp"
        case lefteyeleft = "leftEyeLeft"
        case lefteyeright = "leftEyeRight"
        case lefteyeup = "leftEyeUp"
        case lefteyedown = "leftEyeDown"
        case righteyeleft = "rightEyeLeft"
        case righteyeright = "rightEyeRight"
        case righteyeup = "rightEyeUp"
        case righteyedown = "rightEyeDown"
        case noseleft = "noseLeft"
        case noseright = "noseRight"
        case mouthup = "mouthUp"
        case mouthdown = "mouthDown"
        case leftpupil = "leftPupil"
        case rightpupil = "rightPupil"
        case upperjawlineleft = "upperJawlineLeft"
        case midjawlineleft = "midJawlineLeft"
        case chinbottom = "chinBottom"
        case midjawlineright = "midJawlineRight"
        case upperjawlineright = "upperJawlineRight"
        public var description: String { return self.rawValue }
    }

    public struct EyeOpen: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Value", required: false, type: .boolean), 
            AWSShapeMember(label: "Confidence", required: false, type: .float)
        ]
        /// Boolean value that indicates whether the eyes on the face are open.
        public let value: Bool?
        /// Level of confidence in the determination.
        public let confidence: Float?

        public init(value: Bool? = nil, confidence: Float? = nil) {
            self.value = value
            self.confidence = confidence
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
            case confidence = "Confidence"
        }
    }

    public struct SearchFacesByImageRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxFaces", required: false, type: .integer), 
            AWSShapeMember(label: "Image", required: true, type: .structure), 
            AWSShapeMember(label: "CollectionId", required: true, type: .string), 
            AWSShapeMember(label: "FaceMatchThreshold", required: false, type: .float)
        ]
        /// Maximum number of faces to return. The operation returns the maximum number of faces with the highest confidence in the match.
        public let maxFaces: Int32?
        /// The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call Amazon Rekognition operations, passing base64-encoded image bytes is not supported. 
        public let image: Image
        /// ID of the collection to search.
        public let collectionId: String
        /// (Optional) Specifies the minimum confidence in the face match to return. For example, don't return any matches where confidence in matches is less than 70%.
        public let faceMatchThreshold: Float?

        public init(maxFaces: Int32? = nil, image: Image, collectionId: String, faceMatchThreshold: Float? = nil) {
            self.maxFaces = maxFaces
            self.image = image
            self.collectionId = collectionId
            self.faceMatchThreshold = faceMatchThreshold
        }

        private enum CodingKeys: String, CodingKey {
            case maxFaces = "MaxFaces"
            case image = "Image"
            case collectionId = "CollectionId"
            case faceMatchThreshold = "FaceMatchThreshold"
        }
    }

    public struct StartStreamProcessorRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The name of the stream processor to start processing.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteCollectionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StatusCode", required: false, type: .integer)
        ]
        /// HTTP status code that indicates the result of the operation.
        public let statusCode: Int32?

        public init(statusCode: Int32? = nil) {
            self.statusCode = statusCode
        }

        private enum CodingKeys: String, CodingKey {
            case statusCode = "StatusCode"
        }
    }

    public struct GetContentModerationResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "VideoMetadata", required: false, type: .structure), 
            AWSShapeMember(label: "JobStatus", required: false, type: .enum), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "ModerationLabels", required: false, type: .list), 
            AWSShapeMember(label: "StatusMessage", required: false, type: .string)
        ]
        /// Information about a video that Amazon Rekognition analyzed. Videometadata is returned in every page of paginated responses from GetContentModeration. 
        public let videoMetadata: VideoMetadata?
        /// The current status of the content moderation job.
        public let jobStatus: VideoJobStatus?
        /// If the response is truncated, Amazon Rekognition Video returns this token that you can use in the subsequent request to retrieve the next set of moderation labels. 
        public let nextToken: String?
        /// The detected moderation labels and the time(s) they were detected.
        public let moderationLabels: [ContentModerationDetection]?
        /// If the job fails, StatusMessage provides a descriptive error message.
        public let statusMessage: String?

        public init(videoMetadata: VideoMetadata? = nil, jobStatus: VideoJobStatus? = nil, nextToken: String? = nil, moderationLabels: [ContentModerationDetection]? = nil, statusMessage: String? = nil) {
            self.videoMetadata = videoMetadata
            self.jobStatus = jobStatus
            self.nextToken = nextToken
            self.moderationLabels = moderationLabels
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case videoMetadata = "VideoMetadata"
            case jobStatus = "JobStatus"
            case nextToken = "NextToken"
            case moderationLabels = "ModerationLabels"
            case statusMessage = "StatusMessage"
        }
    }

    public struct SearchFacesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FaceModelVersion", required: false, type: .string), 
            AWSShapeMember(label: "FaceMatches", required: false, type: .list), 
            AWSShapeMember(label: "SearchedFaceId", required: false, type: .string)
        ]
        /// Version number of the face detection model associated with the input collection (CollectionId).
        public let faceModelVersion: String?
        /// An array of faces that matched the input face, along with the confidence in the match.
        public let faceMatches: [FaceMatch]?
        /// ID of the face that was searched for matches in a collection.
        public let searchedFaceId: String?

        public init(faceModelVersion: String? = nil, faceMatches: [FaceMatch]? = nil, searchedFaceId: String? = nil) {
            self.faceModelVersion = faceModelVersion
            self.faceMatches = faceMatches
            self.searchedFaceId = searchedFaceId
        }

        private enum CodingKeys: String, CodingKey {
            case faceModelVersion = "FaceModelVersion"
            case faceMatches = "FaceMatches"
            case searchedFaceId = "SearchedFaceId"
        }
    }

    public struct StartFaceDetectionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobId", required: false, type: .string)
        ]
        /// The identifier for the face detection job. Use JobId to identify the job in a subsequent call to GetFaceDetection.
        public let jobId: String?

        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public enum GenderType: String, CustomStringConvertible, Codable {
        case male = "Male"
        case female = "Female"
        public var description: String { return self.rawValue }
    }

    public struct Video: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "S3Object", required: false, type: .structure)
        ]
        /// The Amazon S3 bucket name and file name for the video.
        public let s3Object: S3Object?

        public init(s3Object: S3Object? = nil) {
            self.s3Object = s3Object
        }

        private enum CodingKeys: String, CodingKey {
            case s3Object = "S3Object"
        }
    }

    public struct Celebrity: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MatchConfidence", required: false, type: .float), 
            AWSShapeMember(label: "Face", required: false, type: .structure), 
            AWSShapeMember(label: "Urls", required: false, type: .list), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]
        /// The confidence, in percentage, that Amazon Rekognition has that the recognized face is the celebrity.
        public let matchConfidence: Float?
        /// Provides information about the celebrity's face, such as its location on the image.
        public let face: ComparedFace?
        /// An array of URLs pointing to additional information about the celebrity. If there is no additional information about the celebrity, this list is empty.
        public let urls: [String]?
        /// A unique identifier for the celebrity. 
        public let id: String?
        /// The name of the celebrity.
        public let name: String?

        public init(matchConfidence: Float? = nil, face: ComparedFace? = nil, urls: [String]? = nil, id: String? = nil, name: String? = nil) {
            self.matchConfidence = matchConfidence
            self.face = face
            self.urls = urls
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case matchConfidence = "MatchConfidence"
            case face = "Face"
            case urls = "Urls"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct DescribeStreamProcessorResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "RoleArn", required: false, type: .string), 
            AWSShapeMember(label: "LastUpdateTimestamp", required: false, type: .timestamp), 
            AWSShapeMember(label: "StatusMessage", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .enum), 
            AWSShapeMember(label: "StreamProcessorArn", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Output", required: false, type: .structure), 
            AWSShapeMember(label: "Settings", required: false, type: .structure), 
            AWSShapeMember(label: "CreationTimestamp", required: false, type: .timestamp), 
            AWSShapeMember(label: "Input", required: false, type: .structure)
        ]
        /// ARN of the IAM role that allows access to the stream processor.
        public let roleArn: String?
        /// The time, in Unix format, the stream processor was last updated. For example, when the stream processor moves from a running state to a failed state, or when the user starts or stops the stream processor.
        public let lastUpdateTimestamp: TimeStamp?
        /// Detailed status message about the stream processor.
        public let statusMessage: String?
        /// Current status of the stream processor.
        public let status: StreamProcessorStatus?
        /// ARN of the stream processor.
        public let streamProcessorArn: String?
        /// Name of the stream processor. 
        public let name: String?
        /// Kinesis data stream to which Amazon Rekognition Video puts the analysis results.
        public let output: StreamProcessorOutput?
        /// Face recognition input parameters that are being used by the stream processor. Includes the collection to use for face recognition and the face attributes to detect.
        public let settings: StreamProcessorSettings?
        /// Date and time the stream processor was created
        public let creationTimestamp: TimeStamp?
        /// Kinesis video stream that provides the source streaming video.
        public let input: StreamProcessorInput?

        public init(roleArn: String? = nil, lastUpdateTimestamp: TimeStamp? = nil, statusMessage: String? = nil, status: StreamProcessorStatus? = nil, streamProcessorArn: String? = nil, name: String? = nil, output: StreamProcessorOutput? = nil, settings: StreamProcessorSettings? = nil, creationTimestamp: TimeStamp? = nil, input: StreamProcessorInput? = nil) {
            self.roleArn = roleArn
            self.lastUpdateTimestamp = lastUpdateTimestamp
            self.statusMessage = statusMessage
            self.status = status
            self.streamProcessorArn = streamProcessorArn
            self.name = name
            self.output = output
            self.settings = settings
            self.creationTimestamp = creationTimestamp
            self.input = input
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "RoleArn"
            case lastUpdateTimestamp = "LastUpdateTimestamp"
            case statusMessage = "StatusMessage"
            case status = "Status"
            case streamProcessorArn = "StreamProcessorArn"
            case name = "Name"
            case output = "Output"
            case settings = "Settings"
            case creationTimestamp = "CreationTimestamp"
            case input = "Input"
        }
    }

    public struct StartLabelDetectionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobId", required: false, type: .string)
        ]
        /// The identifier for the label detection job. Use JobId to identify the job in a subsequent call to GetLabelDetection. 
        public let jobId: String?

        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct DeleteFacesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DeletedFaces", required: false, type: .list)
        ]
        /// An array of strings (face IDs) of the faces that were deleted.
        public let deletedFaces: [String]?

        public init(deletedFaces: [String]? = nil) {
            self.deletedFaces = deletedFaces
        }

        private enum CodingKeys: String, CodingKey {
            case deletedFaces = "DeletedFaces"
        }
    }

    public struct DetectModerationLabelsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ModerationLabels", required: false, type: .list)
        ]
        /// Array of detected Moderation labels and the time, in millseconds from the start of the video, they were detected.
        public let moderationLabels: [ModerationLabel]?

        public init(moderationLabels: [ModerationLabel]? = nil) {
            self.moderationLabels = moderationLabels
        }

        private enum CodingKeys: String, CodingKey {
            case moderationLabels = "ModerationLabels"
        }
    }

    public struct Landmark: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "X", required: false, type: .float), 
            AWSShapeMember(label: "Type", required: false, type: .enum), 
            AWSShapeMember(label: "Y", required: false, type: .float)
        ]
        /// The x-coordinate from the top left of the landmark expressed as the ratio of the width of the image. For example, if the image is 700 x 200 and the x-coordinate of the landmark is at 350 pixels, this value is 0.5. 
        public let x: Float?
        /// Type of landmark.
        public let `type`: LandmarkType?
        /// The y-coordinate from the top left of the landmark expressed as the ratio of the height of the image. For example, if the image is 700 x 200 and the y-coordinate of the landmark is at 100 pixels, this value is 0.5.
        public let y: Float?

        public init(x: Float? = nil, type: LandmarkType? = nil, y: Float? = nil) {
            self.x = x
            self.`type` = `type`
            self.y = y
        }

        private enum CodingKeys: String, CodingKey {
            case x = "X"
            case `type` = "Type"
            case y = "Y"
        }
    }

    public struct CreateCollectionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CollectionId", required: true, type: .string)
        ]
        /// ID for the collection that you are creating.
        public let collectionId: String

        public init(collectionId: String) {
            self.collectionId = collectionId
        }

        private enum CodingKeys: String, CodingKey {
            case collectionId = "CollectionId"
        }
    }

    public struct PersonDetection: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Timestamp", required: false, type: .long), 
            AWSShapeMember(label: "Person", required: false, type: .structure)
        ]
        /// The time, in milliseconds from the start of the video, that the person's path was tracked.
        public let timestamp: Int64?
        /// Details about a person whose path was tracked in a video.
        public let person: PersonDetail?

        public init(timestamp: Int64? = nil, person: PersonDetail? = nil) {
            self.timestamp = timestamp
            self.person = person
        }

        private enum CodingKeys: String, CodingKey {
            case timestamp = "Timestamp"
            case person = "Person"
        }
    }

    public struct DetectLabelsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LabelModelVersion", required: false, type: .string), 
            AWSShapeMember(label: "Labels", required: false, type: .list), 
            AWSShapeMember(label: "OrientationCorrection", required: false, type: .enum)
        ]
        /// Version number of the label detection model that was used to detect labels.
        public let labelModelVersion: String?
        /// An array of labels for the real-world objects detected. 
        public let labels: [Label]?
        /// The value of OrientationCorrection is always null. If the input image is in .jpeg format, it might contain exchangeable image file format (Exif) metadata that includes the image's orientation. Amazon Rekognition uses this orientation information to perform image correction. The bounding box coordinates are translated to represent object locations after the orientation information in the Exif metadata is used to correct the image orientation. Images in .png format don't contain Exif metadata. Amazon Rekognition doesnâ€™t perform image correction for images in .png format and .jpeg images without orientation information in the image Exif metadata. The bounding box coordinates aren't translated and represent the object locations before the image is rotated. 
        public let orientationCorrection: OrientationCorrection?

        public init(labelModelVersion: String? = nil, labels: [Label]? = nil, orientationCorrection: OrientationCorrection? = nil) {
            self.labelModelVersion = labelModelVersion
            self.labels = labels
            self.orientationCorrection = orientationCorrection
        }

        private enum CodingKeys: String, CodingKey {
            case labelModelVersion = "LabelModelVersion"
            case labels = "Labels"
            case orientationCorrection = "OrientationCorrection"
        }
    }

    public struct DetectLabelsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxLabels", required: false, type: .integer), 
            AWSShapeMember(label: "MinConfidence", required: false, type: .float), 
            AWSShapeMember(label: "Image", required: true, type: .structure)
        ]
        /// Maximum number of labels you want the service to return in the response. The service returns the specified number of highest confidence labels. 
        public let maxLabels: Int32?
        /// Specifies the minimum confidence level for the labels to return. Amazon Rekognition doesn't return any labels with confidence lower than this specified value. If MinConfidence is not specified, the operation returns labels with a confidence values greater than or equal to 50 percent.
        public let minConfidence: Float?
        /// The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call Amazon Rekognition operations, passing base64-encoded image bytes is not supported. 
        public let image: Image

        public init(maxLabels: Int32? = nil, minConfidence: Float? = nil, image: Image) {
            self.maxLabels = maxLabels
            self.minConfidence = minConfidence
            self.image = image
        }

        private enum CodingKeys: String, CodingKey {
            case maxLabels = "MaxLabels"
            case minConfidence = "MinConfidence"
            case image = "Image"
        }
    }

    public struct GetLabelDetectionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "VideoMetadata", required: false, type: .structure), 
            AWSShapeMember(label: "StatusMessage", required: false, type: .string), 
            AWSShapeMember(label: "JobStatus", required: false, type: .enum), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Labels", required: false, type: .list)
        ]
        /// Information about a video that Amazon Rekognition Video analyzed. Videometadata is returned in every page of paginated responses from a Amazon Rekognition video operation.
        public let videoMetadata: VideoMetadata?
        /// If the job fails, StatusMessage provides a descriptive error message.
        public let statusMessage: String?
        /// The current status of the label detection job.
        public let jobStatus: VideoJobStatus?
        /// If the response is truncated, Amazon Rekognition Video returns this token that you can use in the subsequent request to retrieve the next set of labels.
        public let nextToken: String?
        /// An array of labels detected in the video. Each element contains the detected label and the time, in milliseconds from the start of the video, that the label was detected. 
        public let labels: [LabelDetection]?

        public init(videoMetadata: VideoMetadata? = nil, statusMessage: String? = nil, jobStatus: VideoJobStatus? = nil, nextToken: String? = nil, labels: [LabelDetection]? = nil) {
            self.videoMetadata = videoMetadata
            self.statusMessage = statusMessage
            self.jobStatus = jobStatus
            self.nextToken = nextToken
            self.labels = labels
        }

        private enum CodingKeys: String, CodingKey {
            case videoMetadata = "VideoMetadata"
            case statusMessage = "StatusMessage"
            case jobStatus = "JobStatus"
            case nextToken = "NextToken"
            case labels = "Labels"
        }
    }

    public struct CompareFacesMatch: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Similarity", required: false, type: .float), 
            AWSShapeMember(label: "Face", required: false, type: .structure)
        ]
        /// Level of confidence that the faces match.
        public let similarity: Float?
        /// Provides face metadata (bounding box and confidence that the bounding box actually contains a face).
        public let face: ComparedFace?

        public init(similarity: Float? = nil, face: ComparedFace? = nil) {
            self.similarity = similarity
            self.face = face
        }

        private enum CodingKeys: String, CodingKey {
            case similarity = "Similarity"
            case face = "Face"
        }
    }

    public struct StreamProcessorInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "KinesisVideoStream", required: false, type: .structure)
        ]
        /// The Kinesis video stream input stream for the source streaming video.
        public let kinesisVideoStream: KinesisVideoStream?

        public init(kinesisVideoStream: KinesisVideoStream? = nil) {
            self.kinesisVideoStream = kinesisVideoStream
        }

        private enum CodingKeys: String, CodingKey {
            case kinesisVideoStream = "KinesisVideoStream"
        }
    }

    public struct ListFacesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FaceModelVersion", required: false, type: .string), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Faces", required: false, type: .list)
        ]
        /// Version number of the face detection model associated with the input collection (CollectionId).
        public let faceModelVersion: String?
        /// If the response is truncated, Amazon Rekognition returns this token that you can use in the subsequent request to retrieve the next set of faces.
        public let nextToken: String?
        /// An array of Face objects. 
        public let faces: [Face]?

        public init(faceModelVersion: String? = nil, nextToken: String? = nil, faces: [Face]? = nil) {
            self.faceModelVersion = faceModelVersion
            self.nextToken = nextToken
            self.faces = faces
        }

        private enum CodingKeys: String, CodingKey {
            case faceModelVersion = "FaceModelVersion"
            case nextToken = "NextToken"
            case faces = "Faces"
        }
    }

    public struct IndexFacesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ExternalImageId", required: false, type: .string), 
            AWSShapeMember(label: "Image", required: true, type: .structure), 
            AWSShapeMember(label: "DetectionAttributes", required: false, type: .list), 
            AWSShapeMember(label: "CollectionId", required: true, type: .string), 
            AWSShapeMember(label: "QualityFilter", required: false, type: .enum), 
            AWSShapeMember(label: "MaxFaces", required: false, type: .integer)
        ]
        /// The ID you want to assign to all the faces detected in the image.
        public let externalImageId: String?
        /// The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call Amazon Rekognition operations, passing base64-encoded image bytes isn't supported. 
        public let image: Image
        /// An array of facial attributes that you want to be returned. This can be the default list of attributes or all attributes. If you don't specify a value for Attributes or if you specify ["DEFAULT"], the API returns the following subset of facial attributes: BoundingBox, Confidence, Pose, Quality, and Landmarks. If you provide ["ALL"], all facial attributes are returned, but the operation takes longer to complete. If you provide both, ["ALL", "DEFAULT"], the service uses a logical AND operator to determine which attributes to return (in this case, all attributes). 
        public let detectionAttributes: [Attribute]?
        /// The ID of an existing collection to which you want to add the faces that are detected in the input images.
        public let collectionId: String
        /// A filter that specifies how much filtering is done to identify faces that are detected with low quality. Filtered faces aren't indexed. If you specify AUTO, filtering prioritizes the identification of faces that donâ€™t meet the required quality bar chosen by Amazon Rekognition. The quality bar is based on a variety of common use cases. Low-quality detections can occur for a number of reasons. Some examples are an object that's misidentified as a face, a face that's too blurry, or a face with a pose that's too extreme to use. If you specify NONE, no filtering is performed. The default value is AUTO. To use quality filtering, the collection you are using must be associated with version 3 of the face model.
        public let qualityFilter: QualityFilter?
        /// The maximum number of faces to index. The value of MaxFaces must be greater than or equal to 1. IndexFaces returns no more than 100 detected faces in an image, even if you specify a larger value for MaxFaces. If IndexFaces detects more faces than the value of MaxFaces, the faces with the lowest quality are filtered out first. If there are still more faces than the value of MaxFaces, the faces with the smallest bounding boxes are filtered out (up to the number that's needed to satisfy the value of MaxFaces). Information about the unindexed faces is available in the UnindexedFaces array.  The faces that are returned by IndexFaces are sorted by the largest face bounding box size to the smallest size, in descending order.  MaxFaces can be used with a collection associated with any version of the face model.
        public let maxFaces: Int32?

        public init(externalImageId: String? = nil, image: Image, detectionAttributes: [Attribute]? = nil, collectionId: String, qualityFilter: QualityFilter? = nil, maxFaces: Int32? = nil) {
            self.externalImageId = externalImageId
            self.image = image
            self.detectionAttributes = detectionAttributes
            self.collectionId = collectionId
            self.qualityFilter = qualityFilter
            self.maxFaces = maxFaces
        }

        private enum CodingKeys: String, CodingKey {
            case externalImageId = "ExternalImageId"
            case image = "Image"
            case detectionAttributes = "DetectionAttributes"
            case collectionId = "CollectionId"
            case qualityFilter = "QualityFilter"
            case maxFaces = "MaxFaces"
        }
    }

    public struct Smile: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Value", required: false, type: .boolean), 
            AWSShapeMember(label: "Confidence", required: false, type: .float)
        ]
        /// Boolean value that indicates whether the face is smiling or not.
        public let value: Bool?
        /// Level of confidence in the determination.
        public let confidence: Float?

        public init(value: Bool? = nil, confidence: Float? = nil) {
            self.value = value
            self.confidence = confidence
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
            case confidence = "Confidence"
        }
    }

    public enum OrientationCorrection: String, CustomStringConvertible, Codable {
        case rotate0 = "ROTATE_0"
        case rotate90 = "ROTATE_90"
        case rotate180 = "ROTATE_180"
        case rotate270 = "ROTATE_270"
        public var description: String { return self.rawValue }
    }

    public enum StreamProcessorStatus: String, CustomStringConvertible, Codable {
        case stopped = "STOPPED"
        case starting = "STARTING"
        case running = "RUNNING"
        case failed = "FAILED"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public struct GetCelebrityRecognitionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "SortBy", required: false, type: .enum), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "JobId", required: true, type: .string)
        ]
        /// If the previous response was incomplete (because there is more recognized celebrities to retrieve), Amazon Rekognition Video returns a pagination token in the response. You can use this pagination token to retrieve the next set of celebrities. 
        public let nextToken: String?
        /// Sort to use for celebrities returned in Celebrities field. Specify ID to sort by the celebrity identifier, specify TIMESTAMP to sort by the time the celebrity was recognized.
        public let sortBy: CelebrityRecognitionSortBy?
        /// Maximum number of results to return per paginated call. The largest value you can specify is 1000. If you specify a value greater than 1000, a maximum of 1000 results is returned. The default value is 1000.
        public let maxResults: Int32?
        /// Job identifier for the required celebrity recognition analysis. You can get the job identifer from a call to StartCelebrityRecognition.
        public let jobId: String

        public init(nextToken: String? = nil, sortBy: CelebrityRecognitionSortBy? = nil, maxResults: Int32? = nil, jobId: String) {
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.maxResults = maxResults
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case maxResults = "MaxResults"
            case jobId = "JobId"
        }
    }

    public struct StartLabelDetectionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClientRequestToken", required: false, type: .string), 
            AWSShapeMember(label: "NotificationChannel", required: false, type: .structure), 
            AWSShapeMember(label: "JobTag", required: false, type: .string), 
            AWSShapeMember(label: "Video", required: true, type: .structure), 
            AWSShapeMember(label: "MinConfidence", required: false, type: .float)
        ]
        /// Idempotent token used to identify the start request. If you use the same token with multiple StartLabelDetection requests, the same JobId is returned. Use ClientRequestToken to prevent the same job from being accidently started more than once. 
        public let clientRequestToken: String?
        /// The Amazon SNS topic ARN you want Amazon Rekognition Video to publish the completion status of the label detection operation to. 
        public let notificationChannel: NotificationChannel?
        /// Unique identifier you specify to identify the job in the completion status published to the Amazon Simple Notification Service topic. 
        public let jobTag: String?
        /// The video in which you want to detect labels. The video must be stored in an Amazon S3 bucket.
        public let video: Video
        /// Specifies the minimum confidence that Amazon Rekognition Video must have in order to return a detected label. Confidence represents how certain Amazon Rekognition is that a label is correctly identified.0 is the lowest confidence. 100 is the highest confidence. Amazon Rekognition Video doesn't return any labels with a confidence level lower than this specified value. If you don't specify MinConfidence, the operation returns labels with confidence values greater than or equal to 50 percent.
        public let minConfidence: Float?

        public init(clientRequestToken: String? = nil, notificationChannel: NotificationChannel? = nil, jobTag: String? = nil, video: Video, minConfidence: Float? = nil) {
            self.clientRequestToken = clientRequestToken
            self.notificationChannel = notificationChannel
            self.jobTag = jobTag
            self.video = video
            self.minConfidence = minConfidence
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case notificationChannel = "NotificationChannel"
            case jobTag = "JobTag"
            case video = "Video"
            case minConfidence = "MinConfidence"
        }
    }

    public struct CreateStreamProcessorRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Output", required: true, type: .structure), 
            AWSShapeMember(label: "Input", required: true, type: .structure), 
            AWSShapeMember(label: "RoleArn", required: true, type: .string), 
            AWSShapeMember(label: "Settings", required: true, type: .structure)
        ]
        /// An identifier you assign to the stream processor. You can use Name to manage the stream processor. For example, you can get the current status of the stream processor by calling . Name is idempotent. 
        public let name: String
        /// Kinesis data stream stream to which Amazon Rekognition Video puts the analysis results. If you are using the AWS CLI, the parameter name is StreamProcessorOutput.
        public let output: StreamProcessorOutput
        /// Kinesis video stream stream that provides the source streaming video. If you are using the AWS CLI, the parameter name is StreamProcessorInput.
        public let input: StreamProcessorInput
        /// ARN of the IAM role that allows access to the stream processor.
        public let roleArn: String
        /// Face recognition input parameters to be used by the stream processor. Includes the collection to use for face recognition and the face attributes to detect.
        public let settings: StreamProcessorSettings

        public init(name: String, output: StreamProcessorOutput, input: StreamProcessorInput, roleArn: String, settings: StreamProcessorSettings) {
            self.name = name
            self.output = output
            self.input = input
            self.roleArn = roleArn
            self.settings = settings
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case output = "Output"
            case input = "Input"
            case roleArn = "RoleArn"
            case settings = "Settings"
        }
    }

    public struct DetectModerationLabelsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MinConfidence", required: false, type: .float), 
            AWSShapeMember(label: "Image", required: true, type: .structure)
        ]
        /// Specifies the minimum confidence level for the labels to return. Amazon Rekognition doesn't return any labels with a confidence level lower than this specified value. If you don't specify MinConfidence, the operation returns labels with confidence values greater than or equal to 50 percent.
        public let minConfidence: Float?
        /// The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call Amazon Rekognition operations, passing base64-encoded image bytes is not supported. 
        public let image: Image

        public init(minConfidence: Float? = nil, image: Image) {
            self.minConfidence = minConfidence
            self.image = image
        }

        private enum CodingKeys: String, CodingKey {
            case minConfidence = "MinConfidence"
            case image = "Image"
        }
    }

    public struct GetFaceSearchResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "StatusMessage", required: false, type: .string), 
            AWSShapeMember(label: "Persons", required: false, type: .list), 
            AWSShapeMember(label: "VideoMetadata", required: false, type: .structure), 
            AWSShapeMember(label: "JobStatus", required: false, type: .enum)
        ]
        /// If the response is truncated, Amazon Rekognition Video returns this token that you can use in the subsequent request to retrieve the next set of search results. 
        public let nextToken: String?
        /// If the job fails, StatusMessage provides a descriptive error message.
        public let statusMessage: String?
        /// An array of persons, , in the video whose face(s) match the face(s) in an Amazon Rekognition collection. It also includes time information for when persons are matched in the video. You specify the input collection in an initial call to StartFaceSearch. Each Persons element includes a time the person was matched, face match details (FaceMatches) for matching faces in the collection, and person information (Person) for the matched person. 
        public let persons: [PersonMatch]?
        /// Information about a video that Amazon Rekognition analyzed. Videometadata is returned in every page of paginated responses from a Amazon Rekognition Video operation. 
        public let videoMetadata: VideoMetadata?
        /// The current status of the face search job.
        public let jobStatus: VideoJobStatus?

        public init(nextToken: String? = nil, statusMessage: String? = nil, persons: [PersonMatch]? = nil, videoMetadata: VideoMetadata? = nil, jobStatus: VideoJobStatus? = nil) {
            self.nextToken = nextToken
            self.statusMessage = statusMessage
            self.persons = persons
            self.videoMetadata = videoMetadata
            self.jobStatus = jobStatus
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case statusMessage = "StatusMessage"
            case persons = "Persons"
            case videoMetadata = "VideoMetadata"
            case jobStatus = "JobStatus"
        }
    }

    public struct DetectTextRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Image", required: true, type: .structure)
        ]
        /// The input image as base64-encoded bytes or an Amazon S3 object. If you use the AWS CLI to call Amazon Rekognition operations, you can't pass image bytes. 
        public let image: Image

        public init(image: Image) {
            self.image = image
        }

        private enum CodingKeys: String, CodingKey {
            case image = "Image"
        }
    }

    public struct FaceDetection: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Timestamp", required: false, type: .long), 
            AWSShapeMember(label: "Face", required: false, type: .structure)
        ]
        /// Time, in milliseconds from the start of the video, that the face was detected.
        public let timestamp: Int64?
        /// The face properties for the detected face.
        public let face: FaceDetail?

        public init(timestamp: Int64? = nil, face: FaceDetail? = nil) {
            self.timestamp = timestamp
            self.face = face
        }

        private enum CodingKeys: String, CodingKey {
            case timestamp = "Timestamp"
            case face = "Face"
        }
    }

    public struct Beard: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Value", required: false, type: .boolean), 
            AWSShapeMember(label: "Confidence", required: false, type: .float)
        ]
        /// Boolean value that indicates whether the face has beard or not.
        public let value: Bool?
        /// Level of confidence in the determination.
        public let confidence: Float?

        public init(value: Bool? = nil, confidence: Float? = nil) {
            self.value = value
            self.confidence = confidence
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
            case confidence = "Confidence"
        }
    }

    public struct ModerationLabel: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Confidence", required: false, type: .float), 
            AWSShapeMember(label: "ParentName", required: false, type: .string)
        ]
        /// The label name for the type of content detected in the image.
        public let name: String?
        /// Specifies the confidence that Amazon Rekognition has that the label has been correctly identified. If you don't specify the MinConfidence parameter in the call to DetectModerationLabels, the operation returns labels with a confidence value greater than or equal to 50 percent.
        public let confidence: Float?
        /// The name for the parent label. Labels at the top level of the hierarchy have the parent label "".
        public let parentName: String?

        public init(name: String? = nil, confidence: Float? = nil, parentName: String? = nil) {
            self.name = name
            self.confidence = confidence
            self.parentName = parentName
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case confidence = "Confidence"
            case parentName = "ParentName"
        }
    }

    public struct ListFacesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "CollectionId", required: true, type: .string)
        ]
        /// If the previous response was incomplete (because there is more data to retrieve), Amazon Rekognition returns a pagination token in the response. You can use this pagination token to retrieve the next set of faces.
        public let nextToken: String?
        /// Maximum number of faces to return.
        public let maxResults: Int32?
        /// ID of the collection from which to list the faces.
        public let collectionId: String

        public init(nextToken: String? = nil, maxResults: Int32? = nil, collectionId: String) {
            self.nextToken = nextToken
            self.maxResults = maxResults
            self.collectionId = collectionId
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case maxResults = "MaxResults"
            case collectionId = "CollectionId"
        }
    }

    public struct Geometry: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Polygon", required: false, type: .list), 
            AWSShapeMember(label: "BoundingBox", required: false, type: .structure)
        ]
        /// Within the bounding box, a fine-grained polygon around the detected text.
        public let polygon: [Point]?
        /// An axis-aligned coarse representation of the detected text's location on the image.
        public let boundingBox: BoundingBox?

        public init(polygon: [Point]? = nil, boundingBox: BoundingBox? = nil) {
            self.polygon = polygon
            self.boundingBox = boundingBox
        }

        private enum CodingKeys: String, CodingKey {
            case polygon = "Polygon"
            case boundingBox = "BoundingBox"
        }
    }

    public enum EmotionName: String, CustomStringConvertible, Codable {
        case happy = "HAPPY"
        case sad = "SAD"
        case angry = "ANGRY"
        case confused = "CONFUSED"
        case disgusted = "DISGUSTED"
        case surprised = "SURPRISED"
        case calm = "CALM"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public struct ListStreamProcessorsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StreamProcessors", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// List of stream processors that you have created.
        public let streamProcessors: [StreamProcessor]?
        /// If the response is truncated, Amazon Rekognition Video returns this token that you can use in the subsequent request to retrieve the next set of stream processors. 
        public let nextToken: String?

        public init(streamProcessors: [StreamProcessor]? = nil, nextToken: String? = nil) {
            self.streamProcessors = streamProcessors
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case streamProcessors = "StreamProcessors"
            case nextToken = "NextToken"
        }
    }

    public struct GetContentModerationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "SortBy", required: false, type: .enum), 
            AWSShapeMember(label: "JobId", required: true, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer)
        ]
        /// If the previous response was incomplete (because there is more data to retrieve), Amazon Rekognition returns a pagination token in the response. You can use this pagination token to retrieve the next set of content moderation labels.
        public let nextToken: String?
        /// Sort to use for elements in the ModerationLabelDetections array. Use TIMESTAMP to sort array elements by the time labels are detected. Use NAME to alphabetically group elements for a label together. Within each label group, the array element are sorted by detection confidence. The default sort is by TIMESTAMP.
        public let sortBy: ContentModerationSortBy?
        /// The identifier for the content moderation job. Use JobId to identify the job in a subsequent call to GetContentModeration.
        public let jobId: String
        /// Maximum number of results to return per paginated call. The largest value you can specify is 1000. If you specify a value greater than 1000, a maximum of 1000 results is returned. The default value is 1000.
        public let maxResults: Int32?

        public init(nextToken: String? = nil, sortBy: ContentModerationSortBy? = nil, jobId: String, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.jobId = jobId
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case jobId = "JobId"
            case maxResults = "MaxResults"
        }
    }

    public struct StreamProcessorOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "KinesisDataStream", required: false, type: .structure)
        ]
        /// The Amazon Kinesis Data Streams stream to which the Amazon Rekognition stream processor streams the analysis results.
        public let kinesisDataStream: KinesisDataStream?

        public init(kinesisDataStream: KinesisDataStream? = nil) {
            self.kinesisDataStream = kinesisDataStream
        }

        private enum CodingKeys: String, CodingKey {
            case kinesisDataStream = "KinesisDataStream"
        }
    }

    public struct IndexFacesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UnindexedFaces", required: false, type: .list), 
            AWSShapeMember(label: "FaceRecords", required: false, type: .list), 
            AWSShapeMember(label: "FaceModelVersion", required: false, type: .string), 
            AWSShapeMember(label: "OrientationCorrection", required: false, type: .enum)
        ]
        /// An array of faces that were detected in the image but weren't indexed. They weren't indexed because the quality filter identified them as low quality, or the MaxFaces request parameter filtered them out. To use the quality filter, you specify the QualityFilter request parameter.
        public let unindexedFaces: [UnindexedFace]?
        /// An array of faces detected and added to the collection. For more information, see Searching Faces in a Collection in the Amazon Rekognition Developer Guide. 
        public let faceRecords: [FaceRecord]?
        /// The version number of the face detection model that's associated with the input collection (CollectionId).
        public let faceModelVersion: String?
        /// If your collection is associated with a face detection model that's later than version 3.0, the value of OrientationCorrection is always null and no orientation information is returned. If your collection is associated with a face detection model that's version 3.0 or earlier, the following applies:   If the input image is in .jpeg format, it might contain exchangeable image file format (Exif) metadata that includes the image's orientation. Amazon Rekognition uses this orientation information to perform image correction - the bounding box coordinates are translated to represent object locations after the orientation information in the Exif metadata is used to correct the image orientation. Images in .png format don't contain Exif metadata. The value of OrientationCorrection is null.   If the image doesn't contain orientation information in its Exif metadata, Amazon Rekognition returns an estimated orientation (ROTATE_0, ROTATE_90, ROTATE_180, ROTATE_270). Amazon Rekognition doesnâ€™t perform image correction for images. The bounding box coordinates aren't translated and represent the object locations before the image is rotated.   Bounding box information is returned in the FaceRecords array. You can get the version of the face detection model by calling . 
        public let orientationCorrection: OrientationCorrection?

        public init(unindexedFaces: [UnindexedFace]? = nil, faceRecords: [FaceRecord]? = nil, faceModelVersion: String? = nil, orientationCorrection: OrientationCorrection? = nil) {
            self.unindexedFaces = unindexedFaces
            self.faceRecords = faceRecords
            self.faceModelVersion = faceModelVersion
            self.orientationCorrection = orientationCorrection
        }

        private enum CodingKeys: String, CodingKey {
            case unindexedFaces = "UnindexedFaces"
            case faceRecords = "FaceRecords"
            case faceModelVersion = "FaceModelVersion"
            case orientationCorrection = "OrientationCorrection"
        }
    }

    public struct PersonMatch: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Timestamp", required: false, type: .long), 
            AWSShapeMember(label: "Person", required: false, type: .structure), 
            AWSShapeMember(label: "FaceMatches", required: false, type: .list)
        ]
        /// The time, in milliseconds from the beginning of the video, that the person was matched in the video.
        public let timestamp: Int64?
        /// Information about the matched person.
        public let person: PersonDetail?
        /// Information about the faces in the input collection that match the face of a person in the video.
        public let faceMatches: [FaceMatch]?

        public init(timestamp: Int64? = nil, person: PersonDetail? = nil, faceMatches: [FaceMatch]? = nil) {
            self.timestamp = timestamp
            self.person = person
            self.faceMatches = faceMatches
        }

        private enum CodingKeys: String, CodingKey {
            case timestamp = "Timestamp"
            case person = "Person"
            case faceMatches = "FaceMatches"
        }
    }

    public struct CompareFacesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TargetImageOrientationCorrection", required: false, type: .enum), 
            AWSShapeMember(label: "SourceImageOrientationCorrection", required: false, type: .enum), 
            AWSShapeMember(label: "FaceMatches", required: false, type: .list), 
            AWSShapeMember(label: "UnmatchedFaces", required: false, type: .list), 
            AWSShapeMember(label: "SourceImageFace", required: false, type: .structure)
        ]
        /// The value of TargetImageOrientationCorrection is always null. If the input image is in .jpeg format, it might contain exchangeable image file format (Exif) metadata that includes the image's orientation. Amazon Rekognition uses this orientation information to perform image correction. The bounding box coordinates are translated to represent object locations after the orientation information in the Exif metadata is used to correct the image orientation. Images in .png format don't contain Exif metadata. Amazon Rekognition doesnâ€™t perform image correction for images in .png format and .jpeg images without orientation information in the image Exif metadata. The bounding box coordinates aren't translated and represent the object locations before the image is rotated. 
        public let targetImageOrientationCorrection: OrientationCorrection?
        /// The value of SourceImageOrientationCorrection is always null. If the input image is in .jpeg format, it might contain exchangeable image file format (Exif) metadata that includes the image's orientation. Amazon Rekognition uses this orientation information to perform image correction. The bounding box coordinates are translated to represent object locations after the orientation information in the Exif metadata is used to correct the image orientation. Images in .png format don't contain Exif metadata. Amazon Rekognition doesnâ€™t perform image correction for images in .png format and .jpeg images without orientation information in the image Exif metadata. The bounding box coordinates aren't translated and represent the object locations before the image is rotated. 
        public let sourceImageOrientationCorrection: OrientationCorrection?
        /// An array of faces in the target image that match the source image face. Each CompareFacesMatch object provides the bounding box, the confidence level that the bounding box contains a face, and the similarity score for the face in the bounding box and the face in the source image.
        public let faceMatches: [CompareFacesMatch]?
        /// An array of faces in the target image that did not match the source image face.
        public let unmatchedFaces: [ComparedFace]?
        /// The face in the source image that was used for comparison.
        public let sourceImageFace: ComparedSourceImageFace?

        public init(targetImageOrientationCorrection: OrientationCorrection? = nil, sourceImageOrientationCorrection: OrientationCorrection? = nil, faceMatches: [CompareFacesMatch]? = nil, unmatchedFaces: [ComparedFace]? = nil, sourceImageFace: ComparedSourceImageFace? = nil) {
            self.targetImageOrientationCorrection = targetImageOrientationCorrection
            self.sourceImageOrientationCorrection = sourceImageOrientationCorrection
            self.faceMatches = faceMatches
            self.unmatchedFaces = unmatchedFaces
            self.sourceImageFace = sourceImageFace
        }

        private enum CodingKeys: String, CodingKey {
            case targetImageOrientationCorrection = "TargetImageOrientationCorrection"
            case sourceImageOrientationCorrection = "SourceImageOrientationCorrection"
            case faceMatches = "FaceMatches"
            case unmatchedFaces = "UnmatchedFaces"
            case sourceImageFace = "SourceImageFace"
        }
    }

    public enum VideoJobStatus: String, CustomStringConvertible, Codable {
        case inProgress = "IN_PROGRESS"
        case succeeded = "SUCCEEDED"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public struct GetFaceDetectionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StatusMessage", required: false, type: .string), 
            AWSShapeMember(label: "JobStatus", required: false, type: .enum), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Faces", required: false, type: .list), 
            AWSShapeMember(label: "VideoMetadata", required: false, type: .structure)
        ]
        /// If the job fails, StatusMessage provides a descriptive error message.
        public let statusMessage: String?
        /// The current status of the face detection job.
        public let jobStatus: VideoJobStatus?
        /// If the response is truncated, Amazon Rekognition returns this token that you can use in the subsequent request to retrieve the next set of faces. 
        public let nextToken: String?
        /// An array of faces detected in the video. Each element contains a detected face's details and the time, in milliseconds from the start of the video, the face was detected. 
        public let faces: [FaceDetection]?
        /// Information about a video that Amazon Rekognition Video analyzed. Videometadata is returned in every page of paginated responses from a Amazon Rekognition video operation.
        public let videoMetadata: VideoMetadata?

        public init(statusMessage: String? = nil, jobStatus: VideoJobStatus? = nil, nextToken: String? = nil, faces: [FaceDetection]? = nil, videoMetadata: VideoMetadata? = nil) {
            self.statusMessage = statusMessage
            self.jobStatus = jobStatus
            self.nextToken = nextToken
            self.faces = faces
            self.videoMetadata = videoMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case statusMessage = "StatusMessage"
            case jobStatus = "JobStatus"
            case nextToken = "NextToken"
            case faces = "Faces"
            case videoMetadata = "VideoMetadata"
        }
    }

    public enum TextTypes: String, CustomStringConvertible, Codable {
        case line = "LINE"
        case word = "WORD"
        public var description: String { return self.rawValue }
    }

    public struct UnindexedFace: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FaceDetail", required: false, type: .structure), 
            AWSShapeMember(label: "Reasons", required: false, type: .list)
        ]
        /// The structure that contains attributes of a face that IndexFacesdetected, but didn't index. 
        public let faceDetail: FaceDetail?
        /// An array of reasons that specify why a face wasn't indexed.    EXTREME_POSE - The face is at a pose that can't be detected. For example, the head is turned too far away from the camera.   EXCEEDS_MAX_FACES - The number of faces detected is already higher than that specified by the MaxFaces input parameter for IndexFaces.   LOW_BRIGHTNESS - The image is too dark.   LOW_SHARPNESS - The image is too blurry.   LOW_CONFIDENCE - The face was detected with a low confidence.   SMALL_BOUNDING_BOX - The bounding box around the face is too small.  
        public let reasons: [Reason]?

        public init(faceDetail: FaceDetail? = nil, reasons: [Reason]? = nil) {
            self.faceDetail = faceDetail
            self.reasons = reasons
        }

        private enum CodingKeys: String, CodingKey {
            case faceDetail = "FaceDetail"
            case reasons = "Reasons"
        }
    }

    public struct StartFaceDetectionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Video", required: true, type: .structure), 
            AWSShapeMember(label: "FaceAttributes", required: false, type: .enum), 
            AWSShapeMember(label: "ClientRequestToken", required: false, type: .string), 
            AWSShapeMember(label: "NotificationChannel", required: false, type: .structure), 
            AWSShapeMember(label: "JobTag", required: false, type: .string)
        ]
        /// The video in which you want to detect faces. The video must be stored in an Amazon S3 bucket.
        public let video: Video
        /// The face attributes you want returned.  DEFAULT - The following subset of facial attributes are returned: BoundingBox, Confidence, Pose, Quality and Landmarks.   ALL - All facial attributes are returned.
        public let faceAttributes: FaceAttributes?
        /// Idempotent token used to identify the start request. If you use the same token with multiple StartFaceDetection requests, the same JobId is returned. Use ClientRequestToken to prevent the same job from being accidently started more than once. 
        public let clientRequestToken: String?
        /// The ARN of the Amazon SNS topic to which you want Amazon Rekognition Video to publish the completion status of the face detection operation.
        public let notificationChannel: NotificationChannel?
        /// Unique identifier you specify to identify the job in the completion status published to the Amazon Simple Notification Service topic. 
        public let jobTag: String?

        public init(video: Video, faceAttributes: FaceAttributes? = nil, clientRequestToken: String? = nil, notificationChannel: NotificationChannel? = nil, jobTag: String? = nil) {
            self.video = video
            self.faceAttributes = faceAttributes
            self.clientRequestToken = clientRequestToken
            self.notificationChannel = notificationChannel
            self.jobTag = jobTag
        }

        private enum CodingKeys: String, CodingKey {
            case video = "Video"
            case faceAttributes = "FaceAttributes"
            case clientRequestToken = "ClientRequestToken"
            case notificationChannel = "NotificationChannel"
            case jobTag = "JobTag"
        }
    }

    public struct FaceMatch: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Face", required: false, type: .structure), 
            AWSShapeMember(label: "Similarity", required: false, type: .float)
        ]
        /// Describes the face properties such as the bounding box, face ID, image ID of the source image, and external image ID that you assigned.
        public let face: Face?
        /// Confidence in the match of this face with the input face.
        public let similarity: Float?

        public init(face: Face? = nil, similarity: Float? = nil) {
            self.face = face
            self.similarity = similarity
        }

        private enum CodingKeys: String, CodingKey {
            case face = "Face"
            case similarity = "Similarity"
        }
    }

    public struct FaceRecord: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Face", required: false, type: .structure), 
            AWSShapeMember(label: "FaceDetail", required: false, type: .structure)
        ]
        /// Describes the face properties such as the bounding box, face ID, image ID of the input image, and external image ID that you assigned. 
        public let face: Face?
        /// Structure containing attributes of the face that the algorithm detected.
        public let faceDetail: FaceDetail?

        public init(face: Face? = nil, faceDetail: FaceDetail? = nil) {
            self.face = face
            self.faceDetail = faceDetail
        }

        private enum CodingKeys: String, CodingKey {
            case face = "Face"
            case faceDetail = "FaceDetail"
        }
    }

    public struct Emotion: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Type", required: false, type: .enum), 
            AWSShapeMember(label: "Confidence", required: false, type: .float)
        ]
        /// Type of emotion detected.
        public let `type`: EmotionName?
        /// Level of confidence in the determination.
        public let confidence: Float?

        public init(type: EmotionName? = nil, confidence: Float? = nil) {
            self.`type` = `type`
            self.confidence = confidence
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "Type"
            case confidence = "Confidence"
        }
    }

    public struct GetLabelDetectionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "JobId", required: true, type: .string), 
            AWSShapeMember(label: "SortBy", required: false, type: .enum), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// Maximum number of results to return per paginated call. The largest value you can specify is 1000. If you specify a value greater than 1000, a maximum of 1000 results is returned. The default value is 1000.
        public let maxResults: Int32?
        /// Job identifier for the label detection operation for which you want results returned. You get the job identifer from an initial call to StartlabelDetection.
        public let jobId: String
        /// Sort to use for elements in the Labels array. Use TIMESTAMP to sort array elements by the time labels are detected. Use NAME to alphabetically group elements for a label together. Within each label group, the array element are sorted by detection confidence. The default sort is by TIMESTAMP.
        public let sortBy: LabelDetectionSortBy?
        /// If the previous response was incomplete (because there are more labels to retrieve), Amazon Rekognition Video returns a pagination token in the response. You can use this pagination token to retrieve the next set of labels. 
        public let nextToken: String?

        public init(maxResults: Int32? = nil, jobId: String, sortBy: LabelDetectionSortBy? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.jobId = jobId
            self.sortBy = sortBy
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case jobId = "JobId"
            case sortBy = "SortBy"
            case nextToken = "NextToken"
        }
    }

    public struct StartFaceSearchResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobId", required: false, type: .string)
        ]
        /// The identifier for the search job. Use JobId to identify the job in a subsequent call to GetFaceSearch. 
        public let jobId: String?

        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct FaceDetail: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Beard", required: false, type: .structure), 
            AWSShapeMember(label: "EyesOpen", required: false, type: .structure), 
            AWSShapeMember(label: "Eyeglasses", required: false, type: .structure), 
            AWSShapeMember(label: "AgeRange", required: false, type: .structure), 
            AWSShapeMember(label: "Confidence", required: false, type: .float), 
            AWSShapeMember(label: "Quality", required: false, type: .structure), 
            AWSShapeMember(label: "Pose", required: false, type: .structure), 
            AWSShapeMember(label: "Mustache", required: false, type: .structure), 
            AWSShapeMember(label: "Gender", required: false, type: .structure), 
            AWSShapeMember(label: "MouthOpen", required: false, type: .structure), 
            AWSShapeMember(label: "Emotions", required: false, type: .list), 
            AWSShapeMember(label: "Landmarks", required: false, type: .list), 
            AWSShapeMember(label: "Smile", required: false, type: .structure), 
            AWSShapeMember(label: "BoundingBox", required: false, type: .structure), 
            AWSShapeMember(label: "Sunglasses", required: false, type: .structure)
        ]
        /// Indicates whether or not the face has a beard, and the confidence level in the determination.
        public let beard: Beard?
        /// Indicates whether or not the eyes on the face are open, and the confidence level in the determination.
        public let eyesOpen: EyeOpen?
        /// Indicates whether or not the face is wearing eye glasses, and the confidence level in the determination.
        public let eyeglasses: Eyeglasses?
        /// The estimated age range, in years, for the face. Low represents the lowest estimated age and High represents the highest estimated age.
        public let ageRange: AgeRange?
        /// Confidence level that the bounding box contains a face (and not a different object such as a tree). Default attribute.
        public let confidence: Float?
        /// Identifies image brightness and sharpness. Default attribute.
        public let quality: ImageQuality?
        /// Indicates the pose of the face as determined by its pitch, roll, and yaw. Default attribute.
        public let pose: Pose?
        /// Indicates whether or not the face has a mustache, and the confidence level in the determination.
        public let mustache: Mustache?
        /// Gender of the face and the confidence level in the determination.
        public let gender: Gender?
        /// Indicates whether or not the mouth on the face is open, and the confidence level in the determination.
        public let mouthOpen: MouthOpen?
        /// The emotions detected on the face, and the confidence level in the determination. For example, HAPPY, SAD, and ANGRY. 
        public let emotions: [Emotion]?
        /// Indicates the location of landmarks on the face. Default attribute.
        public let landmarks: [Landmark]?
        /// Indicates whether or not the face is smiling, and the confidence level in the determination.
        public let smile: Smile?
        /// Bounding box of the face. Default attribute.
        public let boundingBox: BoundingBox?
        /// Indicates whether or not the face is wearing sunglasses, and the confidence level in the determination.
        public let sunglasses: Sunglasses?

        public init(beard: Beard? = nil, eyesOpen: EyeOpen? = nil, eyeglasses: Eyeglasses? = nil, ageRange: AgeRange? = nil, confidence: Float? = nil, quality: ImageQuality? = nil, pose: Pose? = nil, mustache: Mustache? = nil, gender: Gender? = nil, mouthOpen: MouthOpen? = nil, emotions: [Emotion]? = nil, landmarks: [Landmark]? = nil, smile: Smile? = nil, boundingBox: BoundingBox? = nil, sunglasses: Sunglasses? = nil) {
            self.beard = beard
            self.eyesOpen = eyesOpen
            self.eyeglasses = eyeglasses
            self.ageRange = ageRange
            self.confidence = confidence
            self.quality = quality
            self.pose = pose
            self.mustache = mustache
            self.gender = gender
            self.mouthOpen = mouthOpen
            self.emotions = emotions
            self.landmarks = landmarks
            self.smile = smile
            self.boundingBox = boundingBox
            self.sunglasses = sunglasses
        }

        private enum CodingKeys: String, CodingKey {
            case beard = "Beard"
            case eyesOpen = "EyesOpen"
            case eyeglasses = "Eyeglasses"
            case ageRange = "AgeRange"
            case confidence = "Confidence"
            case quality = "Quality"
            case pose = "Pose"
            case mustache = "Mustache"
            case gender = "Gender"
            case mouthOpen = "MouthOpen"
            case emotions = "Emotions"
            case landmarks = "Landmarks"
            case smile = "Smile"
            case boundingBox = "BoundingBox"
            case sunglasses = "Sunglasses"
        }
    }

    public struct CreateStreamProcessorResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StreamProcessorArn", required: false, type: .string)
        ]
        /// ARN for the newly create stream processor.
        public let streamProcessorArn: String?

        public init(streamProcessorArn: String? = nil) {
            self.streamProcessorArn = streamProcessorArn
        }

        private enum CodingKeys: String, CodingKey {
            case streamProcessorArn = "StreamProcessorArn"
        }
    }

    public struct DeleteStreamProcessorResponse: AWSShape {

    }

    public struct CelebrityRecognition: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Celebrity", required: false, type: .structure), 
            AWSShapeMember(label: "Timestamp", required: false, type: .long)
        ]
        /// Information about a recognized celebrity.
        public let celebrity: CelebrityDetail?
        /// The time, in milliseconds from the start of the video, that the celebrity was recognized.
        public let timestamp: Int64?

        public init(celebrity: CelebrityDetail? = nil, timestamp: Int64? = nil) {
            self.celebrity = celebrity
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case celebrity = "Celebrity"
            case timestamp = "Timestamp"
        }
    }

    public struct GetCelebrityInfoResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Urls", required: false, type: .list), 
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]
        /// An array of URLs pointing to additional celebrity information. 
        public let urls: [String]?
        /// The name of the celebrity.
        public let name: String?

        public init(urls: [String]? = nil, name: String? = nil) {
            self.urls = urls
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case urls = "Urls"
            case name = "Name"
        }
    }

    public struct GetFaceDetectionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobId", required: true, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// Unique identifier for the face detection job. The JobId is returned from StartFaceDetection.
        public let jobId: String
        /// Maximum number of results to return per paginated call. The largest value you can specify is 1000. If you specify a value greater than 1000, a maximum of 1000 results is returned. The default value is 1000.
        public let maxResults: Int32?
        /// If the previous response was incomplete (because there are more faces to retrieve), Amazon Rekognition Video returns a pagination token in the response. You can use this pagination token to retrieve the next set of faces.
        public let nextToken: String?

        public init(jobId: String, maxResults: Int32? = nil, nextToken: String? = nil) {
            self.jobId = jobId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct StopStreamProcessorResponse: AWSShape {

    }

    public struct CelebrityDetail: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Urls", required: false, type: .list), 
            AWSShapeMember(label: "BoundingBox", required: false, type: .structure), 
            AWSShapeMember(label: "Confidence", required: false, type: .float), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Face", required: false, type: .structure)
        ]
        /// An array of URLs pointing to additional celebrity information. 
        public let urls: [String]?
        /// Bounding box around the body of a celebrity.
        public let boundingBox: BoundingBox?
        /// The confidence, in percentage, that Amazon Rekognition has that the recognized face is the celebrity. 
        public let confidence: Float?
        /// The name of the celebrity.
        public let name: String?
        /// The unique identifier for the celebrity. 
        public let id: String?
        /// Face details for the recognized celebrity.
        public let face: FaceDetail?

        public init(urls: [String]? = nil, boundingBox: BoundingBox? = nil, confidence: Float? = nil, name: String? = nil, id: String? = nil, face: FaceDetail? = nil) {
            self.urls = urls
            self.boundingBox = boundingBox
            self.confidence = confidence
            self.name = name
            self.id = id
            self.face = face
        }

        private enum CodingKeys: String, CodingKey {
            case urls = "Urls"
            case boundingBox = "BoundingBox"
            case confidence = "Confidence"
            case name = "Name"
            case id = "Id"
            case face = "Face"
        }
    }

    public struct RecognizeCelebritiesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UnrecognizedFaces", required: false, type: .list), 
            AWSShapeMember(label: "OrientationCorrection", required: false, type: .enum), 
            AWSShapeMember(label: "CelebrityFaces", required: false, type: .list)
        ]
        /// Details about each unrecognized face in the image.
        public let unrecognizedFaces: [ComparedFace]?
        /// The orientation of the input image (counterclockwise direction). If your application displays the image, you can use this value to correct the orientation. The bounding box coordinates returned in CelebrityFaces and UnrecognizedFaces represent face locations before the image orientation is corrected.   If the input image is in .jpeg format, it might contain exchangeable image (Exif) metadata that includes the image's orientation. If so, and the Exif metadata for the input image populates the orientation field, the value of OrientationCorrection is null. The CelebrityFaces and UnrecognizedFaces bounding box coordinates represent face locations after Exif metadata is used to correct the image orientation. Images in .png format don't contain Exif metadata.  
        public let orientationCorrection: OrientationCorrection?
        /// Details about each celebrity found in the image. Amazon Rekognition can detect a maximum of 15 celebrities in an image.
        public let celebrityFaces: [Celebrity]?

        public init(unrecognizedFaces: [ComparedFace]? = nil, orientationCorrection: OrientationCorrection? = nil, celebrityFaces: [Celebrity]? = nil) {
            self.unrecognizedFaces = unrecognizedFaces
            self.orientationCorrection = orientationCorrection
            self.celebrityFaces = celebrityFaces
        }

        private enum CodingKeys: String, CodingKey {
            case unrecognizedFaces = "UnrecognizedFaces"
            case orientationCorrection = "OrientationCorrection"
            case celebrityFaces = "CelebrityFaces"
        }
    }

    public struct ListStreamProcessorsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// Maximum number of stream processors you want Amazon Rekognition Video to return in the response. The default is 1000. 
        public let maxResults: Int32?
        /// If the previous response was incomplete (because there are more stream processors to retrieve), Amazon Rekognition Video returns a pagination token in the response. You can use this pagination token to retrieve the next set of stream processors. 
        public let nextToken: String?

        public init(maxResults: Int32? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct PersonDetail: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Face", required: false, type: .structure), 
            AWSShapeMember(label: "BoundingBox", required: false, type: .structure), 
            AWSShapeMember(label: "Index", required: false, type: .long)
        ]
        /// Face details for the detected person.
        public let face: FaceDetail?
        /// Bounding box around the detected person.
        public let boundingBox: BoundingBox?
        /// Identifier for the person detected person within a video. Use to keep track of the person throughout the video. The identifier is not stored by Amazon Rekognition.
        public let index: Int64?

        public init(face: FaceDetail? = nil, boundingBox: BoundingBox? = nil, index: Int64? = nil) {
            self.face = face
            self.boundingBox = boundingBox
            self.index = index
        }

        private enum CodingKeys: String, CodingKey {
            case face = "Face"
            case boundingBox = "BoundingBox"
            case index = "Index"
        }
    }

    public struct Sunglasses: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Value", required: false, type: .boolean), 
            AWSShapeMember(label: "Confidence", required: false, type: .float)
        ]
        /// Boolean value that indicates whether the face is wearing sunglasses or not.
        public let value: Bool?
        /// Level of confidence in the determination.
        public let confidence: Float?

        public init(value: Bool? = nil, confidence: Float? = nil) {
            self.value = value
            self.confidence = confidence
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
            case confidence = "Confidence"
        }
    }

    public struct ListCollectionsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CollectionIds", required: false, type: .list), 
            AWSShapeMember(label: "FaceModelVersions", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// An array of collection IDs.
        public let collectionIds: [String]?
        /// Version numbers of the face detection models associated with the collections in the array CollectionIds. For example, the value of FaceModelVersions[2] is the version number for the face detection model used by the collection in CollectionId[2].
        public let faceModelVersions: [String]?
        /// If the result is truncated, the response provides a NextToken that you can use in the subsequent request to fetch the next set of collection IDs.
        public let nextToken: String?

        public init(collectionIds: [String]? = nil, faceModelVersions: [String]? = nil, nextToken: String? = nil) {
            self.collectionIds = collectionIds
            self.faceModelVersions = faceModelVersions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case collectionIds = "CollectionIds"
            case faceModelVersions = "FaceModelVersions"
            case nextToken = "NextToken"
        }
    }

    public struct GetCelebrityRecognitionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobStatus", required: false, type: .enum), 
            AWSShapeMember(label: "VideoMetadata", required: false, type: .structure), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "StatusMessage", required: false, type: .string), 
            AWSShapeMember(label: "Celebrities", required: false, type: .list)
        ]
        /// The current status of the celebrity recognition job.
        public let jobStatus: VideoJobStatus?
        /// Information about a video that Amazon Rekognition Video analyzed. Videometadata is returned in every page of paginated responses from a Amazon Rekognition Video operation.
        public let videoMetadata: VideoMetadata?
        /// If the response is truncated, Amazon Rekognition Video returns this token that you can use in the subsequent request to retrieve the next set of celebrities.
        public let nextToken: String?
        /// If the job fails, StatusMessage provides a descriptive error message.
        public let statusMessage: String?
        /// Array of celebrities recognized in the video.
        public let celebrities: [CelebrityRecognition]?

        public init(jobStatus: VideoJobStatus? = nil, videoMetadata: VideoMetadata? = nil, nextToken: String? = nil, statusMessage: String? = nil, celebrities: [CelebrityRecognition]? = nil) {
            self.jobStatus = jobStatus
            self.videoMetadata = videoMetadata
            self.nextToken = nextToken
            self.statusMessage = statusMessage
            self.celebrities = celebrities
        }

        private enum CodingKeys: String, CodingKey {
            case jobStatus = "JobStatus"
            case videoMetadata = "VideoMetadata"
            case nextToken = "NextToken"
            case statusMessage = "StatusMessage"
            case celebrities = "Celebrities"
        }
    }

    public struct KinesisDataStream: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", required: false, type: .string)
        ]
        /// ARN of the output Amazon Kinesis Data Streams stream.
        public let arn: String?

        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct SearchFacesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxFaces", required: false, type: .integer), 
            AWSShapeMember(label: "CollectionId", required: true, type: .string), 
            AWSShapeMember(label: "FaceMatchThreshold", required: false, type: .float), 
            AWSShapeMember(label: "FaceId", required: true, type: .string)
        ]
        /// Maximum number of faces to return. The operation returns the maximum number of faces with the highest confidence in the match.
        public let maxFaces: Int32?
        /// ID of the collection the face belongs to.
        public let collectionId: String
        /// Optional value specifying the minimum confidence in the face match to return. For example, don't return any matches where confidence in matches is less than 70%.
        public let faceMatchThreshold: Float?
        /// ID of a face to find matches for in the collection.
        public let faceId: String

        public init(maxFaces: Int32? = nil, collectionId: String, faceMatchThreshold: Float? = nil, faceId: String) {
            self.maxFaces = maxFaces
            self.collectionId = collectionId
            self.faceMatchThreshold = faceMatchThreshold
            self.faceId = faceId
        }

        private enum CodingKeys: String, CodingKey {
            case maxFaces = "MaxFaces"
            case collectionId = "CollectionId"
            case faceMatchThreshold = "FaceMatchThreshold"
            case faceId = "FaceId"
        }
    }

    public struct TextDetection: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Confidence", required: false, type: .float), 
            AWSShapeMember(label: "ParentId", required: false, type: .integer), 
            AWSShapeMember(label: "Geometry", required: false, type: .structure), 
            AWSShapeMember(label: "DetectedText", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .integer), 
            AWSShapeMember(label: "Type", required: false, type: .enum)
        ]
        /// The confidence that Amazon Rekognition has in the accuracy of the detected text and the accuracy of the geometry points around the detected text.
        public let confidence: Float?
        /// The Parent identifier for the detected text identified by the value of ID. If the type of detected text is LINE, the value of ParentId is Null. 
        public let parentId: Int32?
        /// The location of the detected text on the image. Includes an axis aligned coarse bounding box surrounding the text and a finer grain polygon for more accurate spatial information.
        public let geometry: Geometry?
        /// The word or line of text recognized by Amazon Rekognition. 
        public let detectedText: String?
        /// The identifier for the detected text. The identifier is only unique for a single call to DetectText. 
        public let id: Int32?
        /// The type of text that was detected.
        public let `type`: TextTypes?

        public init(confidence: Float? = nil, parentId: Int32? = nil, geometry: Geometry? = nil, detectedText: String? = nil, id: Int32? = nil, type: TextTypes? = nil) {
            self.confidence = confidence
            self.parentId = parentId
            self.geometry = geometry
            self.detectedText = detectedText
            self.id = id
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case parentId = "ParentId"
            case geometry = "Geometry"
            case detectedText = "DetectedText"
            case id = "Id"
            case `type` = "Type"
        }
    }

    public struct Eyeglasses: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Confidence", required: false, type: .float), 
            AWSShapeMember(label: "Value", required: false, type: .boolean)
        ]
        /// Level of confidence in the determination.
        public let confidence: Float?
        /// Boolean value that indicates whether the face is wearing eye glasses or not.
        public let value: Bool?

        public init(confidence: Float? = nil, value: Bool? = nil) {
            self.confidence = confidence
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case value = "Value"
        }
    }

    public struct ImageQuality: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Sharpness", required: false, type: .float), 
            AWSShapeMember(label: "Brightness", required: false, type: .float)
        ]
        /// Value representing sharpness of the face. The service returns a value between 0 and 100 (inclusive). A higher value indicates a sharper face image.
        public let sharpness: Float?
        /// Value representing brightness of the face. The service returns a value between 0 and 100 (inclusive). A higher value indicates a brighter face image.
        public let brightness: Float?

        public init(sharpness: Float? = nil, brightness: Float? = nil) {
            self.sharpness = sharpness
            self.brightness = brightness
        }

        private enum CodingKeys: String, CodingKey {
            case sharpness = "Sharpness"
            case brightness = "Brightness"
        }
    }

    public struct Label: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Instances", required: false, type: .list), 
            AWSShapeMember(label: "Parents", required: false, type: .list), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Confidence", required: false, type: .float)
        ]
        /// If Label represents an object, Instances contains the bounding boxes for each instance of the detected object. Bounding boxes are returned for common object labels such as people, cars, furniture, apparel or pets.  Amazon Rekognition Video does not support bounding box information for detected labels. The value of Instances is returned as null by GetLabelDetection. 
        public let instances: [Instance]?
        /// The parent labels for a label. The response includes all ancestor labels.  Amazon Rekognition Video does not support a hierarchical taxonomy of detected labels. The value of Parents is returned as null by GetLabelDetection. 
        public let parents: [Parent]?
        /// The name (label) of the object or scene.
        public let name: String?
        /// Level of confidence.
        public let confidence: Float?

        public init(instances: [Instance]? = nil, parents: [Parent]? = nil, name: String? = nil, confidence: Float? = nil) {
            self.instances = instances
            self.parents = parents
            self.name = name
            self.confidence = confidence
        }

        private enum CodingKeys: String, CodingKey {
            case instances = "Instances"
            case parents = "Parents"
            case name = "Name"
            case confidence = "Confidence"
        }
    }

    public enum Reason: String, CustomStringConvertible, Codable {
        case exceedsMaxFaces = "EXCEEDS_MAX_FACES"
        case extremePose = "EXTREME_POSE"
        case lowBrightness = "LOW_BRIGHTNESS"
        case lowSharpness = "LOW_SHARPNESS"
        case lowConfidence = "LOW_CONFIDENCE"
        case smallBoundingBox = "SMALL_BOUNDING_BOX"
        public var description: String { return self.rawValue }
    }

    public struct GetPersonTrackingRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SortBy", required: false, type: .enum), 
            AWSShapeMember(label: "JobId", required: true, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// Sort to use for elements in the Persons array. Use TIMESTAMP to sort array elements by the time persons are detected. Use INDEX to sort by the tracked persons. If you sort by INDEX, the array elements for each person are sorted by detection confidence. The default sort is by TIMESTAMP.
        public let sortBy: PersonTrackingSortBy?
        /// The identifier for a job that tracks persons in a video. You get the JobId from a call to StartPersonTracking. 
        public let jobId: String
        /// Maximum number of results to return per paginated call. The largest value you can specify is 1000. If you specify a value greater than 1000, a maximum of 1000 results is returned. The default value is 1000.
        public let maxResults: Int32?
        /// If the previous response was incomplete (because there are more persons to retrieve), Amazon Rekognition Video returns a pagination token in the response. You can use this pagination token to retrieve the next set of persons. 
        public let nextToken: String?

        public init(sortBy: PersonTrackingSortBy? = nil, jobId: String, maxResults: Int32? = nil, nextToken: String? = nil) {
            self.sortBy = sortBy
            self.jobId = jobId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case sortBy = "SortBy"
            case jobId = "JobId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct Face: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Confidence", required: false, type: .float), 
            AWSShapeMember(label: "BoundingBox", required: false, type: .structure), 
            AWSShapeMember(label: "ImageId", required: false, type: .string), 
            AWSShapeMember(label: "ExternalImageId", required: false, type: .string), 
            AWSShapeMember(label: "FaceId", required: false, type: .string)
        ]
        /// Confidence level that the bounding box contains a face (and not a different object such as a tree).
        public let confidence: Float?
        /// Bounding box of the face.
        public let boundingBox: BoundingBox?
        /// Unique identifier that Amazon Rekognition assigns to the input image.
        public let imageId: String?
        /// Identifier that you assign to all the faces in the input image.
        public let externalImageId: String?
        /// Unique identifier that Amazon Rekognition assigns to the face.
        public let faceId: String?

        public init(confidence: Float? = nil, boundingBox: BoundingBox? = nil, imageId: String? = nil, externalImageId: String? = nil, faceId: String? = nil) {
            self.confidence = confidence
            self.boundingBox = boundingBox
            self.imageId = imageId
            self.externalImageId = externalImageId
            self.faceId = faceId
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case boundingBox = "BoundingBox"
            case imageId = "ImageId"
            case externalImageId = "ExternalImageId"
            case faceId = "FaceId"
        }
    }

    public struct Instance: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BoundingBox", required: false, type: .structure), 
            AWSShapeMember(label: "Confidence", required: false, type: .float)
        ]
        /// The position of the label instance on the image.
        public let boundingBox: BoundingBox?
        /// The confidence that Amazon Rekognition Image has in the accuracy of the bounding box.
        public let confidence: Float?

        public init(boundingBox: BoundingBox? = nil, confidence: Float? = nil) {
            self.boundingBox = boundingBox
            self.confidence = confidence
        }

        private enum CodingKeys: String, CodingKey {
            case boundingBox = "BoundingBox"
            case confidence = "Confidence"
        }
    }

    public struct SearchFacesByImageResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SearchedFaceConfidence", required: false, type: .float), 
            AWSShapeMember(label: "FaceModelVersion", required: false, type: .string), 
            AWSShapeMember(label: "FaceMatches", required: false, type: .list), 
            AWSShapeMember(label: "SearchedFaceBoundingBox", required: false, type: .structure)
        ]
        /// The level of confidence that the searchedFaceBoundingBox, contains a face.
        public let searchedFaceConfidence: Float?
        /// Version number of the face detection model associated with the input collection (CollectionId).
        public let faceModelVersion: String?
        /// An array of faces that match the input face, along with the confidence in the match.
        public let faceMatches: [FaceMatch]?
        /// The bounding box around the face in the input image that Amazon Rekognition used for the search.
        public let searchedFaceBoundingBox: BoundingBox?

        public init(searchedFaceConfidence: Float? = nil, faceModelVersion: String? = nil, faceMatches: [FaceMatch]? = nil, searchedFaceBoundingBox: BoundingBox? = nil) {
            self.searchedFaceConfidence = searchedFaceConfidence
            self.faceModelVersion = faceModelVersion
            self.faceMatches = faceMatches
            self.searchedFaceBoundingBox = searchedFaceBoundingBox
        }

        private enum CodingKeys: String, CodingKey {
            case searchedFaceConfidence = "SearchedFaceConfidence"
            case faceModelVersion = "FaceModelVersion"
            case faceMatches = "FaceMatches"
            case searchedFaceBoundingBox = "SearchedFaceBoundingBox"
        }
    }

    public struct StartFaceSearchRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Video", required: true, type: .structure), 
            AWSShapeMember(label: "JobTag", required: false, type: .string), 
            AWSShapeMember(label: "CollectionId", required: true, type: .string), 
            AWSShapeMember(label: "ClientRequestToken", required: false, type: .string), 
            AWSShapeMember(label: "FaceMatchThreshold", required: false, type: .float), 
            AWSShapeMember(label: "NotificationChannel", required: false, type: .structure)
        ]
        /// The video you want to search. The video must be stored in an Amazon S3 bucket. 
        public let video: Video
        /// Unique identifier you specify to identify the job in the completion status published to the Amazon Simple Notification Service topic. 
        public let jobTag: String?
        /// ID of the collection that contains the faces you want to search for.
        public let collectionId: String
        /// Idempotent token used to identify the start request. If you use the same token with multiple StartFaceSearch requests, the same JobId is returned. Use ClientRequestToken to prevent the same job from being accidently started more than once. 
        public let clientRequestToken: String?
        /// The minimum confidence in the person match to return. For example, don't return any matches where confidence in matches is less than 70%. 
        public let faceMatchThreshold: Float?
        /// The ARN of the Amazon SNS topic to which you want Amazon Rekognition Video to publish the completion status of the search. 
        public let notificationChannel: NotificationChannel?

        public init(video: Video, jobTag: String? = nil, collectionId: String, clientRequestToken: String? = nil, faceMatchThreshold: Float? = nil, notificationChannel: NotificationChannel? = nil) {
            self.video = video
            self.jobTag = jobTag
            self.collectionId = collectionId
            self.clientRequestToken = clientRequestToken
            self.faceMatchThreshold = faceMatchThreshold
            self.notificationChannel = notificationChannel
        }

        private enum CodingKeys: String, CodingKey {
            case video = "Video"
            case jobTag = "JobTag"
            case collectionId = "CollectionId"
            case clientRequestToken = "ClientRequestToken"
            case faceMatchThreshold = "FaceMatchThreshold"
            case notificationChannel = "NotificationChannel"
        }
    }

    public struct BoundingBox: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Top", required: false, type: .float), 
            AWSShapeMember(label: "Width", required: false, type: .float), 
            AWSShapeMember(label: "Height", required: false, type: .float), 
            AWSShapeMember(label: "Left", required: false, type: .float)
        ]
        /// Top coordinate of the bounding box as a ratio of overall image height.
        public let top: Float?
        /// Width of the bounding box as a ratio of the overall image width.
        public let width: Float?
        /// Height of the bounding box as a ratio of the overall image height.
        public let height: Float?
        /// Left coordinate of the bounding box as a ratio of overall image width.
        public let left: Float?

        public init(top: Float? = nil, width: Float? = nil, height: Float? = nil, left: Float? = nil) {
            self.top = top
            self.width = width
            self.height = height
            self.left = left
        }

        private enum CodingKeys: String, CodingKey {
            case top = "Top"
            case width = "Width"
            case height = "Height"
            case left = "Left"
        }
    }

    public enum Attribute: String, CustomStringConvertible, Codable {
        case `default` = "DEFAULT"
        case all = "ALL"
        public var description: String { return self.rawValue }
    }

    public struct StreamProcessor: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Status", required: false, type: .enum), 
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]
        /// Current status of the Amazon Rekognition stream processor.
        public let status: StreamProcessorStatus?
        /// Name of the Amazon Rekognition stream processor. 
        public let name: String?

        public init(status: StreamProcessorStatus? = nil, name: String? = nil) {
            self.status = status
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
            case name = "Name"
        }
    }

    public struct KinesisVideoStream: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", required: false, type: .string)
        ]
        /// ARN of the Kinesis video stream stream that streams the source video.
        public let arn: String?

        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct ContentModerationDetection: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ModerationLabel", required: false, type: .structure), 
            AWSShapeMember(label: "Timestamp", required: false, type: .long)
        ]
        /// The moderation label detected by in the stored video.
        public let moderationLabel: ModerationLabel?
        /// Time, in milliseconds from the beginning of the video, that the moderation label was detected.
        public let timestamp: Int64?

        public init(moderationLabel: ModerationLabel? = nil, timestamp: Int64? = nil) {
            self.moderationLabel = moderationLabel
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case moderationLabel = "ModerationLabel"
            case timestamp = "Timestamp"
        }
    }

    public enum LabelDetectionSortBy: String, CustomStringConvertible, Codable {
        case name = "NAME"
        case timestamp = "TIMESTAMP"
        public var description: String { return self.rawValue }
    }

    public struct Point: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "X", required: false, type: .float), 
            AWSShapeMember(label: "Y", required: false, type: .float)
        ]
        /// The value of the X coordinate for a point on a Polygon.
        public let x: Float?
        /// The value of the Y coordinate for a point on a Polygon.
        public let y: Float?

        public init(x: Float? = nil, y: Float? = nil) {
            self.x = x
            self.y = y
        }

        private enum CodingKeys: String, CodingKey {
            case x = "X"
            case y = "Y"
        }
    }

    public struct S3Object: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .string), 
            AWSShapeMember(label: "Bucket", required: false, type: .string)
        ]
        /// S3 object key name.
        public let name: String?
        /// If the bucket is versioning enabled, you can specify the object version. 
        public let version: String?
        /// Name of the S3 bucket.
        public let bucket: String?

        public init(name: String? = nil, version: String? = nil, bucket: String? = nil) {
            self.name = name
            self.version = version
            self.bucket = bucket
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case version = "Version"
            case bucket = "Bucket"
        }
    }

    public struct DescribeCollectionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CollectionId", required: true, type: .string)
        ]
        /// The ID of the collection to describe.
        public let collectionId: String

        public init(collectionId: String) {
            self.collectionId = collectionId
        }

        private enum CodingKeys: String, CodingKey {
            case collectionId = "CollectionId"
        }
    }

    public struct StreamProcessorSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FaceSearch", required: false, type: .structure)
        ]
        /// Face search settings to use on a streaming video. 
        public let faceSearch: FaceSearchSettings?

        public init(faceSearch: FaceSearchSettings? = nil) {
            self.faceSearch = faceSearch
        }

        private enum CodingKeys: String, CodingKey {
            case faceSearch = "FaceSearch"
        }
    }

    public struct Parent: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]
        /// The name of the parent label.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public enum QualityFilter: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case auto = "AUTO"
        public var description: String { return self.rawValue }
    }

    public struct ComparedFace: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Landmarks", required: false, type: .list), 
            AWSShapeMember(label: "Quality", required: false, type: .structure), 
            AWSShapeMember(label: "Confidence", required: false, type: .float), 
            AWSShapeMember(label: "Pose", required: false, type: .structure), 
            AWSShapeMember(label: "BoundingBox", required: false, type: .structure)
        ]
        /// An array of facial landmarks.
        public let landmarks: [Landmark]?
        /// Identifies face image brightness and sharpness. 
        public let quality: ImageQuality?
        /// Level of confidence that what the bounding box contains is a face.
        public let confidence: Float?
        /// Indicates the pose of the face as determined by its pitch, roll, and yaw.
        public let pose: Pose?
        /// Bounding box of the face.
        public let boundingBox: BoundingBox?

        public init(landmarks: [Landmark]? = nil, quality: ImageQuality? = nil, confidence: Float? = nil, pose: Pose? = nil, boundingBox: BoundingBox? = nil) {
            self.landmarks = landmarks
            self.quality = quality
            self.confidence = confidence
            self.pose = pose
            self.boundingBox = boundingBox
        }

        private enum CodingKeys: String, CodingKey {
            case landmarks = "Landmarks"
            case quality = "Quality"
            case confidence = "Confidence"
            case pose = "Pose"
            case boundingBox = "BoundingBox"
        }
    }

    public struct LabelDetection: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Label", required: false, type: .structure), 
            AWSShapeMember(label: "Timestamp", required: false, type: .long)
        ]
        /// Details about the detected label.
        public let label: Label?
        /// Time, in milliseconds from the start of the video, that the label was detected.
        public let timestamp: Int64?

        public init(label: Label? = nil, timestamp: Int64? = nil) {
            self.label = label
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case label = "Label"
            case timestamp = "Timestamp"
        }
    }

    public struct DetectFacesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Attributes", required: false, type: .list), 
            AWSShapeMember(label: "Image", required: true, type: .structure)
        ]
        /// An array of facial attributes you want to be returned. This can be the default list of attributes or all attributes. If you don't specify a value for Attributes or if you specify ["DEFAULT"], the API returns the following subset of facial attributes: BoundingBox, Confidence, Pose, Quality, and Landmarks. If you provide ["ALL"], all facial attributes are returned, but the operation takes longer to complete. If you provide both, ["ALL", "DEFAULT"], the service uses a logical AND operator to determine which attributes to return (in this case, all attributes). 
        public let attributes: [Attribute]?
        /// The input image as base64-encoded bytes or an S3 object. If you use the AWS CLI to call Amazon Rekognition operations, passing base64-encoded image bytes is not supported. 
        public let image: Image

        public init(attributes: [Attribute]? = nil, image: Image) {
            self.attributes = attributes
            self.image = image
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case image = "Image"
        }
    }

}