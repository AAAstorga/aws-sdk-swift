// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Appstream {

    public struct DescribeSessionsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        /// The list of streaming sessions.
        public let sessions: [Session]?

        public init(nextToken: String? = nil, sessions: [Session]? = nil) {
            self.nextToken = nextToken
            self.sessions = sessions
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let sessions = dictionary["Sessions"] as? [[String: Any]] {
                self.sessions = try sessions.map({ try Session(dictionary: $0) })
            } else { 
                self.sessions = nil
            }
        }
    }

    public struct ListAssociatedFleetsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the stack whose associated fleets are listed.
        public let stackName: String
        /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?

        public init(stackName: String, nextToken: String? = nil) {
            self.stackName = stackName
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            guard let stackName = dictionary["StackName"] as? String else { throw InitializableError.missingRequiredParam("StackName") }
            self.stackName = stackName
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct DescribeStacksResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The list of stack details.
        public let stacks: [Stack]?
        /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?

        public init(stacks: [Stack]? = nil, nextToken: String? = nil) {
            self.stacks = stacks
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let stacks = dictionary["Stacks"] as? [[String: Any]] {
                self.stacks = try stacks.map({ try Stack(dictionary: $0) })
            } else { 
                self.stacks = nil
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct DeleteStackResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ComputeCapacity: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The desired number of streaming instances.
        public let desiredInstances: Int32

        public init(desiredInstances: Int32) {
            self.desiredInstances = desiredInstances
        }

        public init(dictionary: [String: Any]) throws {
            guard let desiredInstances = dictionary["DesiredInstances"] as? Int32 else { throw InitializableError.missingRequiredParam("DesiredInstances") }
            self.desiredInstances = desiredInstances
        }
    }

    public struct DescribeImagesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A specific list of images to describe.
        public let names: [String]?

        public init(names: [String]? = nil) {
            self.names = names
        }

        public init(dictionary: [String: Any]) throws {
            self.names = dictionary["Names"] as? [String]
        }
    }

    public struct DescribeImagesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The list of images.
        public let images: [Image]?

        public init(images: [Image]? = nil) {
            self.images = images
        }

        public init(dictionary: [String: Any]) throws {
            if let images = dictionary["Images"] as? [[String: Any]] {
                self.images = try images.map({ try Image(dictionary: $0) })
            } else { 
                self.images = nil
            }
        }
    }

    public struct DescribeSessionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The user for whom to list sessions. Use null to describe all the sessions for the stack and fleet.
        public let userId: String?
        /// The size of each page of results. The default value is 20 and the maximum supported value is 50.
        public let limit: Int32?
        /// The name of the stack for which to list sessions.
        public let stackName: String
        /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?
        /// The name of the fleet for which to list sessions.
        public let fleetName: String

        public init(userId: String? = nil, limit: Int32? = nil, stackName: String, nextToken: String? = nil, fleetName: String) {
            self.userId = userId
            self.limit = limit
            self.stackName = stackName
            self.nextToken = nextToken
            self.fleetName = fleetName
        }

        public init(dictionary: [String: Any]) throws {
            self.userId = dictionary["UserId"] as? String
            self.limit = dictionary["Limit"] as? Int32
            guard let stackName = dictionary["StackName"] as? String else { throw InitializableError.missingRequiredParam("StackName") }
            self.stackName = stackName
            self.nextToken = dictionary["NextToken"] as? String
            guard let fleetName = dictionary["FleetName"] as? String else { throw InitializableError.missingRequiredParam("FleetName") }
            self.fleetName = fleetName
        }
    }

    public struct Session: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The identifier of the user for whom the session was created.
        public let userId: String
        /// The name of the stack for which the streaming session was created.
        public let stackName: String
        /// The current state of the streaming session.
        public let state: SessionState
        /// The name of the fleet for which the streaming session was created.
        public let fleetName: String
        /// The unique ID for a streaming session.
        public let id: String

        public init(userId: String, stackName: String, state: SessionState, fleetName: String, id: String) {
            self.userId = userId
            self.stackName = stackName
            self.state = state
            self.fleetName = fleetName
            self.id = id
        }

        public init(dictionary: [String: Any]) throws {
            guard let userId = dictionary["UserId"] as? String else { throw InitializableError.missingRequiredParam("UserId") }
            self.userId = userId
            guard let stackName = dictionary["StackName"] as? String else { throw InitializableError.missingRequiredParam("StackName") }
            self.stackName = stackName
            guard let rawState = dictionary["State"] as? String, let state = SessionState(rawValue: rawState) else { throw InitializableError.missingRequiredParam("State") }
            self.state = state
            guard let fleetName = dictionary["FleetName"] as? String else { throw InitializableError.missingRequiredParam("FleetName") }
            self.fleetName = fleetName
            guard let id = dictionary["Id"] as? String else { throw InitializableError.missingRequiredParam("Id") }
            self.id = id
        }
    }

    public struct ListAssociatedFleetsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        /// The names of associated fleets.
        public let names: [String]?

        public init(nextToken: String? = nil, names: [String]? = nil) {
            self.nextToken = nextToken
            self.names = names
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            self.names = dictionary["Names"] as? [String]
        }
    }

    public enum FleetState: String, CustomStringConvertible {
        case starting = "STARTING"
        case running = "RUNNING"
        case stopping = "STOPPING"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public struct DescribeFleetsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?
        /// The fleet names to describe. Use null to describe all the fleets for the AWS account.
        public let names: [String]?

        public init(nextToken: String? = nil, names: [String]? = nil) {
            self.nextToken = nextToken
            self.names = names
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            self.names = dictionary["Names"] as? [String]
        }
    }

    public enum PlatformType: String, CustomStringConvertible {
        case windows = "WINDOWS"
        public var description: String { return self.rawValue }
    }

    public struct FleetError: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The error message generated when the fleet has errors.
        public let errorMessage: String?
        /// The error code for the fleet error.
        public let errorCode: FleetErrorCode?

        public init(errorMessage: String? = nil, errorCode: FleetErrorCode? = nil) {
            self.errorMessage = errorMessage
            self.errorCode = errorCode
        }

        public init(dictionary: [String: Any]) throws {
            self.errorMessage = dictionary["ErrorMessage"] as? String
            if let errorCode = dictionary["ErrorCode"] as? String { self.errorCode = FleetErrorCode(rawValue: errorCode) } else { self.errorCode = nil }
        }
    }

    public struct ListAssociatedStacksResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        /// The names of associated stacks.
        public let names: [String]?

        public init(nextToken: String? = nil, names: [String]? = nil) {
            self.nextToken = nextToken
            self.names = names
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            self.names = dictionary["Names"] as? [String]
        }
    }

    public struct UpdateFleetResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of fleet details.
        public let fleet: Fleet?

        public init(fleet: Fleet? = nil) {
            self.fleet = fleet
        }

        public init(dictionary: [String: Any]) throws {
            if let fleet = dictionary["Fleet"] as? [String: Any] { self.fleet = try Appstream.Fleet(dictionary: fleet) } else { self.fleet = nil }
        }
    }

    public struct ExpireSessionResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct DisassociateFleetResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct DeleteFleetResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct CreateFleetRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The parameters for the capacity allocated to the fleet.
        public let computeCapacity: ComputeCapacity
        /// The VPC configuration for the fleet.
        public let vpcConfig: VpcConfig?
        /// A unique identifier for the fleet.
        public let name: String
        /// The display name of the fleet.
        public let displayName: String?
        /// Unique name of the image used by the fleet.
        public let imageName: String
        /// The time after disconnection when a session is considered to have ended. If a user who got disconnected reconnects within this timeout interval, the user is connected back to his/her previous session. 
        public let disconnectTimeoutInSeconds: Int32?
        /// The maximum time up to which a streaming session can run.
        public let maxUserDurationInSeconds: Int32?
        /// The instance type of compute resources for the fleet. Fleet instances are launched from this instance type.
        public let instanceType: String
        /// The description of the fleet.
        public let description: String?

        public init(computeCapacity: ComputeCapacity, vpcConfig: VpcConfig? = nil, name: String, displayName: String? = nil, imageName: String, disconnectTimeoutInSeconds: Int32? = nil, maxUserDurationInSeconds: Int32? = nil, instanceType: String, description: String? = nil) {
            self.computeCapacity = computeCapacity
            self.vpcConfig = vpcConfig
            self.name = name
            self.displayName = displayName
            self.imageName = imageName
            self.disconnectTimeoutInSeconds = disconnectTimeoutInSeconds
            self.maxUserDurationInSeconds = maxUserDurationInSeconds
            self.instanceType = instanceType
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            guard let computeCapacity = dictionary["ComputeCapacity"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ComputeCapacity") }
            self.computeCapacity = try Appstream.ComputeCapacity(dictionary: computeCapacity)
            if let vpcConfig = dictionary["VpcConfig"] as? [String: Any] { self.vpcConfig = try Appstream.VpcConfig(dictionary: vpcConfig) } else { self.vpcConfig = nil }
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            self.displayName = dictionary["DisplayName"] as? String
            guard let imageName = dictionary["ImageName"] as? String else { throw InitializableError.missingRequiredParam("ImageName") }
            self.imageName = imageName
            self.disconnectTimeoutInSeconds = dictionary["DisconnectTimeoutInSeconds"] as? Int32
            self.maxUserDurationInSeconds = dictionary["MaxUserDurationInSeconds"] as? Int32
            guard let instanceType = dictionary["InstanceType"] as? String else { throw InitializableError.missingRequiredParam("InstanceType") }
            self.instanceType = instanceType
            self.description = dictionary["Description"] as? String
        }
    }

    public struct Stack: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A meaningful description for the stack.
        public let description: String?
        /// The ARN of the stack.
        public let arn: String?
        /// The unique identifier of the stack.
        public let name: String
        /// The timestamp when the stack was created.
        public let createdTime: Date?
        /// A display name for the stack.
        public let displayName: String?

        public init(description: String? = nil, arn: String? = nil, name: String, createdTime: Date? = nil, displayName: String? = nil) {
            self.description = description
            self.arn = arn
            self.name = name
            self.createdTime = createdTime
            self.displayName = displayName
        }

        public init(dictionary: [String: Any]) throws {
            self.description = dictionary["Description"] as? String
            self.arn = dictionary["Arn"] as? String
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            self.createdTime = dictionary["CreatedTime"] as? Date
            self.displayName = dictionary["DisplayName"] as? String
        }
    }

    public struct UpdateStackResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of stack details.
        public let stack: Stack?

        public init(stack: Stack? = nil) {
            self.stack = stack
        }

        public init(dictionary: [String: Any]) throws {
            if let stack = dictionary["Stack"] as? [String: Any] { self.stack = try Appstream.Stack(dictionary: stack) } else { self.stack = nil }
        }
    }

    public struct UpdateFleetRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Delete the VPC association for the specified fleet.
        public let deleteVpcConfig: Bool?
        /// The parameters for the capacity allocated to the fleet. 
        public let computeCapacity: ComputeCapacity?
        /// The VPC configuration for the fleet.
        public let vpcConfig: VpcConfig?
        /// The name of the fleet.
        public let name: String
        /// The name displayed to end users on the AppStream 2.0 portal.
        public let displayName: String?
        /// The image name from which a fleet is created.
        public let imageName: String?
        /// The time after disconnection when a session is considered to have ended. When the user reconnects after a disconnection, the user is connected to the same instance within this time interval.
        public let disconnectTimeoutInSeconds: Int32?
        /// The maximum time during which a streaming session can run.
        public let maxUserDurationInSeconds: Int32?
        /// The instance type of compute resources for the fleet. Fleet instances are launched from this instance type.
        public let instanceType: String?
        /// The description displayed to end users on the AppStream 2.0 portal.
        public let description: String?

        public init(deleteVpcConfig: Bool? = nil, computeCapacity: ComputeCapacity? = nil, vpcConfig: VpcConfig? = nil, name: String, displayName: String? = nil, imageName: String? = nil, disconnectTimeoutInSeconds: Int32? = nil, maxUserDurationInSeconds: Int32? = nil, instanceType: String? = nil, description: String? = nil) {
            self.deleteVpcConfig = deleteVpcConfig
            self.computeCapacity = computeCapacity
            self.vpcConfig = vpcConfig
            self.name = name
            self.displayName = displayName
            self.imageName = imageName
            self.disconnectTimeoutInSeconds = disconnectTimeoutInSeconds
            self.maxUserDurationInSeconds = maxUserDurationInSeconds
            self.instanceType = instanceType
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.deleteVpcConfig = dictionary["DeleteVpcConfig"] as? Bool
            if let computeCapacity = dictionary["ComputeCapacity"] as? [String: Any] { self.computeCapacity = try Appstream.ComputeCapacity(dictionary: computeCapacity) } else { self.computeCapacity = nil }
            if let vpcConfig = dictionary["VpcConfig"] as? [String: Any] { self.vpcConfig = try Appstream.VpcConfig(dictionary: vpcConfig) } else { self.vpcConfig = nil }
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            self.displayName = dictionary["DisplayName"] as? String
            self.imageName = dictionary["ImageName"] as? String
            self.disconnectTimeoutInSeconds = dictionary["DisconnectTimeoutInSeconds"] as? Int32
            self.maxUserDurationInSeconds = dictionary["MaxUserDurationInSeconds"] as? Int32
            self.instanceType = dictionary["InstanceType"] as? String
            self.description = dictionary["Description"] as? String
        }
    }

    public struct DisassociateFleetRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the stack with which the fleet is associated.
        public let stackName: String
        /// The name of the fleet to disassociate.
        public let fleetName: String

        public init(stackName: String, fleetName: String) {
            self.stackName = stackName
            self.fleetName = fleetName
        }

        public init(dictionary: [String: Any]) throws {
            guard let stackName = dictionary["StackName"] as? String else { throw InitializableError.missingRequiredParam("StackName") }
            self.stackName = stackName
            guard let fleetName = dictionary["FleetName"] as? String else { throw InitializableError.missingRequiredParam("FleetName") }
            self.fleetName = fleetName
        }
    }

    public struct Application: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Additional attributes that describes the application.
        public let metadata: [String: String]?
        /// The unique identifier for the application.
        public let name: String?
        /// The name of the application shown to the end users.
        public let displayName: String?
        /// An application can be disabled after image creation if there is a problem.
        public let enabled: Bool?
        /// The path to the application executable in the instance.
        public let launchPath: String?
        /// A list of arguments that are passed to the application at launch.
        public let launchParameters: String?
        /// The URL for the application icon. This URL may be time-limited.
        public let iconURL: String?

        public init(metadata: [String: String]? = nil, name: String? = nil, displayName: String? = nil, enabled: Bool? = nil, launchPath: String? = nil, launchParameters: String? = nil, iconURL: String? = nil) {
            self.metadata = metadata
            self.name = name
            self.displayName = displayName
            self.enabled = enabled
            self.launchPath = launchPath
            self.launchParameters = launchParameters
            self.iconURL = iconURL
        }

        public init(dictionary: [String: Any]) throws {
            if let metadata = dictionary["Metadata"] as? [String: String] {
                self.metadata = metadata
            } else { 
                self.metadata = nil
            }
            self.name = dictionary["Name"] as? String
            self.displayName = dictionary["DisplayName"] as? String
            self.enabled = dictionary["Enabled"] as? Bool
            self.launchPath = dictionary["LaunchPath"] as? String
            self.launchParameters = dictionary["LaunchParameters"] as? String
            self.iconURL = dictionary["IconURL"] as? String
        }
    }

    public struct Fleet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN for the fleet.
        public let arn: String
        /// The VPC configuration for the fleet.
        public let vpcConfig: VpcConfig?
        /// The current state for the fleet.
        public let state: FleetState
        /// The capacity information for the fleet.
        public let computeCapacityStatus: ComputeCapacityStatus
        /// The name displayed to end users on the AppStream 2.0 portal.
        public let displayName: String?
        /// The list of fleet errors is appended to this list.
        public let fleetErrors: [FleetError]?
        /// The image used by the fleet.
        public let imageName: String
        /// The instance type of compute resources for the fleet. The fleet instances are launched from this instance type. 
        public let instanceType: String
        /// The time at which the fleet was created.
        public let createdTime: Date?
        /// The description displayed to end users on the AppStream 2.0 portal.
        public let description: String?
        /// The name of the fleet.
        public let name: String
        /// The time after disconnection when a session is considered to have ended. When a user reconnects after a disconnection, the user is connected to the same session and instance within this time interval.
        public let disconnectTimeoutInSeconds: Int32?
        /// The maximum time during which a streaming session can run.
        public let maxUserDurationInSeconds: Int32?

        public init(arn: String, vpcConfig: VpcConfig? = nil, state: FleetState, computeCapacityStatus: ComputeCapacityStatus, displayName: String? = nil, fleetErrors: [FleetError]? = nil, imageName: String, instanceType: String, createdTime: Date? = nil, description: String? = nil, name: String, disconnectTimeoutInSeconds: Int32? = nil, maxUserDurationInSeconds: Int32? = nil) {
            self.arn = arn
            self.vpcConfig = vpcConfig
            self.state = state
            self.computeCapacityStatus = computeCapacityStatus
            self.displayName = displayName
            self.fleetErrors = fleetErrors
            self.imageName = imageName
            self.instanceType = instanceType
            self.createdTime = createdTime
            self.description = description
            self.name = name
            self.disconnectTimeoutInSeconds = disconnectTimeoutInSeconds
            self.maxUserDurationInSeconds = maxUserDurationInSeconds
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["Arn"] as? String else { throw InitializableError.missingRequiredParam("Arn") }
            self.arn = arn
            if let vpcConfig = dictionary["VpcConfig"] as? [String: Any] { self.vpcConfig = try Appstream.VpcConfig(dictionary: vpcConfig) } else { self.vpcConfig = nil }
            guard let rawState = dictionary["State"] as? String, let state = FleetState(rawValue: rawState) else { throw InitializableError.missingRequiredParam("State") }
            self.state = state
            guard let computeCapacityStatus = dictionary["ComputeCapacityStatus"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ComputeCapacityStatus") }
            self.computeCapacityStatus = try Appstream.ComputeCapacityStatus(dictionary: computeCapacityStatus)
            self.displayName = dictionary["DisplayName"] as? String
            if let fleetErrors = dictionary["FleetErrors"] as? [[String: Any]] {
                self.fleetErrors = try fleetErrors.map({ try FleetError(dictionary: $0) })
            } else { 
                self.fleetErrors = nil
            }
            guard let imageName = dictionary["ImageName"] as? String else { throw InitializableError.missingRequiredParam("ImageName") }
            self.imageName = imageName
            guard let instanceType = dictionary["InstanceType"] as? String else { throw InitializableError.missingRequiredParam("InstanceType") }
            self.instanceType = instanceType
            self.createdTime = dictionary["CreatedTime"] as? Date
            self.description = dictionary["Description"] as? String
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            self.disconnectTimeoutInSeconds = dictionary["DisconnectTimeoutInSeconds"] as? Int32
            self.maxUserDurationInSeconds = dictionary["MaxUserDurationInSeconds"] as? Int32
        }
    }

    public struct StartFleetRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the fleet to start.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
        }
    }

    public struct StartFleetResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct VpcConfig: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The list of subnets to which a network interface is established from the fleet instance.
        public let subnetIds: [String]

        public init(subnetIds: [String]) {
            self.subnetIds = subnetIds
        }

        public init(dictionary: [String: Any]) throws {
            guard let subnetIds = dictionary["SubnetIds"] as? [String] else { throw InitializableError.missingRequiredParam("SubnetIds") }
            self.subnetIds = subnetIds
        }
    }

    public struct DescribeStacksRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?
        /// The stack names to describe. Use null to describe all the stacks for the AWS account.
        public let names: [String]?

        public init(nextToken: String? = nil, names: [String]? = nil) {
            self.nextToken = nextToken
            self.names = names
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            self.names = dictionary["Names"] as? [String]
        }
    }

    public struct ImageStateChangeReason: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The state change reason code of the image.
        public let code: ImageStateChangeReasonCode?
        /// The state change reason message to the end user.
        public let message: String?

        public init(code: ImageStateChangeReasonCode? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        public init(dictionary: [String: Any]) throws {
            if let code = dictionary["Code"] as? String { self.code = ImageStateChangeReasonCode(rawValue: code) } else { self.code = nil }
            self.message = dictionary["Message"] as? String
        }
    }

    public enum VisibilityType: String, CustomStringConvertible {
        case `public` = "PUBLIC"
        case `private` = "PRIVATE"
        public var description: String { return self.rawValue }
    }

    public struct ListAssociatedStacksRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?
        /// The name of the fleet whose associated stacks are listed.
        public let fleetName: String

        public init(nextToken: String? = nil, fleetName: String) {
            self.nextToken = nextToken
            self.fleetName = fleetName
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            guard let fleetName = dictionary["FleetName"] as? String else { throw InitializableError.missingRequiredParam("FleetName") }
            self.fleetName = fleetName
        }
    }

    public struct CreateStackRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The unique identifier for this stack.
        public let name: String
        /// The name displayed to end users on the AppStream 2.0 portal.
        public let displayName: String?
        /// The description displayed to end users on the AppStream 2.0 portal.
        public let description: String?

        public init(name: String, displayName: String? = nil, description: String? = nil) {
            self.name = name
            self.displayName = displayName
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            self.displayName = dictionary["DisplayName"] as? String
            self.description = dictionary["Description"] as? String
        }
    }

    public struct UpdateStackRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the stack to update.
        public let name: String
        /// The name displayed to end users on the AppStream 2.0 portal.
        public let displayName: String?
        /// The description displayed to end users on the AppStream 2.0 portal.
        public let description: String?

        public init(name: String, displayName: String? = nil, description: String? = nil) {
            self.name = name
            self.displayName = displayName
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            self.displayName = dictionary["DisplayName"] as? String
            self.description = dictionary["Description"] as? String
        }
    }

    public struct StopFleetRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the fleet to stop.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
        }
    }

    public enum ImageStateChangeReasonCode: String, CustomStringConvertible {
        case internal_error = "INTERNAL_ERROR"
        case image_builder_not_available = "IMAGE_BUILDER_NOT_AVAILABLE"
        public var description: String { return self.rawValue }
    }

    public struct ExpireSessionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The unique identifier of the streaming session to be stopped.
        public let sessionId: String

        public init(sessionId: String) {
            self.sessionId = sessionId
        }

        public init(dictionary: [String: Any]) throws {
            guard let sessionId = dictionary["SessionId"] as? String else { throw InitializableError.missingRequiredParam("SessionId") }
            self.sessionId = sessionId
        }
    }

    public struct CreateFleetResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The details for the created fleet.
        public let fleet: Fleet?

        public init(fleet: Fleet? = nil) {
            self.fleet = fleet
        }

        public init(dictionary: [String: Any]) throws {
            if let fleet = dictionary["Fleet"] as? [String: Any] { self.fleet = try Appstream.Fleet(dictionary: fleet) } else { self.fleet = nil }
        }
    }

    public struct CreateStreamingURLRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The validity duration of the URL in seconds. After this duration, the URL returned by this operation becomes invalid.
        public let validity: Int64?
        /// A unique user ID for whom the URL is generated.
        public let userId: String
        /// The ID of the application that must be launched after the session starts.
        public let applicationId: String?
        /// The sessionContext of the streaming URL.
        public let sessionContext: String?
        /// The stack for which the URL is generated.
        public let stackName: String
        /// The fleet for which the URL is generated.
        public let fleetName: String

        public init(validity: Int64? = nil, userId: String, applicationId: String? = nil, sessionContext: String? = nil, stackName: String, fleetName: String) {
            self.validity = validity
            self.userId = userId
            self.applicationId = applicationId
            self.sessionContext = sessionContext
            self.stackName = stackName
            self.fleetName = fleetName
        }

        public init(dictionary: [String: Any]) throws {
            self.validity = dictionary["Validity"] as? Int64
            guard let userId = dictionary["UserId"] as? String else { throw InitializableError.missingRequiredParam("UserId") }
            self.userId = userId
            self.applicationId = dictionary["ApplicationId"] as? String
            self.sessionContext = dictionary["SessionContext"] as? String
            guard let stackName = dictionary["StackName"] as? String else { throw InitializableError.missingRequiredParam("StackName") }
            self.stackName = stackName
            guard let fleetName = dictionary["FleetName"] as? String else { throw InitializableError.missingRequiredParam("FleetName") }
            self.fleetName = fleetName
        }
    }

    public struct ComputeCapacityStatus: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The number of currently available instances that can be used to stream sessions.
        public let available: Int32?
        /// The number of instances that are being used for streaming.
        public let inUse: Int32?
        /// The desired number of streaming instances.
        public let desired: Int32
        /// The total number of simultaneous streaming instances that are running.
        public let running: Int32?

        public init(available: Int32? = nil, inUse: Int32? = nil, desired: Int32, running: Int32? = nil) {
            self.available = available
            self.inUse = inUse
            self.desired = desired
            self.running = running
        }

        public init(dictionary: [String: Any]) throws {
            self.available = dictionary["Available"] as? Int32
            self.inUse = dictionary["InUse"] as? Int32
            guard let desired = dictionary["Desired"] as? Int32 else { throw InitializableError.missingRequiredParam("Desired") }
            self.desired = desired
            self.running = dictionary["Running"] as? Int32
        }
    }

    public struct CreateStreamingURLResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The URL to start the AppStream 2.0 streaming session.
        public let streamingURL: String?
        /// Elapsed seconds after the Unix epoch, at which time this URL expires.
        public let expires: Date?

        public init(streamingURL: String? = nil, expires: Date? = nil) {
            self.streamingURL = streamingURL
            self.expires = expires
        }

        public init(dictionary: [String: Any]) throws {
            self.streamingURL = dictionary["StreamingURL"] as? String
            self.expires = dictionary["Expires"] as? Date
        }
    }

    public struct AssociateFleetRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the stack to which the fleet is associated.
        public let stackName: String
        /// The name of the fleet to associate.
        public let fleetName: String

        public init(stackName: String, fleetName: String) {
            self.stackName = stackName
            self.fleetName = fleetName
        }

        public init(dictionary: [String: Any]) throws {
            guard let stackName = dictionary["StackName"] as? String else { throw InitializableError.missingRequiredParam("StackName") }
            self.stackName = stackName
            guard let fleetName = dictionary["FleetName"] as? String else { throw InitializableError.missingRequiredParam("FleetName") }
            self.fleetName = fleetName
        }
    }

    public enum FleetErrorCode: String, CustomStringConvertible {
        case iam_service_role_missing_eni_describe_action = "IAM_SERVICE_ROLE_MISSING_ENI_DESCRIBE_ACTION"
        case iam_service_role_missing_eni_create_action = "IAM_SERVICE_ROLE_MISSING_ENI_CREATE_ACTION"
        case iam_service_role_missing_eni_delete_action = "IAM_SERVICE_ROLE_MISSING_ENI_DELETE_ACTION"
        case network_interface_limit_exceeded = "NETWORK_INTERFACE_LIMIT_EXCEEDED"
        case internal_service_error = "INTERNAL_SERVICE_ERROR"
        case iam_service_role_is_missing = "IAM_SERVICE_ROLE_IS_MISSING"
        case subnet_has_insufficient_ip_addresses = "SUBNET_HAS_INSUFFICIENT_IP_ADDRESSES"
        case iam_service_role_missing_describe_subnet_action = "IAM_SERVICE_ROLE_MISSING_DESCRIBE_SUBNET_ACTION"
        case subnet_not_found = "SUBNET_NOT_FOUND"
        case image_not_found = "IMAGE_NOT_FOUND"
        case invalid_subnet_configuration = "INVALID_SUBNET_CONFIGURATION"
        public var description: String { return self.rawValue }
    }

    public struct DescribeFleetsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        /// The list of fleet details.
        public let fleets: [Fleet]?

        public init(nextToken: String? = nil, fleets: [Fleet]? = nil) {
            self.nextToken = nextToken
            self.fleets = fleets
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let fleets = dictionary["Fleets"] as? [[String: Any]] {
                self.fleets = try fleets.map({ try Fleet(dictionary: $0) })
            } else { 
                self.fleets = nil
            }
        }
    }

    public struct Image: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The reason why the last state change occurred.
        public let stateChangeReason: ImageStateChangeReason?
        /// The ARN for the image.
        public let arn: String?
        /// The operating system platform of the image.
        public let platform: PlatformType?
        /// The image starts in the PENDING state, and then moves to AVAILABLE if image creation succeeds and FAILED if image creation has failed.
        public let state: ImageState?
        /// The display name for the image.
        public let displayName: String?
        /// The unique identifier for the image.
        public let name: String
        /// The source image ARN from which this image was created.
        public let baseImageArn: String?
        /// The applications associated with an image.
        public let applications: [Application]?
        /// The visibility of an image to the user; images can be public or private.
        public let visibility: VisibilityType?
        /// The timestamp when the image was created.
        public let createdTime: Date?
        /// A meaningful description for the image.
        public let description: String?

        public init(stateChangeReason: ImageStateChangeReason? = nil, arn: String? = nil, platform: PlatformType? = nil, state: ImageState? = nil, displayName: String? = nil, name: String, baseImageArn: String? = nil, applications: [Application]? = nil, visibility: VisibilityType? = nil, createdTime: Date? = nil, description: String? = nil) {
            self.stateChangeReason = stateChangeReason
            self.arn = arn
            self.platform = platform
            self.state = state
            self.displayName = displayName
            self.name = name
            self.baseImageArn = baseImageArn
            self.applications = applications
            self.visibility = visibility
            self.createdTime = createdTime
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            if let stateChangeReason = dictionary["StateChangeReason"] as? [String: Any] { self.stateChangeReason = try Appstream.ImageStateChangeReason(dictionary: stateChangeReason) } else { self.stateChangeReason = nil }
            self.arn = dictionary["Arn"] as? String
            if let platform = dictionary["Platform"] as? String { self.platform = PlatformType(rawValue: platform) } else { self.platform = nil }
            if let state = dictionary["State"] as? String { self.state = ImageState(rawValue: state) } else { self.state = nil }
            self.displayName = dictionary["DisplayName"] as? String
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            self.baseImageArn = dictionary["BaseImageArn"] as? String
            if let applications = dictionary["Applications"] as? [[String: Any]] {
                self.applications = try applications.map({ try Application(dictionary: $0) })
            } else { 
                self.applications = nil
            }
            if let visibility = dictionary["Visibility"] as? String { self.visibility = VisibilityType(rawValue: visibility) } else { self.visibility = nil }
            self.createdTime = dictionary["CreatedTime"] as? Date
            self.description = dictionary["Description"] as? String
        }
    }

    public struct DeleteStackRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the stack to delete.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
        }
    }

    public struct StopFleetResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public enum SessionState: String, CustomStringConvertible {
        case active = "ACTIVE"
        case pending = "PENDING"
        case expired = "EXPIRED"
        public var description: String { return self.rawValue }
    }

    public struct CreateStackResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The details for the created stack.
        public let stack: Stack?

        public init(stack: Stack? = nil) {
            self.stack = stack
        }

        public init(dictionary: [String: Any]) throws {
            if let stack = dictionary["Stack"] as? [String: Any] { self.stack = try Appstream.Stack(dictionary: stack) } else { self.stack = nil }
        }
    }

    public enum ImageState: String, CustomStringConvertible {
        case pending = "PENDING"
        case available = "AVAILABLE"
        case failed = "FAILED"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public struct DeleteFleetRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the fleet to be deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
        }
    }

    public struct AssociateFleetResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

}