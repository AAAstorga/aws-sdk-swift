// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Codecommit {

    public struct ListRepositoriesOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Lists the repositories called by the list repositories operation.
        public let repositories: [RepositoryNameIdPair]?
        /// An enumeration token that allows the operation to batch the results of the operation. Batch sizes are 1,000 for list repository operations. When the client sends the token back to AWS CodeCommit, another page of 1,000 records is retrieved.
        public let nextToken: String?

        public init(repositories: [RepositoryNameIdPair]? = nil, nextToken: String? = nil) {
            self.repositories = repositories
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let repositories = dictionary["repositories"] as? [[String: Any]] {
                self.repositories = try repositories.map({ try RepositoryNameIdPair(dictionary: $0) })
            } else { 
                self.repositories = nil
            }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct UserInfo: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the user who made the specified commit.
        public let name: String?
        /// The date when the specified commit was pushed to the repository.
        public let date: String?
        /// The email address associated with the user who made the commit, if any.
        public let email: String?

        public init(name: String? = nil, date: String? = nil, email: String? = nil) {
            self.name = name
            self.date = date
            self.email = email
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["name"] as? String
            self.date = dictionary["date"] as? String
            self.email = dictionary["email"] as? String
        }
    }

    public struct BranchInfo: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the branch.
        public let branchName: String?
        /// The ID of the last commit made to the branch.
        public let commitId: String?

        public init(branchName: String? = nil, commitId: String? = nil) {
            self.branchName = branchName
            self.commitId = commitId
        }

        public init(dictionary: [String: Any]) throws {
            self.branchName = dictionary["branchName"] as? String
            self.commitId = dictionary["commitId"] as? String
        }
    }

    public struct GetCommitOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A commit data type object that contains information about the specified commit.
        public let commit: Commit

        public init(commit: Commit) {
            self.commit = commit
        }

        public init(dictionary: [String: Any]) throws {
            guard let commit = dictionary["commit"] as? [String: Any] else { throw InitializableError.missingRequiredParam("commit") }
            self.commit = try Codecommit.Commit(dictionary: commit)
        }
    }

    public struct DeleteRepositoryOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the repository that was deleted.
        public let repositoryId: String?

        public init(repositoryId: String? = nil) {
            self.repositoryId = repositoryId
        }

        public init(dictionary: [String: Any]) throws {
            self.repositoryId = dictionary["repositoryId"] as? String
        }
    }

    public struct RepositoryMetadata: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A comment or description about the repository.
        public let repositoryDescription: String?
        /// The Amazon Resource Name (ARN) of the repository.
        public let arn: String?
        /// The repository's name.
        public let repositoryName: String?
        /// The date and time the repository was created, in timestamp format.
        public let creationDate: Date?
        /// The URL to use for cloning the repository over SSH.
        public let cloneUrlSsh: String?
        /// The ID of the AWS account associated with the repository.
        public let accountId: String?
        /// The URL to use for cloning the repository over HTTPS.
        public let cloneUrlHttp: String?
        /// The ID of the repository.
        public let repositoryId: String?
        /// The date and time the repository was last modified, in timestamp format.
        public let lastModifiedDate: Date?
        /// The repository's default branch name.
        public let defaultBranch: String?

        public init(repositoryDescription: String? = nil, arn: String? = nil, repositoryName: String? = nil, creationDate: Date? = nil, cloneUrlSsh: String? = nil, accountId: String? = nil, cloneUrlHttp: String? = nil, repositoryId: String? = nil, lastModifiedDate: Date? = nil, defaultBranch: String? = nil) {
            self.repositoryDescription = repositoryDescription
            self.arn = arn
            self.repositoryName = repositoryName
            self.creationDate = creationDate
            self.cloneUrlSsh = cloneUrlSsh
            self.accountId = accountId
            self.cloneUrlHttp = cloneUrlHttp
            self.repositoryId = repositoryId
            self.lastModifiedDate = lastModifiedDate
            self.defaultBranch = defaultBranch
        }

        public init(dictionary: [String: Any]) throws {
            self.repositoryDescription = dictionary["repositoryDescription"] as? String
            self.arn = dictionary["Arn"] as? String
            self.repositoryName = dictionary["repositoryName"] as? String
            self.creationDate = dictionary["creationDate"] as? Date
            self.cloneUrlSsh = dictionary["cloneUrlSsh"] as? String
            self.accountId = dictionary["accountId"] as? String
            self.cloneUrlHttp = dictionary["cloneUrlHttp"] as? String
            self.repositoryId = dictionary["repositoryId"] as? String
            self.lastModifiedDate = dictionary["lastModifiedDate"] as? Date
            self.defaultBranch = dictionary["defaultBranch"] as? String
        }
    }

    public struct ListBranchesOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An enumeration token that returns the batch of the results.
        public let nextToken: String?
        /// The list of branch names.
        public let branches: [String]?

        public init(nextToken: String? = nil, branches: [String]? = nil) {
            self.nextToken = nextToken
            self.branches = branches
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            self.branches = dictionary["branches"] as? [String]
        }
    }

    public struct RepositoryTrigger: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the resource that is the target for a trigger. For example, the ARN of a topic in Amazon Simple Notification Service (SNS).
        public let destinationArn: String
        /// The name of the trigger.
        public let name: String
        /// The branches that will be included in the trigger configuration. If no branches are specified, the trigger will apply to all branches.
        public let branches: [String]?
        /// Any custom data associated with the trigger that will be included in the information sent to the target of the trigger.
        public let customData: String?
        /// The repository events that will cause the trigger to run actions in another service, such as sending a notification through Amazon Simple Notification Service (SNS).   The valid value "all" cannot be used with any other values. 
        public let events: [RepositoryTriggerEventEnum]

        public init(destinationArn: String, name: String, branches: [String]? = nil, customData: String? = nil, events: [RepositoryTriggerEventEnum]) {
            self.destinationArn = destinationArn
            self.name = name
            self.branches = branches
            self.customData = customData
            self.events = events
        }

        public init(dictionary: [String: Any]) throws {
            guard let destinationArn = dictionary["destinationArn"] as? String else { throw InitializableError.missingRequiredParam("destinationArn") }
            self.destinationArn = destinationArn
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
            self.branches = dictionary["branches"] as? [String]
            self.customData = dictionary["customData"] as? String
            guard let events = dictionary["events"] as? [String] else { throw InitializableError.missingRequiredParam("events") }
            self.events = events.flatMap({ RepositoryTriggerEventEnum(rawValue: $0)})
        }
    }

    public struct BlobMetadata: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The full ID of the blob.
        public let blobId: String?
        /// The file mode permissions of the blob. File mode permission codes include:    100644 indicates read/write    100755 indicates read/write/execute    160000 indicates a submodule    120000 indicates a symlink  
        public let mode: String?
        /// The path to the blob and any associated file name, if any.
        public let path: String?

        public init(blobId: String? = nil, mode: String? = nil, path: String? = nil) {
            self.blobId = blobId
            self.mode = mode
            self.path = path
        }

        public init(dictionary: [String: Any]) throws {
            self.blobId = dictionary["blobId"] as? String
            self.mode = dictionary["mode"] as? String
            self.path = dictionary["path"] as? String
        }
    }

    public struct Commit: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The parent list for the specified commit.
        public let parents: [String]?
        /// The commit message associated with the specified commit.
        public let message: String?
        /// Information about the author of the specified commit. Information includes the date in timestamp format with GMT offset, the name of the author, and the email address for the author, as configured in Git.
        public let author: UserInfo?
        /// Tree information for the specified commit.
        public let treeId: String?
        /// Any additional data associated with the specified commit.
        public let additionalData: String?
        /// Information about the person who committed the specified commit, also known as the committer. Information includes the date in timestamp format with GMT offset, the name of the committer, and the email address for the committer, as configured in Git. For more information about the difference between an author and a committer in Git, see Viewing the Commit History in Pro Git by Scott Chacon and Ben Straub.
        public let committer: UserInfo?

        public init(parents: [String]? = nil, message: String? = nil, author: UserInfo? = nil, treeId: String? = nil, additionalData: String? = nil, committer: UserInfo? = nil) {
            self.parents = parents
            self.message = message
            self.author = author
            self.treeId = treeId
            self.additionalData = additionalData
            self.committer = committer
        }

        public init(dictionary: [String: Any]) throws {
            self.parents = dictionary["parents"] as? [String]
            self.message = dictionary["message"] as? String
            if let author = dictionary["author"] as? [String: Any] { self.author = try Codecommit.UserInfo(dictionary: author) } else { self.author = nil }
            self.treeId = dictionary["treeId"] as? String
            self.additionalData = dictionary["additionalData"] as? String
            if let committer = dictionary["committer"] as? [String: Any] { self.committer = try Codecommit.UserInfo(dictionary: committer) } else { self.committer = nil }
        }
    }

    public struct UpdateDefaultBranchInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the branch to set as the default.
        public let defaultBranchName: String
        /// The name of the repository to set or change the default branch for.
        public let repositoryName: String

        public init(defaultBranchName: String, repositoryName: String) {
            self.defaultBranchName = defaultBranchName
            self.repositoryName = repositoryName
        }

        public init(dictionary: [String: Any]) throws {
            guard let defaultBranchName = dictionary["defaultBranchName"] as? String else { throw InitializableError.missingRequiredParam("defaultBranchName") }
            self.defaultBranchName = defaultBranchName
            guard let repositoryName = dictionary["repositoryName"] as? String else { throw InitializableError.missingRequiredParam("repositoryName") }
            self.repositoryName = repositoryName
        }
    }

    public enum OrderEnum: String, CustomStringConvertible {
        case ascending = "ascending"
        case descending = "descending"
        public var description: String { return self.rawValue }
    }

    public struct GetRepositoryOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the repository.
        public let repositoryMetadata: RepositoryMetadata?

        public init(repositoryMetadata: RepositoryMetadata? = nil) {
            self.repositoryMetadata = repositoryMetadata
        }

        public init(dictionary: [String: Any]) throws {
            if let repositoryMetadata = dictionary["repositoryMetadata"] as? [String: Any] { self.repositoryMetadata = try Codecommit.RepositoryMetadata(dictionary: repositoryMetadata) } else { self.repositoryMetadata = nil }
        }
    }

    public struct TestRepositoryTriggersOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The list of triggers that were successfully tested. This list provides the names of the triggers that were successfully tested, separated by commas.
        public let successfulExecutions: [String]?
        /// The list of triggers that were not able to be tested. This list provides the names of the triggers that could not be tested, separated by commas.
        public let failedExecutions: [RepositoryTriggerExecutionFailure]?

        public init(successfulExecutions: [String]? = nil, failedExecutions: [RepositoryTriggerExecutionFailure]? = nil) {
            self.successfulExecutions = successfulExecutions
            self.failedExecutions = failedExecutions
        }

        public init(dictionary: [String: Any]) throws {
            self.successfulExecutions = dictionary["successfulExecutions"] as? [String]
            if let failedExecutions = dictionary["failedExecutions"] as? [[String: Any]] {
                self.failedExecutions = try failedExecutions.map({ try RepositoryTriggerExecutionFailure(dictionary: $0) })
            } else { 
                self.failedExecutions = nil
            }
        }
    }

    public struct TestRepositoryTriggersInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The list of triggers to test.
        public let triggers: [RepositoryTrigger]
        /// The name of the repository in which to test the triggers.
        public let repositoryName: String

        public init(triggers: [RepositoryTrigger], repositoryName: String) {
            self.triggers = triggers
            self.repositoryName = repositoryName
        }

        public init(dictionary: [String: Any]) throws {
            guard let triggers = dictionary["triggers"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("triggers") }
            self.triggers = try triggers.map({ try RepositoryTrigger(dictionary: $0) })
            guard let repositoryName = dictionary["repositoryName"] as? String else { throw InitializableError.missingRequiredParam("repositoryName") }
            self.repositoryName = repositoryName
        }
    }

    public enum ChangeTypeEnum: String, CustomStringConvertible {
        case a = "A"
        case m = "M"
        case d = "D"
        public var description: String { return self.rawValue }
    }

    public struct UpdateRepositoryDescriptionInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the repository to set or change the comment or description for.
        public let repositoryName: String
        /// The new comment or description for the specified repository. Repository descriptions are limited to 1,000 characters.
        public let repositoryDescription: String?

        public init(repositoryName: String, repositoryDescription: String? = nil) {
            self.repositoryName = repositoryName
            self.repositoryDescription = repositoryDescription
        }

        public init(dictionary: [String: Any]) throws {
            guard let repositoryName = dictionary["repositoryName"] as? String else { throw InitializableError.missingRequiredParam("repositoryName") }
            self.repositoryName = repositoryName
            self.repositoryDescription = dictionary["repositoryDescription"] as? String
        }
    }

    public struct PutRepositoryTriggersOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The system-generated unique ID for the create or update operation.
        public let configurationId: String?

        public init(configurationId: String? = nil) {
            self.configurationId = configurationId
        }

        public init(dictionary: [String: Any]) throws {
            self.configurationId = dictionary["configurationId"] as? String
        }
    }

    public struct GetBranchInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the branch for which you want to retrieve information.
        public let branchName: String?
        /// The name of the repository that contains the branch for which you want to retrieve information.
        public let repositoryName: String?

        public init(branchName: String? = nil, repositoryName: String? = nil) {
            self.branchName = branchName
            self.repositoryName = repositoryName
        }

        public init(dictionary: [String: Any]) throws {
            self.branchName = dictionary["branchName"] as? String
            self.repositoryName = dictionary["repositoryName"] as? String
        }
    }

    public struct CreateRepositoryOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the newly created repository.
        public let repositoryMetadata: RepositoryMetadata?

        public init(repositoryMetadata: RepositoryMetadata? = nil) {
            self.repositoryMetadata = repositoryMetadata
        }

        public init(dictionary: [String: Any]) throws {
            if let repositoryMetadata = dictionary["repositoryMetadata"] as? [String: Any] { self.repositoryMetadata = try Codecommit.RepositoryMetadata(dictionary: repositoryMetadata) } else { self.repositoryMetadata = nil }
        }
    }

    public enum SortByEnum: String, CustomStringConvertible {
        case repositoryname = "repositoryName"
        case lastmodifieddate = "lastModifiedDate"
        public var description: String { return self.rawValue }
    }

    public struct Difference: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Whether the change type of the difference is an addition (A), deletion (D), or modification (M).
        public let changeType: ChangeTypeEnum?
        /// Information about an afterBlob data type object, including the ID, the file mode permission code, and the path.
        public let afterBlob: BlobMetadata?
        /// Information about a beforeBlob data type object, including the ID, the file mode permission code, and the path.
        public let beforeBlob: BlobMetadata?

        public init(changeType: ChangeTypeEnum? = nil, afterBlob: BlobMetadata? = nil, beforeBlob: BlobMetadata? = nil) {
            self.changeType = changeType
            self.afterBlob = afterBlob
            self.beforeBlob = beforeBlob
        }

        public init(dictionary: [String: Any]) throws {
            if let changeType = dictionary["changeType"] as? String { self.changeType = ChangeTypeEnum(rawValue: changeType) } else { self.changeType = nil }
            if let afterBlob = dictionary["afterBlob"] as? [String: Any] { self.afterBlob = try Codecommit.BlobMetadata(dictionary: afterBlob) } else { self.afterBlob = nil }
            if let beforeBlob = dictionary["beforeBlob"] as? [String: Any] { self.beforeBlob = try Codecommit.BlobMetadata(dictionary: beforeBlob) } else { self.beforeBlob = nil }
        }
    }

    public struct RepositoryNameIdPair: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID associated with the repository.
        public let repositoryId: String?
        /// The name associated with the repository.
        public let repositoryName: String?

        public init(repositoryId: String? = nil, repositoryName: String? = nil) {
            self.repositoryId = repositoryId
            self.repositoryName = repositoryName
        }

        public init(dictionary: [String: Any]) throws {
            self.repositoryId = dictionary["repositoryId"] as? String
            self.repositoryName = dictionary["repositoryName"] as? String
        }
    }

    public enum RepositoryTriggerEventEnum: String, CustomStringConvertible {
        case all = "all"
        case updatereference = "updateReference"
        case createreference = "createReference"
        case deletereference = "deleteReference"
        public var description: String { return self.rawValue }
    }

    public struct GetDifferencesInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit.
        public let afterCommitSpecifier: String
        /// The name of the repository where you want to get differences.
        public let repositoryName: String
        /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit. For example, the full commit ID. Optional. If not specified, all changes prior to the afterCommitSpecifier value will be shown. If you do not use beforeCommitSpecifier in your request, consider limiting the results with maxResults.
        public let beforeCommitSpecifier: String?
        /// The file path in which to check for differences. Limits the results to this path. Can also be used to specify the previous name of a directory or folder. If beforePath and afterPath are not specified, differences will be shown for all paths.
        public let beforePath: String?
        /// The file path in which to check differences. Limits the results to this path. Can also be used to specify the changed name of a directory or folder, if it has changed. If not specified, differences will be shown for all paths.
        public let afterPath: String?
        /// An enumeration token that when provided in a request, returns the next batch of the results.
        public let nextToken: String?
        /// A non-negative integer used to limit the number of returned results.
        public let maxResults: Int32?

        public init(afterCommitSpecifier: String, repositoryName: String, beforeCommitSpecifier: String? = nil, beforePath: String? = nil, afterPath: String? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.afterCommitSpecifier = afterCommitSpecifier
            self.repositoryName = repositoryName
            self.beforeCommitSpecifier = beforeCommitSpecifier
            self.beforePath = beforePath
            self.afterPath = afterPath
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            guard let afterCommitSpecifier = dictionary["afterCommitSpecifier"] as? String else { throw InitializableError.missingRequiredParam("afterCommitSpecifier") }
            self.afterCommitSpecifier = afterCommitSpecifier
            guard let repositoryName = dictionary["repositoryName"] as? String else { throw InitializableError.missingRequiredParam("repositoryName") }
            self.repositoryName = repositoryName
            self.beforeCommitSpecifier = dictionary["beforeCommitSpecifier"] as? String
            self.beforePath = dictionary["beforePath"] as? String
            self.afterPath = dictionary["afterPath"] as? String
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct CreateBranchInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the new branch to create.
        public let branchName: String
        /// The ID of the commit to point the new branch to.
        public let commitId: String
        /// The name of the repository in which you want to create the new branch.
        public let repositoryName: String

        public init(branchName: String, commitId: String, repositoryName: String) {
            self.branchName = branchName
            self.commitId = commitId
            self.repositoryName = repositoryName
        }

        public init(dictionary: [String: Any]) throws {
            guard let branchName = dictionary["branchName"] as? String else { throw InitializableError.missingRequiredParam("branchName") }
            self.branchName = branchName
            guard let commitId = dictionary["commitId"] as? String else { throw InitializableError.missingRequiredParam("commitId") }
            self.commitId = commitId
            guard let repositoryName = dictionary["repositoryName"] as? String else { throw InitializableError.missingRequiredParam("repositoryName") }
            self.repositoryName = repositoryName
        }
    }

    public struct DeleteRepositoryInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the repository to delete.
        public let repositoryName: String

        public init(repositoryName: String) {
            self.repositoryName = repositoryName
        }

        public init(dictionary: [String: Any]) throws {
            guard let repositoryName = dictionary["repositoryName"] as? String else { throw InitializableError.missingRequiredParam("repositoryName") }
            self.repositoryName = repositoryName
        }
    }

    public struct ListBranchesInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An enumeration token that allows the operation to batch the results.
        public let nextToken: String?
        /// The name of the repository that contains the branches.
        public let repositoryName: String

        public init(nextToken: String? = nil, repositoryName: String) {
            self.nextToken = nextToken
            self.repositoryName = repositoryName
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            guard let repositoryName = dictionary["repositoryName"] as? String else { throw InitializableError.missingRequiredParam("repositoryName") }
            self.repositoryName = repositoryName
        }
    }

    public struct GetBranchOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the branch.
        public let branch: BranchInfo?

        public init(branch: BranchInfo? = nil) {
            self.branch = branch
        }

        public init(dictionary: [String: Any]) throws {
            if let branch = dictionary["branch"] as? [String: Any] { self.branch = try Codecommit.BranchInfo(dictionary: branch) } else { self.branch = nil }
        }
    }

    public struct GetCommitInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The commit ID.
        public let commitId: String
        /// The name of the repository to which the commit was made.
        public let repositoryName: String

        public init(commitId: String, repositoryName: String) {
            self.commitId = commitId
            self.repositoryName = repositoryName
        }

        public init(dictionary: [String: Any]) throws {
            guard let commitId = dictionary["commitId"] as? String else { throw InitializableError.missingRequiredParam("commitId") }
            self.commitId = commitId
            guard let repositoryName = dictionary["repositoryName"] as? String else { throw InitializableError.missingRequiredParam("repositoryName") }
            self.repositoryName = repositoryName
        }
    }

    public struct GetRepositoryInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the repository to get information about.
        public let repositoryName: String

        public init(repositoryName: String) {
            self.repositoryName = repositoryName
        }

        public init(dictionary: [String: Any]) throws {
            guard let repositoryName = dictionary["repositoryName"] as? String else { throw InitializableError.missingRequiredParam("repositoryName") }
            self.repositoryName = repositoryName
        }
    }

    public struct GetRepositoryTriggersOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The system-generated unique ID for the trigger.
        public let configurationId: String?
        /// The JSON block of configuration information for each trigger.
        public let triggers: [RepositoryTrigger]?

        public init(configurationId: String? = nil, triggers: [RepositoryTrigger]? = nil) {
            self.configurationId = configurationId
            self.triggers = triggers
        }

        public init(dictionary: [String: Any]) throws {
            self.configurationId = dictionary["configurationId"] as? String
            if let triggers = dictionary["triggers"] as? [[String: Any]] {
                self.triggers = try triggers.map({ try RepositoryTrigger(dictionary: $0) })
            } else { 
                self.triggers = nil
            }
        }
    }

    public struct GetRepositoryTriggersInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the repository for which the trigger is configured.
        public let repositoryName: String

        public init(repositoryName: String) {
            self.repositoryName = repositoryName
        }

        public init(dictionary: [String: Any]) throws {
            guard let repositoryName = dictionary["repositoryName"] as? String else { throw InitializableError.missingRequiredParam("repositoryName") }
            self.repositoryName = repositoryName
        }
    }

    public struct UpdateRepositoryNameInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The existing name of the repository.
        public let oldName: String
        /// The new name for the repository.
        public let newName: String

        public init(oldName: String, newName: String) {
            self.oldName = oldName
            self.newName = newName
        }

        public init(dictionary: [String: Any]) throws {
            guard let oldName = dictionary["oldName"] as? String else { throw InitializableError.missingRequiredParam("oldName") }
            self.oldName = oldName
            guard let newName = dictionary["newName"] as? String else { throw InitializableError.missingRequiredParam("newName") }
            self.newName = newName
        }
    }

    public struct BatchGetRepositoriesOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of repositories returned by the batch get repositories operation.
        public let repositories: [RepositoryMetadata]?
        /// Returns a list of repository names for which information could not be found.
        public let repositoriesNotFound: [String]?

        public init(repositories: [RepositoryMetadata]? = nil, repositoriesNotFound: [String]? = nil) {
            self.repositories = repositories
            self.repositoriesNotFound = repositoriesNotFound
        }

        public init(dictionary: [String: Any]) throws {
            if let repositories = dictionary["repositories"] as? [[String: Any]] {
                self.repositories = try repositories.map({ try RepositoryMetadata(dictionary: $0) })
            } else { 
                self.repositories = nil
            }
            self.repositoriesNotFound = dictionary["repositoriesNotFound"] as? [String]
        }
    }

    public struct GetDifferencesOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An enumeration token that can be used in a request to return the next batch of the results.
        public let nextToken: String?
        /// A differences data type object that contains information about the differences, including whether the difference is added, modified, or deleted (A, D, M).
        public let differences: [Difference]?

        public init(nextToken: String? = nil, differences: [Difference]? = nil) {
            self.nextToken = nextToken
            self.differences = differences
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let differences = dictionary["differences"] as? [[String: Any]] {
                self.differences = try differences.map({ try Difference(dictionary: $0) })
            } else { 
                self.differences = nil
            }
        }
    }

    public struct ListRepositoriesInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The criteria used to sort the results of a list repositories operation.
        public let sortBy: SortByEnum?
        /// The order in which to sort the results of a list repositories operation.
        public let order: OrderEnum?
        /// An enumeration token that allows the operation to batch the results of the operation. Batch sizes are 1,000 for list repository operations. When the client sends the token back to AWS CodeCommit, another page of 1,000 records is retrieved.
        public let nextToken: String?

        public init(sortBy: SortByEnum? = nil, order: OrderEnum? = nil, nextToken: String? = nil) {
            self.sortBy = sortBy
            self.order = order
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let sortBy = dictionary["sortBy"] as? String { self.sortBy = SortByEnum(rawValue: sortBy) } else { self.sortBy = nil }
            if let order = dictionary["order"] as? String { self.order = OrderEnum(rawValue: order) } else { self.order = nil }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct GetBlobOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The content of the blob, usually a file.
        public let content: Data

        public init(content: Data) {
            self.content = content
        }

        public init(dictionary: [String: Any]) throws {
            guard let content = dictionary["content"] as? Data else { throw InitializableError.missingRequiredParam("content") }
            self.content = content
        }
    }

    public struct RepositoryTriggerExecutionFailure: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Additional message information about the trigger that did not run.
        public let failureMessage: String?
        /// The name of the trigger that did not run.
        public let trigger: String?

        public init(failureMessage: String? = nil, trigger: String? = nil) {
            self.failureMessage = failureMessage
            self.trigger = trigger
        }

        public init(dictionary: [String: Any]) throws {
            self.failureMessage = dictionary["failureMessage"] as? String
            self.trigger = dictionary["trigger"] as? String
        }
    }

    public struct GetBlobInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the blob, which is its SHA-1 pointer.
        public let blobId: String
        /// The name of the repository that contains the blob.
        public let repositoryName: String

        public init(blobId: String, repositoryName: String) {
            self.blobId = blobId
            self.repositoryName = repositoryName
        }

        public init(dictionary: [String: Any]) throws {
            guard let blobId = dictionary["blobId"] as? String else { throw InitializableError.missingRequiredParam("blobId") }
            self.blobId = blobId
            guard let repositoryName = dictionary["repositoryName"] as? String else { throw InitializableError.missingRequiredParam("repositoryName") }
            self.repositoryName = repositoryName
        }
    }

    public struct CreateRepositoryInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the new repository to be created.  The repository name must be unique across the calling AWS account. In addition, repository names are limited to 100 alphanumeric, dash, and underscore characters, and cannot include certain characters. For a full description of the limits on repository names, see Limits in the AWS CodeCommit User Guide. The suffix ".git" is prohibited. 
        public let repositoryName: String
        /// A comment or description about the new repository.  The description field for a repository accepts all HTML characters and all valid Unicode characters. Applications that do not HTML-encode the description and display it in a web page could expose users to potentially malicious code. Make sure that you HTML-encode the description field in any application that uses this API to display the repository description on a web page. 
        public let repositoryDescription: String?

        public init(repositoryName: String, repositoryDescription: String? = nil) {
            self.repositoryName = repositoryName
            self.repositoryDescription = repositoryDescription
        }

        public init(dictionary: [String: Any]) throws {
            guard let repositoryName = dictionary["repositoryName"] as? String else { throw InitializableError.missingRequiredParam("repositoryName") }
            self.repositoryName = repositoryName
            self.repositoryDescription = dictionary["repositoryDescription"] as? String
        }
    }

    public struct PutRepositoryTriggersInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The JSON block of configuration information for each trigger.
        public let triggers: [RepositoryTrigger]
        /// The name of the repository where you want to create or update the trigger.
        public let repositoryName: String

        public init(triggers: [RepositoryTrigger], repositoryName: String) {
            self.triggers = triggers
            self.repositoryName = repositoryName
        }

        public init(dictionary: [String: Any]) throws {
            guard let triggers = dictionary["triggers"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("triggers") }
            self.triggers = try triggers.map({ try RepositoryTrigger(dictionary: $0) })
            guard let repositoryName = dictionary["repositoryName"] as? String else { throw InitializableError.missingRequiredParam("repositoryName") }
            self.repositoryName = repositoryName
        }
    }

    public struct BatchGetRepositoriesInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The names of the repositories to get information about.
        public let repositoryNames: [String]

        public init(repositoryNames: [String]) {
            self.repositoryNames = repositoryNames
        }

        public init(dictionary: [String: Any]) throws {
            guard let repositoryNames = dictionary["repositoryNames"] as? [String] else { throw InitializableError.missingRequiredParam("repositoryNames") }
            self.repositoryNames = repositoryNames
        }
    }

}