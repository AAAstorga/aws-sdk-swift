// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension AppMesh {

    public struct UpdateVirtualRouterOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualRouter"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualRouter", required: false, type: .structure)
        ]
        /// A full description of the virtual router that was updated.
        public let virtualRouter: VirtualRouterData?

        public init(virtualRouter: VirtualRouterData? = nil) {
            self.virtualRouter = virtualRouter
        }

        private enum CodingKeys: String, CodingKey {
            case virtualRouter = "virtualRouter"
        }
    }

    public enum RouteStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public struct HealthCheckPolicy: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "intervalMillis", required: false, type: .long), 
            AWSShapeMember(label: "unhealthyThreshold", required: false, type: .integer), 
            AWSShapeMember(label: "protocol", required: false, type: .enum), 
            AWSShapeMember(label: "port", required: false, type: .integer), 
            AWSShapeMember(label: "healthyThreshold", required: false, type: .integer), 
            AWSShapeMember(label: "path", required: false, type: .string), 
            AWSShapeMember(label: "timeoutMillis", required: false, type: .long)
        ]
        /// The time period in milliseconds between each health check execution.
        public let intervalMillis: Int64?
        /// The number of consecutive failed health checks that must occur before declaring a
        ///          virtual node unhealthy. 
        public let unhealthyThreshold: Int32?
        /// The protocol for the health check request.
        public let `protocol`: PortProtocol?
        /// The destination port for the health check request.
        public let port: Int32?
        /// The number of consecutive successful health checks that must occur before declaring
        ///          listener healthy.
        public let healthyThreshold: Int32?
        /// The destination path for the health check request.
        public let path: String?
        /// The amount of time to wait when receiving a response from the health check, in
        ///          milliseconds.
        public let timeoutMillis: Int64?

        public init(intervalMillis: Int64? = nil, unhealthyThreshold: Int32? = nil, protocol: PortProtocol? = nil, port: Int32? = nil, healthyThreshold: Int32? = nil, path: String? = nil, timeoutMillis: Int64? = nil) {
            self.intervalMillis = intervalMillis
            self.unhealthyThreshold = unhealthyThreshold
            self.`protocol` = `protocol`
            self.port = port
            self.healthyThreshold = healthyThreshold
            self.path = path
            self.timeoutMillis = timeoutMillis
        }

        private enum CodingKeys: String, CodingKey {
            case intervalMillis = "intervalMillis"
            case unhealthyThreshold = "unhealthyThreshold"
            case `protocol` = "protocol"
            case port = "port"
            case healthyThreshold = "healthyThreshold"
            case path = "path"
            case timeoutMillis = "timeoutMillis"
        }
    }

    public struct UpdateRouteOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "route"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "route", required: false, type: .structure)
        ]
        /// A full description of the route that was updated.
        public let route: RouteData?

        public init(route: RouteData? = nil) {
            self.route = route
        }

        private enum CodingKeys: String, CodingKey {
            case route = "route"
        }
    }

    public struct MeshRef: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: false, type: .string)
        ]
        /// The name of the service mesh.
        public let meshName: String?
        /// The full Amazon Resource Name (ARN) of the service mesh.
        public let arn: String?

        public init(meshName: String? = nil, arn: String? = nil) {
            self.meshName = meshName
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case arn = "arn"
        }
    }

    public struct DescribeRouteOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "route"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "route", required: false, type: .structure)
        ]
        /// The full description of your route.
        public let route: RouteData?

        public init(route: RouteData? = nil) {
            self.route = route
        }

        private enum CodingKeys: String, CodingKey {
            case route = "route"
        }
    }

    public struct DescribeVirtualNodeOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualNode"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualNode", required: false, type: .structure)
        ]
        /// The full description of your virtual node.
        public let virtualNode: VirtualNodeData?

        public init(virtualNode: VirtualNodeData? = nil) {
            self.virtualNode = virtualNode
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode = "virtualNode"
        }
    }

    public struct VirtualRouterRef: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", required: false, type: .string), 
            AWSShapeMember(label: "virtualRouterName", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: false, type: .string)
        ]
        /// The name of the service mesh in which the virtual router resides.
        public let meshName: String?
        /// The name of the virtual router.
        public let virtualRouterName: String?
        /// The full Amazon Resource Name (ARN) for the virtual router.
        public let arn: String?

        public init(meshName: String? = nil, virtualRouterName: String? = nil, arn: String? = nil) {
            self.meshName = meshName
            self.virtualRouterName = virtualRouterName
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case virtualRouterName = "virtualRouterName"
            case arn = "arn"
        }
    }

    public struct ListVirtualRoutersInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "limit", location: .querystring(locationName: "limit"), required: false, type: .integer), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string)
        ]
        /// The maximum number of mesh results returned by ListVirtualRouters in
        ///          paginated output. When this parameter is used, ListVirtualRouters only returns
        ///          limit results in a single page along with a nextToken
        ///          response element. The remaining results of the initial request can be seen by sending
        ///          another ListVirtualRouters request with the returned nextToken
        ///          value. This value can be between 1 and 100. If this
        ///          parameter is not used, then ListVirtualRouters returns up to
        ///          100 results and a nextToken value if applicable.
        public let limit: Int32?
        /// The name of the service mesh in which to list virtual routers.
        public let meshName: String
        /// The nextToken value returned from a previous paginated
        ///          ListVirtualRouters request where limit was used and the
        ///          results exceeded the value of that parameter. Pagination continues from the end of the
        ///          previous results that returned the nextToken value.
        public let nextToken: String?

        public init(limit: Int32? = nil, meshName: String, nextToken: String? = nil) {
            self.limit = limit
            self.meshName = meshName
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "limit"
            case meshName = "meshName"
            case nextToken = "nextToken"
        }
    }

    public struct CreateVirtualRouterOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualRouter"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualRouter", required: false, type: .structure)
        ]
        /// The full description of your virtual router following the create call.
        public let virtualRouter: VirtualRouterData?

        public init(virtualRouter: VirtualRouterData? = nil) {
            self.virtualRouter = virtualRouter
        }

        private enum CodingKeys: String, CodingKey {
            case virtualRouter = "virtualRouter"
        }
    }

    public enum VirtualRouterStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public struct DeleteMeshOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "mesh"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "mesh", required: false, type: .structure)
        ]
        /// The service mesh that was deleted.
        public let mesh: MeshData?

        public init(mesh: MeshData? = nil) {
            self.mesh = mesh
        }

        private enum CodingKeys: String, CodingKey {
            case mesh = "mesh"
        }
    }

    public struct DescribeMeshInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string)
        ]
        /// The name of the service mesh to describe.
        public let meshName: String

        public init(meshName: String) {
            self.meshName = meshName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
        }
    }

    public struct MeshData: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "status", required: false, type: .structure), 
            AWSShapeMember(label: "metadata", required: true, type: .structure), 
            AWSShapeMember(label: "meshName", required: true, type: .string)
        ]
        /// The status of the service mesh.
        public let status: MeshStatus?
        /// The associated metadata for the service mesh.
        public let metadata: ResourceMetadata
        /// The name of the service mesh.
        public let meshName: String

        public init(status: MeshStatus? = nil, metadata: ResourceMetadata, meshName: String) {
            self.status = status
            self.metadata = metadata
            self.meshName = meshName
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case metadata = "metadata"
            case meshName = "meshName"
        }
    }

    public struct VirtualNodeRef: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualNodeName", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "meshName", required: false, type: .string)
        ]
        /// The name of the virtual node.
        public let virtualNodeName: String?
        /// The full Amazon Resource Name (ARN) for the virtual node.
        public let arn: String?
        /// The name of the service mesh in which the virtual node resides.
        public let meshName: String?

        public init(virtualNodeName: String? = nil, arn: String? = nil, meshName: String? = nil) {
            self.virtualNodeName = virtualNodeName
            self.arn = arn
            self.meshName = meshName
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNodeName = "virtualNodeName"
            case arn = "arn"
            case meshName = "meshName"
        }
    }

    public struct VirtualNodeData: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualNodeName", required: true, type: .string), 
            AWSShapeMember(label: "spec", required: false, type: .structure), 
            AWSShapeMember(label: "meshName", required: true, type: .string), 
            AWSShapeMember(label: "metadata", required: false, type: .structure), 
            AWSShapeMember(label: "status", required: false, type: .structure)
        ]
        /// The name of the virtual node.
        public let virtualNodeName: String
        /// The specifications of the virtual node.
        public let spec: VirtualNodeSpec?
        /// The name of the service mesh in which the virtual node resides.
        public let meshName: String
        /// The associated metadata for the virtual node.
        public let metadata: ResourceMetadata?
        /// The current status for the virtual node.
        public let status: VirtualNodeStatus?

        public init(virtualNodeName: String, spec: VirtualNodeSpec? = nil, meshName: String, metadata: ResourceMetadata? = nil, status: VirtualNodeStatus? = nil) {
            self.virtualNodeName = virtualNodeName
            self.spec = spec
            self.meshName = meshName
            self.metadata = metadata
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNodeName = "virtualNodeName"
            case spec = "spec"
            case meshName = "meshName"
            case metadata = "metadata"
            case status = "status"
        }
    }

    public struct ListMeshesInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "limit", location: .querystring(locationName: "limit"), required: false, type: .integer)
        ]
        /// The nextToken value returned from a previous paginated
        ///          ListMeshes request where limit was used and the
        ///          results exceeded the value of that parameter. Pagination continues from the end of the
        ///          previous results that returned the nextToken value.
        ///          
        ///             This token should be treated as an opaque identifier that is only used to
        ///                 retrieve the next items in a list and not for other programmatic purposes.
        ///         
        public let nextToken: String?
        /// The maximum number of mesh results returned by ListMeshes in paginated
        ///          output. When this parameter is used, ListMeshes only returns
        ///             limit results in a single page along with a nextToken response
        ///          element. The remaining results of the initial request can be seen by sending another
        ///             ListMeshes request with the returned nextToken value. This
        ///          value can be between 1 and 100. If this parameter is not
        ///          used, then ListMeshes returns up to 100 results and a
        ///             nextToken value if applicable.
        public let limit: Int32?

        public init(nextToken: String? = nil, limit: Int32? = nil) {
            self.nextToken = nextToken
            self.limit = limit
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case limit = "limit"
        }
    }

    public struct VirtualNodeStatus: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "status", required: false, type: .enum)
        ]
        /// The current status of the virtual node.
        public let status: VirtualNodeStatusCode?

        public init(status: VirtualNodeStatusCode? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct DescribeRouteInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "routeName", location: .uri(locationName: "routeName"), required: true, type: .string), 
            AWSShapeMember(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"), required: true, type: .string), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string)
        ]
        /// The name of the route to describe.
        public let routeName: String
        /// The name of the virtual router with which the route is associated.
        public let virtualRouterName: String
        /// The name of the service mesh in which the route resides.
        public let meshName: String

        public init(routeName: String, virtualRouterName: String, meshName: String) {
            self.routeName = routeName
            self.virtualRouterName = virtualRouterName
            self.meshName = meshName
        }

        private enum CodingKeys: String, CodingKey {
            case routeName = "routeName"
            case virtualRouterName = "virtualRouterName"
            case meshName = "meshName"
        }
    }

    public struct CreateVirtualNodeInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "virtualNodeName", required: true, type: .string), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "clientToken", required: false, type: .string)
        ]
        /// The name of the service mesh in which to create the virtual node.
        public let meshName: String
        /// The name to use for the virtual node.
        public let virtualNodeName: String
        /// The virtual node specification to apply.
        public let spec: VirtualNodeSpec
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?

        public init(meshName: String, virtualNodeName: String, spec: VirtualNodeSpec, clientToken: String? = nil) {
            self.meshName = meshName
            self.virtualNodeName = virtualNodeName
            self.spec = spec
            self.clientToken = clientToken
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case virtualNodeName = "virtualNodeName"
            case spec = "spec"
            case clientToken = "clientToken"
        }
    }

    public enum VirtualNodeStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public struct UpdateRouteInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"), required: true, type: .string), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "clientToken", required: false, type: .string), 
            AWSShapeMember(label: "routeName", location: .uri(locationName: "routeName"), required: true, type: .string)
        ]
        /// The new route specification to apply. This overwrites the existing data.
        public let spec: RouteSpec
        /// The name of the virtual router with which the route is associated.
        public let virtualRouterName: String
        /// The name of the service mesh in which the route resides.
        public let meshName: String
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the route to update.
        public let routeName: String

        public init(spec: RouteSpec, virtualRouterName: String, meshName: String, clientToken: String? = nil, routeName: String) {
            self.spec = spec
            self.virtualRouterName = virtualRouterName
            self.meshName = meshName
            self.clientToken = clientToken
            self.routeName = routeName
        }

        private enum CodingKeys: String, CodingKey {
            case spec = "spec"
            case virtualRouterName = "virtualRouterName"
            case meshName = "meshName"
            case clientToken = "clientToken"
            case routeName = "routeName"
        }
    }

    public struct ListRoutesInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"), required: true, type: .string), 
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "limit", location: .querystring(locationName: "limit"), required: false, type: .integer)
        ]
        /// The name of the service mesh in which to list routes.
        public let meshName: String
        /// The name of the virtual router in which to list routes.
        public let virtualRouterName: String
        /// The nextToken value returned from a previous paginated
        ///          ListRoutes request where limit was used and the
        ///          results exceeded the value of that parameter. Pagination continues from the end of the
        ///          previous results that returned the nextToken value.
        public let nextToken: String?
        /// The maximum number of mesh results returned by ListRoutes in paginated
        ///          output. When this parameter is used, ListRoutes only returns
        ///             limit results in a single page along with a nextToken response
        ///          element. The remaining results of the initial request can be seen by sending another
        ///             ListRoutes request with the returned nextToken value. This
        ///          value can be between 1 and 100. If this parameter is not
        ///          used, then ListRoutes returns up to 100 results and a
        ///             nextToken value if applicable.
        public let limit: Int32?

        public init(meshName: String, virtualRouterName: String, nextToken: String? = nil, limit: Int32? = nil) {
            self.meshName = meshName
            self.virtualRouterName = virtualRouterName
            self.nextToken = nextToken
            self.limit = limit
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case virtualRouterName = "virtualRouterName"
            case nextToken = "nextToken"
            case limit = "limit"
        }
    }

    public struct VirtualNodeSpec: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "listeners", required: false, type: .list), 
            AWSShapeMember(label: "serviceDiscovery", required: false, type: .structure), 
            AWSShapeMember(label: "backends", required: false, type: .list)
        ]
        /// The listeners from which the virtual node is expected to receive inbound traffic.
        public let listeners: [Listener]?
        /// The service discovery information for the virtual node.
        public let serviceDiscovery: ServiceDiscovery?
        /// The backends to which the virtual node is expected to send outbound traffic.
        public let backends: [String]?

        public init(listeners: [Listener]? = nil, serviceDiscovery: ServiceDiscovery? = nil, backends: [String]? = nil) {
            self.listeners = listeners
            self.serviceDiscovery = serviceDiscovery
            self.backends = backends
        }

        private enum CodingKeys: String, CodingKey {
            case listeners = "listeners"
            case serviceDiscovery = "serviceDiscovery"
            case backends = "backends"
        }
    }

    public struct DeleteRouteInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"), required: true, type: .string), 
            AWSShapeMember(label: "routeName", location: .uri(locationName: "routeName"), required: true, type: .string)
        ]
        /// The name of the service mesh in which to delete the route.
        public let meshName: String
        /// The name of the virtual router in which to delete the route.
        public let virtualRouterName: String
        /// The name of the route to delete.
        public let routeName: String

        public init(meshName: String, virtualRouterName: String, routeName: String) {
            self.meshName = meshName
            self.virtualRouterName = virtualRouterName
            self.routeName = routeName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case virtualRouterName = "virtualRouterName"
            case routeName = "routeName"
        }
    }

    public struct ListVirtualNodesInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "limit", location: .querystring(locationName: "limit"), required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string)
        ]
        /// The maximum number of mesh results returned by ListVirtualNodes in
        ///          paginated output. When this parameter is used, ListVirtualNodes only returns
        ///          limit results in a single page along with a nextToken
        ///          response element. The remaining results of the initial request can be seen by sending
        ///          another ListVirtualNodes request with the returned nextToken
        ///          value. This value can be between 1 and 100. If this
        ///          parameter is not used, then ListVirtualNodes returns up to
        ///          100 results and a nextToken value if applicable.
        public let limit: Int32?
        /// The nextToken value returned from a previous paginated
        ///          ListVirtualNodes request where limit was used and the
        ///          results exceeded the value of that parameter. Pagination continues from the end of the
        ///          previous results that returned the nextToken value.
        public let nextToken: String?
        /// The name of the service mesh in which to list virtual nodes.
        public let meshName: String

        public init(limit: Int32? = nil, nextToken: String? = nil, meshName: String) {
            self.limit = limit
            self.nextToken = nextToken
            self.meshName = meshName
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "limit"
            case nextToken = "nextToken"
            case meshName = "meshName"
        }
    }

    public struct ListMeshesOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshes", required: true, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// The list of existing service meshes.
        public let meshes: [MeshRef]
        /// The nextToken value to include in a future ListMeshes
        ///          request. When the results of a ListMeshes request exceed
        ///          limit, this value can be used to retrieve the next page of
        ///          results. This value is null when there are no more results to
        ///          return.
        public let nextToken: String?

        public init(meshes: [MeshRef], nextToken: String? = nil) {
            self.meshes = meshes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case meshes = "meshes"
            case nextToken = "nextToken"
        }
    }

    public struct ListVirtualRoutersOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "virtualRouters", required: true, type: .list)
        ]
        /// The nextToken value to include in a future ListVirtualRouters
        ///          request. When the results of a ListVirtualRouters request exceed
        ///          limit, this value can be used to retrieve the next page of
        ///          results. This value is null when there are no more results to
        ///          return.
        public let nextToken: String?
        /// The list of existing virtual routers for the specified service mesh.
        public let virtualRouters: [VirtualRouterRef]

        public init(nextToken: String? = nil, virtualRouters: [VirtualRouterRef]) {
            self.nextToken = nextToken
            self.virtualRouters = virtualRouters
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case virtualRouters = "virtualRouters"
        }
    }

    public struct VirtualRouterStatus: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "status", required: false, type: .enum)
        ]
        /// The current status of the virtual router.
        public let status: VirtualRouterStatusCode?

        public init(status: VirtualRouterStatusCode? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct DeleteRouteOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "route"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "route", required: false, type: .structure)
        ]
        /// The route that was deleted.
        public let route: RouteData?

        public init(route: RouteData? = nil) {
            self.route = route
        }

        private enum CodingKeys: String, CodingKey {
            case route = "route"
        }
    }

    public struct MeshStatus: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "status", required: false, type: .enum)
        ]
        /// The current mesh status.
        public let status: MeshStatusCode?

        public init(status: MeshStatusCode? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct CreateRouteInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"), required: true, type: .string), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "routeName", required: true, type: .string), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "clientToken", required: false, type: .string)
        ]
        /// The name of the virtual router in which to create the route.
        public let virtualRouterName: String
        /// The route specification to apply.
        public let spec: RouteSpec
        /// The name to use for the route.
        public let routeName: String
        /// The name of the service mesh in which to create the route.
        public let meshName: String
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?

        public init(virtualRouterName: String, spec: RouteSpec, routeName: String, meshName: String, clientToken: String? = nil) {
            self.virtualRouterName = virtualRouterName
            self.spec = spec
            self.routeName = routeName
            self.meshName = meshName
            self.clientToken = clientToken
        }

        private enum CodingKeys: String, CodingKey {
            case virtualRouterName = "virtualRouterName"
            case spec = "spec"
            case routeName = "routeName"
            case meshName = "meshName"
            case clientToken = "clientToken"
        }
    }

    public struct DescribeVirtualNodeInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "virtualNodeName", location: .uri(locationName: "virtualNodeName"), required: true, type: .string)
        ]
        /// The name of the service mesh in which the virtual node resides.
        public let meshName: String
        /// The name of the virtual node to describe.
        public let virtualNodeName: String

        public init(meshName: String, virtualNodeName: String) {
            self.meshName = meshName
            self.virtualNodeName = virtualNodeName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case virtualNodeName = "virtualNodeName"
        }
    }

    public struct UpdateVirtualNodeOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualNode"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualNode", required: false, type: .structure)
        ]
        /// A full description of the virtual node that was updated.
        public let virtualNode: VirtualNodeData?

        public init(virtualNode: VirtualNodeData? = nil) {
            self.virtualNode = virtualNode
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode = "virtualNode"
        }
    }

    public struct DeleteMeshInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string)
        ]
        /// The name of the service mesh to delete.
        public let meshName: String

        public init(meshName: String) {
            self.meshName = meshName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
        }
    }

    public struct RouteRef: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualRouterName", required: false, type: .string), 
            AWSShapeMember(label: "routeName", required: false, type: .string), 
            AWSShapeMember(label: "meshName", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: false, type: .string)
        ]
        /// The virtual router with which the route is associated.
        public let virtualRouterName: String?
        /// The name of the route.
        public let routeName: String?
        /// The name of the service mesh in which the route resides.
        public let meshName: String?
        /// The full Amazon Resource Name (ARN) for the route.
        public let arn: String?

        public init(virtualRouterName: String? = nil, routeName: String? = nil, meshName: String? = nil, arn: String? = nil) {
            self.virtualRouterName = virtualRouterName
            self.routeName = routeName
            self.meshName = meshName
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case virtualRouterName = "virtualRouterName"
            case routeName = "routeName"
            case meshName = "meshName"
            case arn = "arn"
        }
    }

    public struct WeightedTarget: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualNode", required: false, type: .string), 
            AWSShapeMember(label: "weight", required: false, type: .integer)
        ]
        /// The virtual node to associate with the weighted target.
        public let virtualNode: String?
        /// The relative weight of the weighted target.
        public let weight: Int32?

        public init(virtualNode: String? = nil, weight: Int32? = nil) {
            self.virtualNode = virtualNode
            self.weight = weight
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode = "virtualNode"
            case weight = "weight"
        }
    }

    public struct ResourceMetadata: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "createdAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "version", required: false, type: .long), 
            AWSShapeMember(label: "uid", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedAt", required: false, type: .timestamp)
        ]
        /// The Unix epoch timestamp in seconds for when the cluster was created.
        public let createdAt: TimeStamp?
        /// The full Amazon Resource Name (ARN) for the resource.
        ///          
        ///             After you create a virtual node, set this value (either the full ARN or the
        ///             truncated resource name, for example, mesh/default/virtualNode/simpleapp,
        ///             as the APPMESH_VIRTUAL_NODE_NAME environment variable for your task group's
        ///             Envoy proxy container in your task definition or pod spec. This is then mapped to the
        ///                node.id and node.cluster Envoy parameters.
        ///             If you require your Envoy stats or tracing to use a different name, you can override
        ///             the node.cluster value that is set by
        ///                APPMESH_VIRTUAL_NODE_NAME with the
        ///                APPMESH_VIRTUAL_NODE_CLUSTER environment variable.
        ///          
        public let arn: String?
        /// The version of the resource. Resources are created at version 1, and this version is
        ///          incremented each time they are updated.
        public let version: Int64?
        /// The unique identifier for the resource.
        public let uid: String?
        /// The Unix epoch timestamp in seconds for when the cluster was last updated.
        public let lastUpdatedAt: TimeStamp?

        public init(createdAt: TimeStamp? = nil, arn: String? = nil, version: Int64? = nil, uid: String? = nil, lastUpdatedAt: TimeStamp? = nil) {
            self.createdAt = createdAt
            self.arn = arn
            self.version = version
            self.uid = uid
            self.lastUpdatedAt = lastUpdatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case arn = "arn"
            case version = "version"
            case uid = "uid"
            case lastUpdatedAt = "lastUpdatedAt"
        }
    }

    public struct DeleteVirtualNodeOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualNode"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualNode", required: false, type: .structure)
        ]
        /// The virtual node that was deleted.
        public let virtualNode: VirtualNodeData?

        public init(virtualNode: VirtualNodeData? = nil) {
            self.virtualNode = virtualNode
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode = "virtualNode"
        }
    }

    public struct DescribeMeshOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "mesh"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "mesh", required: false, type: .structure)
        ]
        /// The full description of your service mesh.
        public let mesh: MeshData?

        public init(mesh: MeshData? = nil) {
            self.mesh = mesh
        }

        private enum CodingKeys: String, CodingKey {
            case mesh = "mesh"
        }
    }

    public struct UpdateVirtualNodeInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "virtualNodeName", location: .uri(locationName: "virtualNodeName"), required: true, type: .string), 
            AWSShapeMember(label: "clientToken", required: false, type: .string)
        ]
        /// The new virtual node specification to apply. This overwrites the existing data.
        public let spec: VirtualNodeSpec
        /// The name of the service mesh in which the virtual node resides.
        public let meshName: String
        /// The name of the virtual node to update.
        public let virtualNodeName: String
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?

        public init(spec: VirtualNodeSpec, meshName: String, virtualNodeName: String, clientToken: String? = nil) {
            self.spec = spec
            self.meshName = meshName
            self.virtualNodeName = virtualNodeName
            self.clientToken = clientToken
        }

        private enum CodingKeys: String, CodingKey {
            case spec = "spec"
            case meshName = "meshName"
            case virtualNodeName = "virtualNodeName"
            case clientToken = "clientToken"
        }
    }

    public enum PortProtocol: String, CustomStringConvertible, Codable {
        case http = "http"
        case tcp = "tcp"
        public var description: String { return self.rawValue }
    }

    public struct UpdateVirtualRouterInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"), required: true, type: .string), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "clientToken", required: false, type: .string)
        ]
        /// The new virtual router specification to apply. This overwrites the existing data.
        public let spec: VirtualRouterSpec
        /// The name of the virtual router to update.
        public let virtualRouterName: String
        /// The name of the service mesh in which the virtual router resides.
        public let meshName: String
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?

        public init(spec: VirtualRouterSpec, virtualRouterName: String, meshName: String, clientToken: String? = nil) {
            self.spec = spec
            self.virtualRouterName = virtualRouterName
            self.meshName = meshName
            self.clientToken = clientToken
        }

        private enum CodingKeys: String, CodingKey {
            case spec = "spec"
            case virtualRouterName = "virtualRouterName"
            case meshName = "meshName"
            case clientToken = "clientToken"
        }
    }

    public struct VirtualRouterData: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualRouterName", required: true, type: .string), 
            AWSShapeMember(label: "metadata", required: false, type: .structure), 
            AWSShapeMember(label: "spec", required: false, type: .structure), 
            AWSShapeMember(label: "status", required: false, type: .structure), 
            AWSShapeMember(label: "meshName", required: true, type: .string)
        ]
        /// The name of the virtual router.
        public let virtualRouterName: String
        /// The associated metadata for the virtual router.
        public let metadata: ResourceMetadata?
        /// The specifications of the virtual router.
        public let spec: VirtualRouterSpec?
        /// The current status of the virtual router.
        public let status: VirtualRouterStatus?
        /// The name of the service mesh in which the virtual router resides.
        public let meshName: String

        public init(virtualRouterName: String, metadata: ResourceMetadata? = nil, spec: VirtualRouterSpec? = nil, status: VirtualRouterStatus? = nil, meshName: String) {
            self.virtualRouterName = virtualRouterName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.meshName = meshName
        }

        private enum CodingKeys: String, CodingKey {
            case virtualRouterName = "virtualRouterName"
            case metadata = "metadata"
            case spec = "spec"
            case status = "status"
            case meshName = "meshName"
        }
    }

    public struct VirtualRouterSpec: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "serviceNames", required: false, type: .list)
        ]
        /// The service mesh service names to associate with the virtual router.
        public let serviceNames: [String]?

        public init(serviceNames: [String]? = nil) {
            self.serviceNames = serviceNames
        }

        private enum CodingKeys: String, CodingKey {
            case serviceNames = "serviceNames"
        }
    }

    public struct CreateVirtualRouterInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientToken", required: false, type: .string), 
            AWSShapeMember(label: "virtualRouterName", required: true, type: .string), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string)
        ]
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name to use for the virtual router.
        public let virtualRouterName: String
        /// The virtual router specification to apply.
        public let spec: VirtualRouterSpec
        /// The name of the service mesh in which to create the virtual router.
        public let meshName: String

        public init(clientToken: String? = nil, virtualRouterName: String, spec: VirtualRouterSpec, meshName: String) {
            self.clientToken = clientToken
            self.virtualRouterName = virtualRouterName
            self.spec = spec
            self.meshName = meshName
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case virtualRouterName = "virtualRouterName"
            case spec = "spec"
            case meshName = "meshName"
        }
    }

    public struct DeleteVirtualRouterOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualRouter"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualRouter", required: false, type: .structure)
        ]
        /// The virtual router that was deleted.
        public let virtualRouter: VirtualRouterData?

        public init(virtualRouter: VirtualRouterData? = nil) {
            self.virtualRouter = virtualRouter
        }

        private enum CodingKeys: String, CodingKey {
            case virtualRouter = "virtualRouter"
        }
    }

    public struct DeleteVirtualRouterInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"), required: true, type: .string)
        ]
        /// The name of the service mesh in which to delete the virtual router.
        public let meshName: String
        /// The name of the virtual router to delete.
        public let virtualRouterName: String

        public init(meshName: String, virtualRouterName: String) {
            self.meshName = meshName
            self.virtualRouterName = virtualRouterName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct ListRoutesOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "routes", required: true, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// The list of existing routes for the specified service mesh and virtual router.
        public let routes: [RouteRef]
        /// The nextToken value to include in a future ListRoutes
        ///          request. When the results of a ListRoutes request exceed
        ///          limit, this value can be used to retrieve the next page of
        ///          results. This value is null when there are no more results to
        ///          return.
        public let nextToken: String?

        public init(routes: [RouteRef], nextToken: String? = nil) {
            self.routes = routes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case routes = "routes"
            case nextToken = "nextToken"
        }
    }

    public struct RouteData: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "routeName", required: true, type: .string), 
            AWSShapeMember(label: "virtualRouterName", required: true, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .structure), 
            AWSShapeMember(label: "spec", required: false, type: .structure), 
            AWSShapeMember(label: "meshName", required: true, type: .string), 
            AWSShapeMember(label: "metadata", required: false, type: .structure)
        ]
        /// The name of the route.
        public let routeName: String
        /// The virtual router with which the route is associated.
        public let virtualRouterName: String
        /// The status of the route.
        public let status: RouteStatus?
        /// The specifications of the route.
        public let spec: RouteSpec?
        /// The name of the service mesh in which the route resides.
        public let meshName: String
        /// The associated metadata for the route.
        public let metadata: ResourceMetadata?

        public init(routeName: String, virtualRouterName: String, status: RouteStatus? = nil, spec: RouteSpec? = nil, meshName: String, metadata: ResourceMetadata? = nil) {
            self.routeName = routeName
            self.virtualRouterName = virtualRouterName
            self.status = status
            self.spec = spec
            self.meshName = meshName
            self.metadata = metadata
        }

        private enum CodingKeys: String, CodingKey {
            case routeName = "routeName"
            case virtualRouterName = "virtualRouterName"
            case status = "status"
            case spec = "spec"
            case meshName = "meshName"
            case metadata = "metadata"
        }
    }

    public struct ListVirtualNodesOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualNodes", required: true, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// The list of existing virtual nodes for the specified service mesh.
        public let virtualNodes: [VirtualNodeRef]
        /// The nextToken value to include in a future ListVirtualNodes
        ///          request. When the results of a ListVirtualNodes request exceed
        ///          limit, this value can be used to retrieve the next page of
        ///          results. This value is null when there are no more results to
        ///          return.
        public let nextToken: String?

        public init(virtualNodes: [VirtualNodeRef], nextToken: String? = nil) {
            self.virtualNodes = virtualNodes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNodes = "virtualNodes"
            case nextToken = "nextToken"
        }
    }

    public struct Listener: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "portMapping", required: false, type: .structure), 
            AWSShapeMember(label: "healthCheck", required: false, type: .structure)
        ]
        /// The port mapping information for the listener.
        public let portMapping: PortMapping?
        /// The health check information for the listener.
        ///          
        ///             Listener health checks are not available during the App Mesh preview.
        ///          
        public let healthCheck: HealthCheckPolicy?

        public init(portMapping: PortMapping? = nil, healthCheck: HealthCheckPolicy? = nil) {
            self.portMapping = portMapping
            self.healthCheck = healthCheck
        }

        private enum CodingKeys: String, CodingKey {
            case portMapping = "portMapping"
            case healthCheck = "healthCheck"
        }
    }

    public struct DnsServiceDiscovery: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "serviceName", required: false, type: .string)
        ]
        /// The DNS service name for your virtual node.
        public let serviceName: String?

        public init(serviceName: String? = nil) {
            self.serviceName = serviceName
        }

        private enum CodingKeys: String, CodingKey {
            case serviceName = "serviceName"
        }
    }

    public struct CreateRouteOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "route"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "route", required: false, type: .structure)
        ]
        /// The full description of your mesh following the create call.
        public let route: RouteData?

        public init(route: RouteData? = nil) {
            self.route = route
        }

        private enum CodingKeys: String, CodingKey {
            case route = "route"
        }
    }

    public struct CreateMeshInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", required: true, type: .string), 
            AWSShapeMember(label: "clientToken", required: false, type: .string)
        ]
        /// The name to use for the service mesh.
        public let meshName: String
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?

        public init(meshName: String, clientToken: String? = nil) {
            self.meshName = meshName
            self.clientToken = clientToken
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case clientToken = "clientToken"
        }
    }

    public struct CreateMeshOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "mesh"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "mesh", required: false, type: .structure)
        ]
        /// The full description of your service mesh following the create call.
        public let mesh: MeshData?

        public init(mesh: MeshData? = nil) {
            self.mesh = mesh
        }

        private enum CodingKeys: String, CodingKey {
            case mesh = "mesh"
        }
    }

    public struct RouteSpec: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "httpRoute", required: false, type: .structure)
        ]
        /// The HTTP routing information for the route.
        public let httpRoute: HttpRoute?

        public init(httpRoute: HttpRoute? = nil) {
            self.httpRoute = httpRoute
        }

        private enum CodingKeys: String, CodingKey {
            case httpRoute = "httpRoute"
        }
    }

    public struct HttpRouteAction: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "weightedTargets", required: false, type: .list)
        ]
        /// The targets that traffic is routed to when a request matches the route. You can specify
        ///          one or more targets and their relative weights with which to distribute traffic.
        public let weightedTargets: [WeightedTarget]?

        public init(weightedTargets: [WeightedTarget]? = nil) {
            self.weightedTargets = weightedTargets
        }

        private enum CodingKeys: String, CodingKey {
            case weightedTargets = "weightedTargets"
        }
    }

    public struct ServiceDiscovery: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "dns", required: false, type: .structure)
        ]
        /// Specifies the DNS service name for the virtual node.
        public let dns: DnsServiceDiscovery?

        public init(dns: DnsServiceDiscovery? = nil) {
            self.dns = dns
        }

        private enum CodingKeys: String, CodingKey {
            case dns = "dns"
        }
    }

    public struct PortMapping: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "port", required: false, type: .integer), 
            AWSShapeMember(label: "protocol", required: false, type: .enum)
        ]
        /// The port used for the port mapping.
        public let port: Int32?
        /// The protocol used for the port mapping.
        public let `protocol`: PortProtocol?

        public init(port: Int32? = nil, protocol: PortProtocol? = nil) {
            self.port = port
            self.`protocol` = `protocol`
        }

        private enum CodingKeys: String, CodingKey {
            case port = "port"
            case `protocol` = "protocol"
        }
    }

    public struct HttpRouteMatch: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "prefix", required: false, type: .string)
        ]
        /// Specifies the path with which to match requests. This parameter must always start with
        ///             /, which by itself matches all requests to the virtual router service name.
        ///          You can also match for path-based routing of requests. For example, if your virtual router
        ///          service name is my-service.local, and you want the route to match requests to
        ///             my-service.local/metrics, then your prefix should be
        ///          /metrics.
        public let prefix: String?

        public init(prefix: String? = nil) {
            self.prefix = prefix
        }

        private enum CodingKeys: String, CodingKey {
            case prefix = "prefix"
        }
    }

    public enum MeshStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public struct DescribeVirtualRouterOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualRouter"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualRouter", required: false, type: .structure)
        ]
        /// The full description of your virtual router.
        public let virtualRouter: VirtualRouterData?

        public init(virtualRouter: VirtualRouterData? = nil) {
            self.virtualRouter = virtualRouter
        }

        private enum CodingKeys: String, CodingKey {
            case virtualRouter = "virtualRouter"
        }
    }

    public struct DescribeVirtualRouterInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"), required: true, type: .string)
        ]
        /// The name of the service mesh in which the virtual router resides.
        public let meshName: String
        /// The name of the virtual router to describe.
        public let virtualRouterName: String

        public init(meshName: String, virtualRouterName: String) {
            self.meshName = meshName
            self.virtualRouterName = virtualRouterName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct DeleteVirtualNodeInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "virtualNodeName", location: .uri(locationName: "virtualNodeName"), required: true, type: .string)
        ]
        /// The name of the service mesh in which to delete the virtual node.
        public let meshName: String
        /// The name of the virtual node to delete.
        public let virtualNodeName: String

        public init(meshName: String, virtualNodeName: String) {
            self.meshName = meshName
            self.virtualNodeName = virtualNodeName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case virtualNodeName = "virtualNodeName"
        }
    }

    public struct CreateVirtualNodeOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualNode"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualNode", required: false, type: .structure)
        ]
        /// The full description of your virtual node following the create call.
        public let virtualNode: VirtualNodeData?

        public init(virtualNode: VirtualNodeData? = nil) {
            self.virtualNode = virtualNode
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode = "virtualNode"
        }
    }

    public struct RouteStatus: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "status", required: false, type: .enum)
        ]
        /// The current status for the route.
        public let status: RouteStatusCode?

        public init(status: RouteStatusCode? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct HttpRoute: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "match", required: false, type: .structure), 
            AWSShapeMember(label: "action", required: false, type: .structure)
        ]
        /// The criteria for determining an HTTP request match.
        public let match: HttpRouteMatch?
        /// The action to take if a match is determined.
        public let action: HttpRouteAction?

        public init(match: HttpRouteMatch? = nil, action: HttpRouteAction? = nil) {
            self.match = match
            self.action = action
        }

        private enum CodingKeys: String, CodingKey {
            case match = "match"
            case action = "action"
        }
    }

}