// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Devicefarm {

    public struct DeleteUploadResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ListDevicesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the project.
        public let arn: String?

        public init(nextToken: String? = nil, arn: String? = nil) {
            self.nextToken = nextToken
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            self.arn = dictionary["arn"] as? String
        }
    }

    public struct NetworkProfile: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public let uplinkJitterMs: Int64?
        /// The name of the network profile.
        public let name: String?
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public let downlinkJitterMs: Int64?
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public let downlinkDelayMs: Int64?
        /// Proportion of transmitted packets that fail to arrive from 0 to 100 percent.
        public let uplinkLossPercent: Int32?
        /// Proportion of received packets that fail to arrive from 0 to 100 percent.
        public let downlinkLossPercent: Int32?
        /// The description of the network profile.
        public let description: String?
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public let uplinkDelayMs: Int64?
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public let uplinkBandwidthBits: Int64?
        /// The type of network profile. Valid values are listed below.
        public let `type`: NetworkProfileType?
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public let downlinkBandwidthBits: Int64?
        /// The Amazon Resource Name (ARN) of the network profile.
        public let arn: String?

        public init(uplinkJitterMs: Int64? = nil, name: String? = nil, downlinkJitterMs: Int64? = nil, downlinkDelayMs: Int64? = nil, uplinkLossPercent: Int32? = nil, downlinkLossPercent: Int32? = nil, description: String? = nil, uplinkDelayMs: Int64? = nil, uplinkBandwidthBits: Int64? = nil, type: NetworkProfileType? = nil, downlinkBandwidthBits: Int64? = nil, arn: String? = nil) {
            self.uplinkJitterMs = uplinkJitterMs
            self.name = name
            self.downlinkJitterMs = downlinkJitterMs
            self.downlinkDelayMs = downlinkDelayMs
            self.uplinkLossPercent = uplinkLossPercent
            self.downlinkLossPercent = downlinkLossPercent
            self.description = description
            self.uplinkDelayMs = uplinkDelayMs
            self.uplinkBandwidthBits = uplinkBandwidthBits
            self.`type` = `type`
            self.downlinkBandwidthBits = downlinkBandwidthBits
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.uplinkJitterMs = dictionary["uplinkJitterMs"] as? Int64
            self.name = dictionary["name"] as? String
            self.downlinkJitterMs = dictionary["downlinkJitterMs"] as? Int64
            self.downlinkDelayMs = dictionary["downlinkDelayMs"] as? Int64
            self.uplinkLossPercent = dictionary["uplinkLossPercent"] as? Int32
            self.downlinkLossPercent = dictionary["downlinkLossPercent"] as? Int32
            self.description = dictionary["description"] as? String
            self.uplinkDelayMs = dictionary["uplinkDelayMs"] as? Int64
            self.uplinkBandwidthBits = dictionary["uplinkBandwidthBits"] as? Int64
            if let `type` = dictionary["type"] as? String { self.`type` = NetworkProfileType(rawValue: `type`) } else { self.`type` = nil }
            self.downlinkBandwidthBits = dictionary["downlinkBandwidthBits"] as? Int64
            self.arn = dictionary["arn"] as? String
        }
    }

    public struct GetTestResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A test condition that is evaluated.
        public let test: Test?

        public init(test: Test? = nil) {
            self.test = test
        }

        public init(dictionary: [String: Any]) throws {
            if let test = dictionary["test"] as? [String: Any] { self.test = try Devicefarm.Test(dictionary: test) } else { self.test = nil }
        }
    }

    public struct Rule: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The rule's stringified attribute. For example, specify the value as "\"abc\"". Allowed values include:   ARN: The ARN.   FORM_FACTOR: The form factor (for example, phone or tablet).   MANUFACTURER: The manufacturer.   PLATFORM: The platform (for example, Android or iOS).  
        public let attribute: DeviceAttribute?
        /// The rule's operator.   EQUALS: The equals operator.   GREATER_THAN: The greater-than operator.   IN: The in operator.   LESS_THAN: The less-than operator.   NOT_IN: The not-in operator.  
        public let `operator`: RuleOperator?
        /// The rule's value.
        public let value: String?

        public init(attribute: DeviceAttribute? = nil, operator: RuleOperator? = nil, value: String? = nil) {
            self.attribute = attribute
            self.`operator` = `operator`
            self.value = value
        }

        public init(dictionary: [String: Any]) throws {
            if let attribute = dictionary["attribute"] as? String { self.attribute = DeviceAttribute(rawValue: attribute) } else { self.attribute = nil }
            if let `operator` = dictionary["operator"] as? String { self.`operator` = RuleOperator(rawValue: `operator`) } else { self.`operator` = nil }
            self.value = dictionary["value"] as? String
        }
    }

    public struct ListTestsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The tests' ARNs.
        public let arn: String

        public init(nextToken: String? = nil, arn: String) {
            self.nextToken = nextToken
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct CreateRemoteAccessSessionConfiguration: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Returns the billing method for purposes of configuring a remote access session.
        public let billingMethod: BillingMethod?

        public init(billingMethod: BillingMethod? = nil) {
            self.billingMethod = billingMethod
        }

        public init(dictionary: [String: Any]) throws {
            if let billingMethod = dictionary["billingMethod"] as? String { self.billingMethod = BillingMethod(rawValue: billingMethod) } else { self.billingMethod = nil }
        }
    }

    public struct GetUploadResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An app or a set of one or more tests to upload or that have been uploaded.
        public let upload: Upload?

        public init(upload: Upload? = nil) {
            self.upload = upload
        }

        public init(dictionary: [String: Any]) throws {
            if let upload = dictionary["upload"] as? [String: Any] { self.upload = try Devicefarm.Upload(dictionary: upload) } else { self.upload = nil }
        }
    }

    public struct ListSuitesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the suites.
        public let suites: [Suite]?
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(suites: [Suite]? = nil, nextToken: String? = nil) {
            self.suites = suites
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let suites = dictionary["suites"] as? [[String: Any]] {
                self.suites = try suites.map({ try Suite(dictionary: $0) })
            } else { 
                self.suites = nil
            }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct ListRemoteAccessSessionsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// A container representing the metadata from the service about each remote access session you are requesting.
        public let remoteAccessSessions: [RemoteAccessSession]?

        public init(nextToken: String? = nil, remoteAccessSessions: [RemoteAccessSession]? = nil) {
            self.nextToken = nextToken
            self.remoteAccessSessions = remoteAccessSessions
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            if let remoteAccessSessions = dictionary["remoteAccessSessions"] as? [[String: Any]] {
                self.remoteAccessSessions = try remoteAccessSessions.map({ try RemoteAccessSession(dictionary: $0) })
            } else { 
                self.remoteAccessSessions = nil
            }
        }
    }

    public struct UpdateNetworkProfileRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public let uplinkJitterMs: Int64?
        /// The name of the network profile about which you are returning information.
        public let name: String?
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public let downlinkJitterMs: Int64?
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public let downlinkDelayMs: Int64?
        /// Proportion of transmitted packets that fail to arrive from 0 to 100 percent.
        public let uplinkLossPercent: Int32?
        /// Proportion of received packets that fail to arrive from 0 to 100 percent.
        public let downlinkLossPercent: Int32?
        /// The descriptoin of the network profile about which you are returning information.
        public let description: String?
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public let uplinkDelayMs: Int64?
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public let uplinkBandwidthBits: Int64?
        /// The type of network profile you wish to return information about. Valid values are listed below.
        public let `type`: NetworkProfileType?
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public let downlinkBandwidthBits: Int64?
        /// The Amazon Resource Name (ARN) of the project that you wish to update network profile settings.
        public let arn: String

        public init(uplinkJitterMs: Int64? = nil, name: String? = nil, downlinkJitterMs: Int64? = nil, downlinkDelayMs: Int64? = nil, uplinkLossPercent: Int32? = nil, downlinkLossPercent: Int32? = nil, description: String? = nil, uplinkDelayMs: Int64? = nil, uplinkBandwidthBits: Int64? = nil, type: NetworkProfileType? = nil, downlinkBandwidthBits: Int64? = nil, arn: String) {
            self.uplinkJitterMs = uplinkJitterMs
            self.name = name
            self.downlinkJitterMs = downlinkJitterMs
            self.downlinkDelayMs = downlinkDelayMs
            self.uplinkLossPercent = uplinkLossPercent
            self.downlinkLossPercent = downlinkLossPercent
            self.description = description
            self.uplinkDelayMs = uplinkDelayMs
            self.uplinkBandwidthBits = uplinkBandwidthBits
            self.`type` = `type`
            self.downlinkBandwidthBits = downlinkBandwidthBits
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.uplinkJitterMs = dictionary["uplinkJitterMs"] as? Int64
            self.name = dictionary["name"] as? String
            self.downlinkJitterMs = dictionary["downlinkJitterMs"] as? Int64
            self.downlinkDelayMs = dictionary["downlinkDelayMs"] as? Int64
            self.uplinkLossPercent = dictionary["uplinkLossPercent"] as? Int32
            self.downlinkLossPercent = dictionary["downlinkLossPercent"] as? Int32
            self.description = dictionary["description"] as? String
            self.uplinkDelayMs = dictionary["uplinkDelayMs"] as? Int64
            self.uplinkBandwidthBits = dictionary["uplinkBandwidthBits"] as? Int64
            if let `type` = dictionary["type"] as? String { self.`type` = NetworkProfileType(rawValue: `type`) } else { self.`type` = nil }
            self.downlinkBandwidthBits = dictionary["downlinkBandwidthBits"] as? Int64
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct GetDevicePoolResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An object containing information about the requested device pool.
        public let devicePool: DevicePool?

        public init(devicePool: DevicePool? = nil) {
            self.devicePool = devicePool
        }

        public init(dictionary: [String: Any]) throws {
            if let devicePool = dictionary["devicePool"] as? [String: Any] { self.devicePool = try Devicefarm.DevicePool(dictionary: devicePool) } else { self.devicePool = nil }
        }
    }

    public enum UploadStatus: String, CustomStringConvertible {
        case initialized = "INITIALIZED"
        case processing = "PROCESSING"
        case succeeded = "SUCCEEDED"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public struct DevicePool: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The device pool's description.
        public let description: String?
        /// The device pool's name.
        public let name: String?
        /// The device pool's type. Allowed values include:   CURATED: A device pool that is created and managed by AWS Device Farm.   PRIVATE: A device pool that is created and managed by the device pool developer.  
        public let `type`: DevicePoolType?
        /// Information about the device pool's rules.
        public let rules: [Rule]?
        /// The device pool's ARN.
        public let arn: String?

        public init(description: String? = nil, name: String? = nil, type: DevicePoolType? = nil, rules: [Rule]? = nil, arn: String? = nil) {
            self.description = description
            self.name = name
            self.`type` = `type`
            self.rules = rules
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.description = dictionary["description"] as? String
            self.name = dictionary["name"] as? String
            if let `type` = dictionary["type"] as? String { self.`type` = DevicePoolType(rawValue: `type`) } else { self.`type` = nil }
            if let rules = dictionary["rules"] as? [[String: Any]] {
                self.rules = try rules.map({ try Rule(dictionary: $0) })
            } else { 
                self.rules = nil
            }
            self.arn = dictionary["arn"] as? String
        }
    }

    public struct CreateProjectResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The newly created project.
        public let project: Project?

        public init(project: Project? = nil) {
            self.project = project
        }

        public init(dictionary: [String: Any]) throws {
            if let project = dictionary["project"] as? [String: Any] { self.project = try Devicefarm.Project(dictionary: project) } else { self.project = nil }
        }
    }

    public struct PurchaseOfferingResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Represents the offering transaction for the purchase result.
        public let offeringTransaction: OfferingTransaction?

        public init(offeringTransaction: OfferingTransaction? = nil) {
            self.offeringTransaction = offeringTransaction
        }

        public init(dictionary: [String: Any]) throws {
            if let offeringTransaction = dictionary["offeringTransaction"] as? [String: Any] { self.offeringTransaction = try Devicefarm.OfferingTransaction(dictionary: offeringTransaction) } else { self.offeringTransaction = nil }
        }
    }

    public struct ExecutionConfiguration: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The number of minutes a test run will execute before it times out.
        public let jobTimeoutMinutes: Int32?

        public init(jobTimeoutMinutes: Int32? = nil) {
            self.jobTimeoutMinutes = jobTimeoutMinutes
        }

        public init(dictionary: [String: Any]) throws {
            self.jobTimeoutMinutes = dictionary["jobTimeoutMinutes"] as? Int32
        }
    }

    public struct MonetaryAmount: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The currency code of a monetary amount. For example, USD means "U.S. dollars."
        public let currencyCode: CurrencyCode?
        /// The numerical amount of an offering or transaction.
        public let amount: Double?

        public init(currencyCode: CurrencyCode? = nil, amount: Double? = nil) {
            self.currencyCode = currencyCode
            self.amount = amount
        }

        public init(dictionary: [String: Any]) throws {
            if let currencyCode = dictionary["currencyCode"] as? String { self.currencyCode = CurrencyCode(rawValue: currencyCode) } else { self.currencyCode = nil }
            self.amount = dictionary["amount"] as? Double
        }
    }

    public struct CreateNetworkProfileRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public let uplinkJitterMs: Int64?
        /// The name you wish to specify for the new network profile.
        public let name: String
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public let downlinkJitterMs: Int64?
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public let downlinkDelayMs: Int64?
        /// Proportion of transmitted packets that fail to arrive from 0 to 100 percent.
        public let uplinkLossPercent: Int32?
        /// Proportion of received packets that fail to arrive from 0 to 100 percent.
        public let downlinkLossPercent: Int32?
        /// The description of the network profile.
        public let description: String?
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public let uplinkDelayMs: Int64?
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public let uplinkBandwidthBits: Int64?
        /// The type of network profile you wish to create. Valid values are listed below.
        public let `type`: NetworkProfileType?
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public let downlinkBandwidthBits: Int64?
        /// The Amazon Resource Name (ARN) of the project for which you want to create a network profile.
        public let projectArn: String

        public init(uplinkJitterMs: Int64? = nil, name: String, downlinkJitterMs: Int64? = nil, downlinkDelayMs: Int64? = nil, uplinkLossPercent: Int32? = nil, downlinkLossPercent: Int32? = nil, description: String? = nil, uplinkDelayMs: Int64? = nil, uplinkBandwidthBits: Int64? = nil, type: NetworkProfileType? = nil, downlinkBandwidthBits: Int64? = nil, projectArn: String) {
            self.uplinkJitterMs = uplinkJitterMs
            self.name = name
            self.downlinkJitterMs = downlinkJitterMs
            self.downlinkDelayMs = downlinkDelayMs
            self.uplinkLossPercent = uplinkLossPercent
            self.downlinkLossPercent = downlinkLossPercent
            self.description = description
            self.uplinkDelayMs = uplinkDelayMs
            self.uplinkBandwidthBits = uplinkBandwidthBits
            self.`type` = `type`
            self.downlinkBandwidthBits = downlinkBandwidthBits
            self.projectArn = projectArn
        }

        public init(dictionary: [String: Any]) throws {
            self.uplinkJitterMs = dictionary["uplinkJitterMs"] as? Int64
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
            self.downlinkJitterMs = dictionary["downlinkJitterMs"] as? Int64
            self.downlinkDelayMs = dictionary["downlinkDelayMs"] as? Int64
            self.uplinkLossPercent = dictionary["uplinkLossPercent"] as? Int32
            self.downlinkLossPercent = dictionary["downlinkLossPercent"] as? Int32
            self.description = dictionary["description"] as? String
            self.uplinkDelayMs = dictionary["uplinkDelayMs"] as? Int64
            self.uplinkBandwidthBits = dictionary["uplinkBandwidthBits"] as? Int64
            if let `type` = dictionary["type"] as? String { self.`type` = NetworkProfileType(rawValue: `type`) } else { self.`type` = nil }
            self.downlinkBandwidthBits = dictionary["downlinkBandwidthBits"] as? Int64
            guard let projectArn = dictionary["projectArn"] as? String else { throw InitializableError.missingRequiredParam("projectArn") }
            self.projectArn = projectArn
        }
    }

    public struct GetDevicePoolRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The device pool's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct RemoteAccessSession: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The billing method of the remote access session. Possible values include METERED or UNMETERED. For more information about metered devices, see AWS Device Farm terminology."
        public let billingMethod: BillingMethod?
        /// The status of the remote access session. Can be any of the following:   PENDING: A pending status.   PENDING_CONCURRENCY: A pending concurrency status.   PENDING_DEVICE: A pending device status.   PROCESSING: A processing status.   SCHEDULING: A scheduling status.   PREPARING: A preparing status.   RUNNING: A running status.   COMPLETED: A completed status.   STOPPING: A stopping status.  
        public let status: ExecutionStatus?
        /// The name of the remote access session.
        public let name: String?
        /// The endpoint for the remote access sesssion.
        public let endpoint: String?
        /// The date and time the remote access session was created.
        public let created: Date?
        /// The date and time the remote access session was started.
        public let started: Date?
        /// The date and time the remote access session was stopped.
        public let stopped: Date?
        /// The number of minutes a device is used in a remote access sesssion (including setup and teardown minutes).
        public let deviceMinutes: DeviceMinutes?
        /// A message about the remote access session.
        public let message: String?
        /// The device (phone or tablet) used in the remote access session.
        public let device: Device?
        /// The result of the remote access session. Can be any of the following:   PENDING: A pending condition.   PASSED: A passing condition.   WARNED: A warning condition.   FAILED: A failed condition.   SKIPPED: A skipped condition.   ERRORED: An error condition.   STOPPED: A stopped condition.  
        public let result: ExecutionResult?
        /// The Amazon Resource Name (ARN) of the remote access session.
        public let arn: String?

        public init(billingMethod: BillingMethod? = nil, status: ExecutionStatus? = nil, name: String? = nil, endpoint: String? = nil, created: Date? = nil, started: Date? = nil, stopped: Date? = nil, deviceMinutes: DeviceMinutes? = nil, message: String? = nil, device: Device? = nil, result: ExecutionResult? = nil, arn: String? = nil) {
            self.billingMethod = billingMethod
            self.status = status
            self.name = name
            self.endpoint = endpoint
            self.created = created
            self.started = started
            self.stopped = stopped
            self.deviceMinutes = deviceMinutes
            self.message = message
            self.device = device
            self.result = result
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            if let billingMethod = dictionary["billingMethod"] as? String { self.billingMethod = BillingMethod(rawValue: billingMethod) } else { self.billingMethod = nil }
            if let status = dictionary["status"] as? String { self.status = ExecutionStatus(rawValue: status) } else { self.status = nil }
            self.name = dictionary["name"] as? String
            self.endpoint = dictionary["endpoint"] as? String
            self.created = dictionary["created"] as? Date
            self.started = dictionary["started"] as? Date
            self.stopped = dictionary["stopped"] as? Date
            if let deviceMinutes = dictionary["deviceMinutes"] as? [String: Any] { self.deviceMinutes = try Devicefarm.DeviceMinutes(dictionary: deviceMinutes) } else { self.deviceMinutes = nil }
            self.message = dictionary["message"] as? String
            if let device = dictionary["device"] as? [String: Any] { self.device = try Devicefarm.Device(dictionary: device) } else { self.device = nil }
            if let result = dictionary["result"] as? String { self.result = ExecutionResult(rawValue: result) } else { self.result = nil }
            self.arn = dictionary["arn"] as? String
        }
    }

    public struct RecurringCharge: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The frequency in which charges will recur.
        public let frequency: RecurringChargeFrequency?
        /// The cost of the recurring charge.
        public let cost: MonetaryAmount?

        public init(frequency: RecurringChargeFrequency? = nil, cost: MonetaryAmount? = nil) {
            self.frequency = frequency
            self.cost = cost
        }

        public init(dictionary: [String: Any]) throws {
            if let frequency = dictionary["frequency"] as? String { self.frequency = RecurringChargeFrequency(rawValue: frequency) } else { self.frequency = nil }
            if let cost = dictionary["cost"] as? [String: Any] { self.cost = try Devicefarm.MonetaryAmount(dictionary: cost) } else { self.cost = nil }
        }
    }

    public struct Suite: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The suite's status. Allowed values include:   PENDING: A pending status.   PENDING_CONCURRENCY: A pending concurrency status.   PENDING_DEVICE: A pending device status.   PROCESSING: A processing status.   SCHEDULING: A scheduling status.   PREPARING: A preparing status.   RUNNING: A running status.   COMPLETED: A completed status.   STOPPING: A stopping status.  
        public let status: ExecutionStatus?
        /// The suite's name.
        public let name: String?
        /// When the suite was created.
        public let created: Date?
        /// The suite's start time.
        public let started: Date?
        /// Represents the total (metered or unmetered) minutes used by the test suite.
        public let deviceMinutes: DeviceMinutes?
        /// The suite's stop time.
        public let stopped: Date?
        /// A message about the suite's result.
        public let message: String?
        /// The suite's type. Must be one of the following values:   BUILTIN_FUZZ: The built-in fuzz type.   BUILTIN_EXPLORER: For Android, an app explorer that will traverse an Android app, interacting with it and capturing screenshots at the same time.   APPIUM_JAVA_JUNIT: The Appium Java JUnit type.   APPIUM_JAVA_TESTNG: The Appium Java TestNG type.   APPIUM_PYTHON: The Appium Python type.   APPIUM_WEB_JAVA_JUNIT: The Appium Java JUnit type for Web apps.   APPIUM_WEB_JAVA_TESTNG: The Appium Java TestNG type for Web apps.   APPIUM_WEB_PYTHON: The Appium Python type for Web apps.   CALABASH: The Calabash type.   INSTRUMENTATION: The Instrumentation type.   UIAUTOMATION: The uiautomation type.   UIAUTOMATOR: The uiautomator type.   XCTEST: The XCode test type.   XCTEST_UI: The XCode UI test type.  
        public let `type`: TestType?
        /// The suite's result. Allowed values include:   PENDING: A pending condition.   PASSED: A passing condition.   WARNED: A warning condition.   FAILED: A failed condition.   SKIPPED: A skipped condition.   ERRORED: An error condition.   STOPPED: A stopped condition.  
        public let result: ExecutionResult?
        /// The suite's result counters.
        public let counters: Counters?
        /// The suite's ARN.
        public let arn: String?

        public init(status: ExecutionStatus? = nil, name: String? = nil, created: Date? = nil, started: Date? = nil, deviceMinutes: DeviceMinutes? = nil, stopped: Date? = nil, message: String? = nil, type: TestType? = nil, result: ExecutionResult? = nil, counters: Counters? = nil, arn: String? = nil) {
            self.status = status
            self.name = name
            self.created = created
            self.started = started
            self.deviceMinutes = deviceMinutes
            self.stopped = stopped
            self.message = message
            self.`type` = `type`
            self.result = result
            self.counters = counters
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            if let status = dictionary["status"] as? String { self.status = ExecutionStatus(rawValue: status) } else { self.status = nil }
            self.name = dictionary["name"] as? String
            self.created = dictionary["created"] as? Date
            self.started = dictionary["started"] as? Date
            if let deviceMinutes = dictionary["deviceMinutes"] as? [String: Any] { self.deviceMinutes = try Devicefarm.DeviceMinutes(dictionary: deviceMinutes) } else { self.deviceMinutes = nil }
            self.stopped = dictionary["stopped"] as? Date
            self.message = dictionary["message"] as? String
            if let `type` = dictionary["type"] as? String { self.`type` = TestType(rawValue: `type`) } else { self.`type` = nil }
            if let result = dictionary["result"] as? String { self.result = ExecutionResult(rawValue: result) } else { self.result = nil }
            if let counters = dictionary["counters"] as? [String: Any] { self.counters = try Devicefarm.Counters(dictionary: counters) } else { self.counters = nil }
            self.arn = dictionary["arn"] as? String
        }
    }

    public struct DeleteUploadRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Represents the Amazon Resource Name (ARN) of the Device Farm upload you wish to delete.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct ListUniqueProblemsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The unique problems' ARNs.
        public let arn: String

        public init(nextToken: String? = nil, arn: String) {
            self.nextToken = nextToken
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct GetAccountSettingsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public enum CurrencyCode: String, CustomStringConvertible {
        case usd = "USD"
        public var description: String { return self.rawValue }
    }

    public struct ProblemDetail: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The problem detail's name.
        public let name: String?
        /// The problem detail's ARN.
        public let arn: String?

        public init(name: String? = nil, arn: String? = nil) {
            self.name = name
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["name"] as? String
            self.arn = dictionary["arn"] as? String
        }
    }

    public struct ScheduleRunConfiguration: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the extra data for the run. The extra data is a .zip file that AWS Device Farm will extract to external data for Android or the app's sandbox for iOS.
        public let extraDataPackageArn: String?
        /// Information about the location that is used for the run.
        public let location: Location?
        /// Reserved for internal use.
        public let networkProfileArn: String?
        /// A list of auxiliary apps for the run.
        public let auxiliaryApps: [String]?
        /// Information about the radio states for the run.
        public let radios: Radios?
        /// Information about the locale that is used for the run.
        public let locale: String?
        /// Specifies the billing method for a test run: metered or unmetered. If the parameter is not specified, the default value is metered.
        public let billingMethod: BillingMethod?

        public init(extraDataPackageArn: String? = nil, location: Location? = nil, networkProfileArn: String? = nil, auxiliaryApps: [String]? = nil, radios: Radios? = nil, locale: String? = nil, billingMethod: BillingMethod? = nil) {
            self.extraDataPackageArn = extraDataPackageArn
            self.location = location
            self.networkProfileArn = networkProfileArn
            self.auxiliaryApps = auxiliaryApps
            self.radios = radios
            self.locale = locale
            self.billingMethod = billingMethod
        }

        public init(dictionary: [String: Any]) throws {
            self.extraDataPackageArn = dictionary["extraDataPackageArn"] as? String
            if let location = dictionary["location"] as? [String: Any] { self.location = try Devicefarm.Location(dictionary: location) } else { self.location = nil }
            self.networkProfileArn = dictionary["networkProfileArn"] as? String
            self.auxiliaryApps = dictionary["auxiliaryApps"] as? [String]
            if let radios = dictionary["radios"] as? [String: Any] { self.radios = try Devicefarm.Radios(dictionary: radios) } else { self.radios = nil }
            self.locale = dictionary["locale"] as? String
            if let billingMethod = dictionary["billingMethod"] as? String { self.billingMethod = BillingMethod(rawValue: billingMethod) } else { self.billingMethod = nil }
        }
    }

    public struct GetJobResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An object containing information about the requested job.
        public let job: Job?

        public init(job: Job? = nil) {
            self.job = job
        }

        public init(dictionary: [String: Any]) throws {
            if let job = dictionary["job"] as? [String: Any] { self.job = try Devicefarm.Job(dictionary: job) } else { self.job = nil }
        }
    }

    public enum RuleOperator: String, CustomStringConvertible {
        case equals = "EQUALS"
        case less_than = "LESS_THAN"
        case greater_than = "GREATER_THAN"
        case `in` = "IN"
        case not_in = "NOT_IN"
        public var description: String { return self.rawValue }
    }

    public struct ListOfferingsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// A value representing the list offering results.
        public let offerings: [Offering]?

        public init(nextToken: String? = nil, offerings: [Offering]? = nil) {
            self.nextToken = nextToken
            self.offerings = offerings
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            if let offerings = dictionary["offerings"] as? [[String: Any]] {
                self.offerings = try offerings.map({ try Offering(dictionary: $0) })
            } else { 
                self.offerings = nil
            }
        }
    }

    public struct StopRunResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The run that was stopped.
        public let run: Run?

        public init(run: Run? = nil) {
            self.run = run
        }

        public init(dictionary: [String: Any]) throws {
            if let run = dictionary["run"] as? [String: Any] { self.run = try Devicefarm.Run(dictionary: run) } else { self.run = nil }
        }
    }

    public struct ScheduleRunRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the project for the run to be scheduled.
        public let projectArn: String
        /// The name for the run to be scheduled.
        public let name: String?
        /// Specifies configuration information about a test run, such as the execution timeout (in minutes).
        public let executionConfiguration: ExecutionConfiguration?
        /// Information about the test for the run to be scheduled.
        public let test: ScheduleRunTest
        /// The ARN of the app to schedule a run.
        public let appArn: String?
        /// The ARN of the device pool for the run to be scheduled.
        public let devicePoolArn: String
        /// Information about the settings for the run to be scheduled.
        public let configuration: ScheduleRunConfiguration?

        public init(projectArn: String, name: String? = nil, executionConfiguration: ExecutionConfiguration? = nil, test: ScheduleRunTest, appArn: String? = nil, devicePoolArn: String, configuration: ScheduleRunConfiguration? = nil) {
            self.projectArn = projectArn
            self.name = name
            self.executionConfiguration = executionConfiguration
            self.test = test
            self.appArn = appArn
            self.devicePoolArn = devicePoolArn
            self.configuration = configuration
        }

        public init(dictionary: [String: Any]) throws {
            guard let projectArn = dictionary["projectArn"] as? String else { throw InitializableError.missingRequiredParam("projectArn") }
            self.projectArn = projectArn
            self.name = dictionary["name"] as? String
            if let executionConfiguration = dictionary["executionConfiguration"] as? [String: Any] { self.executionConfiguration = try Devicefarm.ExecutionConfiguration(dictionary: executionConfiguration) } else { self.executionConfiguration = nil }
            guard let test = dictionary["test"] as? [String: Any] else { throw InitializableError.missingRequiredParam("test") }
            self.test = try Devicefarm.ScheduleRunTest(dictionary: test)
            self.appArn = dictionary["appArn"] as? String
            guard let devicePoolArn = dictionary["devicePoolArn"] as? String else { throw InitializableError.missingRequiredParam("devicePoolArn") }
            self.devicePoolArn = devicePoolArn
            if let configuration = dictionary["configuration"] as? [String: Any] { self.configuration = try Devicefarm.ScheduleRunConfiguration(dictionary: configuration) } else { self.configuration = nil }
        }
    }

    public enum UploadType: String, CustomStringConvertible {
        case android_app = "ANDROID_APP"
        case ios_app = "IOS_APP"
        case web_app = "WEB_APP"
        case external_data = "EXTERNAL_DATA"
        case appium_java_junit_test_package = "APPIUM_JAVA_JUNIT_TEST_PACKAGE"
        case appium_java_testng_test_package = "APPIUM_JAVA_TESTNG_TEST_PACKAGE"
        case appium_python_test_package = "APPIUM_PYTHON_TEST_PACKAGE"
        case appium_web_java_junit_test_package = "APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE"
        case appium_web_java_testng_test_package = "APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE"
        case appium_web_python_test_package = "APPIUM_WEB_PYTHON_TEST_PACKAGE"
        case calabash_test_package = "CALABASH_TEST_PACKAGE"
        case instrumentation_test_package = "INSTRUMENTATION_TEST_PACKAGE"
        case uiautomation_test_package = "UIAUTOMATION_TEST_PACKAGE"
        case uiautomator_test_package = "UIAUTOMATOR_TEST_PACKAGE"
        case xctest_test_package = "XCTEST_TEST_PACKAGE"
        case xctest_ui_test_package = "XCTEST_UI_TEST_PACKAGE"
        public var description: String { return self.rawValue }
    }

    public enum DeviceAttribute: String, CustomStringConvertible {
        case arn = "ARN"
        case platform = "PLATFORM"
        case form_factor = "FORM_FACTOR"
        case manufacturer = "MANUFACTURER"
        case remote_access_enabled = "REMOTE_ACCESS_ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct Artifact: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The artifact's name.
        public let name: String?
        /// The artifact's type. Allowed values include the following:   UNKNOWN: An unknown type.   SCREENSHOT: The screenshot type.   DEVICE_LOG: The device log type.   MESSAGE_LOG: The message log type.   RESULT_LOG: The result log type.   SERVICE_LOG: The service log type.   WEBKIT_LOG: The web kit log type.   INSTRUMENTATION_OUTPUT: The instrumentation type.   EXERCISER_MONKEY_OUTPUT: For Android, the artifact (log) generated by an Android fuzz test.   CALABASH_JSON_OUTPUT: The Calabash JSON output type.   CALABASH_PRETTY_OUTPUT: The Calabash pretty output type.   CALABASH_STANDARD_OUTPUT: The Calabash standard output type.   CALABASH_JAVA_XML_OUTPUT: The Calabash Java XML output type.   AUTOMATION_OUTPUT: The automation output type.   APPIUM_SERVER_OUTPUT: The Appium server output type.   APPIUM_JAVA_OUTPUT: The Appium Java output type.   APPIUM_JAVA_XML_OUTPUT: The Appium Java XML output type.   APPIUM_PYTHON_OUTPUT: The Appium Python output type.   APPIUM_PYTHON_XML_OUTPUT: The Appium Python XML output type.   EXPLORER_EVENT_LOG: The Explorer event log output type.   EXPLORER_SUMMARY_LOG: The Explorer summary log output type.   APPLICATION_CRASH_REPORT: The application crash report output type.   XCTEST_LOG: The XCode test output type.  
        public let `type`: ArtifactType?
        /// The artifact's file extension.
        public let `extension`: String?
        /// The pre-signed Amazon S3 URL that can be used with a corresponding GET request to download the artifact's file.
        public let url: String?
        /// The artifact's ARN.
        public let arn: String?

        public init(name: String? = nil, type: ArtifactType? = nil, extension: String? = nil, url: String? = nil, arn: String? = nil) {
            self.name = name
            self.`type` = `type`
            self.`extension` = `extension`
            self.url = url
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["name"] as? String
            if let `type` = dictionary["type"] as? String { self.`type` = ArtifactType(rawValue: `type`) } else { self.`type` = nil }
            self.`extension` = dictionary["extension"] as? String
            self.url = dictionary["url"] as? String
            self.arn = dictionary["arn"] as? String
        }
    }

    public struct CreateNetworkProfileResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The network profile that is returned by the create network profile request.
        public let networkProfile: NetworkProfile?

        public init(networkProfile: NetworkProfile? = nil) {
            self.networkProfile = networkProfile
        }

        public init(dictionary: [String: Any]) throws {
            if let networkProfile = dictionary["networkProfile"] as? [String: Any] { self.networkProfile = try Devicefarm.NetworkProfile(dictionary: networkProfile) } else { self.networkProfile = nil }
        }
    }

    public struct DeleteNetworkProfileRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Amazon Resource Name (ARN) of the network profile you want to delete.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct Project: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The project's name.
        public let name: String?
        /// When the project was created.
        public let created: Date?
        /// The default number of minutes (at the project level) a test run will execute before it times out. Default value is 60 minutes.
        public let defaultJobTimeoutMinutes: Int32?
        /// The project's ARN.
        public let arn: String?

        public init(name: String? = nil, created: Date? = nil, defaultJobTimeoutMinutes: Int32? = nil, arn: String? = nil) {
            self.name = name
            self.created = created
            self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["name"] as? String
            self.created = dictionary["created"] as? Date
            self.defaultJobTimeoutMinutes = dictionary["defaultJobTimeoutMinutes"] as? Int32
            self.arn = dictionary["arn"] as? String
        }
    }

    public struct ScheduleRunResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the scheduled run.
        public let run: Run?

        public init(run: Run? = nil) {
            self.run = run
        }

        public init(dictionary: [String: Any]) throws {
            if let run = dictionary["run"] as? [String: Any] { self.run = try Devicefarm.Run(dictionary: run) } else { self.run = nil }
        }
    }

    public struct GetRunRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The run's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct ListNetworkProfilesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of the available network profiles.
        public let networkProfiles: [NetworkProfile]?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(networkProfiles: [NetworkProfile]? = nil, nextToken: String? = nil) {
            self.networkProfiles = networkProfiles
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let networkProfiles = dictionary["networkProfiles"] as? [[String: Any]] {
                self.networkProfiles = try networkProfiles.map({ try NetworkProfile(dictionary: $0) })
            } else { 
                self.networkProfiles = nil
            }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct ListSamplesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the project for which you want to list samples.
        public let arn: String

        public init(nextToken: String? = nil, arn: String) {
            self.nextToken = nextToken
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct CreateProjectRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The project's name.
        public let name: String
        /// Sets the execution timeout value (in minutes) for a project. All test runs in this project will use the specified execution timeout value unless overridden when scheduling a run.
        public let defaultJobTimeoutMinutes: Int32?

        public init(name: String, defaultJobTimeoutMinutes: Int32? = nil) {
            self.name = name
            self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
            self.defaultJobTimeoutMinutes = dictionary["defaultJobTimeoutMinutes"] as? Int32
        }
    }

    public struct GetRemoteAccessSessionResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A container that lists detailed information about the remote access session.
        public let remoteAccessSession: RemoteAccessSession?

        public init(remoteAccessSession: RemoteAccessSession? = nil) {
            self.remoteAccessSession = remoteAccessSession
        }

        public init(dictionary: [String: Any]) throws {
            if let remoteAccessSession = dictionary["remoteAccessSession"] as? [String: Any] { self.remoteAccessSession = try Devicefarm.RemoteAccessSession(dictionary: remoteAccessSession) } else { self.remoteAccessSession = nil }
        }
    }

    public struct UpdateDevicePoolResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The device pool you just updated.
        public let devicePool: DevicePool?

        public init(devicePool: DevicePool? = nil) {
            self.devicePool = devicePool
        }

        public init(dictionary: [String: Any]) throws {
            if let devicePool = dictionary["devicePool"] as? [String: Any] { self.devicePool = try Devicefarm.DevicePool(dictionary: devicePool) } else { self.devicePool = nil }
        }
    }

    public struct PurchaseOfferingRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the offering.
        public let offeringId: String?
        /// The number of device slots you wish to purchase in an offering request.
        public let quantity: Int32?

        public init(offeringId: String? = nil, quantity: Int32? = nil) {
            self.offeringId = offeringId
            self.quantity = quantity
        }

        public init(dictionary: [String: Any]) throws {
            self.offeringId = dictionary["offeringId"] as? String
            self.quantity = dictionary["quantity"] as? Int32
        }
    }

    public enum ArtifactCategory: String, CustomStringConvertible {
        case screenshot = "SCREENSHOT"
        case file = "FILE"
        case log = "LOG"
        public var description: String { return self.rawValue }
    }

    public enum ArtifactType: String, CustomStringConvertible {
        case unknown = "UNKNOWN"
        case screenshot = "SCREENSHOT"
        case device_log = "DEVICE_LOG"
        case message_log = "MESSAGE_LOG"
        case video_log = "VIDEO_LOG"
        case result_log = "RESULT_LOG"
        case service_log = "SERVICE_LOG"
        case webkit_log = "WEBKIT_LOG"
        case instrumentation_output = "INSTRUMENTATION_OUTPUT"
        case exerciser_monkey_output = "EXERCISER_MONKEY_OUTPUT"
        case calabash_json_output = "CALABASH_JSON_OUTPUT"
        case calabash_pretty_output = "CALABASH_PRETTY_OUTPUT"
        case calabash_standard_output = "CALABASH_STANDARD_OUTPUT"
        case calabash_java_xml_output = "CALABASH_JAVA_XML_OUTPUT"
        case automation_output = "AUTOMATION_OUTPUT"
        case appium_server_output = "APPIUM_SERVER_OUTPUT"
        case appium_java_output = "APPIUM_JAVA_OUTPUT"
        case appium_java_xml_output = "APPIUM_JAVA_XML_OUTPUT"
        case appium_python_output = "APPIUM_PYTHON_OUTPUT"
        case appium_python_xml_output = "APPIUM_PYTHON_XML_OUTPUT"
        case explorer_event_log = "EXPLORER_EVENT_LOG"
        case explorer_summary_log = "EXPLORER_SUMMARY_LOG"
        case application_crash_report = "APPLICATION_CRASH_REPORT"
        case xctest_log = "XCTEST_LOG"
        case video = "VIDEO"
        public var description: String { return self.rawValue }
    }

    public struct StopRemoteAccessSessionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Amazon Resource Name (ARN) of the remote access session you wish to stop.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public enum OfferingTransactionType: String, CustomStringConvertible {
        case purchase = "PURCHASE"
        case renew = "RENEW"
        case system = "SYSTEM"
        public var description: String { return self.rawValue }
    }

    public struct CreateUploadResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The newly created upload.
        public let upload: Upload?

        public init(upload: Upload? = nil) {
            self.upload = upload
        }

        public init(dictionary: [String: Any]) throws {
            if let upload = dictionary["upload"] as? [String: Any] { self.upload = try Devicefarm.Upload(dictionary: upload) } else { self.upload = nil }
        }
    }

    public struct UniqueProblem: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the problems.
        public let problems: [Problem]?
        /// A message about the unique problems' result.
        public let message: String?

        public init(problems: [Problem]? = nil, message: String? = nil) {
            self.problems = problems
            self.message = message
        }

        public init(dictionary: [String: Any]) throws {
            if let problems = dictionary["problems"] as? [[String: Any]] {
                self.problems = try problems.map({ try Problem(dictionary: $0) })
            } else { 
                self.problems = nil
            }
            self.message = dictionary["message"] as? String
        }
    }

    public struct UpdateNetworkProfileResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of the available network profiles.
        public let networkProfile: NetworkProfile?

        public init(networkProfile: NetworkProfile? = nil) {
            self.networkProfile = networkProfile
        }

        public init(dictionary: [String: Any]) throws {
            if let networkProfile = dictionary["networkProfile"] as? [String: Any] { self.networkProfile = try Devicefarm.NetworkProfile(dictionary: networkProfile) } else { self.networkProfile = nil }
        }
    }

    public struct ListNetworkProfilesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The type of network profile you wish to return information about. Valid values are listed below.
        public let `type`: NetworkProfileType?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the project for which you want to list network profiles.
        public let arn: String

        public init(type: NetworkProfileType? = nil, nextToken: String? = nil, arn: String) {
            self.`type` = `type`
            self.nextToken = nextToken
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            if let `type` = dictionary["type"] as? String { self.`type` = NetworkProfileType(rawValue: `type`) } else { self.`type` = nil }
            self.nextToken = dictionary["nextToken"] as? String
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct GetJobRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The job's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct ListRunsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?
        /// Information about the runs.
        public let runs: [Run]?

        public init(nextToken: String? = nil, runs: [Run]? = nil) {
            self.nextToken = nextToken
            self.runs = runs
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            if let runs = dictionary["runs"] as? [[String: Any]] {
                self.runs = try runs.map({ try Run(dictionary: $0) })
            } else { 
                self.runs = nil
            }
        }
    }

    public struct ListTestsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the tests.
        public let tests: [Test]?
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(tests: [Test]? = nil, nextToken: String? = nil) {
            self.tests = tests
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let tests = dictionary["tests"] as? [[String: Any]] {
                self.tests = try tests.map({ try Test(dictionary: $0) })
            } else { 
                self.tests = nil
            }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct DeleteNetworkProfileResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct OfferingTransaction: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The transaction ID of the offering transaction.
        public let transactionId: String?
        /// The cost of an offering transaction.
        public let cost: MonetaryAmount?
        /// The date on which an offering transaction was created.
        public let createdOn: Date?
        /// The status of an offering transaction.
        public let offeringStatus: OfferingStatus?

        public init(transactionId: String? = nil, cost: MonetaryAmount? = nil, createdOn: Date? = nil, offeringStatus: OfferingStatus? = nil) {
            self.transactionId = transactionId
            self.cost = cost
            self.createdOn = createdOn
            self.offeringStatus = offeringStatus
        }

        public init(dictionary: [String: Any]) throws {
            self.transactionId = dictionary["transactionId"] as? String
            if let cost = dictionary["cost"] as? [String: Any] { self.cost = try Devicefarm.MonetaryAmount(dictionary: cost) } else { self.cost = nil }
            self.createdOn = dictionary["createdOn"] as? Date
            if let offeringStatus = dictionary["offeringStatus"] as? [String: Any] { self.offeringStatus = try Devicefarm.OfferingStatus(dictionary: offeringStatus) } else { self.offeringStatus = nil }
        }
    }

    public enum RecurringChargeFrequency: String, CustomStringConvertible {
        case monthly = "MONTHLY"
        public var description: String { return self.rawValue }
    }

    public struct ListDevicesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the devices.
        public let devices: [Device]?
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(devices: [Device]? = nil, nextToken: String? = nil) {
            self.devices = devices
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let devices = dictionary["devices"] as? [[String: Any]] {
                self.devices = try devices.map({ try Device(dictionary: $0) })
            } else { 
                self.devices = nil
            }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct ListUploadsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the uploads.
        public let uploads: [Upload]?
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(uploads: [Upload]? = nil, nextToken: String? = nil) {
            self.uploads = uploads
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let uploads = dictionary["uploads"] as? [[String: Any]] {
                self.uploads = try uploads.map({ try Upload(dictionary: $0) })
            } else { 
                self.uploads = nil
            }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct Offering: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A string describing the offering.
        public let description: String?
        /// Specifies whether there are recurring charges for the offering.
        public let recurringCharges: [RecurringCharge]?
        /// The ID that corresponds to a device offering.
        public let id: String?
        /// The type of offering (e.g., "RECURRING") for a device.
        public let `type`: OfferingType?
        /// The platform of the device (e.g., ANDROID or IOS).
        public let platform: DevicePlatform?

        public init(description: String? = nil, recurringCharges: [RecurringCharge]? = nil, id: String? = nil, type: OfferingType? = nil, platform: DevicePlatform? = nil) {
            self.description = description
            self.recurringCharges = recurringCharges
            self.id = id
            self.`type` = `type`
            self.platform = platform
        }

        public init(dictionary: [String: Any]) throws {
            self.description = dictionary["description"] as? String
            if let recurringCharges = dictionary["recurringCharges"] as? [[String: Any]] {
                self.recurringCharges = try recurringCharges.map({ try RecurringCharge(dictionary: $0) })
            } else { 
                self.recurringCharges = nil
            }
            self.id = dictionary["id"] as? String
            if let `type` = dictionary["type"] as? String { self.`type` = OfferingType(rawValue: `type`) } else { self.`type` = nil }
            if let platform = dictionary["platform"] as? String { self.platform = DevicePlatform(rawValue: platform) } else { self.platform = nil }
        }
    }

    public struct GetSuiteResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A collection of one or more tests.
        public let suite: Suite?

        public init(suite: Suite? = nil) {
            self.suite = suite
        }

        public init(dictionary: [String: Any]) throws {
            if let suite = dictionary["suite"] as? [String: Any] { self.suite = try Devicefarm.Suite(dictionary: suite) } else { self.suite = nil }
        }
    }

    public struct GetSuiteRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The suite's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct GetUploadRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The upload's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct Test: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The test's status. Allowed values include:   PENDING: A pending status.   PENDING_CONCURRENCY: A pending concurrency status.   PENDING_DEVICE: A pending device status.   PROCESSING: A processing status.   SCHEDULING: A scheduling status.   PREPARING: A preparing status.   RUNNING: A running status.   COMPLETED: A completed status.   STOPPING: A stopping status.  
        public let status: ExecutionStatus?
        /// The test's name.
        public let name: String?
        /// When the test was created.
        public let created: Date?
        /// The test's start time.
        public let started: Date?
        /// Represents the total (metered or unmetered) minutes used by the test.
        public let deviceMinutes: DeviceMinutes?
        /// The test's stop time.
        public let stopped: Date?
        /// A message about the test's result.
        public let message: String?
        /// The test's type. Must be one of the following values:   BUILTIN_FUZZ: The built-in fuzz type.   BUILTIN_EXPLORER: For Android, an app explorer that will traverse an Android app, interacting with it and capturing screenshots at the same time.   APPIUM_JAVA_JUNIT: The Appium Java JUnit type.   APPIUM_JAVA_TESTNG: The Appium Java TestNG type.   APPIUM_PYTHON: The Appium Python type.   APPIUM_WEB_JAVA_JUNIT: The Appium Java JUnit type for Web apps.   APPIUM_WEB_JAVA_TESTNG: The Appium Java TestNG type for Web apps.   APPIUM_WEB_PYTHON: The Appium Python type for Web apps.   CALABASH: The Calabash type.   INSTRUMENTATION: The Instrumentation type.   UIAUTOMATION: The uiautomation type.   UIAUTOMATOR: The uiautomator type.   XCTEST: The XCode test type.   XCTEST_UI: The XCode UI test type.  
        public let `type`: TestType?
        /// The test's result. Allowed values include:   PENDING: A pending condition.   PASSED: A passing condition.   WARNED: A warning condition.   FAILED: A failed condition.   SKIPPED: A skipped condition.   ERRORED: An error condition.   STOPPED: A stopped condition.  
        public let result: ExecutionResult?
        /// The test's result counters.
        public let counters: Counters?
        /// The test's ARN.
        public let arn: String?

        public init(status: ExecutionStatus? = nil, name: String? = nil, created: Date? = nil, started: Date? = nil, deviceMinutes: DeviceMinutes? = nil, stopped: Date? = nil, message: String? = nil, type: TestType? = nil, result: ExecutionResult? = nil, counters: Counters? = nil, arn: String? = nil) {
            self.status = status
            self.name = name
            self.created = created
            self.started = started
            self.deviceMinutes = deviceMinutes
            self.stopped = stopped
            self.message = message
            self.`type` = `type`
            self.result = result
            self.counters = counters
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            if let status = dictionary["status"] as? String { self.status = ExecutionStatus(rawValue: status) } else { self.status = nil }
            self.name = dictionary["name"] as? String
            self.created = dictionary["created"] as? Date
            self.started = dictionary["started"] as? Date
            if let deviceMinutes = dictionary["deviceMinutes"] as? [String: Any] { self.deviceMinutes = try Devicefarm.DeviceMinutes(dictionary: deviceMinutes) } else { self.deviceMinutes = nil }
            self.stopped = dictionary["stopped"] as? Date
            self.message = dictionary["message"] as? String
            if let `type` = dictionary["type"] as? String { self.`type` = TestType(rawValue: `type`) } else { self.`type` = nil }
            if let result = dictionary["result"] as? String { self.result = ExecutionResult(rawValue: result) } else { self.result = nil }
            if let counters = dictionary["counters"] as? [String: Any] { self.counters = try Devicefarm.Counters(dictionary: counters) } else { self.counters = nil }
            self.arn = dictionary["arn"] as? String
        }
    }

    public struct DeleteRemoteAccessSessionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Amazon Resource Name (ARN) of the sesssion for which you want to delete remote access.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct GetOfferingStatusResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// When specified, gets the offering status for the next period.
        public let nextPeriod: [String: OfferingStatus]?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// When specified, gets the offering status for the current period.
        public let current: [String: OfferingStatus]?

        public init(nextPeriod: [String: OfferingStatus]? = nil, nextToken: String? = nil, current: [String: OfferingStatus]? = nil) {
            self.nextPeriod = nextPeriod
            self.nextToken = nextToken
            self.current = current
        }

        public init(dictionary: [String: Any]) throws {
            if let nextPeriod = dictionary["nextPeriod"] as? [String: Any] {
                var nextPeriodDict: [String: OfferingStatus] = [:]
                for (key, value) in nextPeriod {
                    guard let offeringStatusDict = value as? [String: Any] else { throw InitializableError.convertingError }
                    nextPeriodDict[key] = try OfferingStatus(dictionary: offeringStatusDict)
                }
                self.nextPeriod = nextPeriodDict
            } else { 
                self.nextPeriod = nil
            }
            self.nextToken = dictionary["nextToken"] as? String
            if let current = dictionary["current"] as? [String: Any] {
                var currentDict: [String: OfferingStatus] = [:]
                for (key, value) in current {
                    guard let offeringStatusDict = value as? [String: Any] else { throw InitializableError.convertingError }
                    currentDict[key] = try OfferingStatus(dictionary: offeringStatusDict)
                }
                self.current = currentDict
            } else { 
                self.current = nil
            }
        }
    }

    public enum TestType: String, CustomStringConvertible {
        case builtin_fuzz = "BUILTIN_FUZZ"
        case builtin_explorer = "BUILTIN_EXPLORER"
        case appium_java_junit = "APPIUM_JAVA_JUNIT"
        case appium_java_testng = "APPIUM_JAVA_TESTNG"
        case appium_python = "APPIUM_PYTHON"
        case appium_web_java_junit = "APPIUM_WEB_JAVA_JUNIT"
        case appium_web_java_testng = "APPIUM_WEB_JAVA_TESTNG"
        case appium_web_python = "APPIUM_WEB_PYTHON"
        case calabash = "CALABASH"
        case instrumentation = "INSTRUMENTATION"
        case uiautomation = "UIAUTOMATION"
        case uiautomator = "UIAUTOMATOR"
        case xctest = "XCTEST"
        case xctest_ui = "XCTEST_UI"
        public var description: String { return self.rawValue }
    }

    public struct GetOfferingStatusRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct IncompatibilityMessage: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The type of incompatibility. Allowed values include:   ARN: The ARN.   FORM_FACTOR: The form factor (for example, phone or tablet).   MANUFACTURER: The manufacturer.   PLATFORM: The platform (for example, Android or iOS).  
        public let `type`: DeviceAttribute?
        /// A message about the incompatibility.
        public let message: String?

        public init(type: DeviceAttribute? = nil, message: String? = nil) {
            self.`type` = `type`
            self.message = message
        }

        public init(dictionary: [String: Any]) throws {
            if let `type` = dictionary["type"] as? String { self.`type` = DeviceAttribute(rawValue: `type`) } else { self.`type` = nil }
            self.message = dictionary["message"] as? String
        }
    }

    public struct CreateUploadRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The upload's file name. The name should not contain the '/' character. If uploading an iOS app, the file name needs to end with the .ipa extension. If uploading an Android app, the file name needs to end with the .apk extension. For all others, the file name must end with the .zip file extension.
        public let name: String
        /// The upload's content type (for example, "application/octet-stream").
        public let contentType: String?
        /// The upload's upload type. Must be one of the following values:   ANDROID_APP: An Android upload.   IOS_APP: An iOS upload.   WEB_APP: A web appliction upload.   EXTERNAL_DATA: An external data upload.   APPIUM_JAVA_JUNIT_TEST_PACKAGE: An Appium Java JUnit test package upload.   APPIUM_JAVA_TESTNG_TEST_PACKAGE: An Appium Java TestNG test package upload.   APPIUM_PYTHON_TEST_PACKAGE: An Appium Python test package upload.   APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE: An Appium Java JUnit test package upload.   APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE: An Appium Java TestNG test package upload.   APPIUM_WEB_PYTHON_TEST_PACKAGE: An Appium Python test package upload.   CALABASH_TEST_PACKAGE: A Calabash test package upload.   INSTRUMENTATION_TEST_PACKAGE: An instrumentation upload.   UIAUTOMATION_TEST_PACKAGE: A uiautomation test package upload.   UIAUTOMATOR_TEST_PACKAGE: A uiautomator test package upload.   XCTEST_TEST_PACKAGE: An XCode test package upload.   XCTEST_UI_TEST_PACKAGE: An XCode UI test package upload.    Note If you call CreateUpload with WEB_APP specified, AWS Device Farm throws an ArgumentException error.
        public let `type`: UploadType
        /// The ARN of the project for the upload.
        public let projectArn: String

        public init(name: String, contentType: String? = nil, type: UploadType, projectArn: String) {
            self.name = name
            self.contentType = contentType
            self.`type` = `type`
            self.projectArn = projectArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
            self.contentType = dictionary["contentType"] as? String
            guard let rawtype = dictionary["type"] as? String, let `type` = UploadType(rawValue: rawtype) else { throw InitializableError.missingRequiredParam("type") }
            self.`type` = `type`
            guard let projectArn = dictionary["projectArn"] as? String else { throw InitializableError.missingRequiredParam("projectArn") }
            self.projectArn = projectArn
        }
    }

    public struct UpdateProjectResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The project you wish to update.
        public let project: Project?

        public init(project: Project? = nil) {
            self.project = project
        }

        public init(dictionary: [String: Any]) throws {
            if let project = dictionary["project"] as? [String: Any] { self.project = try Devicefarm.Project(dictionary: project) } else { self.project = nil }
        }
    }

    public struct ScheduleRunTest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The test's filter.
        public let filter: String?
        /// The test's type. Must be one of the following values:   BUILTIN_FUZZ: The built-in fuzz type.   BUILTIN_EXPLORER: For Android, an app explorer that will traverse an Android app, interacting with it and capturing screenshots at the same time.   APPIUM_JAVA_JUNIT: The Appium Java JUnit type.   APPIUM_JAVA_TESTNG: The Appium Java TestNG type.   APPIUM_PYTHON: The Appium Python type.   APPIUM_WEB_JAVA_JUNIT: The Appium Java JUnit type for Web apps.   APPIUM_WEB_JAVA_TESTNG: The Appium Java TestNG type for Web apps.   APPIUM_WEB_PYTHON: The Appium Python type for Web apps.   CALABASH: The Calabash type.   INSTRUMENTATION: The Instrumentation type.   UIAUTOMATION: The uiautomation type.   UIAUTOMATOR: The uiautomator type.   XCTEST: The XCode test type.   XCTEST_UI: The XCode UI test type.  
        public let `type`: TestType
        /// The ARN of the uploaded test that will be run.
        public let testPackageArn: String?
        /// The test's parameters, such as test framework parameters and fixture settings.
        public let parameters: [String: String]?

        public init(filter: String? = nil, type: TestType, testPackageArn: String? = nil, parameters: [String: String]? = nil) {
            self.filter = filter
            self.`type` = `type`
            self.testPackageArn = testPackageArn
            self.parameters = parameters
        }

        public init(dictionary: [String: Any]) throws {
            self.filter = dictionary["filter"] as? String
            guard let rawtype = dictionary["type"] as? String, let `type` = TestType(rawValue: rawtype) else { throw InitializableError.missingRequiredParam("type") }
            self.`type` = `type`
            self.testPackageArn = dictionary["testPackageArn"] as? String
            if let parameters = dictionary["parameters"] as? [String: String] {
                self.parameters = parameters
            } else { 
                self.parameters = nil
            }
        }
    }

    public struct DeleteDevicePoolResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ListUploadsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the project for which you want to list uploads.
        public let arn: String

        public init(nextToken: String? = nil, arn: String) {
            self.nextToken = nextToken
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct CreateRemoteAccessSessionResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A container that describes the remote access session when the request to create a remote access session is sent.
        public let remoteAccessSession: RemoteAccessSession?

        public init(remoteAccessSession: RemoteAccessSession? = nil) {
            self.remoteAccessSession = remoteAccessSession
        }

        public init(dictionary: [String: Any]) throws {
            if let remoteAccessSession = dictionary["remoteAccessSession"] as? [String: Any] { self.remoteAccessSession = try Devicefarm.RemoteAccessSession(dictionary: remoteAccessSession) } else { self.remoteAccessSession = nil }
        }
    }

    public struct GetDeviceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The device type's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct Radios: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// True if Wi-Fi is enabled at the beginning of the test; otherwise, false.
        public let wifi: Bool?
        /// True if Bluetooth is enabled at the beginning of the test; otherwise, false.
        public let bluetooth: Bool?
        /// True if NFC is enabled at the beginning of the test; otherwise, false.
        public let nfc: Bool?
        /// True if GPS is enabled at the beginning of the test; otherwise, false.
        public let gps: Bool?

        public init(wifi: Bool? = nil, bluetooth: Bool? = nil, nfc: Bool? = nil, gps: Bool? = nil) {
            self.wifi = wifi
            self.bluetooth = bluetooth
            self.nfc = nfc
            self.gps = gps
        }

        public init(dictionary: [String: Any]) throws {
            self.wifi = dictionary["wifi"] as? Bool
            self.bluetooth = dictionary["bluetooth"] as? Bool
            self.nfc = dictionary["nfc"] as? Bool
            self.gps = dictionary["gps"] as? Bool
        }
    }

    public enum DeviceFormFactor: String, CustomStringConvertible {
        case phone = "PHONE"
        case tablet = "TABLET"
        public var description: String { return self.rawValue }
    }

    public struct GetRunResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The run you wish to get results from.
        public let run: Run?

        public init(run: Run? = nil) {
            self.run = run
        }

        public init(dictionary: [String: Any]) throws {
            if let run = dictionary["run"] as? [String: Any] { self.run = try Devicefarm.Run(dictionary: run) } else { self.run = nil }
        }
    }

    public struct RenewOfferingResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Represents the status of the offering transaction for the renewal.
        public let offeringTransaction: OfferingTransaction?

        public init(offeringTransaction: OfferingTransaction? = nil) {
            self.offeringTransaction = offeringTransaction
        }

        public init(dictionary: [String: Any]) throws {
            if let offeringTransaction = dictionary["offeringTransaction"] as? [String: Any] { self.offeringTransaction = try Devicefarm.OfferingTransaction(dictionary: offeringTransaction) } else { self.offeringTransaction = nil }
        }
    }

    public enum NetworkProfileType: String, CustomStringConvertible {
        case curated = "CURATED"
        case `private` = "PRIVATE"
        public var description: String { return self.rawValue }
    }

    public struct DeleteDevicePoolRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Represents the Amazon Resource Name (ARN) of the Device Farm device pool you wish to delete.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct CreateRemoteAccessSessionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the remote access session that you wish to create.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the device for which you want to create a remote access session.
        public let deviceArn: String
        /// The Amazon Resource Name (ARN) of the project for which you want to create a remote access session.
        public let projectArn: String
        /// The configuration information for the remote access session request.
        public let configuration: CreateRemoteAccessSessionConfiguration?

        public init(name: String? = nil, deviceArn: String, projectArn: String, configuration: CreateRemoteAccessSessionConfiguration? = nil) {
            self.name = name
            self.deviceArn = deviceArn
            self.projectArn = projectArn
            self.configuration = configuration
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["name"] as? String
            guard let deviceArn = dictionary["deviceArn"] as? String else { throw InitializableError.missingRequiredParam("deviceArn") }
            self.deviceArn = deviceArn
            guard let projectArn = dictionary["projectArn"] as? String else { throw InitializableError.missingRequiredParam("projectArn") }
            self.projectArn = projectArn
            if let configuration = dictionary["configuration"] as? [String: Any] { self.configuration = try Devicefarm.CreateRemoteAccessSessionConfiguration(dictionary: configuration) } else { self.configuration = nil }
        }
    }

    public struct ListJobsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?
        /// Information about the jobs.
        public let jobs: [Job]?

        public init(nextToken: String? = nil, jobs: [Job]? = nil) {
            self.nextToken = nextToken
            self.jobs = jobs
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            if let jobs = dictionary["jobs"] as? [[String: Any]] {
                self.jobs = try jobs.map({ try Job(dictionary: $0) })
            } else { 
                self.jobs = nil
            }
        }
    }

    public struct ListSamplesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the samples.
        public let samples: [Sample]?
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(samples: [Sample]? = nil, nextToken: String? = nil) {
            self.samples = samples
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let samples = dictionary["samples"] as? [[String: Any]] {
                self.samples = try samples.map({ try Sample(dictionary: $0) })
            } else { 
                self.samples = nil
            }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct CreateDevicePoolRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The device pool's description.
        public let description: String?
        /// The device pool's name.
        public let name: String
        /// The device pool's rules.
        public let rules: [Rule]
        /// The ARN of the project for the device pool.
        public let projectArn: String

        public init(description: String? = nil, name: String, rules: [Rule], projectArn: String) {
            self.description = description
            self.name = name
            self.rules = rules
            self.projectArn = projectArn
        }

        public init(dictionary: [String: Any]) throws {
            self.description = dictionary["description"] as? String
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
            guard let rules = dictionary["rules"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("rules") }
            self.rules = try rules.map({ try Rule(dictionary: $0) })
            guard let projectArn = dictionary["projectArn"] as? String else { throw InitializableError.missingRequiredParam("projectArn") }
            self.projectArn = projectArn
        }
    }

    public struct ListProjectsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?
        /// Information about the projects.
        public let projects: [Project]?

        public init(nextToken: String? = nil, projects: [Project]? = nil) {
            self.nextToken = nextToken
            self.projects = projects
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            if let projects = dictionary["projects"] as? [[String: Any]] {
                self.projects = try projects.map({ try Project(dictionary: $0) })
            } else { 
                self.projects = nil
            }
        }
    }

    public struct OfferingStatus: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The number of available devices in the offering.
        public let quantity: Int32?
        /// The type specified for the offering status.
        public let `type`: OfferingTransactionType?
        /// The date on which the offering is effective.
        public let effectiveOn: Date?
        /// Represents the metadata of an offering status.
        public let offering: Offering?

        public init(quantity: Int32? = nil, type: OfferingTransactionType? = nil, effectiveOn: Date? = nil, offering: Offering? = nil) {
            self.quantity = quantity
            self.`type` = `type`
            self.effectiveOn = effectiveOn
            self.offering = offering
        }

        public init(dictionary: [String: Any]) throws {
            self.quantity = dictionary["quantity"] as? Int32
            if let `type` = dictionary["type"] as? String { self.`type` = OfferingTransactionType(rawValue: `type`) } else { self.`type` = nil }
            self.effectiveOn = dictionary["effectiveOn"] as? Date
            if let offering = dictionary["offering"] as? [String: Any] { self.offering = try Devicefarm.Offering(dictionary: offering) } else { self.offering = nil }
        }
    }

    public struct ListDevicePoolsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The device pools' type. Allowed values include:   CURATED: A device pool that is created and managed by AWS Device Farm.   PRIVATE: A device pool that is created and managed by the device pool developer.  
        public let `type`: DevicePoolType?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The project ARN.
        public let arn: String

        public init(type: DevicePoolType? = nil, nextToken: String? = nil, arn: String) {
            self.`type` = `type`
            self.nextToken = nextToken
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            if let `type` = dictionary["type"] as? String { self.`type` = DevicePoolType(rawValue: `type`) } else { self.`type` = nil }
            self.nextToken = dictionary["nextToken"] as? String
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct ListJobsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The jobs' ARNs.
        public let arn: String

        public init(nextToken: String? = nil, arn: String) {
            self.nextToken = nextToken
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct Run: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The run's name.
        public let name: String?
        /// The run's platform. Allowed values include:   ANDROID: The Android platform.   IOS: The iOS platform.  
        public let platform: DevicePlatform?
        /// The run's type. Must be one of the following values:   BUILTIN_FUZZ: The built-in fuzz type.   BUILTIN_EXPLORER: For Android, an app explorer that will traverse an Android app, interacting with it and capturing screenshots at the same time.   APPIUM_JAVA_JUNIT: The Appium Java JUnit type.   APPIUM_JAVA_TESTNG: The Appium Java TestNG type.   APPIUM_PYTHON: The Appium Python type.   APPIUM_WEB_JAVA_JUNIT: The Appium Java JUnit type for Web apps.   APPIUM_WEB_JAVA_TESTNG: The Appium Java TestNG type for Web apps.   APPIUM_WEB_PYTHON: The Appium Python type for Web apps.   CALABASH: The Calabash type.   INSTRUMENTATION: The Instrumentation type.   UIAUTOMATION: The uiautomation type.   UIAUTOMATOR: The uiautomator type.   XCTEST: The XCode test type.   XCTEST_UI: The XCode UI test type.  
        public let `type`: TestType?
        /// The run's result. Allowed values include:   PENDING: A pending condition.   PASSED: A passing condition.   WARNED: A warning condition.   FAILED: A failed condition.   SKIPPED: A skipped condition.   ERRORED: An error condition.   STOPPED: A stopped condition.  
        public let result: ExecutionResult?
        /// The run's ARN.
        public let arn: String?
        /// The run's status. Allowed values include:   PENDING: A pending status.   PENDING_CONCURRENCY: A pending concurrency status.   PENDING_DEVICE: A pending device status.   PROCESSING: A processing status.   SCHEDULING: A scheduling status.   PREPARING: A preparing status.   RUNNING: A running status.   COMPLETED: A completed status.   STOPPING: A stopping status.  
        public let status: ExecutionStatus?
        /// The total number of completed jobs.
        public let completedJobs: Int32?
        /// When the run was created.
        public let created: Date?
        /// The run's start time.
        public let started: Date?
        /// The total number of jobs for the run.
        public let totalJobs: Int32?
        /// The run's stop time.
        public let stopped: Date?
        /// Represents the total (metered or unmetered) minutes used by the test run.
        public let deviceMinutes: DeviceMinutes?
        /// A message about the run's result.
        public let message: String?
        /// The network profile being used for a test run.
        public let networkProfile: NetworkProfile?
        /// The run's result counters.
        public let counters: Counters?
        /// Specifies the billing method for a test run: metered or unmetered. If the parameter is not specified, the default value is metered.
        public let billingMethod: BillingMethod?

        public init(name: String? = nil, platform: DevicePlatform? = nil, type: TestType? = nil, result: ExecutionResult? = nil, arn: String? = nil, status: ExecutionStatus? = nil, completedJobs: Int32? = nil, created: Date? = nil, started: Date? = nil, totalJobs: Int32? = nil, stopped: Date? = nil, deviceMinutes: DeviceMinutes? = nil, message: String? = nil, networkProfile: NetworkProfile? = nil, counters: Counters? = nil, billingMethod: BillingMethod? = nil) {
            self.name = name
            self.platform = platform
            self.`type` = `type`
            self.result = result
            self.arn = arn
            self.status = status
            self.completedJobs = completedJobs
            self.created = created
            self.started = started
            self.totalJobs = totalJobs
            self.stopped = stopped
            self.deviceMinutes = deviceMinutes
            self.message = message
            self.networkProfile = networkProfile
            self.counters = counters
            self.billingMethod = billingMethod
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["name"] as? String
            if let platform = dictionary["platform"] as? String { self.platform = DevicePlatform(rawValue: platform) } else { self.platform = nil }
            if let `type` = dictionary["type"] as? String { self.`type` = TestType(rawValue: `type`) } else { self.`type` = nil }
            if let result = dictionary["result"] as? String { self.result = ExecutionResult(rawValue: result) } else { self.result = nil }
            self.arn = dictionary["arn"] as? String
            if let status = dictionary["status"] as? String { self.status = ExecutionStatus(rawValue: status) } else { self.status = nil }
            self.completedJobs = dictionary["completedJobs"] as? Int32
            self.created = dictionary["created"] as? Date
            self.started = dictionary["started"] as? Date
            self.totalJobs = dictionary["totalJobs"] as? Int32
            self.stopped = dictionary["stopped"] as? Date
            if let deviceMinutes = dictionary["deviceMinutes"] as? [String: Any] { self.deviceMinutes = try Devicefarm.DeviceMinutes(dictionary: deviceMinutes) } else { self.deviceMinutes = nil }
            self.message = dictionary["message"] as? String
            if let networkProfile = dictionary["networkProfile"] as? [String: Any] { self.networkProfile = try Devicefarm.NetworkProfile(dictionary: networkProfile) } else { self.networkProfile = nil }
            if let counters = dictionary["counters"] as? [String: Any] { self.counters = try Devicefarm.Counters(dictionary: counters) } else { self.counters = nil }
            if let billingMethod = dictionary["billingMethod"] as? String { self.billingMethod = BillingMethod(rawValue: billingMethod) } else { self.billingMethod = nil }
        }
    }

    public struct DevicePoolCompatibilityResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The device (phone or tablet) that you wish to return information about.
        public let device: Device?
        /// Whether the result was compatible with the device pool.
        public let compatible: Bool?
        /// Information about the compatibility.
        public let incompatibilityMessages: [IncompatibilityMessage]?

        public init(device: Device? = nil, compatible: Bool? = nil, incompatibilityMessages: [IncompatibilityMessage]? = nil) {
            self.device = device
            self.compatible = compatible
            self.incompatibilityMessages = incompatibilityMessages
        }

        public init(dictionary: [String: Any]) throws {
            if let device = dictionary["device"] as? [String: Any] { self.device = try Devicefarm.Device(dictionary: device) } else { self.device = nil }
            self.compatible = dictionary["compatible"] as? Bool
            if let incompatibilityMessages = dictionary["incompatibilityMessages"] as? [[String: Any]] {
                self.incompatibilityMessages = try incompatibilityMessages.map({ try IncompatibilityMessage(dictionary: $0) })
            } else { 
                self.incompatibilityMessages = nil
            }
        }
    }

    public struct Upload: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The upload's metadata. For example, for Android, this contains information that is parsed from the manifest and is displayed in the AWS Device Farm console after the associated app is uploaded.
        public let metadata: String?
        /// The upload's status. Must be one of the following values:   FAILED: A failed status.   INITIALIZED: An initialized status.   PROCESSING: A processing status.   SUCCEEDED: A succeeded status.  
        public let status: UploadStatus?
        /// The upload's content type (for example, "application/octet-stream").
        public let contentType: String?
        /// The upload's file name.
        public let name: String?
        /// When the upload was created.
        public let created: Date?
        /// A message about the upload's result.
        public let message: String?
        /// The upload's type. Must be one of the following values:   ANDROID_APP: An Android upload.   IOS_APP: An iOS upload.   WEB_APP: A web appliction upload.   EXTERNAL_DATA: An external data upload.   APPIUM_JAVA_JUNIT_TEST_PACKAGE: An Appium Java JUnit test package upload.   APPIUM_JAVA_TESTNG_TEST_PACKAGE: An Appium Java TestNG test package upload.   APPIUM_PYTHON_TEST_PACKAGE: An Appium Python test package upload.   APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE: An Appium Java JUnit test package upload.   APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE: An Appium Java TestNG test package upload.   APPIUM_WEB_PYTHON_TEST_PACKAGE: An Appium Python test package upload.   CALABASH_TEST_PACKAGE: A Calabash test package upload.   INSTRUMENTATION_TEST_PACKAGE: An instrumentation upload.   UIAUTOMATION_TEST_PACKAGE: A uiautomation test package upload.   UIAUTOMATOR_TEST_PACKAGE: A uiautomator test package upload.   XCTEST_TEST_PACKAGE: An XCode test package upload.   XCTEST_UI_TEST_PACKAGE: An XCode UI test package upload.  
        public let `type`: UploadType?
        /// The pre-signed Amazon S3 URL that was used to store a file through a corresponding PUT request.
        public let url: String?
        /// The upload's ARN.
        public let arn: String?

        public init(metadata: String? = nil, status: UploadStatus? = nil, contentType: String? = nil, name: String? = nil, created: Date? = nil, message: String? = nil, type: UploadType? = nil, url: String? = nil, arn: String? = nil) {
            self.metadata = metadata
            self.status = status
            self.contentType = contentType
            self.name = name
            self.created = created
            self.message = message
            self.`type` = `type`
            self.url = url
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.metadata = dictionary["metadata"] as? String
            if let status = dictionary["status"] as? String { self.status = UploadStatus(rawValue: status) } else { self.status = nil }
            self.contentType = dictionary["contentType"] as? String
            self.name = dictionary["name"] as? String
            self.created = dictionary["created"] as? Date
            self.message = dictionary["message"] as? String
            if let `type` = dictionary["type"] as? String { self.`type` = UploadType(rawValue: `type`) } else { self.`type` = nil }
            self.url = dictionary["url"] as? String
            self.arn = dictionary["arn"] as? String
        }
    }

    public struct ListOfferingsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct DeleteRunResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct DeleteProjectResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ListDevicePoolsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the device pools.
        public let devicePools: [DevicePool]?
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(devicePools: [DevicePool]? = nil, nextToken: String? = nil) {
            self.devicePools = devicePools
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let devicePools = dictionary["devicePools"] as? [[String: Any]] {
                self.devicePools = try devicePools.map({ try DevicePool(dictionary: $0) })
            } else { 
                self.devicePools = nil
            }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct ListOfferingTransactionsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The audit log of subscriptions you have purchased and modified through AWS Device Farm.
        public let offeringTransactions: [OfferingTransaction]?

        public init(nextToken: String? = nil, offeringTransactions: [OfferingTransaction]? = nil) {
            self.nextToken = nextToken
            self.offeringTransactions = offeringTransactions
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            if let offeringTransactions = dictionary["offeringTransactions"] as? [[String: Any]] {
                self.offeringTransactions = try offeringTransactions.map({ try OfferingTransaction(dictionary: $0) })
            } else { 
                self.offeringTransactions = nil
            }
        }
    }

    public enum DevicePoolType: String, CustomStringConvertible {
        case curated = "CURATED"
        case `private` = "PRIVATE"
        public var description: String { return self.rawValue }
    }

    public struct ListSuitesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The suites' ARNs.
        public let arn: String

        public init(nextToken: String? = nil, arn: String) {
            self.nextToken = nextToken
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct CPU: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The CPU's frequency.
        public let frequency: String?
        /// The CPU's architecture, for example x86 or ARM.
        public let architecture: String?
        /// The clock speed of the device's CPU, expressed in hertz (Hz). For example, a 1.2 GHz CPU is expressed as 1200000000.
        public let clock: Double?

        public init(frequency: String? = nil, architecture: String? = nil, clock: Double? = nil) {
            self.frequency = frequency
            self.architecture = architecture
            self.clock = clock
        }

        public init(dictionary: [String: Any]) throws {
            self.frequency = dictionary["frequency"] as? String
            self.architecture = dictionary["architecture"] as? String
            self.clock = dictionary["clock"] as? Double
        }
    }

    public struct InstallToRemoteAccessSessionResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An app to upload or that has been uploaded.
        public let appUpload: Upload?

        public init(appUpload: Upload? = nil) {
            self.appUpload = appUpload
        }

        public init(dictionary: [String: Any]) throws {
            if let appUpload = dictionary["appUpload"] as? [String: Any] { self.appUpload = try Devicefarm.Upload(dictionary: appUpload) } else { self.appUpload = nil }
        }
    }

    public struct GetNetworkProfileRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Amazon Resource Name (ARN) of the network profile you want to return information about.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct Counters: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The number of warned entities.
        public let warned: Int32?
        /// The number of errored entities.
        public let errored: Int32?
        /// The number of failed entities.
        public let failed: Int32?
        /// The number of skipped entities.
        public let skipped: Int32?
        /// The number of passed entities.
        public let passed: Int32?
        /// The number of stopped entities.
        public let stopped: Int32?
        /// The total number of entities.
        public let total: Int32?

        public init(warned: Int32? = nil, errored: Int32? = nil, failed: Int32? = nil, skipped: Int32? = nil, passed: Int32? = nil, stopped: Int32? = nil, total: Int32? = nil) {
            self.warned = warned
            self.errored = errored
            self.failed = failed
            self.skipped = skipped
            self.passed = passed
            self.stopped = stopped
            self.total = total
        }

        public init(dictionary: [String: Any]) throws {
            self.warned = dictionary["warned"] as? Int32
            self.errored = dictionary["errored"] as? Int32
            self.failed = dictionary["failed"] as? Int32
            self.skipped = dictionary["skipped"] as? Int32
            self.passed = dictionary["passed"] as? Int32
            self.stopped = dictionary["stopped"] as? Int32
            self.total = dictionary["total"] as? Int32
        }
    }

    public struct DeleteRemoteAccessSessionResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct DeviceMinutes: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// When specified, represents the total minutes used by the resource to run tests.
        public let total: Double?
        /// When specified, represents only the sum of metered minutes used by the resource to run tests.
        public let metered: Double?
        /// When specified, represents only the sum of unmetered minutes used by the resource to run tests.
        public let unmetered: Double?

        public init(total: Double? = nil, metered: Double? = nil, unmetered: Double? = nil) {
            self.total = total
            self.metered = metered
            self.unmetered = unmetered
        }

        public init(dictionary: [String: Any]) throws {
            self.total = dictionary["total"] as? Double
            self.metered = dictionary["metered"] as? Double
            self.unmetered = dictionary["unmetered"] as? Double
        }
    }

    public struct ListRemoteAccessSessionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the remote access session about which you are requesting information.
        public let arn: String

        public init(nextToken: String? = nil, arn: String) {
            self.nextToken = nextToken
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct ListArtifactsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The artifacts' type. Allowed values include:   FILE: The artifacts are files.   LOG: The artifacts are logs.   SCREENSHOT: The artifacts are screenshots.  
        public let `type`: ArtifactCategory
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The Run, Job, Suite, or Test ARN.
        public let arn: String

        public init(type: ArtifactCategory, nextToken: String? = nil, arn: String) {
            self.`type` = `type`
            self.nextToken = nextToken
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let rawtype = dictionary["type"] as? String, let `type` = ArtifactCategory(rawValue: rawtype) else { throw InitializableError.missingRequiredParam("type") }
            self.`type` = `type`
            self.nextToken = dictionary["nextToken"] as? String
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct GetTestRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The test's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct GetDeviceResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An object containing information about the requested device.
        public let device: Device?

        public init(device: Device? = nil) {
            self.device = device
        }

        public init(dictionary: [String: Any]) throws {
            if let device = dictionary["device"] as? [String: Any] { self.device = try Devicefarm.Device(dictionary: device) } else { self.device = nil }
        }
    }

    public struct DeleteProjectRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Represents the Amazon Resource Name (ARN) of the Device Farm project you wish to delete.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public enum ExecutionStatus: String, CustomStringConvertible {
        case pending = "PENDING"
        case pending_concurrency = "PENDING_CONCURRENCY"
        case pending_device = "PENDING_DEVICE"
        case processing = "PROCESSING"
        case scheduling = "SCHEDULING"
        case preparing = "PREPARING"
        case running = "RUNNING"
        case completed = "COMPLETED"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public struct StopRunRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Represents the Amazon Resource Name (ARN) of the Device Farm run you wish to stop.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public enum OfferingType: String, CustomStringConvertible {
        case recurring = "RECURRING"
        public var description: String { return self.rawValue }
    }

    public struct ListUniqueProblemsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the unique problems. Allowed values include:   PENDING: A pending condition.   PASSED: A passing condition.   WARNED: A warning condition.   FAILED: A failed condition.   SKIPPED: A skipped condition.   ERRORED: An error condition.   STOPPED: A stopped condition.  
        public let uniqueProblems: [ExecutionResult: [UniqueProblem]]?
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(uniqueProblems: [ExecutionResult: [UniqueProblem]]? = nil, nextToken: String? = nil) {
            self.uniqueProblems = uniqueProblems
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let uniqueProblems = dictionary["uniqueProblems"] as? [String: Any] {
                var uniqueProblemsDict: [ExecutionResult: [UniqueProblem]] = [:]
                for (key, value) in uniqueProblems {
                    guard let uniqueProblem = value as? [[String: Any]] else { throw InitializableError.convertingError }
                    let uniqueProblemList: [UniqueProblem] = try uniqueProblem.map { try UniqueProblem(dictionary: $0) }
                    uniqueProblemsDict[ExecutionResult(rawValue: key)!] = uniqueProblemList
                }
                self.uniqueProblems = uniqueProblemsDict
            } else { 
                self.uniqueProblems = nil
            }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public enum DevicePlatform: String, CustomStringConvertible {
        case android = "ANDROID"
        case ios = "IOS"
        public var description: String { return self.rawValue }
    }

    public struct Problem: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the associated test.
        public let test: ProblemDetail?
        /// Information about the associated suite.
        public let suite: ProblemDetail?
        /// Information about the associated job.
        public let job: ProblemDetail?
        /// A message about the problem's result.
        public let message: String?
        /// Information about the associated device.
        public let device: Device?
        /// Information about the associated run.
        public let run: ProblemDetail?
        /// The problem's result. Allowed values include:   PENDING: A pending condition.   PASSED: A passing condition.   WARNED: A warning condition.   FAILED: A failed condition.   SKIPPED: A skipped condition.   ERRORED: An error condition.   STOPPED: A stopped condition.  
        public let result: ExecutionResult?

        public init(test: ProblemDetail? = nil, suite: ProblemDetail? = nil, job: ProblemDetail? = nil, message: String? = nil, device: Device? = nil, run: ProblemDetail? = nil, result: ExecutionResult? = nil) {
            self.test = test
            self.suite = suite
            self.job = job
            self.message = message
            self.device = device
            self.run = run
            self.result = result
        }

        public init(dictionary: [String: Any]) throws {
            if let test = dictionary["test"] as? [String: Any] { self.test = try Devicefarm.ProblemDetail(dictionary: test) } else { self.test = nil }
            if let suite = dictionary["suite"] as? [String: Any] { self.suite = try Devicefarm.ProblemDetail(dictionary: suite) } else { self.suite = nil }
            if let job = dictionary["job"] as? [String: Any] { self.job = try Devicefarm.ProblemDetail(dictionary: job) } else { self.job = nil }
            self.message = dictionary["message"] as? String
            if let device = dictionary["device"] as? [String: Any] { self.device = try Devicefarm.Device(dictionary: device) } else { self.device = nil }
            if let run = dictionary["run"] as? [String: Any] { self.run = try Devicefarm.ProblemDetail(dictionary: run) } else { self.run = nil }
            if let result = dictionary["result"] as? String { self.result = ExecutionResult(rawValue: result) } else { self.result = nil }
        }
    }

    public struct Sample: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The sample's type. Must be one of the following values:   CPU: A CPU sample type. This is expressed as the app processing CPU time (including child processes) as reported by process, as a percentage.   MEMORY: A memory usage sample type. This is expressed as the total proportional set size of an app process, in kilobytes.   NATIVE_AVG_DRAWTIME   NATIVE_FPS   NATIVE_FRAMES   NATIVE_MAX_DRAWTIME   NATIVE_MIN_DRAWTIME   OPENGL_AVG_DRAWTIME   OPENGL_FPS   OPENGL_FRAMES   OPENGL_MAX_DRAWTIME   OPENGL_MIN_DRAWTIME   RX   RX_RATE: The total number of bytes per second (TCP and UDP) that are sent, by app process.   THREADS: A threads sample type. This is expressed as the total number of threads per app process.   TX   TX_RATE: The total number of bytes per second (TCP and UDP) that are received, by app process.  
        public let `type`: SampleType?
        /// The pre-signed Amazon S3 URL that can be used with a corresponding GET request to download the sample's file.
        public let url: String?
        /// The sample's ARN.
        public let arn: String?

        public init(type: SampleType? = nil, url: String? = nil, arn: String? = nil) {
            self.`type` = `type`
            self.url = url
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            if let `type` = dictionary["type"] as? String { self.`type` = SampleType(rawValue: `type`) } else { self.`type` = nil }
            self.url = dictionary["url"] as? String
            self.arn = dictionary["arn"] as? String
        }
    }

    public struct DeleteRunRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Amazon Resource Name (ARN) for the run you wish to delete.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct CreateDevicePoolResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The newly created device pool.
        public let devicePool: DevicePool?

        public init(devicePool: DevicePool? = nil) {
            self.devicePool = devicePool
        }

        public init(dictionary: [String: Any]) throws {
            if let devicePool = dictionary["devicePool"] as? [String: Any] { self.devicePool = try Devicefarm.DevicePool(dictionary: devicePool) } else { self.devicePool = nil }
        }
    }

    public struct UpdateDevicePoolRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A description of the device pool you wish to update.
        public let description: String?
        /// A string representing the name of the device pool you wish to update.
        public let name: String?
        /// Represents the rules you wish to modify for the device pool. Updating rules is optional; however, if you choose to update rules for your request, the update will replace the existing rules.
        public let rules: [Rule]?
        /// The Amazon Resourc Name (ARN) of the Device Farm device pool you wish to update.
        public let arn: String

        public init(description: String? = nil, name: String? = nil, rules: [Rule]? = nil, arn: String) {
            self.description = description
            self.name = name
            self.rules = rules
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.description = dictionary["description"] as? String
            self.name = dictionary["name"] as? String
            if let rules = dictionary["rules"] as? [[String: Any]] {
                self.rules = try rules.map({ try Rule(dictionary: $0) })
            } else { 
                self.rules = nil
            }
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public enum SampleType: String, CustomStringConvertible {
        case cpu = "CPU"
        case memory = "MEMORY"
        case threads = "THREADS"
        case rx_rate = "RX_RATE"
        case tx_rate = "TX_RATE"
        case rx = "RX"
        case tx = "TX"
        case native_frames = "NATIVE_FRAMES"
        case native_fps = "NATIVE_FPS"
        case native_min_drawtime = "NATIVE_MIN_DRAWTIME"
        case native_avg_drawtime = "NATIVE_AVG_DRAWTIME"
        case native_max_drawtime = "NATIVE_MAX_DRAWTIME"
        case opengl_frames = "OPENGL_FRAMES"
        case opengl_fps = "OPENGL_FPS"
        case opengl_min_drawtime = "OPENGL_MIN_DRAWTIME"
        case opengl_avg_drawtime = "OPENGL_AVG_DRAWTIME"
        case opengl_max_drawtime = "OPENGL_MAX_DRAWTIME"
        public var description: String { return self.rawValue }
    }

    public struct ListOfferingTransactionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct AccountSettings: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The AWS account number specified in the AccountSettings container.
        public let awsAccountNumber: String?
        /// Returns the unmetered devices you have purchased or want to purchase.
        public let unmeteredDevices: [DevicePlatform: Int32]?
        /// The default number of minutes (at the account level) a test run will execute before it times out. Default value is 60 minutes.
        public let defaultJobTimeoutMinutes: Int32?
        /// The maximum number of minutes a test run will execute before it times out.
        public let maxJobTimeoutMinutes: Int32?
        /// Returns the unmetered remote access devices you have purchased or want to purchase.
        public let unmeteredRemoteAccessDevices: [DevicePlatform: Int32]?

        public init(awsAccountNumber: String? = nil, unmeteredDevices: [DevicePlatform: Int32]? = nil, defaultJobTimeoutMinutes: Int32? = nil, maxJobTimeoutMinutes: Int32? = nil, unmeteredRemoteAccessDevices: [DevicePlatform: Int32]? = nil) {
            self.awsAccountNumber = awsAccountNumber
            self.unmeteredDevices = unmeteredDevices
            self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
            self.maxJobTimeoutMinutes = maxJobTimeoutMinutes
            self.unmeteredRemoteAccessDevices = unmeteredRemoteAccessDevices
        }

        public init(dictionary: [String: Any]) throws {
            self.awsAccountNumber = dictionary["awsAccountNumber"] as? String
            if let unmeteredDevices = dictionary["unmeteredDevices"] as? [DevicePlatform: Int32] {
                self.unmeteredDevices = unmeteredDevices
            } else { 
                self.unmeteredDevices = nil
            }
            self.defaultJobTimeoutMinutes = dictionary["defaultJobTimeoutMinutes"] as? Int32
            self.maxJobTimeoutMinutes = dictionary["maxJobTimeoutMinutes"] as? Int32
            if let unmeteredRemoteAccessDevices = dictionary["unmeteredRemoteAccessDevices"] as? [DevicePlatform: Int32] {
                self.unmeteredRemoteAccessDevices = unmeteredRemoteAccessDevices
            } else { 
                self.unmeteredRemoteAccessDevices = nil
            }
        }
    }

    public struct StopRemoteAccessSessionResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A container representing the metadata from the service about the remote access session you are stopping.
        public let remoteAccessSession: RemoteAccessSession?

        public init(remoteAccessSession: RemoteAccessSession? = nil) {
            self.remoteAccessSession = remoteAccessSession
        }

        public init(dictionary: [String: Any]) throws {
            if let remoteAccessSession = dictionary["remoteAccessSession"] as? [String: Any] { self.remoteAccessSession = try Devicefarm.RemoteAccessSession(dictionary: remoteAccessSession) } else { self.remoteAccessSession = nil }
        }
    }

    public struct ListArtifactsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the artifacts.
        public let artifacts: [Artifact]?
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(artifacts: [Artifact]? = nil, nextToken: String? = nil) {
            self.artifacts = artifacts
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let artifacts = dictionary["artifacts"] as? [[String: Any]] {
                self.artifacts = try artifacts.map({ try Artifact(dictionary: $0) })
            } else { 
                self.artifacts = nil
            }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct GetNetworkProfileResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The network profile.
        public let networkProfile: NetworkProfile?

        public init(networkProfile: NetworkProfile? = nil) {
            self.networkProfile = networkProfile
        }

        public init(dictionary: [String: Any]) throws {
            if let networkProfile = dictionary["networkProfile"] as? [String: Any] { self.networkProfile = try Devicefarm.NetworkProfile(dictionary: networkProfile) } else { self.networkProfile = nil }
        }
    }

    public struct Location: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The longitude.
        public let longitude: Double
        /// The latitude.
        public let latitude: Double

        public init(longitude: Double, latitude: Double) {
            self.longitude = longitude
            self.latitude = latitude
        }

        public init(dictionary: [String: Any]) throws {
            guard let longitude = dictionary["longitude"] as? Double else { throw InitializableError.missingRequiredParam("longitude") }
            self.longitude = longitude
            guard let latitude = dictionary["latitude"] as? Double else { throw InitializableError.missingRequiredParam("latitude") }
            self.latitude = latitude
        }
    }

    public struct GetAccountSettingsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The account settings.
        public let accountSettings: AccountSettings?

        public init(accountSettings: AccountSettings? = nil) {
            self.accountSettings = accountSettings
        }

        public init(dictionary: [String: Any]) throws {
            if let accountSettings = dictionary["accountSettings"] as? [String: Any] { self.accountSettings = try Devicefarm.AccountSettings(dictionary: accountSettings) } else { self.accountSettings = nil }
        }
    }

    public struct GetDevicePoolCompatibilityRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the app that is associated with the specified device pool.
        public let appArn: String?
        /// The device pool's ARN.
        public let devicePoolArn: String
        /// The test type for the specified device pool. Allowed values include the following:   BUILTIN_FUZZ: The built-in fuzz type.   BUILTIN_EXPLORER: For Android, an app explorer that will traverse an Android app, interacting with it and capturing screenshots at the same time.   APPIUM_JAVA_JUNIT: The Appium Java JUnit type.   APPIUM_JAVA_TESTNG: The Appium Java TestNG type.   APPIUM_PYTHON: The Appium Python type.   APPIUM_WEB_JAVA_JUNIT: The Appium Java JUnit type for Web apps.   APPIUM_WEB_JAVA_TESTNG: The Appium Java TestNG type for Web apps.   APPIUM_WEB_PYTHON: The Appium Python type for Web apps.   CALABASH: The Calabash type.   INSTRUMENTATION: The Instrumentation type.   UIAUTOMATION: The uiautomation type.   UIAUTOMATOR: The uiautomator type.   XCTEST: The XCode test type.   XCTEST_UI: The XCode UI test type.  
        public let testType: TestType?

        public init(appArn: String? = nil, devicePoolArn: String, testType: TestType? = nil) {
            self.appArn = appArn
            self.devicePoolArn = devicePoolArn
            self.testType = testType
        }

        public init(dictionary: [String: Any]) throws {
            self.appArn = dictionary["appArn"] as? String
            guard let devicePoolArn = dictionary["devicePoolArn"] as? String else { throw InitializableError.missingRequiredParam("devicePoolArn") }
            self.devicePoolArn = devicePoolArn
            if let testType = dictionary["testType"] as? String { self.testType = TestType(rawValue: testType) } else { self.testType = nil }
        }
    }

    public struct Resolution: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The screen resolution's height, expressed in pixels.
        public let height: Int32?
        /// The screen resolution's width, expressed in pixels.
        public let width: Int32?

        public init(height: Int32? = nil, width: Int32? = nil) {
            self.height = height
            self.width = width
        }

        public init(dictionary: [String: Any]) throws {
            self.height = dictionary["height"] as? Int32
            self.width = dictionary["width"] as? Int32
        }
    }

    public struct RenewOfferingRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of a request to renew an offering.
        public let offeringId: String?
        /// The quantity requested in an offering renewal.
        public let quantity: Int32?

        public init(offeringId: String? = nil, quantity: Int32? = nil) {
            self.offeringId = offeringId
            self.quantity = quantity
        }

        public init(dictionary: [String: Any]) throws {
            self.offeringId = dictionary["offeringId"] as? String
            self.quantity = dictionary["quantity"] as? Int32
        }
    }

    public struct Device: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The device's display name.
        public let name: String?
        /// Information about the device's CPU.
        public let cpu: CPU?
        /// The device's platform. Allowed values include:   ANDROID: The Android platform.   IOS: The iOS platform.  
        public let platform: DevicePlatform?
        /// The device's heap size, expressed in bytes.
        public let heapSize: Int64?
        /// The device's model name.
        public let model: String?
        /// The device's radio.
        public let radio: String?
        /// The device's ARN.
        public let arn: String?
        /// The device's total memory size, expressed in bytes.
        public let memory: Int64?
        /// The resolution of the device.
        public let resolution: Resolution?
        /// The device's operating system type.
        public let os: String?
        /// The device's image name.
        public let image: String?
        /// Specifies whether remote access has been enabled for the specified device.
        public let remoteAccessEnabled: Bool?
        /// The device's form factor. Allowed values include:   PHONE: The phone form factor.   TABLET: The tablet form factor.  
        public let formFactor: DeviceFormFactor?
        /// The type of fleet to which this device belongs. Possible values for fleet type are PRIVATE and PUBLIC.
        public let fleetType: String?
        /// The name of the fleet to which this device belongs.
        public let fleetName: String?
        /// The device's manufacturer name.
        public let manufacturer: String?
        /// The device's carrier.
        public let carrier: String?

        public init(name: String? = nil, cpu: CPU? = nil, platform: DevicePlatform? = nil, heapSize: Int64? = nil, model: String? = nil, radio: String? = nil, arn: String? = nil, memory: Int64? = nil, resolution: Resolution? = nil, os: String? = nil, image: String? = nil, remoteAccessEnabled: Bool? = nil, formFactor: DeviceFormFactor? = nil, fleetType: String? = nil, fleetName: String? = nil, manufacturer: String? = nil, carrier: String? = nil) {
            self.name = name
            self.cpu = cpu
            self.platform = platform
            self.heapSize = heapSize
            self.model = model
            self.radio = radio
            self.arn = arn
            self.memory = memory
            self.resolution = resolution
            self.os = os
            self.image = image
            self.remoteAccessEnabled = remoteAccessEnabled
            self.formFactor = formFactor
            self.fleetType = fleetType
            self.fleetName = fleetName
            self.manufacturer = manufacturer
            self.carrier = carrier
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["name"] as? String
            if let cpu = dictionary["cpu"] as? [String: Any] { self.cpu = try Devicefarm.CPU(dictionary: cpu) } else { self.cpu = nil }
            if let platform = dictionary["platform"] as? String { self.platform = DevicePlatform(rawValue: platform) } else { self.platform = nil }
            self.heapSize = dictionary["heapSize"] as? Int64
            self.model = dictionary["model"] as? String
            self.radio = dictionary["radio"] as? String
            self.arn = dictionary["arn"] as? String
            self.memory = dictionary["memory"] as? Int64
            if let resolution = dictionary["resolution"] as? [String: Any] { self.resolution = try Devicefarm.Resolution(dictionary: resolution) } else { self.resolution = nil }
            self.os = dictionary["os"] as? String
            self.image = dictionary["image"] as? String
            self.remoteAccessEnabled = dictionary["remoteAccessEnabled"] as? Bool
            if let formFactor = dictionary["formFactor"] as? String { self.formFactor = DeviceFormFactor(rawValue: formFactor) } else { self.formFactor = nil }
            self.fleetType = dictionary["fleetType"] as? String
            self.fleetName = dictionary["fleetName"] as? String
            self.manufacturer = dictionary["manufacturer"] as? String
            self.carrier = dictionary["carrier"] as? String
        }
    }

    public struct ListRunsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the project for which you want to list runs.
        public let arn: String

        public init(nextToken: String? = nil, arn: String) {
            self.nextToken = nextToken
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct Job: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The device (phone or tablet).
        public let device: Device?
        /// The job's status. Allowed values include:   PENDING: A pending status.   PENDING_CONCURRENCY: A pending concurrency status.   PENDING_DEVICE: A pending device status.   PROCESSING: A processing status.   SCHEDULING: A scheduling status.   PREPARING: A preparing status.   RUNNING: A running status.   COMPLETED: A completed status.   STOPPING: A stopping status.  
        public let status: ExecutionStatus?
        /// The job's name.
        public let name: String?
        /// When the job was created.
        public let created: Date?
        /// The job's start time.
        public let started: Date?
        /// The job's stop time.
        public let stopped: Date?
        /// Represents the total (metered or unmetered) minutes used by the job.
        public let deviceMinutes: DeviceMinutes?
        /// A message about the job's result.
        public let message: String?
        /// The job's type. Allowed values include the following:   BUILTIN_FUZZ: The built-in fuzz type.   BUILTIN_EXPLORER: For Android, an app explorer that will traverse an Android app, interacting with it and capturing screenshots at the same time.   APPIUM_JAVA_JUNIT: The Appium Java JUnit type.   APPIUM_JAVA_TESTNG: The Appium Java TestNG type.   APPIUM_PYTHON: The Appium Python type.   APPIUM_WEB_JAVA_JUNIT: The Appium Java JUnit type for Web apps.   APPIUM_WEB_JAVA_TESTNG: The Appium Java TestNG type for Web apps.   APPIUM_WEB_PYTHON: The Appium Python type for Web apps.   CALABASH: The Calabash type.   INSTRUMENTATION: The Instrumentation type.   UIAUTOMATION: The uiautomation type.   UIAUTOMATOR: The uiautomator type.   XCTEST: The XCode test type.   XCTEST_UI: The XCode UI test type.  
        public let `type`: TestType?
        /// The job's result. Allowed values include:   PENDING: A pending condition.   PASSED: A passing condition.   WARNED: A warning condition.   FAILED: A failed condition.   SKIPPED: A skipped condition.   ERRORED: An error condition.   STOPPED: A stopped condition.  
        public let result: ExecutionResult?
        /// The job's result counters.
        public let counters: Counters?
        /// The job's ARN.
        public let arn: String?

        public init(device: Device? = nil, status: ExecutionStatus? = nil, name: String? = nil, created: Date? = nil, started: Date? = nil, stopped: Date? = nil, deviceMinutes: DeviceMinutes? = nil, message: String? = nil, type: TestType? = nil, result: ExecutionResult? = nil, counters: Counters? = nil, arn: String? = nil) {
            self.device = device
            self.status = status
            self.name = name
            self.created = created
            self.started = started
            self.stopped = stopped
            self.deviceMinutes = deviceMinutes
            self.message = message
            self.`type` = `type`
            self.result = result
            self.counters = counters
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            if let device = dictionary["device"] as? [String: Any] { self.device = try Devicefarm.Device(dictionary: device) } else { self.device = nil }
            if let status = dictionary["status"] as? String { self.status = ExecutionStatus(rawValue: status) } else { self.status = nil }
            self.name = dictionary["name"] as? String
            self.created = dictionary["created"] as? Date
            self.started = dictionary["started"] as? Date
            self.stopped = dictionary["stopped"] as? Date
            if let deviceMinutes = dictionary["deviceMinutes"] as? [String: Any] { self.deviceMinutes = try Devicefarm.DeviceMinutes(dictionary: deviceMinutes) } else { self.deviceMinutes = nil }
            self.message = dictionary["message"] as? String
            if let `type` = dictionary["type"] as? String { self.`type` = TestType(rawValue: `type`) } else { self.`type` = nil }
            if let result = dictionary["result"] as? String { self.result = ExecutionResult(rawValue: result) } else { self.result = nil }
            if let counters = dictionary["counters"] as? [String: Any] { self.counters = try Devicefarm.Counters(dictionary: counters) } else { self.counters = nil }
            self.arn = dictionary["arn"] as? String
        }
    }

    public struct GetProjectRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The project's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct ListProjectsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// Optional. If no Amazon Resource Name (ARN) is specified, then AWS Device Farm returns a list of all projects for the AWS account. You can also specify a project ARN.
        public let arn: String?

        public init(nextToken: String? = nil, arn: String? = nil) {
            self.nextToken = nextToken
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            self.arn = dictionary["arn"] as? String
        }
    }

    public struct UpdateProjectRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A string representing the new name of the project that you are updating.
        public let name: String?
        /// The number of minutes a test run in the project will execute before it times out.
        public let defaultJobTimeoutMinutes: Int32?
        /// The Amazon Resource Name (ARN) of the project whose name you wish to update.
        public let arn: String

        public init(name: String? = nil, defaultJobTimeoutMinutes: Int32? = nil, arn: String) {
            self.name = name
            self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["name"] as? String
            self.defaultJobTimeoutMinutes = dictionary["defaultJobTimeoutMinutes"] as? Int32
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public enum ExecutionResult: String, CustomStringConvertible {
        case pending = "PENDING"
        case passed = "PASSED"
        case warned = "WARNED"
        case failed = "FAILED"
        case skipped = "SKIPPED"
        case errored = "ERRORED"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum BillingMethod: String, CustomStringConvertible {
        case metered = "METERED"
        case unmetered = "UNMETERED"
        public var description: String { return self.rawValue }
    }

    public struct InstallToRemoteAccessSessionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Amazon Resource Name (ARN) of the app about which you are requesting information.
        public let appArn: String
        /// The Amazon Resource Name (ARN) of the remote access session about which you are requesting information.
        public let remoteAccessSessionArn: String

        public init(appArn: String, remoteAccessSessionArn: String) {
            self.appArn = appArn
            self.remoteAccessSessionArn = remoteAccessSessionArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let appArn = dictionary["appArn"] as? String else { throw InitializableError.missingRequiredParam("appArn") }
            self.appArn = appArn
            guard let remoteAccessSessionArn = dictionary["remoteAccessSessionArn"] as? String else { throw InitializableError.missingRequiredParam("remoteAccessSessionArn") }
            self.remoteAccessSessionArn = remoteAccessSessionArn
        }
    }

    public struct GetDevicePoolCompatibilityResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about incompatible devices.
        public let incompatibleDevices: [DevicePoolCompatibilityResult]?
        /// Information about compatible devices.
        public let compatibleDevices: [DevicePoolCompatibilityResult]?

        public init(incompatibleDevices: [DevicePoolCompatibilityResult]? = nil, compatibleDevices: [DevicePoolCompatibilityResult]? = nil) {
            self.incompatibleDevices = incompatibleDevices
            self.compatibleDevices = compatibleDevices
        }

        public init(dictionary: [String: Any]) throws {
            if let incompatibleDevices = dictionary["incompatibleDevices"] as? [[String: Any]] {
                self.incompatibleDevices = try incompatibleDevices.map({ try DevicePoolCompatibilityResult(dictionary: $0) })
            } else { 
                self.incompatibleDevices = nil
            }
            if let compatibleDevices = dictionary["compatibleDevices"] as? [[String: Any]] {
                self.compatibleDevices = try compatibleDevices.map({ try DevicePoolCompatibilityResult(dictionary: $0) })
            } else { 
                self.compatibleDevices = nil
            }
        }
    }

    public struct GetRemoteAccessSessionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Amazon Resource Name (ARN) of the remote access session about which you want to get session information.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct GetProjectResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The project you wish to get information about.
        public let project: Project?

        public init(project: Project? = nil) {
            self.project = project
        }

        public init(dictionary: [String: Any]) throws {
            if let project = dictionary["project"] as? [String: Any] { self.project = try Devicefarm.Project(dictionary: project) } else { self.project = nil }
        }
    }

}