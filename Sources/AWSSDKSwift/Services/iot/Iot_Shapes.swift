// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Iot {

    public struct DynamoDBv2Action: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the IAM role that grants access to the DynamoDB table.
        public let roleArn: String?
        /// Specifies the DynamoDB table to which the message data will be written. For example: { "dynamoDBv2": { "roleArn": "aws:iam:12341251:my-role" "putItem": { "tableName": "my-table" } } } Each attribute in the message payload will be written to a separate column in the DynamoDB database.
        public let putItem: PutItemInput?

        public init(roleArn: String? = nil, putItem: PutItemInput? = nil) {
            self.roleArn = roleArn
            self.putItem = putItem
        }

        public init(dictionary: [String: Any]) throws {
            self.roleArn = dictionary["roleArn"] as? String
            if let putItem = dictionary["putItem"] as? [String: Any] { self.putItem = try Iot.PutItemInput(dictionary: putItem) } else { self.putItem = nil }
        }
    }

    public struct CreatePolicyResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The policy version ID.
        public let policyVersionId: String?
        /// The policy name.
        public let policyName: String?
        /// The policy ARN.
        public let policyArn: String?
        /// The JSON document that describes the policy.
        public let policyDocument: String?

        public init(policyVersionId: String? = nil, policyName: String? = nil, policyArn: String? = nil, policyDocument: String? = nil) {
            self.policyVersionId = policyVersionId
            self.policyName = policyName
            self.policyArn = policyArn
            self.policyDocument = policyDocument
        }

        public init(dictionary: [String: Any]) throws {
            self.policyVersionId = dictionary["policyVersionId"] as? String
            self.policyName = dictionary["policyName"] as? String
            self.policyArn = dictionary["policyArn"] as? String
            self.policyDocument = dictionary["policyDocument"] as? String
        }
    }

    public struct TransferCertificateRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["targetAwsAccount": "targetAwsAccount"]
        }
        public static var pathParams: [String: String] {
            return ["certificateId": "certificateId"]
        }
        /// The ID of the certificate.
        public let certificateId: String
        /// The transfer message.
        public let transferMessage: String?
        /// The AWS account.
        public let targetAwsAccount: String

        public init(certificateId: String, transferMessage: String? = nil, targetAwsAccount: String) {
            self.certificateId = certificateId
            self.transferMessage = transferMessage
            self.targetAwsAccount = targetAwsAccount
        }

        public init(dictionary: [String: Any]) throws {
            guard let certificateId = dictionary["CertificateId"] as? String else { throw InitializableError.missingRequiredParam("CertificateId") }
            self.certificateId = certificateId
            self.transferMessage = dictionary["transferMessage"] as? String
            guard let targetAwsAccount = dictionary["TargetAwsAccount"] as? String else { throw InitializableError.missingRequiredParam("TargetAwsAccount") }
            self.targetAwsAccount = targetAwsAccount
        }
    }

    public struct GetRegistrationCodeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ListCertificatesByCARequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["marker": "marker", "pageSize": "pageSize", "isAscendingOrder": "ascendingOrder"]
        }
        public static var pathParams: [String: String] {
            return ["caCertificateId": "caCertificateId"]
        }
        /// The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate. 
        public let caCertificateId: String
        /// The result page size.
        public let pageSize: Int32?
        /// The marker for the next set of results.
        public let marker: String?
        /// Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
        public let ascendingOrder: Bool?

        public init(caCertificateId: String, pageSize: Int32? = nil, marker: String? = nil, ascendingOrder: Bool? = nil) {
            self.caCertificateId = caCertificateId
            self.pageSize = pageSize
            self.marker = marker
            self.ascendingOrder = ascendingOrder
        }

        public init(dictionary: [String: Any]) throws {
            guard let caCertificateId = dictionary["CaCertificateId"] as? String else { throw InitializableError.missingRequiredParam("CaCertificateId") }
            self.caCertificateId = caCertificateId
            self.pageSize = dictionary["PageSize"] as? Int32
            self.marker = dictionary["Marker"] as? String
            self.ascendingOrder = dictionary["IsAscendingOrder"] as? Bool
        }
    }

    public struct Policy: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The policy ARN.
        public let policyArn: String?
        /// The policy name.
        public let policyName: String?

        public init(policyArn: String? = nil, policyName: String? = nil) {
            self.policyArn = policyArn
            self.policyName = policyName
        }

        public init(dictionary: [String: Any]) throws {
            self.policyArn = dictionary["policyArn"] as? String
            self.policyName = dictionary["policyName"] as? String
        }
    }

    public struct SetLoggingOptionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = "loggingOptionsPayload"
        /// The logging options payload.
        public let loggingOptionsPayload: LoggingOptionsPayload

        public init(loggingOptionsPayload: LoggingOptionsPayload) {
            self.loggingOptionsPayload = loggingOptionsPayload
        }

        public init(dictionary: [String: Any]) throws {
            guard let loggingOptionsPayload = dictionary["loggingOptionsPayload"] as? [String: Any] else { throw InitializableError.missingRequiredParam("loggingOptionsPayload") }
            self.loggingOptionsPayload = try Iot.LoggingOptionsPayload(dictionary: loggingOptionsPayload)
        }
    }

    public struct ListThingTypesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The thing types.
        public let thingTypes: [ThingTypeDefinition]?
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(thingTypes: [ThingTypeDefinition]? = nil, nextToken: String? = nil) {
            self.thingTypes = thingTypes
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let thingTypes = dictionary["thingTypes"] as? [[String: Any]] {
                self.thingTypes = try thingTypes.map({ try ThingTypeDefinition(dictionary: $0) })
            } else { 
                self.thingTypes = nil
            }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct Action: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Write data to an Amazon Kinesis stream.
        public let kinesis: KinesisAction?
        /// Write data to an Amazon Elasticsearch Service domain.
        public let elasticsearch: ElasticsearchAction?
        /// Publish to an Amazon SQS queue.
        public let sqs: SqsAction?
        /// Capture a CloudWatch metric.
        public let cloudwatchMetric: CloudwatchMetricAction?
        /// Publish to another MQTT topic.
        public let republish: RepublishAction?
        /// Write to an Amazon S3 bucket.
        public let s3: S3Action?
        /// Change the state of a CloudWatch alarm.
        public let cloudwatchAlarm: CloudwatchAlarmAction?
        /// Write to an Amazon Kinesis Firehose stream.
        public let firehose: FirehoseAction?
        /// Write to a DynamoDB table. This is a new version of the DynamoDB action. It allows you to write each attribute in an MQTT message payload into a separate DynamoDB column.
        public let dynamoDBv2: DynamoDBv2Action?
        /// Write to a DynamoDB table.
        public let dynamoDB: DynamoDBAction?
        /// Invoke a Lambda function.
        public let lambda: LambdaAction?
        /// Publish to an Amazon SNS topic.
        public let sns: SnsAction?

        public init(kinesis: KinesisAction? = nil, elasticsearch: ElasticsearchAction? = nil, sqs: SqsAction? = nil, cloudwatchMetric: CloudwatchMetricAction? = nil, republish: RepublishAction? = nil, s3: S3Action? = nil, cloudwatchAlarm: CloudwatchAlarmAction? = nil, firehose: FirehoseAction? = nil, dynamoDBv2: DynamoDBv2Action? = nil, dynamoDB: DynamoDBAction? = nil, lambda: LambdaAction? = nil, sns: SnsAction? = nil) {
            self.kinesis = kinesis
            self.elasticsearch = elasticsearch
            self.sqs = sqs
            self.cloudwatchMetric = cloudwatchMetric
            self.republish = republish
            self.s3 = s3
            self.cloudwatchAlarm = cloudwatchAlarm
            self.firehose = firehose
            self.dynamoDBv2 = dynamoDBv2
            self.dynamoDB = dynamoDB
            self.lambda = lambda
            self.sns = sns
        }

        public init(dictionary: [String: Any]) throws {
            if let kinesis = dictionary["kinesis"] as? [String: Any] { self.kinesis = try Iot.KinesisAction(dictionary: kinesis) } else { self.kinesis = nil }
            if let elasticsearch = dictionary["elasticsearch"] as? [String: Any] { self.elasticsearch = try Iot.ElasticsearchAction(dictionary: elasticsearch) } else { self.elasticsearch = nil }
            if let sqs = dictionary["sqs"] as? [String: Any] { self.sqs = try Iot.SqsAction(dictionary: sqs) } else { self.sqs = nil }
            if let cloudwatchMetric = dictionary["cloudwatchMetric"] as? [String: Any] { self.cloudwatchMetric = try Iot.CloudwatchMetricAction(dictionary: cloudwatchMetric) } else { self.cloudwatchMetric = nil }
            if let republish = dictionary["republish"] as? [String: Any] { self.republish = try Iot.RepublishAction(dictionary: republish) } else { self.republish = nil }
            if let s3 = dictionary["s3"] as? [String: Any] { self.s3 = try Iot.S3Action(dictionary: s3) } else { self.s3 = nil }
            if let cloudwatchAlarm = dictionary["cloudwatchAlarm"] as? [String: Any] { self.cloudwatchAlarm = try Iot.CloudwatchAlarmAction(dictionary: cloudwatchAlarm) } else { self.cloudwatchAlarm = nil }
            if let firehose = dictionary["firehose"] as? [String: Any] { self.firehose = try Iot.FirehoseAction(dictionary: firehose) } else { self.firehose = nil }
            if let dynamoDBv2 = dictionary["dynamoDBv2"] as? [String: Any] { self.dynamoDBv2 = try Iot.DynamoDBv2Action(dictionary: dynamoDBv2) } else { self.dynamoDBv2 = nil }
            if let dynamoDB = dictionary["dynamoDB"] as? [String: Any] { self.dynamoDB = try Iot.DynamoDBAction(dictionary: dynamoDB) } else { self.dynamoDB = nil }
            if let lambda = dictionary["lambda"] as? [String: Any] { self.lambda = try Iot.LambdaAction(dictionary: lambda) } else { self.lambda = nil }
            if let sns = dictionary["sns"] as? [String: Any] { self.sns = try Iot.SnsAction(dictionary: sns) } else { self.sns = nil }
        }
    }

    public struct DescribeCACertificateResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The CA certificate description.
        public let certificateDescription: CACertificateDescription?

        public init(certificateDescription: CACertificateDescription? = nil) {
            self.certificateDescription = certificateDescription
        }

        public init(dictionary: [String: Any]) throws {
            if let certificateDescription = dictionary["certificateDescription"] as? [String: Any] { self.certificateDescription = try Iot.CACertificateDescription(dictionary: certificateDescription) } else { self.certificateDescription = nil }
        }
    }

    public struct RepublishAction: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the IAM role that grants access.
        public let roleArn: String
        /// The name of the MQTT topic.
        public let topic: String

        public init(roleArn: String, topic: String) {
            self.roleArn = roleArn
            self.topic = topic
        }

        public init(dictionary: [String: Any]) throws {
            guard let roleArn = dictionary["roleArn"] as? String else { throw InitializableError.missingRequiredParam("roleArn") }
            self.roleArn = roleArn
            guard let topic = dictionary["topic"] as? String else { throw InitializableError.missingRequiredParam("topic") }
            self.topic = topic
        }
    }

    public struct GetTopicRuleRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["ruleName": "ruleName"]
        }
        /// The name of the rule.
        public let ruleName: String

        public init(ruleName: String) {
            self.ruleName = ruleName
        }

        public init(dictionary: [String: Any]) throws {
            guard let ruleName = dictionary["RuleName"] as? String else { throw InitializableError.missingRequiredParam("RuleName") }
            self.ruleName = ruleName
        }
    }

    public struct ListPolicyPrincipalsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The descriptions of the principals.
        public let principals: [String]?
        /// The marker for the next set of results, or null if there are no additional results.
        public let nextMarker: String?

        public init(principals: [String]? = nil, nextMarker: String? = nil) {
            self.principals = principals
            self.nextMarker = nextMarker
        }

        public init(dictionary: [String: Any]) throws {
            self.principals = dictionary["principals"] as? [String]
            self.nextMarker = dictionary["nextMarker"] as? String
        }
    }

    public struct ListCertificatesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The descriptions of the certificates.
        public let certificates: [Certificate]?
        /// The marker for the next set of results, or null if there are no additional results.
        public let nextMarker: String?

        public init(certificates: [Certificate]? = nil, nextMarker: String? = nil) {
            self.certificates = certificates
            self.nextMarker = nextMarker
        }

        public init(dictionary: [String: Any]) throws {
            if let certificates = dictionary["certificates"] as? [[String: Any]] {
                self.certificates = try certificates.map({ try Certificate(dictionary: $0) })
            } else { 
                self.certificates = nil
            }
            self.nextMarker = dictionary["nextMarker"] as? String
        }
    }

    public struct RegisterCACertificateRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["allowAutoRegistration": "allowAutoRegistration", "setAsActive": "setAsActive"]
        }
        /// Allows this CA certificate to be used for auto registration of device certificates.
        public let allowAutoRegistration: Bool?
        /// The private key verification certificate.
        public let verificationCertificate: String
        /// The CA certificate.
        public let caCertificate: String
        /// A boolean value that specifies if the CA certificate is set to active.
        public let setAsActive: Bool?

        public init(allowAutoRegistration: Bool? = nil, verificationCertificate: String, caCertificate: String, setAsActive: Bool? = nil) {
            self.allowAutoRegistration = allowAutoRegistration
            self.verificationCertificate = verificationCertificate
            self.caCertificate = caCertificate
            self.setAsActive = setAsActive
        }

        public init(dictionary: [String: Any]) throws {
            self.allowAutoRegistration = dictionary["AllowAutoRegistration"] as? Bool
            guard let verificationCertificate = dictionary["verificationCertificate"] as? String else { throw InitializableError.missingRequiredParam("verificationCertificate") }
            self.verificationCertificate = verificationCertificate
            guard let caCertificate = dictionary["caCertificate"] as? String else { throw InitializableError.missingRequiredParam("caCertificate") }
            self.caCertificate = caCertificate
            self.setAsActive = dictionary["SetAsActive"] as? Bool
        }
    }

    public struct DetachThingPrincipalRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var headerParams: [String: String] {
            return ["x-amzn-principal": "principal"]
        }
        public static var pathParams: [String: String] {
            return ["thingName": "thingName"]
        }
        /// The name of the thing.
        public let thingName: String
        /// If the principal is a certificate, this value must be ARN of the certificate. If the principal is an Amazon Cognito identity, this value must be the ID of the Amazon Cognito identity.
        public let principal: String

        public init(thingName: String, principal: String) {
            self.thingName = thingName
            self.principal = principal
        }

        public init(dictionary: [String: Any]) throws {
            guard let thingName = dictionary["ThingName"] as? String else { throw InitializableError.missingRequiredParam("ThingName") }
            self.thingName = thingName
            guard let principal = dictionary["X-amzn-principal"] as? String else { throw InitializableError.missingRequiredParam("X-amzn-principal") }
            self.principal = principal
        }
    }

    public struct CreateThingResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the new thing.
        public let thingName: String?
        /// The ARN of the new thing.
        public let thingArn: String?

        public init(thingName: String? = nil, thingArn: String? = nil) {
            self.thingName = thingName
            self.thingArn = thingArn
        }

        public init(dictionary: [String: Any]) throws {
            self.thingName = dictionary["thingName"] as? String
            self.thingArn = dictionary["thingArn"] as? String
        }
    }

    public enum CACertificateStatus: String, CustomStringConvertible {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public struct ListPrincipalThingsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// The things.
        public let things: [String]?

        public init(nextToken: String? = nil, things: [String]? = nil) {
            self.nextToken = nextToken
            self.things = things
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            self.things = dictionary["things"] as? [String]
        }
    }

    public struct LoggingOptionsPayload: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the IAM role that grants access.
        public let roleArn: String
        /// The logging level.
        public let logLevel: LogLevel?

        public init(roleArn: String, logLevel: LogLevel? = nil) {
            self.roleArn = roleArn
            self.logLevel = logLevel
        }

        public init(dictionary: [String: Any]) throws {
            guard let roleArn = dictionary["roleArn"] as? String else { throw InitializableError.missingRequiredParam("roleArn") }
            self.roleArn = roleArn
            if let logLevel = dictionary["logLevel"] as? String { self.logLevel = LogLevel(rawValue: logLevel) } else { self.logLevel = nil }
        }
    }

    public struct ListThingsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["attributeValue": "attributeValue", "thingTypeName": "thingTypeName", "nextToken": "nextToken", "maxResults": "maxResults", "attributeName": "attributeName"]
        }
        /// The attribute value used to search for things.
        public let attributeValue: String?
        /// The name of the thing type used to search for things.
        public let thingTypeName: String?
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// The maximum number of results to return in this operation.
        public let maxResults: Int32?
        /// The attribute name used to search for things.
        public let attributeName: String?

        public init(attributeValue: String? = nil, thingTypeName: String? = nil, nextToken: String? = nil, maxResults: Int32? = nil, attributeName: String? = nil) {
            self.attributeValue = attributeValue
            self.thingTypeName = thingTypeName
            self.nextToken = nextToken
            self.maxResults = maxResults
            self.attributeName = attributeName
        }

        public init(dictionary: [String: Any]) throws {
            self.attributeValue = dictionary["AttributeValue"] as? String
            self.thingTypeName = dictionary["ThingTypeName"] as? String
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
            self.attributeName = dictionary["AttributeName"] as? String
        }
    }

    public struct ThingTypeDefinition: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let thingTypeMetadata: ThingTypeMetadata?
        /// The name of the thing type.
        public let thingTypeName: String?
        /// The ThingTypeProperties for the thing type.
        public let thingTypeProperties: ThingTypeProperties?

        public init(thingTypeMetadata: ThingTypeMetadata? = nil, thingTypeName: String? = nil, thingTypeProperties: ThingTypeProperties? = nil) {
            self.thingTypeMetadata = thingTypeMetadata
            self.thingTypeName = thingTypeName
            self.thingTypeProperties = thingTypeProperties
        }

        public init(dictionary: [String: Any]) throws {
            if let thingTypeMetadata = dictionary["thingTypeMetadata"] as? [String: Any] { self.thingTypeMetadata = try Iot.ThingTypeMetadata(dictionary: thingTypeMetadata) } else { self.thingTypeMetadata = nil }
            self.thingTypeName = dictionary["thingTypeName"] as? String
            if let thingTypeProperties = dictionary["thingTypeProperties"] as? [String: Any] { self.thingTypeProperties = try Iot.ThingTypeProperties(dictionary: thingTypeProperties) } else { self.thingTypeProperties = nil }
        }
    }

    public struct CreateKeysAndCertificateResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The generated key pair.
        public let keyPair: KeyPair?
        /// The certificate data, in PEM format.
        public let certificatePem: String?
        /// The ID of the certificate. AWS IoT issues a default subject name for the certificate (for example, AWS IoT Certificate).
        public let certificateId: String?
        /// The ARN of the certificate.
        public let certificateArn: String?

        public init(keyPair: KeyPair? = nil, certificatePem: String? = nil, certificateId: String? = nil, certificateArn: String? = nil) {
            self.keyPair = keyPair
            self.certificatePem = certificatePem
            self.certificateId = certificateId
            self.certificateArn = certificateArn
        }

        public init(dictionary: [String: Any]) throws {
            if let keyPair = dictionary["keyPair"] as? [String: Any] { self.keyPair = try Iot.KeyPair(dictionary: keyPair) } else { self.keyPair = nil }
            self.certificatePem = dictionary["certificatePem"] as? String
            self.certificateId = dictionary["certificateId"] as? String
            self.certificateArn = dictionary["certificateArn"] as? String
        }
    }

    public struct GetTopicRuleResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The rule ARN.
        public let ruleArn: String?
        /// The rule.
        public let rule: TopicRule?

        public init(ruleArn: String? = nil, rule: TopicRule? = nil) {
            self.ruleArn = ruleArn
            self.rule = rule
        }

        public init(dictionary: [String: Any]) throws {
            self.ruleArn = dictionary["ruleArn"] as? String
            if let rule = dictionary["rule"] as? [String: Any] { self.rule = try Iot.TopicRule(dictionary: rule) } else { self.rule = nil }
        }
    }

    public struct CreateThingTypeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["thingTypeName": "thingTypeName"]
        }
        /// The name of the thing type.
        public let thingTypeName: String
        /// The ThingTypeProperties for the thing type to create. It contains information about the new thing type including a description, and a list of searchable thing attribute names.
        public let thingTypeProperties: ThingTypeProperties?

        public init(thingTypeName: String, thingTypeProperties: ThingTypeProperties? = nil) {
            self.thingTypeName = thingTypeName
            self.thingTypeProperties = thingTypeProperties
        }

        public init(dictionary: [String: Any]) throws {
            guard let thingTypeName = dictionary["ThingTypeName"] as? String else { throw InitializableError.missingRequiredParam("ThingTypeName") }
            self.thingTypeName = thingTypeName
            if let thingTypeProperties = dictionary["thingTypeProperties"] as? [String: Any] { self.thingTypeProperties = try Iot.ThingTypeProperties(dictionary: thingTypeProperties) } else { self.thingTypeProperties = nil }
        }
    }

    public struct DescribeCACertificateRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["caCertificateId": "certificateId"]
        }
        /// The CA certificate identifier.
        public let certificateId: String

        public init(certificateId: String) {
            self.certificateId = certificateId
        }

        public init(dictionary: [String: Any]) throws {
            guard let certificateId = dictionary["CaCertificateId"] as? String else { throw InitializableError.missingRequiredParam("CaCertificateId") }
            self.certificateId = certificateId
        }
    }

    public struct DescribeCertificateRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["certificateId": "certificateId"]
        }
        /// The ID of the certificate.
        public let certificateId: String

        public init(certificateId: String) {
            self.certificateId = certificateId
        }

        public init(dictionary: [String: Any]) throws {
            guard let certificateId = dictionary["CertificateId"] as? String else { throw InitializableError.missingRequiredParam("CertificateId") }
            self.certificateId = certificateId
        }
    }

    public struct CreateCertificateFromCsrRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["setAsActive": "setAsActive"]
        }
        /// The certificate signing request (CSR).
        public let certificateSigningRequest: String
        /// Specifies whether the certificate is active.
        public let setAsActive: Bool?

        public init(certificateSigningRequest: String, setAsActive: Bool? = nil) {
            self.certificateSigningRequest = certificateSigningRequest
            self.setAsActive = setAsActive
        }

        public init(dictionary: [String: Any]) throws {
            guard let certificateSigningRequest = dictionary["certificateSigningRequest"] as? String else { throw InitializableError.missingRequiredParam("certificateSigningRequest") }
            self.certificateSigningRequest = certificateSigningRequest
            self.setAsActive = dictionary["SetAsActive"] as? Bool
        }
    }

    public struct DescribeCertificateResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The description of the certificate.
        public let certificateDescription: CertificateDescription?

        public init(certificateDescription: CertificateDescription? = nil) {
            self.certificateDescription = certificateDescription
        }

        public init(dictionary: [String: Any]) throws {
            if let certificateDescription = dictionary["certificateDescription"] as? [String: Any] { self.certificateDescription = try Iot.CertificateDescription(dictionary: certificateDescription) } else { self.certificateDescription = nil }
        }
    }

    public struct CreateKeysAndCertificateRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["setAsActive": "setAsActive"]
        }
        /// Specifies whether the certificate is active.
        public let setAsActive: Bool?

        public init(setAsActive: Bool? = nil) {
            self.setAsActive = setAsActive
        }

        public init(dictionary: [String: Any]) throws {
            self.setAsActive = dictionary["SetAsActive"] as? Bool
        }
    }

    public struct ListPrincipalPoliciesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The policies.
        public let policies: [Policy]?
        /// The marker for the next set of results, or null if there are no additional results.
        public let nextMarker: String?

        public init(policies: [Policy]? = nil, nextMarker: String? = nil) {
            self.policies = policies
            self.nextMarker = nextMarker
        }

        public init(dictionary: [String: Any]) throws {
            if let policies = dictionary["policies"] as? [[String: Any]] {
                self.policies = try policies.map({ try Policy(dictionary: $0) })
            } else { 
                self.policies = nil
            }
            self.nextMarker = dictionary["nextMarker"] as? String
        }
    }

    public struct DetachPrincipalPolicyRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var headerParams: [String: String] {
            return ["x-amzn-iot-principal": "principal"]
        }
        public static var pathParams: [String: String] {
            return ["policyName": "policyName"]
        }
        /// The name of the policy to detach.
        public let policyName: String
        /// The principal. If the principal is a certificate, specify the certificate ARN. If the principal is an Amazon Cognito identity, specify the identity ID.
        public let principal: String

        public init(policyName: String, principal: String) {
            self.policyName = policyName
            self.principal = principal
        }

        public init(dictionary: [String: Any]) throws {
            guard let policyName = dictionary["PolicyName"] as? String else { throw InitializableError.missingRequiredParam("PolicyName") }
            self.policyName = policyName
            guard let principal = dictionary["X-amzn-iot-principal"] as? String else { throw InitializableError.missingRequiredParam("X-amzn-iot-principal") }
            self.principal = principal
        }
    }

    public struct ThingTypeMetadata: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Whether the thing type is deprecated. If true, no new things could be associated with this type.
        public let deprecated: Bool?
        /// The date and time when the thing type was deprecated.
        public let deprecationDate: Date?
        /// The date and time when the thing type was created.
        public let creationDate: Date?

        public init(deprecated: Bool? = nil, deprecationDate: Date? = nil, creationDate: Date? = nil) {
            self.deprecated = deprecated
            self.deprecationDate = deprecationDate
            self.creationDate = creationDate
        }

        public init(dictionary: [String: Any]) throws {
            self.deprecated = dictionary["deprecated"] as? Bool
            self.deprecationDate = dictionary["deprecationDate"] as? Date
            self.creationDate = dictionary["creationDate"] as? Date
        }
    }

    public struct EnableTopicRuleRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["ruleName": "ruleName"]
        }
        /// The name of the topic rule to enable.
        public let ruleName: String

        public init(ruleName: String) {
            self.ruleName = ruleName
        }

        public init(dictionary: [String: Any]) throws {
            guard let ruleName = dictionary["RuleName"] as? String else { throw InitializableError.missingRequiredParam("RuleName") }
            self.ruleName = ruleName
        }
    }

    public struct CreatePolicyVersionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["setAsDefault": "setAsDefault"]
        }
        public static var pathParams: [String: String] {
            return ["policyName": "policyName"]
        }
        /// The policy name.
        public let policyName: String
        /// Specifies whether the policy version is set as the default. When this parameter is true, the new policy version becomes the operative version (that is, the version that is in effect for the certificates to which the policy is attached).
        public let setAsDefault: Bool?
        /// The JSON document that describes the policy. Minimum length of 1. Maximum length of 2048, excluding whitespaces
        public let policyDocument: String

        public init(policyName: String, setAsDefault: Bool? = nil, policyDocument: String) {
            self.policyName = policyName
            self.setAsDefault = setAsDefault
            self.policyDocument = policyDocument
        }

        public init(dictionary: [String: Any]) throws {
            guard let policyName = dictionary["PolicyName"] as? String else { throw InitializableError.missingRequiredParam("PolicyName") }
            self.policyName = policyName
            self.setAsDefault = dictionary["SetAsDefault"] as? Bool
            guard let policyDocument = dictionary["policyDocument"] as? String else { throw InitializableError.missingRequiredParam("policyDocument") }
            self.policyDocument = policyDocument
        }
    }

    public struct KinesisAction: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the IAM role that grants access to the Amazon Kinesis stream.
        public let roleArn: String
        /// The name of the Amazon Kinesis stream.
        public let streamName: String
        /// The partition key.
        public let partitionKey: String?

        public init(roleArn: String, streamName: String, partitionKey: String? = nil) {
            self.roleArn = roleArn
            self.streamName = streamName
            self.partitionKey = partitionKey
        }

        public init(dictionary: [String: Any]) throws {
            guard let roleArn = dictionary["roleArn"] as? String else { throw InitializableError.missingRequiredParam("roleArn") }
            self.roleArn = roleArn
            guard let streamName = dictionary["streamName"] as? String else { throw InitializableError.missingRequiredParam("streamName") }
            self.streamName = streamName
            self.partitionKey = dictionary["partitionKey"] as? String
        }
    }

    public struct SqsAction: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Specifies whether to use Base64 encoding.
        public let useBase64: Bool?
        /// The ARN of the IAM role that grants access.
        public let roleArn: String
        /// The URL of the Amazon SQS queue.
        public let queueUrl: String

        public init(useBase64: Bool? = nil, roleArn: String, queueUrl: String) {
            self.useBase64 = useBase64
            self.roleArn = roleArn
            self.queueUrl = queueUrl
        }

        public init(dictionary: [String: Any]) throws {
            self.useBase64 = dictionary["useBase64"] as? Bool
            guard let roleArn = dictionary["roleArn"] as? String else { throw InitializableError.missingRequiredParam("roleArn") }
            self.roleArn = roleArn
            guard let queueUrl = dictionary["queueUrl"] as? String else { throw InitializableError.missingRequiredParam("queueUrl") }
            self.queueUrl = queueUrl
        }
    }

    public struct UpdateThingResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ListThingPrincipalsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["thingName": "thingName"]
        }
        /// The name of the thing.
        public let thingName: String

        public init(thingName: String) {
            self.thingName = thingName
        }

        public init(dictionary: [String: Any]) throws {
            guard let thingName = dictionary["ThingName"] as? String else { throw InitializableError.missingRequiredParam("ThingName") }
            self.thingName = thingName
        }
    }

    public struct SetDefaultPolicyVersionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["policyVersionId": "policyVersionId", "policyName": "policyName"]
        }
        /// The policy version ID.
        public let policyVersionId: String
        /// The policy name.
        public let policyName: String

        public init(policyVersionId: String, policyName: String) {
            self.policyVersionId = policyVersionId
            self.policyName = policyName
        }

        public init(dictionary: [String: Any]) throws {
            guard let policyVersionId = dictionary["PolicyVersionId"] as? String else { throw InitializableError.missingRequiredParam("PolicyVersionId") }
            self.policyVersionId = policyVersionId
            guard let policyName = dictionary["PolicyName"] as? String else { throw InitializableError.missingRequiredParam("PolicyName") }
            self.policyName = policyName
        }
    }

    public struct UpdateCACertificateRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["newStatus": "newStatus", "newAutoRegistrationStatus": "newAutoRegistrationStatus"]
        }
        public static var pathParams: [String: String] {
            return ["caCertificateId": "certificateId"]
        }
        /// The CA certificate identifier.
        public let certificateId: String
        /// The updated status of the CA certificate. Note: The status value REGISTER_INACTIVE is deprecated and should not be used.
        public let newStatus: CACertificateStatus?
        /// The new value for the auto registration status. Valid values are: "ENABLE" or "DISABLE".
        public let newAutoRegistrationStatus: AutoRegistrationStatus?

        public init(certificateId: String, newStatus: CACertificateStatus? = nil, newAutoRegistrationStatus: AutoRegistrationStatus? = nil) {
            self.certificateId = certificateId
            self.newStatus = newStatus
            self.newAutoRegistrationStatus = newAutoRegistrationStatus
        }

        public init(dictionary: [String: Any]) throws {
            guard let certificateId = dictionary["CaCertificateId"] as? String else { throw InitializableError.missingRequiredParam("CaCertificateId") }
            self.certificateId = certificateId
            if let newStatus = dictionary["NewStatus"] as? String { self.newStatus = CACertificateStatus(rawValue: newStatus) } else { self.newStatus = nil }
            if let newAutoRegistrationStatus = dictionary["NewAutoRegistrationStatus"] as? String { self.newAutoRegistrationStatus = AutoRegistrationStatus(rawValue: newAutoRegistrationStatus) } else { self.newAutoRegistrationStatus = nil }
        }
    }

    public struct ListPoliciesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The descriptions of the policies.
        public let policies: [Policy]?
        /// The marker for the next set of results, or null if there are no additional results.
        public let nextMarker: String?

        public init(policies: [Policy]? = nil, nextMarker: String? = nil) {
            self.policies = policies
            self.nextMarker = nextMarker
        }

        public init(dictionary: [String: Any]) throws {
            if let policies = dictionary["policies"] as? [[String: Any]] {
                self.policies = try policies.map({ try Policy(dictionary: $0) })
            } else { 
                self.policies = nil
            }
            self.nextMarker = dictionary["nextMarker"] as? String
        }
    }

    public struct ElasticsearchAction: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IAM role ARN that has access to Elasticsearch.
        public let roleArn: String
        /// The endpoint of your Elasticsearch domain.
        public let endpoint: String
        /// The unique identifier for the document you are storing.
        public let id: String
        /// The type of document you are storing.
        public let `type`: String
        /// The Elasticsearch index where you want to store your data.
        public let index: String

        public init(roleArn: String, endpoint: String, id: String, type: String, index: String) {
            self.roleArn = roleArn
            self.endpoint = endpoint
            self.id = id
            self.`type` = `type`
            self.index = index
        }

        public init(dictionary: [String: Any]) throws {
            guard let roleArn = dictionary["roleArn"] as? String else { throw InitializableError.missingRequiredParam("roleArn") }
            self.roleArn = roleArn
            guard let endpoint = dictionary["endpoint"] as? String else { throw InitializableError.missingRequiredParam("endpoint") }
            self.endpoint = endpoint
            guard let id = dictionary["id"] as? String else { throw InitializableError.missingRequiredParam("id") }
            self.id = id
            guard let `type` = dictionary["type"] as? String else { throw InitializableError.missingRequiredParam("type") }
            self.`type` = `type`
            guard let index = dictionary["index"] as? String else { throw InitializableError.missingRequiredParam("index") }
            self.index = index
        }
    }

    public struct ListOutgoingCertificatesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The marker for the next set of results.
        public let nextMarker: String?
        /// The certificates that are being transfered but not yet accepted.
        public let outgoingCertificates: [OutgoingCertificate]?

        public init(nextMarker: String? = nil, outgoingCertificates: [OutgoingCertificate]? = nil) {
            self.nextMarker = nextMarker
            self.outgoingCertificates = outgoingCertificates
        }

        public init(dictionary: [String: Any]) throws {
            self.nextMarker = dictionary["nextMarker"] as? String
            if let outgoingCertificates = dictionary["outgoingCertificates"] as? [[String: Any]] {
                self.outgoingCertificates = try outgoingCertificates.map({ try OutgoingCertificate(dictionary: $0) })
            } else { 
                self.outgoingCertificates = nil
            }
        }
    }

    public struct UpdateCertificateRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["newStatus": "newStatus"]
        }
        public static var pathParams: [String: String] {
            return ["certificateId": "certificateId"]
        }
        /// The ID of the certificate.
        public let certificateId: String
        /// The new status. Note: Setting the status to PENDING_TRANSFER will result in an exception being thrown. PENDING_TRANSFER is a status used internally by AWS IoT. It is not intended for developer use. Note: The status value REGISTER_INACTIVE is deprecated and should not be used.
        public let newStatus: CertificateStatus

        public init(certificateId: String, newStatus: CertificateStatus) {
            self.certificateId = certificateId
            self.newStatus = newStatus
        }

        public init(dictionary: [String: Any]) throws {
            guard let certificateId = dictionary["CertificateId"] as? String else { throw InitializableError.missingRequiredParam("CertificateId") }
            self.certificateId = certificateId
            guard let rawnewStatus = dictionary["NewStatus"] as? String, let newStatus = CertificateStatus(rawValue: rawnewStatus) else { throw InitializableError.missingRequiredParam("NewStatus") }
            self.newStatus = newStatus
        }
    }

    public enum MessageFormat: String, CustomStringConvertible {
        case raw = "RAW"
        case json = "JSON"
        public var description: String { return self.rawValue }
    }

    public struct TopicRuleListItem: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Specifies whether the rule is disabled.
        public let ruleDisabled: Bool?
        /// The pattern for the topic names that apply.
        public let topicPattern: String?
        /// The name of the rule.
        public let ruleName: String?
        /// The rule ARN.
        public let ruleArn: String?
        /// The date and time the rule was created.
        public let createdAt: Date?

        public init(ruleDisabled: Bool? = nil, topicPattern: String? = nil, ruleName: String? = nil, ruleArn: String? = nil, createdAt: Date? = nil) {
            self.ruleDisabled = ruleDisabled
            self.topicPattern = topicPattern
            self.ruleName = ruleName
            self.ruleArn = ruleArn
            self.createdAt = createdAt
        }

        public init(dictionary: [String: Any]) throws {
            self.ruleDisabled = dictionary["ruleDisabled"] as? Bool
            self.topicPattern = dictionary["topicPattern"] as? String
            self.ruleName = dictionary["ruleName"] as? String
            self.ruleArn = dictionary["ruleArn"] as? String
            self.createdAt = dictionary["createdAt"] as? Date
        }
    }

    public struct DeleteThingTypeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["thingTypeName": "thingTypeName"]
        }
        /// The name of the thing type.
        public let thingTypeName: String

        public init(thingTypeName: String) {
            self.thingTypeName = thingTypeName
        }

        public init(dictionary: [String: Any]) throws {
            guard let thingTypeName = dictionary["ThingTypeName"] as? String else { throw InitializableError.missingRequiredParam("ThingTypeName") }
            self.thingTypeName = thingTypeName
        }
    }

    public struct RegisterCertificateResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The certificate identifier.
        public let certificateId: String?
        /// The certificate ARN.
        public let certificateArn: String?

        public init(certificateId: String? = nil, certificateArn: String? = nil) {
            self.certificateId = certificateId
            self.certificateArn = certificateArn
        }

        public init(dictionary: [String: Any]) throws {
            self.certificateId = dictionary["certificateId"] as? String
            self.certificateArn = dictionary["certificateArn"] as? String
        }
    }

    public struct PutItemInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The table where the message data will be written
        public let tableName: String

        public init(tableName: String) {
            self.tableName = tableName
        }

        public init(dictionary: [String: Any]) throws {
            guard let tableName = dictionary["tableName"] as? String else { throw InitializableError.missingRequiredParam("tableName") }
            self.tableName = tableName
        }
    }

    public struct AttributePayload: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Specifies whether the list of attributes provided in the AttributePayload is merged with the attributes stored in the registry, instead of overwriting them. To remove an attribute, call UpdateThing with an empty attribute value.  The merge attribute is only valid when calling UpdateThing. 
        public let merge: Bool?
        /// A JSON string containing up to three key-value pair in JSON format. For example: {\"attributes\":{\"string1\":\"string2\"}})
        public let attributes: [String: String]?

        public init(merge: Bool? = nil, attributes: [String: String]? = nil) {
            self.merge = merge
            self.attributes = attributes
        }

        public init(dictionary: [String: Any]) throws {
            self.merge = dictionary["merge"] as? Bool
            if let attributes = dictionary["attributes"] as? [String: String] {
                self.attributes = attributes
            } else { 
                self.attributes = nil
            }
        }
    }

    public struct CreatePolicyRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["policyName": "policyName"]
        }
        /// The JSON document that describes the policy. policyDocument must have a minimum length of 1, with a maximum length of 2048, excluding whitespace.
        public let policyDocument: String
        /// The policy name.
        public let policyName: String

        public init(policyDocument: String, policyName: String) {
            self.policyDocument = policyDocument
            self.policyName = policyName
        }

        public init(dictionary: [String: Any]) throws {
            guard let policyDocument = dictionary["policyDocument"] as? String else { throw InitializableError.missingRequiredParam("policyDocument") }
            self.policyDocument = policyDocument
            guard let policyName = dictionary["PolicyName"] as? String else { throw InitializableError.missingRequiredParam("PolicyName") }
            self.policyName = policyName
        }
    }

    public struct DeletePolicyVersionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["policyVersionId": "policyVersionId", "policyName": "policyName"]
        }
        /// The policy version ID.
        public let policyVersionId: String
        /// The name of the policy.
        public let policyName: String

        public init(policyVersionId: String, policyName: String) {
            self.policyVersionId = policyVersionId
            self.policyName = policyName
        }

        public init(dictionary: [String: Any]) throws {
            guard let policyVersionId = dictionary["PolicyVersionId"] as? String else { throw InitializableError.missingRequiredParam("PolicyVersionId") }
            self.policyVersionId = policyVersionId
            guard let policyName = dictionary["PolicyName"] as? String else { throw InitializableError.missingRequiredParam("PolicyName") }
            self.policyName = policyName
        }
    }

    public struct DeleteThingTypeResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct DeleteRegistrationCodeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct GetLoggingOptionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct LambdaAction: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the Lambda function.
        public let functionArn: String

        public init(functionArn: String) {
            self.functionArn = functionArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let functionArn = dictionary["functionArn"] as? String else { throw InitializableError.missingRequiredParam("functionArn") }
            self.functionArn = functionArn
        }
    }

    public struct TopicRule: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Specifies whether the rule is disabled.
        public let ruleDisabled: Bool?
        /// The name of the rule.
        public let ruleName: String?
        /// The date and time the rule was created.
        public let createdAt: Date?
        /// The version of the SQL rules engine to use when evaluating the rule.
        public let awsIotSqlVersion: String?
        /// The description of the rule.
        public let description: String?
        /// The actions associated with the rule.
        public let actions: [Action]?
        /// The SQL statement used to query the topic. When using a SQL query with multiple lines, be sure to escape the newline characters.
        public let sql: String?

        public init(ruleDisabled: Bool? = nil, ruleName: String? = nil, createdAt: Date? = nil, awsIotSqlVersion: String? = nil, description: String? = nil, actions: [Action]? = nil, sql: String? = nil) {
            self.ruleDisabled = ruleDisabled
            self.ruleName = ruleName
            self.createdAt = createdAt
            self.awsIotSqlVersion = awsIotSqlVersion
            self.description = description
            self.actions = actions
            self.sql = sql
        }

        public init(dictionary: [String: Any]) throws {
            self.ruleDisabled = dictionary["ruleDisabled"] as? Bool
            self.ruleName = dictionary["ruleName"] as? String
            self.createdAt = dictionary["createdAt"] as? Date
            self.awsIotSqlVersion = dictionary["awsIotSqlVersion"] as? String
            self.description = dictionary["description"] as? String
            if let actions = dictionary["actions"] as? [[String: Any]] {
                self.actions = try actions.map({ try Action(dictionary: $0) })
            } else { 
                self.actions = nil
            }
            self.sql = dictionary["sql"] as? String
        }
    }

    public struct CreateThingRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["thingName": "thingName"]
        }
        /// The name of the thing type associated with the new thing.
        public let thingTypeName: String?
        /// The attribute payload, which consists of up to three name/value pairs in a JSON document. For example: {\"attributes\":{\"string1\":\"string2\"}})
        public let attributePayload: AttributePayload?
        /// The name of the thing to create.
        public let thingName: String

        public init(thingTypeName: String? = nil, attributePayload: AttributePayload? = nil, thingName: String) {
            self.thingTypeName = thingTypeName
            self.attributePayload = attributePayload
            self.thingName = thingName
        }

        public init(dictionary: [String: Any]) throws {
            self.thingTypeName = dictionary["thingTypeName"] as? String
            if let attributePayload = dictionary["attributePayload"] as? [String: Any] { self.attributePayload = try Iot.AttributePayload(dictionary: attributePayload) } else { self.attributePayload = nil }
            guard let thingName = dictionary["ThingName"] as? String else { throw InitializableError.missingRequiredParam("ThingName") }
            self.thingName = thingName
        }
    }

    public struct CertificateDescription: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The certificate ID of the CA certificate used to sign this certificate.
        public let caCertificateId: String?
        /// The status of the certificate.
        public let status: CertificateStatus?
        /// The date and time the certificate was created.
        public let creationDate: Date?
        /// The ID of the certificate.
        public let certificateId: String?
        /// The certificate data, in PEM format.
        public let certificatePem: String?
        /// The ID of the AWS account of the previous owner of the certificate.
        public let previousOwnedBy: String?
        /// The transfer data.
        public let transferData: TransferData?
        /// The ID of the AWS account that owns the certificate.
        public let ownedBy: String?
        /// The ARN of the certificate.
        public let certificateArn: String?
        /// The date and time the certificate was last modified.
        public let lastModifiedDate: Date?

        public init(caCertificateId: String? = nil, status: CertificateStatus? = nil, creationDate: Date? = nil, certificateId: String? = nil, certificatePem: String? = nil, previousOwnedBy: String? = nil, transferData: TransferData? = nil, ownedBy: String? = nil, certificateArn: String? = nil, lastModifiedDate: Date? = nil) {
            self.caCertificateId = caCertificateId
            self.status = status
            self.creationDate = creationDate
            self.certificateId = certificateId
            self.certificatePem = certificatePem
            self.previousOwnedBy = previousOwnedBy
            self.transferData = transferData
            self.ownedBy = ownedBy
            self.certificateArn = certificateArn
            self.lastModifiedDate = lastModifiedDate
        }

        public init(dictionary: [String: Any]) throws {
            self.caCertificateId = dictionary["caCertificateId"] as? String
            if let status = dictionary["status"] as? String { self.status = CertificateStatus(rawValue: status) } else { self.status = nil }
            self.creationDate = dictionary["creationDate"] as? Date
            self.certificateId = dictionary["certificateId"] as? String
            self.certificatePem = dictionary["certificatePem"] as? String
            self.previousOwnedBy = dictionary["previousOwnedBy"] as? String
            if let transferData = dictionary["transferData"] as? [String: Any] { self.transferData = try Iot.TransferData(dictionary: transferData) } else { self.transferData = nil }
            self.ownedBy = dictionary["ownedBy"] as? String
            self.certificateArn = dictionary["certificateArn"] as? String
            self.lastModifiedDate = dictionary["lastModifiedDate"] as? Date
        }
    }

    public struct CloudwatchAlarmAction: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IAM role that allows access to the CloudWatch alarm.
        public let roleArn: String
        /// The reason for the alarm change.
        public let stateReason: String
        /// The CloudWatch alarm name.
        public let alarmName: String
        /// The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.
        public let stateValue: String

        public init(roleArn: String, stateReason: String, alarmName: String, stateValue: String) {
            self.roleArn = roleArn
            self.stateReason = stateReason
            self.alarmName = alarmName
            self.stateValue = stateValue
        }

        public init(dictionary: [String: Any]) throws {
            guard let roleArn = dictionary["roleArn"] as? String else { throw InitializableError.missingRequiredParam("roleArn") }
            self.roleArn = roleArn
            guard let stateReason = dictionary["stateReason"] as? String else { throw InitializableError.missingRequiredParam("stateReason") }
            self.stateReason = stateReason
            guard let alarmName = dictionary["alarmName"] as? String else { throw InitializableError.missingRequiredParam("alarmName") }
            self.alarmName = alarmName
            guard let stateValue = dictionary["stateValue"] as? String else { throw InitializableError.missingRequiredParam("stateValue") }
            self.stateValue = stateValue
        }
    }

    public struct DisableTopicRuleRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["ruleName": "ruleName"]
        }
        /// The name of the rule to disable.
        public let ruleName: String

        public init(ruleName: String) {
            self.ruleName = ruleName
        }

        public init(dictionary: [String: Any]) throws {
            guard let ruleName = dictionary["RuleName"] as? String else { throw InitializableError.missingRequiredParam("RuleName") }
            self.ruleName = ruleName
        }
    }

    public struct ListPrincipalThingsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var headerParams: [String: String] {
            return ["x-amzn-principal": "principal"]
        }
        public static var queryParams: [String: String] {
            return ["maxResults": "maxResults", "nextToken": "nextToken"]
        }
        /// The maximum number of results to return in this operation.
        public let maxResults: Int32?
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// The principal.
        public let principal: String

        public init(maxResults: Int32? = nil, nextToken: String? = nil, principal: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.principal = principal
        }

        public init(dictionary: [String: Any]) throws {
            self.maxResults = dictionary["MaxResults"] as? Int32
            self.nextToken = dictionary["NextToken"] as? String
            guard let principal = dictionary["X-amzn-principal"] as? String else { throw InitializableError.missingRequiredParam("X-amzn-principal") }
            self.principal = principal
        }
    }

    public struct CreateTopicRuleRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = "topicRulePayload"
        public static var pathParams: [String: String] {
            return ["ruleName": "ruleName"]
        }
        /// The name of the rule.
        public let ruleName: String
        /// The rule payload.
        public let topicRulePayload: TopicRulePayload

        public init(ruleName: String, topicRulePayload: TopicRulePayload) {
            self.ruleName = ruleName
            self.topicRulePayload = topicRulePayload
        }

        public init(dictionary: [String: Any]) throws {
            guard let ruleName = dictionary["RuleName"] as? String else { throw InitializableError.missingRequiredParam("RuleName") }
            self.ruleName = ruleName
            guard let topicRulePayload = dictionary["topicRulePayload"] as? [String: Any] else { throw InitializableError.missingRequiredParam("topicRulePayload") }
            self.topicRulePayload = try Iot.TopicRulePayload(dictionary: topicRulePayload)
        }
    }

    public struct DeleteCACertificateRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["caCertificateId": "certificateId"]
        }
        /// The ID of the certificate to delete.
        public let certificateId: String

        public init(certificateId: String) {
            self.certificateId = certificateId
        }

        public init(dictionary: [String: Any]) throws {
            guard let certificateId = dictionary["CaCertificateId"] as? String else { throw InitializableError.missingRequiredParam("CaCertificateId") }
            self.certificateId = certificateId
        }
    }

    public struct CACertificate: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The status of the CA certificate.  The status value REGISTER_INACTIVE is deprecated and should not be used.
        public let status: CACertificateStatus?
        /// The date the CA certificate was created.
        public let creationDate: Date?
        /// The ID of the CA certificate.
        public let certificateId: String?
        /// The ARN of the CA certificate.
        public let certificateArn: String?

        public init(status: CACertificateStatus? = nil, creationDate: Date? = nil, certificateId: String? = nil, certificateArn: String? = nil) {
            self.status = status
            self.creationDate = creationDate
            self.certificateId = certificateId
            self.certificateArn = certificateArn
        }

        public init(dictionary: [String: Any]) throws {
            if let status = dictionary["status"] as? String { self.status = CACertificateStatus(rawValue: status) } else { self.status = nil }
            self.creationDate = dictionary["creationDate"] as? Date
            self.certificateId = dictionary["certificateId"] as? String
            self.certificateArn = dictionary["certificateArn"] as? String
        }
    }

    public struct ListPolicyVersionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["policyName": "policyName"]
        }
        /// The policy name.
        public let policyName: String

        public init(policyName: String) {
            self.policyName = policyName
        }

        public init(dictionary: [String: Any]) throws {
            guard let policyName = dictionary["PolicyName"] as? String else { throw InitializableError.missingRequiredParam("PolicyName") }
            self.policyName = policyName
        }
    }

    public struct ListPolicyPrincipalsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var headerParams: [String: String] {
            return ["x-amzn-iot-policy": "policyName"]
        }
        public static var queryParams: [String: String] {
            return ["marker": "marker", "pageSize": "pageSize", "isAscendingOrder": "ascendingOrder"]
        }
        /// The marker for the next set of results.
        public let marker: String?
        /// The result page size.
        public let pageSize: Int32?
        /// The policy name.
        public let policyName: String
        /// Specifies the order for results. If true, the results are returned in ascending creation order.
        public let ascendingOrder: Bool?

        public init(marker: String? = nil, pageSize: Int32? = nil, policyName: String, ascendingOrder: Bool? = nil) {
            self.marker = marker
            self.pageSize = pageSize
            self.policyName = policyName
            self.ascendingOrder = ascendingOrder
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["Marker"] as? String
            self.pageSize = dictionary["PageSize"] as? Int32
            guard let policyName = dictionary["X-amzn-iot-policy"] as? String else { throw InitializableError.missingRequiredParam("X-amzn-iot-policy") }
            self.policyName = policyName
            self.ascendingOrder = dictionary["IsAscendingOrder"] as? Bool
        }
    }

    public struct PolicyVersion: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The date and time the policy was created.
        public let createDate: Date?
        /// The policy version ID.
        public let versionId: String?
        /// Specifies whether the policy version is the default.
        public let isDefaultVersion: Bool?

        public init(createDate: Date? = nil, versionId: String? = nil, isDefaultVersion: Bool? = nil) {
            self.createDate = createDate
            self.versionId = versionId
            self.isDefaultVersion = isDefaultVersion
        }

        public init(dictionary: [String: Any]) throws {
            self.createDate = dictionary["createDate"] as? Date
            self.versionId = dictionary["versionId"] as? String
            self.isDefaultVersion = dictionary["isDefaultVersion"] as? Bool
        }
    }

    public struct AttachThingPrincipalRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var headerParams: [String: String] {
            return ["x-amzn-principal": "principal"]
        }
        public static var pathParams: [String: String] {
            return ["thingName": "thingName"]
        }
        /// The name of the thing.
        public let thingName: String
        /// The principal, such as a certificate or other credential.
        public let principal: String

        public init(thingName: String, principal: String) {
            self.thingName = thingName
            self.principal = principal
        }

        public init(dictionary: [String: Any]) throws {
            guard let thingName = dictionary["ThingName"] as? String else { throw InitializableError.missingRequiredParam("ThingName") }
            self.thingName = thingName
            guard let principal = dictionary["X-amzn-principal"] as? String else { throw InitializableError.missingRequiredParam("X-amzn-principal") }
            self.principal = principal
        }
    }

    public struct DeleteCACertificateResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct GetRegistrationCodeResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The CA certificate registration code.
        public let registrationCode: String?

        public init(registrationCode: String? = nil) {
            self.registrationCode = registrationCode
        }

        public init(dictionary: [String: Any]) throws {
            self.registrationCode = dictionary["registrationCode"] as? String
        }
    }

    public struct ListCertificatesByCAResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The device certificates signed by the specified CA certificate.
        public let certificates: [Certificate]?
        /// The marker for the next set of results, or null if there are no additional results.
        public let nextMarker: String?

        public init(certificates: [Certificate]? = nil, nextMarker: String? = nil) {
            self.certificates = certificates
            self.nextMarker = nextMarker
        }

        public init(dictionary: [String: Any]) throws {
            if let certificates = dictionary["certificates"] as? [[String: Any]] {
                self.certificates = try certificates.map({ try Certificate(dictionary: $0) })
            } else { 
                self.certificates = nil
            }
            self.nextMarker = dictionary["nextMarker"] as? String
        }
    }

    public struct ListPoliciesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["marker": "marker", "pageSize": "pageSize", "isAscendingOrder": "ascendingOrder"]
        }
        /// The marker for the next set of results.
        public let marker: String?
        /// The result page size.
        public let pageSize: Int32?
        /// Specifies the order for results. If true, the results are returned in ascending creation order.
        public let ascendingOrder: Bool?

        public init(marker: String? = nil, pageSize: Int32? = nil, ascendingOrder: Bool? = nil) {
            self.marker = marker
            self.pageSize = pageSize
            self.ascendingOrder = ascendingOrder
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["Marker"] as? String
            self.pageSize = dictionary["PageSize"] as? Int32
            self.ascendingOrder = dictionary["IsAscendingOrder"] as? Bool
        }
    }

    public struct ListCACertificatesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["marker": "marker", "pageSize": "pageSize", "isAscendingOrder": "ascendingOrder"]
        }
        /// The marker for the next set of results.
        public let marker: String?
        /// The result page size.
        public let pageSize: Int32?
        /// Determines the order of the results.
        public let ascendingOrder: Bool?

        public init(marker: String? = nil, pageSize: Int32? = nil, ascendingOrder: Bool? = nil) {
            self.marker = marker
            self.pageSize = pageSize
            self.ascendingOrder = ascendingOrder
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["Marker"] as? String
            self.pageSize = dictionary["PageSize"] as? Int32
            self.ascendingOrder = dictionary["IsAscendingOrder"] as? Bool
        }
    }

    public struct DeprecateThingTypeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["thingTypeName": "thingTypeName"]
        }
        /// The name of the thing type to deprecate.
        public let thingTypeName: String
        /// Whether to undeprecate a deprecated thing type. If true, the thing type will not be deprecated anymore and you can associate it with things.
        public let undoDeprecate: Bool?

        public init(thingTypeName: String, undoDeprecate: Bool? = nil) {
            self.thingTypeName = thingTypeName
            self.undoDeprecate = undoDeprecate
        }

        public init(dictionary: [String: Any]) throws {
            guard let thingTypeName = dictionary["ThingTypeName"] as? String else { throw InitializableError.missingRequiredParam("ThingTypeName") }
            self.thingTypeName = thingTypeName
            self.undoDeprecate = dictionary["undoDeprecate"] as? Bool
        }
    }

    public struct TopicRulePayload: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The version of the SQL rules engine to use when evaluating the rule.
        public let awsIotSqlVersion: String?
        /// Specifies whether the rule is disabled.
        public let ruleDisabled: Bool?
        /// The description of the rule.
        public let description: String?
        /// The actions associated with the rule.
        public let actions: [Action]
        /// The SQL statement used to query the topic. For more information, see AWS IoT SQL Reference in the AWS IoT Developer Guide.
        public let sql: String

        public init(awsIotSqlVersion: String? = nil, ruleDisabled: Bool? = nil, description: String? = nil, actions: [Action], sql: String) {
            self.awsIotSqlVersion = awsIotSqlVersion
            self.ruleDisabled = ruleDisabled
            self.description = description
            self.actions = actions
            self.sql = sql
        }

        public init(dictionary: [String: Any]) throws {
            self.awsIotSqlVersion = dictionary["awsIotSqlVersion"] as? String
            self.ruleDisabled = dictionary["ruleDisabled"] as? Bool
            self.description = dictionary["description"] as? String
            guard let actions = dictionary["actions"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("actions") }
            self.actions = try actions.map({ try Action(dictionary: $0) })
            guard let sql = dictionary["sql"] as? String else { throw InitializableError.missingRequiredParam("sql") }
            self.sql = sql
        }
    }

    public struct SnsAction: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The message format of the message to publish. Optional. Accepted values are "JSON" and "RAW". The default value of the attribute is "RAW". SNS uses this setting to determine if the payload should be parsed and relevant platform-specific bits of the payload should be extracted. To read more about SNS message formats, see  refer to their official documentation.
        public let messageFormat: MessageFormat?
        /// The ARN of the IAM role that grants access.
        public let roleArn: String
        /// The ARN of the SNS topic.
        public let targetArn: String

        public init(messageFormat: MessageFormat? = nil, roleArn: String, targetArn: String) {
            self.messageFormat = messageFormat
            self.roleArn = roleArn
            self.targetArn = targetArn
        }

        public init(dictionary: [String: Any]) throws {
            if let messageFormat = dictionary["messageFormat"] as? String { self.messageFormat = MessageFormat(rawValue: messageFormat) } else { self.messageFormat = nil }
            guard let roleArn = dictionary["roleArn"] as? String else { throw InitializableError.missingRequiredParam("roleArn") }
            self.roleArn = roleArn
            guard let targetArn = dictionary["targetArn"] as? String else { throw InitializableError.missingRequiredParam("targetArn") }
            self.targetArn = targetArn
        }
    }

    public struct KeyPair: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The public key.
        public let publicKey: String?
        /// The private key.
        public let privateKey: String?

        public init(publicKey: String? = nil, privateKey: String? = nil) {
            self.publicKey = publicKey
            self.privateKey = privateKey
        }

        public init(dictionary: [String: Any]) throws {
            self.publicKey = dictionary["PublicKey"] as? String
            self.privateKey = dictionary["PrivateKey"] as? String
        }
    }

    public struct DeleteRegistrationCodeResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ListPolicyVersionsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The policy versions.
        public let policyVersions: [PolicyVersion]?

        public init(policyVersions: [PolicyVersion]? = nil) {
            self.policyVersions = policyVersions
        }

        public init(dictionary: [String: Any]) throws {
            if let policyVersions = dictionary["policyVersions"] as? [[String: Any]] {
                self.policyVersions = try policyVersions.map({ try PolicyVersion(dictionary: $0) })
            } else { 
                self.policyVersions = nil
            }
        }
    }

    public struct GetPolicyVersionResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The JSON document that describes the policy.
        public let policyDocument: String?
        /// The policy version ID.
        public let policyVersionId: String?
        /// The policy name.
        public let policyName: String?
        /// Specifies whether the policy version is the default.
        public let isDefaultVersion: Bool?
        /// The policy ARN.
        public let policyArn: String?

        public init(policyDocument: String? = nil, policyVersionId: String? = nil, policyName: String? = nil, isDefaultVersion: Bool? = nil, policyArn: String? = nil) {
            self.policyDocument = policyDocument
            self.policyVersionId = policyVersionId
            self.policyName = policyName
            self.isDefaultVersion = isDefaultVersion
            self.policyArn = policyArn
        }

        public init(dictionary: [String: Any]) throws {
            self.policyDocument = dictionary["policyDocument"] as? String
            self.policyVersionId = dictionary["policyVersionId"] as? String
            self.policyName = dictionary["policyName"] as? String
            self.isDefaultVersion = dictionary["isDefaultVersion"] as? Bool
            self.policyArn = dictionary["policyArn"] as? String
        }
    }

    public struct ListThingTypesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["thingTypeName": "thingTypeName", "nextToken": "nextToken", "maxResults": "maxResults"]
        }
        /// The name of the thing type.
        public let thingTypeName: String?
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// The maximum number of results to return in this operation.
        public let maxResults: Int32?

        public init(thingTypeName: String? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.thingTypeName = thingTypeName
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.thingTypeName = dictionary["ThingTypeName"] as? String
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct CreateThingTypeResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the thing type.
        public let thingTypeName: String?
        /// The Amazon Resource Name (ARN) of the thing type.
        public let thingTypeArn: String?

        public init(thingTypeName: String? = nil, thingTypeArn: String? = nil) {
            self.thingTypeName = thingTypeName
            self.thingTypeArn = thingTypeArn
        }

        public init(dictionary: [String: Any]) throws {
            self.thingTypeName = dictionary["thingTypeName"] as? String
            self.thingTypeArn = dictionary["thingTypeArn"] as? String
        }
    }

    public struct DeleteTopicRuleRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["ruleName": "ruleName"]
        }
        /// The name of the rule.
        public let ruleName: String

        public init(ruleName: String) {
            self.ruleName = ruleName
        }

        public init(dictionary: [String: Any]) throws {
            guard let ruleName = dictionary["RuleName"] as? String else { throw InitializableError.missingRequiredParam("RuleName") }
            self.ruleName = ruleName
        }
    }

    public struct GetPolicyVersionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["policyVersionId": "policyVersionId", "policyName": "policyName"]
        }
        /// The policy version ID.
        public let policyVersionId: String
        /// The name of the policy.
        public let policyName: String

        public init(policyVersionId: String, policyName: String) {
            self.policyVersionId = policyVersionId
            self.policyName = policyName
        }

        public init(dictionary: [String: Any]) throws {
            guard let policyVersionId = dictionary["PolicyVersionId"] as? String else { throw InitializableError.missingRequiredParam("PolicyVersionId") }
            self.policyVersionId = policyVersionId
            guard let policyName = dictionary["PolicyName"] as? String else { throw InitializableError.missingRequiredParam("PolicyName") }
            self.policyName = policyName
        }
    }

    public struct ListTopicRulesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The rules.
        public let rules: [TopicRuleListItem]?
        /// A token used to retrieve the next value.
        public let nextToken: String?

        public init(rules: [TopicRuleListItem]? = nil, nextToken: String? = nil) {
            self.rules = rules
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let rules = dictionary["rules"] as? [[String: Any]] {
                self.rules = try rules.map({ try TopicRuleListItem(dictionary: $0) })
            } else { 
                self.rules = nil
            }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct S3Action: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Amazon S3 bucket.
        public let bucketName: String
        /// The ARN of the IAM role that grants access.
        public let roleArn: String
        /// The Amazon S3 canned ACL that controls access to the object identified by the object key. For more information, see S3 canned ACLs.
        public let cannedAcl: CannedAccessControlList?
        /// The object key.
        public let key: String

        public init(bucketName: String, roleArn: String, cannedAcl: CannedAccessControlList? = nil, key: String) {
            self.bucketName = bucketName
            self.roleArn = roleArn
            self.cannedAcl = cannedAcl
            self.key = key
        }

        public init(dictionary: [String: Any]) throws {
            guard let bucketName = dictionary["bucketName"] as? String else { throw InitializableError.missingRequiredParam("bucketName") }
            self.bucketName = bucketName
            guard let roleArn = dictionary["roleArn"] as? String else { throw InitializableError.missingRequiredParam("roleArn") }
            self.roleArn = roleArn
            if let cannedAcl = dictionary["cannedAcl"] as? String { self.cannedAcl = CannedAccessControlList(rawValue: cannedAcl) } else { self.cannedAcl = nil }
            guard let key = dictionary["key"] as? String else { throw InitializableError.missingRequiredParam("key") }
            self.key = key
        }
    }

    public struct OutgoingCertificate: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The transfer message.
        public let transferMessage: String?
        /// The certificate creation date.
        public let creationDate: Date?
        /// The certificate ID.
        public let certificateId: String?
        /// The certificate ARN.
        public let certificateArn: String?
        /// The AWS account to which the transfer was made.
        public let transferredTo: String?
        /// The date the transfer was initiated.
        public let transferDate: Date?

        public init(transferMessage: String? = nil, creationDate: Date? = nil, certificateId: String? = nil, certificateArn: String? = nil, transferredTo: String? = nil, transferDate: Date? = nil) {
            self.transferMessage = transferMessage
            self.creationDate = creationDate
            self.certificateId = certificateId
            self.certificateArn = certificateArn
            self.transferredTo = transferredTo
            self.transferDate = transferDate
        }

        public init(dictionary: [String: Any]) throws {
            self.transferMessage = dictionary["transferMessage"] as? String
            self.creationDate = dictionary["creationDate"] as? Date
            self.certificateId = dictionary["certificateId"] as? String
            self.certificateArn = dictionary["certificateArn"] as? String
            self.transferredTo = dictionary["transferredTo"] as? String
            self.transferDate = dictionary["transferDate"] as? Date
        }
    }

    public struct CreateCertificateFromCsrResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the certificate. Certificate management operations only take a certificateId.
        public let certificateId: String?
        /// The Amazon Resource Name (ARN) of the certificate. You can use the ARN as a principal for policy operations.
        public let certificateArn: String?
        /// The certificate data, in PEM format.
        public let certificatePem: String?

        public init(certificateId: String? = nil, certificateArn: String? = nil, certificatePem: String? = nil) {
            self.certificateId = certificateId
            self.certificateArn = certificateArn
            self.certificatePem = certificatePem
        }

        public init(dictionary: [String: Any]) throws {
            self.certificateId = dictionary["certificateId"] as? String
            self.certificateArn = dictionary["certificateArn"] as? String
            self.certificatePem = dictionary["certificatePem"] as? String
        }
    }

    public struct TransferCertificateResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the certificate.
        public let transferredCertificateArn: String?

        public init(transferredCertificateArn: String? = nil) {
            self.transferredCertificateArn = transferredCertificateArn
        }

        public init(dictionary: [String: Any]) throws {
            self.transferredCertificateArn = dictionary["transferredCertificateArn"] as? String
        }
    }

    public struct FirehoseAction: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IAM role that grants access to the Amazon Kinesis Firehost stream.
        public let roleArn: String
        /// The delivery stream name.
        public let deliveryStreamName: String
        /// A character separator that will be used to separate records written to the Firehose stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).
        public let separator: String?

        public init(roleArn: String, deliveryStreamName: String, separator: String? = nil) {
            self.roleArn = roleArn
            self.deliveryStreamName = deliveryStreamName
            self.separator = separator
        }

        public init(dictionary: [String: Any]) throws {
            guard let roleArn = dictionary["roleArn"] as? String else { throw InitializableError.missingRequiredParam("roleArn") }
            self.roleArn = roleArn
            guard let deliveryStreamName = dictionary["deliveryStreamName"] as? String else { throw InitializableError.missingRequiredParam("deliveryStreamName") }
            self.deliveryStreamName = deliveryStreamName
            self.separator = dictionary["separator"] as? String
        }
    }

    public struct CreatePolicyVersionResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The policy ARN.
        public let policyArn: String?
        /// The policy version ID.
        public let policyVersionId: String?
        /// Specifies whether the policy version is the default.
        public let isDefaultVersion: Bool?
        /// The JSON document that describes the policy.
        public let policyDocument: String?

        public init(policyArn: String? = nil, policyVersionId: String? = nil, isDefaultVersion: Bool? = nil, policyDocument: String? = nil) {
            self.policyArn = policyArn
            self.policyVersionId = policyVersionId
            self.isDefaultVersion = isDefaultVersion
            self.policyDocument = policyDocument
        }

        public init(dictionary: [String: Any]) throws {
            self.policyArn = dictionary["policyArn"] as? String
            self.policyVersionId = dictionary["policyVersionId"] as? String
            self.isDefaultVersion = dictionary["isDefaultVersion"] as? Bool
            self.policyDocument = dictionary["policyDocument"] as? String
        }
    }

    public struct AcceptCertificateTransferRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["setAsActive": "setAsActive"]
        }
        public static var pathParams: [String: String] {
            return ["certificateId": "certificateId"]
        }
        /// The ID of the certificate.
        public let certificateId: String
        /// Specifies whether the certificate is active.
        public let setAsActive: Bool?

        public init(certificateId: String, setAsActive: Bool? = nil) {
            self.certificateId = certificateId
            self.setAsActive = setAsActive
        }

        public init(dictionary: [String: Any]) throws {
            guard let certificateId = dictionary["CertificateId"] as? String else { throw InitializableError.missingRequiredParam("CertificateId") }
            self.certificateId = certificateId
            self.setAsActive = dictionary["SetAsActive"] as? Bool
        }
    }

    public struct CancelCertificateTransferRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["certificateId": "certificateId"]
        }
        /// The ID of the certificate.
        public let certificateId: String

        public init(certificateId: String) {
            self.certificateId = certificateId
        }

        public init(dictionary: [String: Any]) throws {
            guard let certificateId = dictionary["CertificateId"] as? String else { throw InitializableError.missingRequiredParam("CertificateId") }
            self.certificateId = certificateId
        }
    }

    public struct DeleteCertificateRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["certificateId": "certificateId"]
        }
        /// The ID of the certificate.
        public let certificateId: String

        public init(certificateId: String) {
            self.certificateId = certificateId
        }

        public init(dictionary: [String: Any]) throws {
            guard let certificateId = dictionary["CertificateId"] as? String else { throw InitializableError.missingRequiredParam("CertificateId") }
            self.certificateId = certificateId
        }
    }

    public struct DetachThingPrincipalResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct DescribeEndpointResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The endpoint. The format of the endpoint is as follows: identifier.iot.region.amazonaws.com.
        public let endpointAddress: String?

        public init(endpointAddress: String? = nil) {
            self.endpointAddress = endpointAddress
        }

        public init(dictionary: [String: Any]) throws {
            self.endpointAddress = dictionary["endpointAddress"] as? String
        }
    }

    public struct RejectCertificateTransferRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["certificateId": "certificateId"]
        }
        /// The ID of the certificate.
        public let certificateId: String
        /// The reason the certificate transfer was rejected.
        public let rejectReason: String?

        public init(certificateId: String, rejectReason: String? = nil) {
            self.certificateId = certificateId
            self.rejectReason = rejectReason
        }

        public init(dictionary: [String: Any]) throws {
            guard let certificateId = dictionary["CertificateId"] as? String else { throw InitializableError.missingRequiredParam("CertificateId") }
            self.certificateId = certificateId
            self.rejectReason = dictionary["rejectReason"] as? String
        }
    }

    public struct TransferData: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The date the transfer was rejected.
        public let rejectDate: Date?
        /// The date the transfer was accepted.
        public let acceptDate: Date?
        /// The transfer message.
        public let transferMessage: String?
        /// The date the transfer took place.
        public let transferDate: Date?
        /// The reason why the transfer was rejected.
        public let rejectReason: String?

        public init(rejectDate: Date? = nil, acceptDate: Date? = nil, transferMessage: String? = nil, transferDate: Date? = nil, rejectReason: String? = nil) {
            self.rejectDate = rejectDate
            self.acceptDate = acceptDate
            self.transferMessage = transferMessage
            self.transferDate = transferDate
            self.rejectReason = rejectReason
        }

        public init(dictionary: [String: Any]) throws {
            self.rejectDate = dictionary["rejectDate"] as? Date
            self.acceptDate = dictionary["acceptDate"] as? Date
            self.transferMessage = dictionary["transferMessage"] as? String
            self.transferDate = dictionary["transferDate"] as? Date
            self.rejectReason = dictionary["rejectReason"] as? String
        }
    }

    public struct GetPolicyRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["policyName": "policyName"]
        }
        /// The name of the policy.
        public let policyName: String

        public init(policyName: String) {
            self.policyName = policyName
        }

        public init(dictionary: [String: Any]) throws {
            guard let policyName = dictionary["PolicyName"] as? String else { throw InitializableError.missingRequiredParam("PolicyName") }
            self.policyName = policyName
        }
    }

    public enum AutoRegistrationStatus: String, CustomStringConvertible {
        case enable = "ENABLE"
        case disable = "DISABLE"
        public var description: String { return self.rawValue }
    }

    public struct Certificate: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The status of the certificate. The status value REGISTER_INACTIVE is deprecated and should not be used.
        public let status: CertificateStatus?
        /// The date and time the certificate was created.
        public let creationDate: Date?
        /// The ID of the certificate.
        public let certificateId: String?
        /// The ARN of the certificate.
        public let certificateArn: String?

        public init(status: CertificateStatus? = nil, creationDate: Date? = nil, certificateId: String? = nil, certificateArn: String? = nil) {
            self.status = status
            self.creationDate = creationDate
            self.certificateId = certificateId
            self.certificateArn = certificateArn
        }

        public init(dictionary: [String: Any]) throws {
            if let status = dictionary["status"] as? String { self.status = CertificateStatus(rawValue: status) } else { self.status = nil }
            self.creationDate = dictionary["creationDate"] as? Date
            self.certificateId = dictionary["certificateId"] as? String
            self.certificateArn = dictionary["certificateArn"] as? String
        }
    }

    public struct RegisterCertificateRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["setAsActive": "setAsActive"]
        }
        /// The CA certificate used to sign the device certificate being registered.
        public let caCertificatePem: String?
        public let status: CertificateStatus?
        /// The certificate data, in PEM format.
        public let certificatePem: String
        /// A boolean value that specifies if the CA certificate is set to active.
        public let setAsActive: Bool?

        public init(caCertificatePem: String? = nil, status: CertificateStatus? = nil, certificatePem: String, setAsActive: Bool? = nil) {
            self.caCertificatePem = caCertificatePem
            self.status = status
            self.certificatePem = certificatePem
            self.setAsActive = setAsActive
        }

        public init(dictionary: [String: Any]) throws {
            self.caCertificatePem = dictionary["caCertificatePem"] as? String
            if let status = dictionary["status"] as? String { self.status = CertificateStatus(rawValue: status) } else { self.status = nil }
            guard let certificatePem = dictionary["certificatePem"] as? String else { throw InitializableError.missingRequiredParam("certificatePem") }
            self.certificatePem = certificatePem
            self.setAsActive = dictionary["SetAsActive"] as? Bool
        }
    }

    public struct ListThingPrincipalsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The principals associated with the thing.
        public let principals: [String]?

        public init(principals: [String]? = nil) {
            self.principals = principals
        }

        public init(dictionary: [String: Any]) throws {
            self.principals = dictionary["principals"] as? [String]
        }
    }

    public struct GetLoggingOptionsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the IAM role that grants access.
        public let roleArn: String?
        /// The logging level.
        public let logLevel: LogLevel?

        public init(roleArn: String? = nil, logLevel: LogLevel? = nil) {
            self.roleArn = roleArn
            self.logLevel = logLevel
        }

        public init(dictionary: [String: Any]) throws {
            self.roleArn = dictionary["roleArn"] as? String
            if let logLevel = dictionary["logLevel"] as? String { self.logLevel = LogLevel(rawValue: logLevel) } else { self.logLevel = nil }
        }
    }

    public struct ListOutgoingCertificatesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["marker": "marker", "pageSize": "pageSize", "isAscendingOrder": "ascendingOrder"]
        }
        /// The marker for the next set of results.
        public let marker: String?
        /// The result page size.
        public let pageSize: Int32?
        /// Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
        public let ascendingOrder: Bool?

        public init(marker: String? = nil, pageSize: Int32? = nil, ascendingOrder: Bool? = nil) {
            self.marker = marker
            self.pageSize = pageSize
            self.ascendingOrder = ascendingOrder
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["Marker"] as? String
            self.pageSize = dictionary["PageSize"] as? Int32
            self.ascendingOrder = dictionary["IsAscendingOrder"] as? Bool
        }
    }

    public struct ListCACertificatesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The CA certificates registered in your AWS account.
        public let certificates: [CACertificate]?
        /// The current position within the list of CA certificates.
        public let nextMarker: String?

        public init(certificates: [CACertificate]? = nil, nextMarker: String? = nil) {
            self.certificates = certificates
            self.nextMarker = nextMarker
        }

        public init(dictionary: [String: Any]) throws {
            if let certificates = dictionary["certificates"] as? [[String: Any]] {
                self.certificates = try certificates.map({ try CACertificate(dictionary: $0) })
            } else { 
                self.certificates = nil
            }
            self.nextMarker = dictionary["nextMarker"] as? String
        }
    }

    public struct ThingTypeProperties: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The description of the thing type.
        public let thingTypeDescription: String?
        /// A list of searchable thing attribute names.
        public let searchableAttributes: [String]?

        public init(thingTypeDescription: String? = nil, searchableAttributes: [String]? = nil) {
            self.thingTypeDescription = thingTypeDescription
            self.searchableAttributes = searchableAttributes
        }

        public init(dictionary: [String: Any]) throws {
            self.thingTypeDescription = dictionary["thingTypeDescription"] as? String
            self.searchableAttributes = dictionary["searchableAttributes"] as? [String]
        }
    }

    public struct GetPolicyResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The policy name.
        public let policyName: String?
        /// The default policy version ID.
        public let defaultVersionId: String?
        /// The policy ARN.
        public let policyArn: String?
        /// The JSON document that describes the policy.
        public let policyDocument: String?

        public init(policyName: String? = nil, defaultVersionId: String? = nil, policyArn: String? = nil, policyDocument: String? = nil) {
            self.policyName = policyName
            self.defaultVersionId = defaultVersionId
            self.policyArn = policyArn
            self.policyDocument = policyDocument
        }

        public init(dictionary: [String: Any]) throws {
            self.policyName = dictionary["policyName"] as? String
            self.defaultVersionId = dictionary["defaultVersionId"] as? String
            self.policyArn = dictionary["policyArn"] as? String
            self.policyDocument = dictionary["policyDocument"] as? String
        }
    }

    public struct ListThingsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// The things.
        public let things: [ThingAttribute]?

        public init(nextToken: String? = nil, things: [ThingAttribute]? = nil) {
            self.nextToken = nextToken
            self.things = things
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            if let things = dictionary["things"] as? [[String: Any]] {
                self.things = try things.map({ try ThingAttribute(dictionary: $0) })
            } else { 
                self.things = nil
            }
        }
    }

    public struct ListPrincipalPoliciesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var headerParams: [String: String] {
            return ["x-amzn-iot-principal": "principal"]
        }
        public static var queryParams: [String: String] {
            return ["marker": "marker", "pageSize": "pageSize", "isAscendingOrder": "ascendingOrder"]
        }
        /// The marker for the next set of results.
        public let marker: String?
        /// The result page size.
        public let pageSize: Int32?
        /// Specifies the order for results. If true, results are returned in ascending creation order.
        public let ascendingOrder: Bool?
        /// The principal.
        public let principal: String

        public init(marker: String? = nil, pageSize: Int32? = nil, ascendingOrder: Bool? = nil, principal: String) {
            self.marker = marker
            self.pageSize = pageSize
            self.ascendingOrder = ascendingOrder
            self.principal = principal
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["Marker"] as? String
            self.pageSize = dictionary["PageSize"] as? Int32
            self.ascendingOrder = dictionary["IsAscendingOrder"] as? Bool
            guard let principal = dictionary["X-amzn-iot-principal"] as? String else { throw InitializableError.missingRequiredParam("X-amzn-iot-principal") }
            self.principal = principal
        }
    }

    public enum LogLevel: String, CustomStringConvertible {
        case debug = "DEBUG"
        case info = "INFO"
        case error = "ERROR"
        case warn = "WARN"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public struct ThingAttribute: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the thing.
        public let thingName: String?
        /// The name of the thing type, if the thing has been associated with a type.
        public let thingTypeName: String?
        /// A list of thing attributes which are name-value pairs.
        public let attributes: [String: String]?
        /// The version of the thing record in the registry.
        public let version: Int64?

        public init(thingName: String? = nil, thingTypeName: String? = nil, attributes: [String: String]? = nil, version: Int64? = nil) {
            self.thingName = thingName
            self.thingTypeName = thingTypeName
            self.attributes = attributes
            self.version = version
        }

        public init(dictionary: [String: Any]) throws {
            self.thingName = dictionary["thingName"] as? String
            self.thingTypeName = dictionary["thingTypeName"] as? String
            if let attributes = dictionary["attributes"] as? [String: String] {
                self.attributes = attributes
            } else { 
                self.attributes = nil
            }
            self.version = dictionary["version"] as? Int64
        }
    }

    public struct DeletePolicyRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["policyName": "policyName"]
        }
        /// The name of the policy to delete.
        public let policyName: String

        public init(policyName: String) {
            self.policyName = policyName
        }

        public init(dictionary: [String: Any]) throws {
            guard let policyName = dictionary["PolicyName"] as? String else { throw InitializableError.missingRequiredParam("PolicyName") }
            self.policyName = policyName
        }
    }

    public struct DescribeThingRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["thingName": "thingName"]
        }
        /// The name of the thing.
        public let thingName: String

        public init(thingName: String) {
            self.thingName = thingName
        }

        public init(dictionary: [String: Any]) throws {
            guard let thingName = dictionary["ThingName"] as? String else { throw InitializableError.missingRequiredParam("ThingName") }
            self.thingName = thingName
        }
    }

    public struct CACertificateDescription: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The status of a CA certificate.
        public let status: CACertificateStatus?
        /// Whether the CA certificate configured for auto registration of device certificates. Valid values are "ENABLE" and "DISABLE"
        public let autoRegistrationStatus: AutoRegistrationStatus?
        /// The date the CA certificate was created.
        public let creationDate: Date?
        /// The CA certificate ID.
        public let certificateId: String?
        /// The CA certificate data, in PEM format.
        public let certificatePem: String?
        /// The owner of the CA certificate.
        public let ownedBy: String?
        /// The CA certificate ARN.
        public let certificateArn: String?

        public init(status: CACertificateStatus? = nil, autoRegistrationStatus: AutoRegistrationStatus? = nil, creationDate: Date? = nil, certificateId: String? = nil, certificatePem: String? = nil, ownedBy: String? = nil, certificateArn: String? = nil) {
            self.status = status
            self.autoRegistrationStatus = autoRegistrationStatus
            self.creationDate = creationDate
            self.certificateId = certificateId
            self.certificatePem = certificatePem
            self.ownedBy = ownedBy
            self.certificateArn = certificateArn
        }

        public init(dictionary: [String: Any]) throws {
            if let status = dictionary["status"] as? String { self.status = CACertificateStatus(rawValue: status) } else { self.status = nil }
            if let autoRegistrationStatus = dictionary["autoRegistrationStatus"] as? String { self.autoRegistrationStatus = AutoRegistrationStatus(rawValue: autoRegistrationStatus) } else { self.autoRegistrationStatus = nil }
            self.creationDate = dictionary["creationDate"] as? Date
            self.certificateId = dictionary["certificateId"] as? String
            self.certificatePem = dictionary["certificatePem"] as? String
            self.ownedBy = dictionary["ownedBy"] as? String
            self.certificateArn = dictionary["certificateArn"] as? String
        }
    }

    public struct ListTopicRulesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["ruleDisabled": "ruleDisabled", "maxResults": "maxResults", "nextToken": "nextToken", "topic": "topic"]
        }
        /// Specifies whether the rule is disabled.
        public let ruleDisabled: Bool?
        /// The maximum number of results to return.
        public let maxResults: Int32?
        /// A token used to retrieve the next value.
        public let nextToken: String?
        /// The topic.
        public let topic: String?

        public init(ruleDisabled: Bool? = nil, maxResults: Int32? = nil, nextToken: String? = nil, topic: String? = nil) {
            self.ruleDisabled = ruleDisabled
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.topic = topic
        }

        public init(dictionary: [String: Any]) throws {
            self.ruleDisabled = dictionary["RuleDisabled"] as? Bool
            self.maxResults = dictionary["MaxResults"] as? Int32
            self.nextToken = dictionary["NextToken"] as? String
            self.topic = dictionary["Topic"] as? String
        }
    }

    public enum CertificateStatus: String, CustomStringConvertible {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        case revoked = "REVOKED"
        case pending_transfer = "PENDING_TRANSFER"
        case register_inactive = "REGISTER_INACTIVE"
        case pending_activation = "PENDING_ACTIVATION"
        public var description: String { return self.rawValue }
    }

    public struct DescribeThingResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The default client ID.
        public let defaultClientId: String?
        /// The name of the thing.
        public let thingName: String?
        /// The thing type name.
        public let thingTypeName: String?
        /// The thing attributes.
        public let attributes: [String: String]?
        /// The current version of the thing record in the registry.  To avoid unintentional changes to the information in the registry, you can pass the version information in the expectedVersion parameter of the UpdateThing and DeleteThing calls. 
        public let version: Int64?

        public init(defaultClientId: String? = nil, thingName: String? = nil, thingTypeName: String? = nil, attributes: [String: String]? = nil, version: Int64? = nil) {
            self.defaultClientId = defaultClientId
            self.thingName = thingName
            self.thingTypeName = thingTypeName
            self.attributes = attributes
            self.version = version
        }

        public init(dictionary: [String: Any]) throws {
            self.defaultClientId = dictionary["defaultClientId"] as? String
            self.thingName = dictionary["thingName"] as? String
            self.thingTypeName = dictionary["thingTypeName"] as? String
            if let attributes = dictionary["attributes"] as? [String: String] {
                self.attributes = attributes
            } else { 
                self.attributes = nil
            }
            self.version = dictionary["version"] as? Int64
        }
    }

    public struct DescribeThingTypeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["thingTypeName": "thingTypeName"]
        }
        /// The name of the thing type.
        public let thingTypeName: String

        public init(thingTypeName: String) {
            self.thingTypeName = thingTypeName
        }

        public init(dictionary: [String: Any]) throws {
            guard let thingTypeName = dictionary["ThingTypeName"] as? String else { throw InitializableError.missingRequiredParam("ThingTypeName") }
            self.thingTypeName = thingTypeName
        }
    }

    public struct AttachPrincipalPolicyRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var headerParams: [String: String] {
            return ["x-amzn-iot-principal": "principal"]
        }
        public static var pathParams: [String: String] {
            return ["policyName": "policyName"]
        }
        /// The policy name.
        public let policyName: String
        /// The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.
        public let principal: String

        public init(policyName: String, principal: String) {
            self.policyName = policyName
            self.principal = principal
        }

        public init(dictionary: [String: Any]) throws {
            guard let policyName = dictionary["PolicyName"] as? String else { throw InitializableError.missingRequiredParam("PolicyName") }
            self.policyName = policyName
            guard let principal = dictionary["X-amzn-iot-principal"] as? String else { throw InitializableError.missingRequiredParam("X-amzn-iot-principal") }
            self.principal = principal
        }
    }

    public struct UpdateThingRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["thingName": "thingName"]
        }
        /// Remove a thing type association. If true, the assocation is removed.
        public let removeThingType: Bool?
        /// The name of the thing to update.
        public let thingName: String
        /// The name of the thing type.
        public let thingTypeName: String?
        /// The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the UpdateThing request is rejected with a VersionConflictException.
        public let expectedVersion: Int64?
        /// A list of thing attributes, a JSON string containing name-value pairs. For example: {\"attributes\":{\"name1\":\"value2\"}}) This data is used to add new attributes or update existing attributes.
        public let attributePayload: AttributePayload?

        public init(removeThingType: Bool? = nil, thingName: String, thingTypeName: String? = nil, expectedVersion: Int64? = nil, attributePayload: AttributePayload? = nil) {
            self.removeThingType = removeThingType
            self.thingName = thingName
            self.thingTypeName = thingTypeName
            self.expectedVersion = expectedVersion
            self.attributePayload = attributePayload
        }

        public init(dictionary: [String: Any]) throws {
            self.removeThingType = dictionary["removeThingType"] as? Bool
            guard let thingName = dictionary["ThingName"] as? String else { throw InitializableError.missingRequiredParam("ThingName") }
            self.thingName = thingName
            self.thingTypeName = dictionary["thingTypeName"] as? String
            self.expectedVersion = dictionary["expectedVersion"] as? Int64
            if let attributePayload = dictionary["attributePayload"] as? [String: Any] { self.attributePayload = try Iot.AttributePayload(dictionary: attributePayload) } else { self.attributePayload = nil }
        }
    }

    public struct DeprecateThingTypeResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public enum DynamoKeyType: String, CustomStringConvertible {
        case string = "STRING"
        case number = "NUMBER"
        public var description: String { return self.rawValue }
    }

    public struct ListCertificatesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["marker": "marker", "pageSize": "pageSize", "isAscendingOrder": "ascendingOrder"]
        }
        /// The marker for the next set of results.
        public let marker: String?
        /// The result page size.
        public let pageSize: Int32?
        /// Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
        public let ascendingOrder: Bool?

        public init(marker: String? = nil, pageSize: Int32? = nil, ascendingOrder: Bool? = nil) {
            self.marker = marker
            self.pageSize = pageSize
            self.ascendingOrder = ascendingOrder
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["Marker"] as? String
            self.pageSize = dictionary["PageSize"] as? Int32
            self.ascendingOrder = dictionary["IsAscendingOrder"] as? Bool
        }
    }

    public enum CannedAccessControlList: String, CustomStringConvertible {
        case `private` = "private"
        case public_read = "public-read"
        case public_read_write = "public-read-write"
        case aws_exec_read = "aws-exec-read"
        case authenticated_read = "authenticated-read"
        case bucket_owner_read = "bucket-owner-read"
        case bucket_owner_full_control = "bucket-owner-full-control"
        case log_delivery_write = "log-delivery-write"
        public var description: String { return self.rawValue }
    }

    public struct ReplaceTopicRuleRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = "topicRulePayload"
        public static var pathParams: [String: String] {
            return ["ruleName": "ruleName"]
        }
        /// The name of the rule.
        public let ruleName: String
        /// The rule payload.
        public let topicRulePayload: TopicRulePayload

        public init(ruleName: String, topicRulePayload: TopicRulePayload) {
            self.ruleName = ruleName
            self.topicRulePayload = topicRulePayload
        }

        public init(dictionary: [String: Any]) throws {
            guard let ruleName = dictionary["RuleName"] as? String else { throw InitializableError.missingRequiredParam("RuleName") }
            self.ruleName = ruleName
            guard let topicRulePayload = dictionary["topicRulePayload"] as? [String: Any] else { throw InitializableError.missingRequiredParam("topicRulePayload") }
            self.topicRulePayload = try Iot.TopicRulePayload(dictionary: topicRulePayload)
        }
    }

    public struct CloudwatchMetricAction: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The CloudWatch metric value.
        public let metricValue: String
        /// The IAM role that allows access to the CloudWatch metric.
        public let roleArn: String
        /// An optional Unix timestamp.
        public let metricTimestamp: String?
        /// The CloudWatch metric namespace name.
        public let metricNamespace: String
        /// The CloudWatch metric name.
        public let metricName: String
        /// The metric unit supported by CloudWatch.
        public let metricUnit: String

        public init(metricValue: String, roleArn: String, metricTimestamp: String? = nil, metricNamespace: String, metricName: String, metricUnit: String) {
            self.metricValue = metricValue
            self.roleArn = roleArn
            self.metricTimestamp = metricTimestamp
            self.metricNamespace = metricNamespace
            self.metricName = metricName
            self.metricUnit = metricUnit
        }

        public init(dictionary: [String: Any]) throws {
            guard let metricValue = dictionary["metricValue"] as? String else { throw InitializableError.missingRequiredParam("metricValue") }
            self.metricValue = metricValue
            guard let roleArn = dictionary["roleArn"] as? String else { throw InitializableError.missingRequiredParam("roleArn") }
            self.roleArn = roleArn
            self.metricTimestamp = dictionary["metricTimestamp"] as? String
            guard let metricNamespace = dictionary["metricNamespace"] as? String else { throw InitializableError.missingRequiredParam("metricNamespace") }
            self.metricNamespace = metricNamespace
            guard let metricName = dictionary["metricName"] as? String else { throw InitializableError.missingRequiredParam("metricName") }
            self.metricName = metricName
            guard let metricUnit = dictionary["metricUnit"] as? String else { throw InitializableError.missingRequiredParam("metricUnit") }
            self.metricUnit = metricUnit
        }
    }

    public struct RegisterCACertificateResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The CA certificate identifier.
        public let certificateId: String?
        /// The CA certificate ARN.
        public let certificateArn: String?

        public init(certificateId: String? = nil, certificateArn: String? = nil) {
            self.certificateId = certificateId
            self.certificateArn = certificateArn
        }

        public init(dictionary: [String: Any]) throws {
            self.certificateId = dictionary["certificateId"] as? String
            self.certificateArn = dictionary["certificateArn"] as? String
        }
    }

    public struct DescribeThingTypeResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let thingTypeMetadata: ThingTypeMetadata?
        /// The name of the thing type.
        public let thingTypeName: String?
        /// The ThingTypeProperties contains information about the thing type including description, and a list of searchable thing attribute names.
        public let thingTypeProperties: ThingTypeProperties?

        public init(thingTypeMetadata: ThingTypeMetadata? = nil, thingTypeName: String? = nil, thingTypeProperties: ThingTypeProperties? = nil) {
            self.thingTypeMetadata = thingTypeMetadata
            self.thingTypeName = thingTypeName
            self.thingTypeProperties = thingTypeProperties
        }

        public init(dictionary: [String: Any]) throws {
            if let thingTypeMetadata = dictionary["thingTypeMetadata"] as? [String: Any] { self.thingTypeMetadata = try Iot.ThingTypeMetadata(dictionary: thingTypeMetadata) } else { self.thingTypeMetadata = nil }
            self.thingTypeName = dictionary["thingTypeName"] as? String
            if let thingTypeProperties = dictionary["thingTypeProperties"] as? [String: Any] { self.thingTypeProperties = try Iot.ThingTypeProperties(dictionary: thingTypeProperties) } else { self.thingTypeProperties = nil }
        }
    }

    public struct DynamoDBAction: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the IAM role that grants access to the DynamoDB table.
        public let roleArn: String
        /// The range key type. Valid values are "STRING" or "NUMBER"
        public let rangeKeyType: DynamoKeyType?
        /// The range key value.
        public let rangeKeyValue: String?
        /// The hash key value.
        public let hashKeyValue: String
        /// The type of operation to be performed. This follows the substitution template, so it can be ${operation}, but the substitution must result in one of the following: INSERT, UPDATE, or DELETE.
        public let operation: String?
        /// The action payload. This name can be customized.
        public let payloadField: String?
        /// The range key name.
        public let rangeKeyField: String?
        /// The name of the DynamoDB table.
        public let tableName: String
        /// The hash key name.
        public let hashKeyField: String
        /// The hash key type. Valid values are "STRING" or "NUMBER"
        public let hashKeyType: DynamoKeyType?

        public init(roleArn: String, rangeKeyType: DynamoKeyType? = nil, rangeKeyValue: String? = nil, hashKeyValue: String, operation: String? = nil, payloadField: String? = nil, rangeKeyField: String? = nil, tableName: String, hashKeyField: String, hashKeyType: DynamoKeyType? = nil) {
            self.roleArn = roleArn
            self.rangeKeyType = rangeKeyType
            self.rangeKeyValue = rangeKeyValue
            self.hashKeyValue = hashKeyValue
            self.operation = operation
            self.payloadField = payloadField
            self.rangeKeyField = rangeKeyField
            self.tableName = tableName
            self.hashKeyField = hashKeyField
            self.hashKeyType = hashKeyType
        }

        public init(dictionary: [String: Any]) throws {
            guard let roleArn = dictionary["roleArn"] as? String else { throw InitializableError.missingRequiredParam("roleArn") }
            self.roleArn = roleArn
            if let rangeKeyType = dictionary["rangeKeyType"] as? String { self.rangeKeyType = DynamoKeyType(rawValue: rangeKeyType) } else { self.rangeKeyType = nil }
            self.rangeKeyValue = dictionary["rangeKeyValue"] as? String
            guard let hashKeyValue = dictionary["hashKeyValue"] as? String else { throw InitializableError.missingRequiredParam("hashKeyValue") }
            self.hashKeyValue = hashKeyValue
            self.operation = dictionary["operation"] as? String
            self.payloadField = dictionary["payloadField"] as? String
            self.rangeKeyField = dictionary["rangeKeyField"] as? String
            guard let tableName = dictionary["tableName"] as? String else { throw InitializableError.missingRequiredParam("tableName") }
            self.tableName = tableName
            guard let hashKeyField = dictionary["hashKeyField"] as? String else { throw InitializableError.missingRequiredParam("hashKeyField") }
            self.hashKeyField = hashKeyField
            if let hashKeyType = dictionary["hashKeyType"] as? String { self.hashKeyType = DynamoKeyType(rawValue: hashKeyType) } else { self.hashKeyType = nil }
        }
    }

    public struct AttachThingPrincipalResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct DeleteThingResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct DescribeEndpointRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct DeleteThingRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["expectedVersion": "expectedVersion"]
        }
        public static var pathParams: [String: String] {
            return ["thingName": "thingName"]
        }
        /// The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the DeleteThing request is rejected with a VersionConflictException.
        public let expectedVersion: Int64?
        /// The name of the thing to delete.
        public let thingName: String

        public init(expectedVersion: Int64? = nil, thingName: String) {
            self.expectedVersion = expectedVersion
            self.thingName = thingName
        }

        public init(dictionary: [String: Any]) throws {
            self.expectedVersion = dictionary["ExpectedVersion"] as? Int64
            guard let thingName = dictionary["ThingName"] as? String else { throw InitializableError.missingRequiredParam("ThingName") }
            self.thingName = thingName
        }
    }

}