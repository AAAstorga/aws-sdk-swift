// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Rekognition {

    public struct Landmark: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// x-coordinate from the top left of the landmark expressed as the ration of the width of the image. For example, if the images is 700x200 and the x-coordinate of the landmark is at 350 pixels, this value is 0.5. 
        public let x: Float?
        /// Type of the landmark.
        public let `type`: LandmarkType?
        /// y-coordinate from the top left of the landmark expressed as the ration of the height of the image. For example, if the images is 700x200 and the y-coordinate of the landmark is at 100 pixels, this value is 0.5.
        public let y: Float?

        public init(x: Float? = nil, type: LandmarkType? = nil, y: Float? = nil) {
            self.x = x
            self.`type` = `type`
            self.y = y
        }

        public init(dictionary: [String: Any]) throws {
            self.x = dictionary["X"] as? Float
            if let `type` = dictionary["Type"] as? String { self.`type` = LandmarkType(rawValue: `type`) } else { self.`type` = nil }
            self.y = dictionary["Y"] as? Float
        }
    }

    public struct SearchFacesByImageResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The level of confidence that the searchedFaceBoundingBox, contains a face.
        public let searchedFaceConfidence: Float?
        /// An array of faces that match the input face, along with the confidence in the match.
        public let faceMatches: [FaceMatch]?
        /// The bounding box around the face in the input image that Amazon Rekognition used for the search.
        public let searchedFaceBoundingBox: BoundingBox?

        public init(searchedFaceConfidence: Float? = nil, faceMatches: [FaceMatch]? = nil, searchedFaceBoundingBox: BoundingBox? = nil) {
            self.searchedFaceConfidence = searchedFaceConfidence
            self.faceMatches = faceMatches
            self.searchedFaceBoundingBox = searchedFaceBoundingBox
        }

        public init(dictionary: [String: Any]) throws {
            self.searchedFaceConfidence = dictionary["SearchedFaceConfidence"] as? Float
            if let faceMatches = dictionary["FaceMatches"] as? [[String: Any]] {
                self.faceMatches = try faceMatches.map({ try FaceMatch(dictionary: $0) })
            } else { 
                self.faceMatches = nil
            }
            if let searchedFaceBoundingBox = dictionary["SearchedFaceBoundingBox"] as? [String: Any] { self.searchedFaceBoundingBox = try Rekognition.BoundingBox(dictionary: searchedFaceBoundingBox) } else { self.searchedFaceBoundingBox = nil }
        }
    }

    public struct DeleteCollectionResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// HTTP status code that indicates the result of the operation.
        public let statusCode: Int32?

        public init(statusCode: Int32? = nil) {
            self.statusCode = statusCode
        }

        public init(dictionary: [String: Any]) throws {
            self.statusCode = dictionary["StatusCode"] as? Int32
        }
    }

    public struct ListCollectionsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of collection IDs.
        public let collectionIds: [String]?
        /// If the result is truncated, the response provides a NextToken that you can use in the subsequent request to fetch the next set of collection IDs.
        public let nextToken: String?

        public init(collectionIds: [String]? = nil, nextToken: String? = nil) {
            self.collectionIds = collectionIds
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            self.collectionIds = dictionary["CollectionIds"] as? [String]
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public enum OrientationCorrection: String, CustomStringConvertible {
        case rotate_0 = "ROTATE_0"
        case rotate_90 = "ROTATE_90"
        case rotate_180 = "ROTATE_180"
        case rotate_270 = "ROTATE_270"
        public var description: String { return self.rawValue }
    }

    public struct Emotion: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Level of confidence in the determination.
        public let confidence: Float?
        /// Type of emotion detected.
        public let `type`: EmotionName?

        public init(confidence: Float? = nil, type: EmotionName? = nil) {
            self.confidence = confidence
            self.`type` = `type`
        }

        public init(dictionary: [String: Any]) throws {
            self.confidence = dictionary["Confidence"] as? Float
            if let `type` = dictionary["Type"] as? String { self.`type` = EmotionName(rawValue: `type`) } else { self.`type` = nil }
        }
    }

    public struct DeleteFacesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of face IDs to delete.
        public let faceIds: [String]
        /// Collection from which to remove the specific faces.
        public let collectionId: String

        public init(faceIds: [String], collectionId: String) {
            self.faceIds = faceIds
            self.collectionId = collectionId
        }

        public init(dictionary: [String: Any]) throws {
            guard let faceIds = dictionary["FaceIds"] as? [String] else { throw InitializableError.missingRequiredParam("FaceIds") }
            self.faceIds = faceIds
            guard let collectionId = dictionary["CollectionId"] as? String else { throw InitializableError.missingRequiredParam("CollectionId") }
            self.collectionId = collectionId
        }
    }

    public struct DeleteFacesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of strings (face IDs) of the faces that were deleted.
        public let deletedFaces: [String]?

        public init(deletedFaces: [String]? = nil) {
            self.deletedFaces = deletedFaces
        }

        public init(dictionary: [String: Any]) throws {
            self.deletedFaces = dictionary["DeletedFaces"] as? [String]
        }
    }

    public struct BoundingBox: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Height of the bounding box as a ratio of the overall image height.
        public let height: Float?
        /// Top coordinate of the bounding box as a ratio of overall image height.
        public let top: Float?
        /// Left coordinate of the bounding box as a ratio of overall image width.
        public let left: Float?
        /// Width of the bounding box as a ratio of the overall image width.
        public let width: Float?

        public init(height: Float? = nil, top: Float? = nil, left: Float? = nil, width: Float? = nil) {
            self.height = height
            self.top = top
            self.left = left
            self.width = width
        }

        public init(dictionary: [String: Any]) throws {
            self.height = dictionary["Height"] as? Float
            self.top = dictionary["Top"] as? Float
            self.left = dictionary["Left"] as? Float
            self.width = dictionary["Width"] as? Float
        }
    }

    public struct Pose: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Value representing the face rotation on the yaw axis.
        public let yaw: Float?
        /// Value representing the face rotation on the roll axis.
        public let roll: Float?
        /// Value representing the face rotation on the pitch axis.
        public let pitch: Float?

        public init(yaw: Float? = nil, roll: Float? = nil, pitch: Float? = nil) {
            self.yaw = yaw
            self.roll = roll
            self.pitch = pitch
        }

        public init(dictionary: [String: Any]) throws {
            self.yaw = dictionary["Yaw"] as? Float
            self.roll = dictionary["Roll"] as? Float
            self.pitch = dictionary["Pitch"] as? Float
        }
    }

    public struct ComparedFace: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Level of confidence that what the bounding box contains is a face.
        public let confidence: Float?
        public let boundingBox: BoundingBox?

        public init(confidence: Float? = nil, boundingBox: BoundingBox? = nil) {
            self.confidence = confidence
            self.boundingBox = boundingBox
        }

        public init(dictionary: [String: Any]) throws {
            self.confidence = dictionary["Confidence"] as? Float
            if let boundingBox = dictionary["BoundingBox"] as? [String: Any] { self.boundingBox = try Rekognition.BoundingBox(dictionary: boundingBox) } else { self.boundingBox = nil }
        }
    }

    public struct SearchFacesByImageRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let image: Image
        /// (Optional) Specifies the minimum confidence in the face match to return. For example, don't return any matches where confidence in matches is less than 70%.
        public let faceMatchThreshold: Float?
        /// Maximum number of faces to return. The operation returns the maximum number of faces with the highest confidence in the match.
        public let maxFaces: Int32?
        /// ID of the collection to search.
        public let collectionId: String

        public init(image: Image, faceMatchThreshold: Float? = nil, maxFaces: Int32? = nil, collectionId: String) {
            self.image = image
            self.faceMatchThreshold = faceMatchThreshold
            self.maxFaces = maxFaces
            self.collectionId = collectionId
        }

        public init(dictionary: [String: Any]) throws {
            guard let image = dictionary["Image"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Image") }
            self.image = try Rekognition.Image(dictionary: image)
            self.faceMatchThreshold = dictionary["FaceMatchThreshold"] as? Float
            self.maxFaces = dictionary["MaxFaces"] as? Int32
            guard let collectionId = dictionary["CollectionId"] as? String else { throw InitializableError.missingRequiredParam("CollectionId") }
            self.collectionId = collectionId
        }
    }

    public struct FaceMatch: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let face: Face?
        /// Confidence in the match of this face with the input face.
        public let similarity: Float?

        public init(face: Face? = nil, similarity: Float? = nil) {
            self.face = face
            self.similarity = similarity
        }

        public init(dictionary: [String: Any]) throws {
            if let face = dictionary["Face"] as? [String: Any] { self.face = try Rekognition.Face(dictionary: face) } else { self.face = nil }
            self.similarity = dictionary["Similarity"] as? Float
        }
    }

    public struct Gender: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Level of confidence in the determination.
        public let confidence: Float?
        /// Gender of the face.
        public let value: GenderType?

        public init(confidence: Float? = nil, value: GenderType? = nil) {
            self.confidence = confidence
            self.value = value
        }

        public init(dictionary: [String: Any]) throws {
            self.confidence = dictionary["Confidence"] as? Float
            if let value = dictionary["Value"] as? String { self.value = GenderType(rawValue: value) } else { self.value = nil }
        }
    }

    public struct Smile: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Level of confidence in the determination.
        public let confidence: Float?
        /// Boolean value that indicates whether the face is smiling or not.
        public let value: Bool?

        public init(confidence: Float? = nil, value: Bool? = nil) {
            self.confidence = confidence
            self.value = value
        }

        public init(dictionary: [String: Any]) throws {
            self.confidence = dictionary["Confidence"] as? Float
            self.value = dictionary["Value"] as? Bool
        }
    }

    public struct S3Object: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Name of the S3 bucket.
        public let bucket: String?
        /// S3 object key name.
        public let name: String?
        /// If the bucket is versioning enabled, you can specify the object version. 
        public let version: String?

        public init(bucket: String? = nil, name: String? = nil, version: String? = nil) {
            self.bucket = bucket
            self.name = name
            self.version = version
        }

        public init(dictionary: [String: Any]) throws {
            self.bucket = dictionary["Bucket"] as? String
            self.name = dictionary["Name"] as? String
            self.version = dictionary["Version"] as? String
        }
    }

    public struct DetectFacesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The algorithm detects the image orientation. If it detects that the image was rotated, it returns the degrees of rotation. If your application is displaying the image, you can use this value to adjust the orientation.  For example, if the service detects that the input image was rotated by 90 degrees, it corrects orientation, performs face detection, and then returns the faces. That is, the bounding box coordinates in the response are based on the corrected orientation.   If the source image Exif metadata populates the orientation field, Amazon Rekognition does not perform orientation correction and the value of OrientationCorrection will be nil. 
        public let orientationCorrection: OrientationCorrection?
        /// Details of each face found in the image. 
        public let faceDetails: [FaceDetail]?

        public init(orientationCorrection: OrientationCorrection? = nil, faceDetails: [FaceDetail]? = nil) {
            self.orientationCorrection = orientationCorrection
            self.faceDetails = faceDetails
        }

        public init(dictionary: [String: Any]) throws {
            if let orientationCorrection = dictionary["OrientationCorrection"] as? String { self.orientationCorrection = OrientationCorrection(rawValue: orientationCorrection) } else { self.orientationCorrection = nil }
            if let faceDetails = dictionary["FaceDetails"] as? [[String: Any]] {
                self.faceDetails = try faceDetails.map({ try FaceDetail(dictionary: $0) })
            } else { 
                self.faceDetails = nil
            }
        }
    }

    public struct IndexFacesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The algorithm detects the image orientation. If it detects that the image was rotated, it returns the degree of rotation. You can use this value to correct the orientation and also appropriately analyze the bounding box coordinates that are returned.   If the source image Exif metadata populates the orientation field, Amazon Rekognition does not perform orientation correction and the value of OrientationCorrection will be nil. 
        public let orientationCorrection: OrientationCorrection?
        /// An array of faces detected and added to the collection. For more information, see howitworks-index-faces. 
        public let faceRecords: [FaceRecord]?

        public init(orientationCorrection: OrientationCorrection? = nil, faceRecords: [FaceRecord]? = nil) {
            self.orientationCorrection = orientationCorrection
            self.faceRecords = faceRecords
        }

        public init(dictionary: [String: Any]) throws {
            if let orientationCorrection = dictionary["OrientationCorrection"] as? String { self.orientationCorrection = OrientationCorrection(rawValue: orientationCorrection) } else { self.orientationCorrection = nil }
            if let faceRecords = dictionary["FaceRecords"] as? [[String: Any]] {
                self.faceRecords = try faceRecords.map({ try FaceRecord(dictionary: $0) })
            } else { 
                self.faceRecords = nil
            }
        }
    }

    public struct Label: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Level of confidence.
        public let confidence: Float?
        /// The name (label) of the object.
        public let name: String?

        public init(confidence: Float? = nil, name: String? = nil) {
            self.confidence = confidence
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            self.confidence = dictionary["Confidence"] as? Float
            self.name = dictionary["Name"] as? String
        }
    }

    public struct FaceDetail: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Indicates whether or not the face is wearing sunglasses, and the confidence level in the determination.
        public let sunglasses: Sunglasses?
        /// Gender of the face and the confidence level in the determination.
        public let gender: Gender?
        /// Indicates whether or not the eyes on the face are open, and the confidence level in the determination.
        public let eyesOpen: EyeOpen?
        /// Indicates whether or not the face is smiling, and the confidence level in the determination.
        public let smile: Smile?
        /// Indicates whether or not the mouth on the face is open, and the confidence level in the determination.
        public let mouthOpen: MouthOpen?
        /// Bounding box of the face.
        public let boundingBox: BoundingBox?
        /// Indicates the pose of the face as determined by pitch, roll, and the yaw.
        public let pose: Pose?
        /// The estimated age range, in years, for the face. Low represents the lowest estimated age and High represents the highest estimated age.
        public let ageRange: AgeRange?
        /// Indicates whether or not the face is wearing eye glasses, and the confidence level in the determination.
        public let eyeglasses: Eyeglasses?
        /// Indicates the location of the landmark on the face.
        public let landmarks: [Landmark]?
        /// Indicates whether or not the face has a beard, and the confidence level in the determination.
        public let beard: Beard?
        /// Identifies image brightness and sharpness.
        public let quality: ImageQuality?
        /// Confidence level that the bounding box contains a face (and not a different object such as a tree).
        public let confidence: Float?
        /// Indicates whether or not the face has a mustache, and the confidence level in the determination.
        public let mustache: Mustache?
        /// The emotions detected on the face, and the confidence level in the determination. For example, HAPPY, SAD, and ANGRY. 
        public let emotions: [Emotion]?

        public init(sunglasses: Sunglasses? = nil, gender: Gender? = nil, eyesOpen: EyeOpen? = nil, smile: Smile? = nil, mouthOpen: MouthOpen? = nil, boundingBox: BoundingBox? = nil, pose: Pose? = nil, ageRange: AgeRange? = nil, eyeglasses: Eyeglasses? = nil, landmarks: [Landmark]? = nil, beard: Beard? = nil, quality: ImageQuality? = nil, confidence: Float? = nil, mustache: Mustache? = nil, emotions: [Emotion]? = nil) {
            self.sunglasses = sunglasses
            self.gender = gender
            self.eyesOpen = eyesOpen
            self.smile = smile
            self.mouthOpen = mouthOpen
            self.boundingBox = boundingBox
            self.pose = pose
            self.ageRange = ageRange
            self.eyeglasses = eyeglasses
            self.landmarks = landmarks
            self.beard = beard
            self.quality = quality
            self.confidence = confidence
            self.mustache = mustache
            self.emotions = emotions
        }

        public init(dictionary: [String: Any]) throws {
            if let sunglasses = dictionary["Sunglasses"] as? [String: Any] { self.sunglasses = try Rekognition.Sunglasses(dictionary: sunglasses) } else { self.sunglasses = nil }
            if let gender = dictionary["Gender"] as? [String: Any] { self.gender = try Rekognition.Gender(dictionary: gender) } else { self.gender = nil }
            if let eyesOpen = dictionary["EyesOpen"] as? [String: Any] { self.eyesOpen = try Rekognition.EyeOpen(dictionary: eyesOpen) } else { self.eyesOpen = nil }
            if let smile = dictionary["Smile"] as? [String: Any] { self.smile = try Rekognition.Smile(dictionary: smile) } else { self.smile = nil }
            if let mouthOpen = dictionary["MouthOpen"] as? [String: Any] { self.mouthOpen = try Rekognition.MouthOpen(dictionary: mouthOpen) } else { self.mouthOpen = nil }
            if let boundingBox = dictionary["BoundingBox"] as? [String: Any] { self.boundingBox = try Rekognition.BoundingBox(dictionary: boundingBox) } else { self.boundingBox = nil }
            if let pose = dictionary["Pose"] as? [String: Any] { self.pose = try Rekognition.Pose(dictionary: pose) } else { self.pose = nil }
            if let ageRange = dictionary["AgeRange"] as? [String: Any] { self.ageRange = try Rekognition.AgeRange(dictionary: ageRange) } else { self.ageRange = nil }
            if let eyeglasses = dictionary["Eyeglasses"] as? [String: Any] { self.eyeglasses = try Rekognition.Eyeglasses(dictionary: eyeglasses) } else { self.eyeglasses = nil }
            if let landmarks = dictionary["Landmarks"] as? [[String: Any]] {
                self.landmarks = try landmarks.map({ try Landmark(dictionary: $0) })
            } else { 
                self.landmarks = nil
            }
            if let beard = dictionary["Beard"] as? [String: Any] { self.beard = try Rekognition.Beard(dictionary: beard) } else { self.beard = nil }
            if let quality = dictionary["Quality"] as? [String: Any] { self.quality = try Rekognition.ImageQuality(dictionary: quality) } else { self.quality = nil }
            self.confidence = dictionary["Confidence"] as? Float
            if let mustache = dictionary["Mustache"] as? [String: Any] { self.mustache = try Rekognition.Mustache(dictionary: mustache) } else { self.mustache = nil }
            if let emotions = dictionary["Emotions"] as? [[String: Any]] {
                self.emotions = try emotions.map({ try Emotion(dictionary: $0) })
            } else { 
                self.emotions = nil
            }
        }
    }

    public struct CompareFacesMatch: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Provides face metadata (bounding box and confidence that the bounding box actually contains a face).
        public let face: ComparedFace?
        /// Level of confidence that the faces match.
        public let similarity: Float?

        public init(face: ComparedFace? = nil, similarity: Float? = nil) {
            self.face = face
            self.similarity = similarity
        }

        public init(dictionary: [String: Any]) throws {
            if let face = dictionary["Face"] as? [String: Any] { self.face = try Rekognition.ComparedFace(dictionary: face) } else { self.face = nil }
            self.similarity = dictionary["Similarity"] as? Float
        }
    }

    public struct SearchFacesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of faces that matched the input face, along with the confidence in the match.
        public let faceMatches: [FaceMatch]?
        /// ID of the face that was searched for matches in a collection.
        public let searchedFaceId: String?

        public init(faceMatches: [FaceMatch]? = nil, searchedFaceId: String? = nil) {
            self.faceMatches = faceMatches
            self.searchedFaceId = searchedFaceId
        }

        public init(dictionary: [String: Any]) throws {
            if let faceMatches = dictionary["FaceMatches"] as? [[String: Any]] {
                self.faceMatches = try faceMatches.map({ try FaceMatch(dictionary: $0) })
            } else { 
                self.faceMatches = nil
            }
            self.searchedFaceId = dictionary["SearchedFaceId"] as? String
        }
    }

    public struct SearchFacesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Optional value specifying the minimum confidence in the face match to return. For example, don't return any matches where confidence in matches is less than 70%.
        public let faceMatchThreshold: Float?
        /// Maximum number of faces to return. The operation returns the maximum number of faces with the highest confidence in the match.
        public let maxFaces: Int32?
        /// ID of the collection the face belongs to.
        public let collectionId: String
        /// ID of a face to find matches for in the collection.
        public let faceId: String

        public init(faceMatchThreshold: Float? = nil, maxFaces: Int32? = nil, collectionId: String, faceId: String) {
            self.faceMatchThreshold = faceMatchThreshold
            self.maxFaces = maxFaces
            self.collectionId = collectionId
            self.faceId = faceId
        }

        public init(dictionary: [String: Any]) throws {
            self.faceMatchThreshold = dictionary["FaceMatchThreshold"] as? Float
            self.maxFaces = dictionary["MaxFaces"] as? Int32
            guard let collectionId = dictionary["CollectionId"] as? String else { throw InitializableError.missingRequiredParam("CollectionId") }
            self.collectionId = collectionId
            guard let faceId = dictionary["FaceId"] as? String else { throw InitializableError.missingRequiredParam("FaceId") }
            self.faceId = faceId
        }
    }

    public struct Mustache: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Level of confidence in the determination.
        public let confidence: Float?
        /// Boolean value that indicates whether the face has mustache or not.
        public let value: Bool?

        public init(confidence: Float? = nil, value: Bool? = nil) {
            self.confidence = confidence
            self.value = value
        }

        public init(dictionary: [String: Any]) throws {
            self.confidence = dictionary["Confidence"] as? Float
            self.value = dictionary["Value"] as? Bool
        }
    }

    public struct ListCollectionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Pagination token from the previous response.
        public let nextToken: String?
        /// Maximum number of collection IDs to return.
        public let maxResults: Int32?

        public init(nextToken: String? = nil, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct EyeOpen: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Level of confidence in the determination.
        public let confidence: Float?
        /// Boolean value that indicates whether the eyes on the face are open.
        public let value: Bool?

        public init(confidence: Float? = nil, value: Bool? = nil) {
            self.confidence = confidence
            self.value = value
        }

        public init(dictionary: [String: Any]) throws {
            self.confidence = dictionary["Confidence"] as? Float
            self.value = dictionary["Value"] as? Bool
        }
    }

    public struct DetectLabelsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The input image. You can provide a blob of image bytes or an S3 object.
        public let image: Image
        /// Maximum number of labels you want the service to return in the response. The service returns the specified number of highest confidence labels. 
        public let maxLabels: Int32?
        /// Specifies the minimum confidence level for the labels to return. Amazon Rekognition doesn't return any labels with confidence lower than this specified value. If minConfidence is not specified, the operation returns labels with a confidence values greater than or equal to 50 percent.
        public let minConfidence: Float?

        public init(image: Image, maxLabels: Int32? = nil, minConfidence: Float? = nil) {
            self.image = image
            self.maxLabels = maxLabels
            self.minConfidence = minConfidence
        }

        public init(dictionary: [String: Any]) throws {
            guard let image = dictionary["Image"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Image") }
            self.image = try Rekognition.Image(dictionary: image)
            self.maxLabels = dictionary["MaxLabels"] as? Int32
            self.minConfidence = dictionary["MinConfidence"] as? Float
        }
    }

    public struct CreateCollectionResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Amazon Resource Name (ARN) of the collection. You can use this to manage permissions on your resources. 
        public let collectionArn: String?
        /// HTTP status code indicating the result of the operation.
        public let statusCode: Int32?

        public init(collectionArn: String? = nil, statusCode: Int32? = nil) {
            self.collectionArn = collectionArn
            self.statusCode = statusCode
        }

        public init(dictionary: [String: Any]) throws {
            self.collectionArn = dictionary["CollectionArn"] as? String
            self.statusCode = dictionary["StatusCode"] as? Int32
        }
    }

    public enum Attribute: String, CustomStringConvertible {
        case `default` = "DEFAULT"
        case all = "ALL"
        public var description: String { return self.rawValue }
    }

    public struct DetectFacesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The image in which you want to detect faces. You can specify a blob or an S3 object. 
        public let image: Image
        /// A list of facial attributes you would like to be returned. By default, the API returns subset of facial attributes.  For example, you can specify the value as, ["ALL"] or ["DEFAULT"]. If you provide both, ["ALL", "DEFAULT"], the service uses a logical AND operator to determine which attributes to return (in this case, it is all attributes). If you specify all attributes, Amazon Rekognition performs additional detection. 
        public let attributes: [Attribute]?

        public init(image: Image, attributes: [Attribute]? = nil) {
            self.image = image
            self.attributes = attributes
        }

        public init(dictionary: [String: Any]) throws {
            guard let image = dictionary["Image"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Image") }
            self.image = try Rekognition.Image(dictionary: image)
            if let attributes = dictionary["Attributes"] as? [String] { self.attributes = attributes.flatMap({ Attribute(rawValue: $0)}) } else { self.attributes = nil }
        }
    }

    public struct FaceRecord: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let face: Face?
        public let faceDetail: FaceDetail?

        public init(face: Face? = nil, faceDetail: FaceDetail? = nil) {
            self.face = face
            self.faceDetail = faceDetail
        }

        public init(dictionary: [String: Any]) throws {
            if let face = dictionary["Face"] as? [String: Any] { self.face = try Rekognition.Face(dictionary: face) } else { self.face = nil }
            if let faceDetail = dictionary["FaceDetail"] as? [String: Any] { self.faceDetail = try Rekognition.FaceDetail(dictionary: faceDetail) } else { self.faceDetail = nil }
        }
    }

    public struct Beard: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Level of confidence in the determination.
        public let confidence: Float?
        /// Boolean value that indicates whether the face has beard or not.
        public let value: Bool?

        public init(confidence: Float? = nil, value: Bool? = nil) {
            self.confidence = confidence
            self.value = value
        }

        public init(dictionary: [String: Any]) throws {
            self.confidence = dictionary["Confidence"] as? Float
            self.value = dictionary["Value"] as? Bool
        }
    }

    public struct Face: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let boundingBox: BoundingBox?
        /// Identifier that you assign to all the faces in the input image.
        public let externalImageId: String?
        /// Confidence level that the bounding box contains a face (and not a different object such as a tree).
        public let confidence: Float?
        /// Unique identifier that Amazon Rekognition assigns to the face.
        public let faceId: String?
        /// Unique identifier that Amazon Rekognition assigns to the source image.
        public let imageId: String?

        public init(boundingBox: BoundingBox? = nil, externalImageId: String? = nil, confidence: Float? = nil, faceId: String? = nil, imageId: String? = nil) {
            self.boundingBox = boundingBox
            self.externalImageId = externalImageId
            self.confidence = confidence
            self.faceId = faceId
            self.imageId = imageId
        }

        public init(dictionary: [String: Any]) throws {
            if let boundingBox = dictionary["BoundingBox"] as? [String: Any] { self.boundingBox = try Rekognition.BoundingBox(dictionary: boundingBox) } else { self.boundingBox = nil }
            self.externalImageId = dictionary["ExternalImageId"] as? String
            self.confidence = dictionary["Confidence"] as? Float
            self.faceId = dictionary["FaceId"] as? String
            self.imageId = dictionary["ImageId"] as? String
        }
    }

    public enum GenderType: String, CustomStringConvertible {
        case male = "MALE"
        case female = "FEMALE"
        public var description: String { return self.rawValue }
    }

    public struct CompareFacesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Source image either as bytes or an S3 object
        public let sourceImage: Image
        /// Target image either as bytes or an S3 object
        public let targetImage: Image
        /// The minimum level of confidence in the match you want included in the result.
        public let similarityThreshold: Float?

        public init(sourceImage: Image, targetImage: Image, similarityThreshold: Float? = nil) {
            self.sourceImage = sourceImage
            self.targetImage = targetImage
            self.similarityThreshold = similarityThreshold
        }

        public init(dictionary: [String: Any]) throws {
            guard let sourceImage = dictionary["SourceImage"] as? [String: Any] else { throw InitializableError.missingRequiredParam("SourceImage") }
            self.sourceImage = try Rekognition.Image(dictionary: sourceImage)
            guard let targetImage = dictionary["TargetImage"] as? [String: Any] else { throw InitializableError.missingRequiredParam("TargetImage") }
            self.targetImage = try Rekognition.Image(dictionary: targetImage)
            self.similarityThreshold = dictionary["SimilarityThreshold"] as? Float
        }
    }

    public struct Sunglasses: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Level of confidence in the determination.
        public let confidence: Float?
        /// Boolean value that indicates whether the face is wearing sunglasses or not.
        public let value: Bool?

        public init(confidence: Float? = nil, value: Bool? = nil) {
            self.confidence = confidence
            self.value = value
        }

        public init(dictionary: [String: Any]) throws {
            self.confidence = dictionary["Confidence"] as? Float
            self.value = dictionary["Value"] as? Bool
        }
    }

    public struct MouthOpen: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Level of confidence in the determination.
        public let confidence: Float?
        /// Boolean value that indicates whether the mouth on the face is open or not.
        public let value: Bool?

        public init(confidence: Float? = nil, value: Bool? = nil) {
            self.confidence = confidence
            self.value = value
        }

        public init(dictionary: [String: Any]) throws {
            self.confidence = dictionary["Confidence"] as? Float
            self.value = dictionary["Value"] as? Bool
        }
    }

    public struct Image: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Blob of image bytes up to 5 MBs.
        public let bytes: Data?
        /// Identifies an S3 object as the image source.
        public let s3Object: S3Object?

        public init(bytes: Data? = nil, s3Object: S3Object? = nil) {
            self.bytes = bytes
            self.s3Object = s3Object
        }

        public init(dictionary: [String: Any]) throws {
            self.bytes = dictionary["Bytes"] as? Data
            if let s3Object = dictionary["S3Object"] as? [String: Any] { self.s3Object = try Rekognition.S3Object(dictionary: s3Object) } else { self.s3Object = nil }
        }
    }

    public struct CompareFacesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Provides an array of CompareFacesMatch objects. Each object provides the bounding box, confidence that the bounding box contains a face, and the similarity between the face in the bounding box and the face in the source image.
        public let faceMatches: [CompareFacesMatch]?
        /// The face from the source image that was used for comparison.
        public let sourceImageFace: ComparedSourceImageFace?

        public init(faceMatches: [CompareFacesMatch]? = nil, sourceImageFace: ComparedSourceImageFace? = nil) {
            self.faceMatches = faceMatches
            self.sourceImageFace = sourceImageFace
        }

        public init(dictionary: [String: Any]) throws {
            if let faceMatches = dictionary["FaceMatches"] as? [[String: Any]] {
                self.faceMatches = try faceMatches.map({ try CompareFacesMatch(dictionary: $0) })
            } else { 
                self.faceMatches = nil
            }
            if let sourceImageFace = dictionary["SourceImageFace"] as? [String: Any] { self.sourceImageFace = try Rekognition.ComparedSourceImageFace(dictionary: sourceImageFace) } else { self.sourceImageFace = nil }
        }
    }

    public struct AgeRange: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The highest estimated age.
        public let high: Int32?
        /// The lowest estimated age.
        public let low: Int32?

        public init(high: Int32? = nil, low: Int32? = nil) {
            self.high = high
            self.low = low
        }

        public init(dictionary: [String: Any]) throws {
            self.high = dictionary["High"] as? Int32
            self.low = dictionary["Low"] as? Int32
        }
    }

    public struct Eyeglasses: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Level of confidence in the determination.
        public let confidence: Float?
        /// Boolean value that indicates whether the face is wearing eye glasses or not.
        public let value: Bool?

        public init(confidence: Float? = nil, value: Bool? = nil) {
            self.confidence = confidence
            self.value = value
        }

        public init(dictionary: [String: Any]) throws {
            self.confidence = dictionary["Confidence"] as? Float
            self.value = dictionary["Value"] as? Bool
        }
    }

    public struct DeleteCollectionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// ID of the collection to delete.
        public let collectionId: String

        public init(collectionId: String) {
            self.collectionId = collectionId
        }

        public init(dictionary: [String: Any]) throws {
            guard let collectionId = dictionary["CollectionId"] as? String else { throw InitializableError.missingRequiredParam("CollectionId") }
            self.collectionId = collectionId
        }
    }

    public enum LandmarkType: String, CustomStringConvertible {
        case eye_left = "EYE_LEFT"
        case eye_right = "EYE_RIGHT"
        case nose = "NOSE"
        case mouth_left = "MOUTH_LEFT"
        case mouth_right = "MOUTH_RIGHT"
        case left_eyebrow_left = "LEFT_EYEBROW_LEFT"
        case left_eyebrow_right = "LEFT_EYEBROW_RIGHT"
        case left_eyebrow_up = "LEFT_EYEBROW_UP"
        case right_eyebrow_left = "RIGHT_EYEBROW_LEFT"
        case right_eyebrow_right = "RIGHT_EYEBROW_RIGHT"
        case right_eyebrow_up = "RIGHT_EYEBROW_UP"
        case left_eye_left = "LEFT_EYE_LEFT"
        case left_eye_right = "LEFT_EYE_RIGHT"
        case left_eye_up = "LEFT_EYE_UP"
        case left_eye_down = "LEFT_EYE_DOWN"
        case right_eye_left = "RIGHT_EYE_LEFT"
        case right_eye_right = "RIGHT_EYE_RIGHT"
        case right_eye_up = "RIGHT_EYE_UP"
        case right_eye_down = "RIGHT_EYE_DOWN"
        case nose_left = "NOSE_LEFT"
        case nose_right = "NOSE_RIGHT"
        case mouth_up = "MOUTH_UP"
        case mouth_down = "MOUTH_DOWN"
        case left_pupil = "LEFT_PUPIL"
        case right_pupil = "RIGHT_PUPIL"
        public var description: String { return self.rawValue }
    }

    public struct CreateCollectionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// ID for the collection that you are creating.
        public let collectionId: String

        public init(collectionId: String) {
            self.collectionId = collectionId
        }

        public init(dictionary: [String: Any]) throws {
            guard let collectionId = dictionary["CollectionId"] as? String else { throw InitializableError.missingRequiredParam("CollectionId") }
            self.collectionId = collectionId
        }
    }

    public struct ListFacesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// If the previous response was incomplete (because there is more data to retrieve), Amazon Rekognition returns a pagination token in the response. You can use this pagination token to retrieve the next set of faces.
        public let nextToken: String?
        /// ID of the collection from which to list the faces.
        public let collectionId: String
        /// Maximum number of faces to return.
        public let maxResults: Int32?

        public init(nextToken: String? = nil, collectionId: String, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.collectionId = collectionId
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            guard let collectionId = dictionary["CollectionId"] as? String else { throw InitializableError.missingRequiredParam("CollectionId") }
            self.collectionId = collectionId
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct ImageQuality: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Value representing sharpness of the face.
        public let sharpness: Float?
        /// Value representing brightness of the face. The service returns a value between 0 and 1 (inclusive).
        public let brightness: Float?

        public init(sharpness: Float? = nil, brightness: Float? = nil) {
            self.sharpness = sharpness
            self.brightness = brightness
        }

        public init(dictionary: [String: Any]) throws {
            self.sharpness = dictionary["Sharpness"] as? Float
            self.brightness = dictionary["Brightness"] as? Float
        }
    }

    public struct DetectLabelsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        ///  Amazon Rekognition returns the orientation of the input image that was detected (clockwise direction). If your application displays the image, you can use this value to correct the orientation. If Amazon Rekognition detects that the input image was rotated (for example, by 90 degrees), it first corrects the orientation before detecting the labels.   If the source image Exif metadata populates the orientation field, Amazon Rekognition does not perform orientation correction and the value of OrientationCorrection will be nil. 
        public let orientationCorrection: OrientationCorrection?
        /// An array of labels for the real-world objects detected. 
        public let labels: [Label]?

        public init(orientationCorrection: OrientationCorrection? = nil, labels: [Label]? = nil) {
            self.orientationCorrection = orientationCorrection
            self.labels = labels
        }

        public init(dictionary: [String: Any]) throws {
            if let orientationCorrection = dictionary["OrientationCorrection"] as? String { self.orientationCorrection = OrientationCorrection(rawValue: orientationCorrection) } else { self.orientationCorrection = nil }
            if let labels = dictionary["Labels"] as? [[String: Any]] {
                self.labels = try labels.map({ try Label(dictionary: $0) })
            } else { 
                self.labels = nil
            }
        }
    }

    public struct ListFacesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An array of Face objects. 
        public let faces: [Face]?
        /// If the response is truncated, Amazon Rekognition returns this token that you can use in the subsequent request to retrieve the next set of faces.
        public let nextToken: String?

        public init(faces: [Face]? = nil, nextToken: String? = nil) {
            self.faces = faces
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let faces = dictionary["Faces"] as? [[String: Any]] {
                self.faces = try faces.map({ try Face(dictionary: $0) })
            } else { 
                self.faces = nil
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct IndexFacesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let image: Image
        /// ID you want to assign to all the faces detected in the image.
        public let externalImageId: String?
        /// ID of an existing collection to which you want to add the faces that are detected in the input images.
        public let collectionId: String
        /// (Optional) Returns detailed attributes of indexed faces. By default, the operation returns a subset of the facial attributes.  For example, you can specify the value as, ["ALL"] or ["DEFAULT"]. If you provide both, ["ALL", "DEFAULT"], Amazon Rekognition uses the logical AND operator to determine which attributes to return (in this case, it is all attributes). If you specify all attributes, the service performs additional detection, in addition to the default. 
        public let detectionAttributes: [Attribute]?

        public init(image: Image, externalImageId: String? = nil, collectionId: String, detectionAttributes: [Attribute]? = nil) {
            self.image = image
            self.externalImageId = externalImageId
            self.collectionId = collectionId
            self.detectionAttributes = detectionAttributes
        }

        public init(dictionary: [String: Any]) throws {
            guard let image = dictionary["Image"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Image") }
            self.image = try Rekognition.Image(dictionary: image)
            self.externalImageId = dictionary["ExternalImageId"] as? String
            guard let collectionId = dictionary["CollectionId"] as? String else { throw InitializableError.missingRequiredParam("CollectionId") }
            self.collectionId = collectionId
            if let detectionAttributes = dictionary["DetectionAttributes"] as? [String] { self.detectionAttributes = detectionAttributes.flatMap({ Attribute(rawValue: $0)}) } else { self.detectionAttributes = nil }
        }
    }

    public struct ComparedSourceImageFace: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Confidence level that the selected bounding box contains a face.
        public let confidence: Float?
        public let boundingBox: BoundingBox?

        public init(confidence: Float? = nil, boundingBox: BoundingBox? = nil) {
            self.confidence = confidence
            self.boundingBox = boundingBox
        }

        public init(dictionary: [String: Any]) throws {
            self.confidence = dictionary["Confidence"] as? Float
            if let boundingBox = dictionary["BoundingBox"] as? [String: Any] { self.boundingBox = try Rekognition.BoundingBox(dictionary: boundingBox) } else { self.boundingBox = nil }
        }
    }

    public enum EmotionName: String, CustomStringConvertible {
        case happy = "HAPPY"
        case sad = "SAD"
        case angry = "ANGRY"
        case confused = "CONFUSED"
        case disgusted = "DISGUSTED"
        case surprised = "SURPRISED"
        case calm = "CALM"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

}