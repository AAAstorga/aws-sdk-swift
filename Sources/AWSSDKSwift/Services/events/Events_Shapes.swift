// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Events {

    public struct InputTransformer: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Input template where you can use the values of the keys from InputPathsMap to customize the data sent to the target.
        public let inputTemplate: String
        /// Map of JSON paths to be extracted from the event. These are key-value pairs, where each value is a JSON path.
        public let inputPathsMap: [String: String]?

        public init(inputTemplate: String, inputPathsMap: [String: String]? = nil) {
            self.inputTemplate = inputTemplate
            self.inputPathsMap = inputPathsMap
        }

        public init(dictionary: [String: Any]) throws {
            guard let inputTemplate = dictionary["InputTemplate"] as? String else { throw InitializableError.missingRequiredParam("InputTemplate") }
            self.inputTemplate = inputTemplate
            if let inputPathsMap = dictionary["InputPathsMap"] as? [String: String] {
                self.inputPathsMap = inputPathsMap
            } else { 
                self.inputPathsMap = nil
            }
        }
    }

    public struct PutTargetsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The number of failed entries.
        public let failedEntryCount: Int32?
        /// The failed target entries.
        public let failedEntries: [PutTargetsResultEntry]?

        public init(failedEntryCount: Int32? = nil, failedEntries: [PutTargetsResultEntry]? = nil) {
            self.failedEntryCount = failedEntryCount
            self.failedEntries = failedEntries
        }

        public init(dictionary: [String: Any]) throws {
            self.failedEntryCount = dictionary["FailedEntryCount"] as? Int32
            if let failedEntries = dictionary["FailedEntries"] as? [[String: Any]] {
                self.failedEntries = try failedEntries.map({ try PutTargetsResultEntry(dictionary: $0) })
            } else { 
                self.failedEntries = nil
            }
        }
    }

    public struct Rule: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Amazon Resource Name (ARN) of the rule.
        public let arn: String?
        /// The state of the rule.
        public let state: RuleState?
        /// The name of the rule.
        public let name: String?
        /// The event pattern of the rule.
        public let eventPattern: String?
        /// The Amazon Resource Name (ARN) of the role that is used for target invocation.
        public let roleArn: String?
        /// The scheduling expression. For example, "cron(0 20 * * ? *)", "rate(5 minutes)".
        public let scheduleExpression: String?
        /// The description of the rule.
        public let description: String?

        public init(arn: String? = nil, state: RuleState? = nil, name: String? = nil, eventPattern: String? = nil, roleArn: String? = nil, scheduleExpression: String? = nil, description: String? = nil) {
            self.arn = arn
            self.state = state
            self.name = name
            self.eventPattern = eventPattern
            self.roleArn = roleArn
            self.scheduleExpression = scheduleExpression
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.arn = dictionary["Arn"] as? String
            if let state = dictionary["State"] as? String { self.state = RuleState(rawValue: state) } else { self.state = nil }
            self.name = dictionary["Name"] as? String
            self.eventPattern = dictionary["EventPattern"] as? String
            self.roleArn = dictionary["RoleArn"] as? String
            self.scheduleExpression = dictionary["ScheduleExpression"] as? String
            self.description = dictionary["Description"] as? String
        }
    }

    public struct Target: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Parameters used when you are using the rule to invoke Amazon EC2 Run Command.
        public let runCommandParameters: RunCommandParameters?
        /// Settings to enable you to provide custom input to a target based on certain event data. You can extract one or more key-value pairs from the event and then use that data to send customized input to the target.
        public let inputTransformer: InputTransformer?
        /// The Amazon Resource Name (ARN) of the target.
        public let arn: String
        /// Valid JSON text passed to the target. In this case, nothing from the event itself is passed to the target. For more information, see The JavaScript Object Notation (JSON) Data Interchange Format.
        public let input: String?
        /// The value of the JSONPath that is used for extracting part of the matched event when passing it to the target. For more information about JSON paths, see JSONPath.
        public let inputPath: String?
        /// Contains the Amazon ECS task definition and task count to be used, if the event target is an Amazon ECS task. For more information about Amazon ECS tasks, see Task Definitions  in the Amazon EC2 Container Service Developer Guide.
        public let ecsParameters: EcsParameters?
        /// The Amazon Resource Name (ARN) of the IAM role to be used for this target when the rule is triggered. If one rule triggers multiple targets, you can use a different IAM role for each target.
        public let roleArn: String?
        /// The custom parameter you can use to control shard assignment, when the target is an Amazon Kinesis stream. If you do not include this parameter, the default is to use the eventId as the partition key.
        public let kinesisParameters: KinesisParameters?
        /// The ID of the target.
        public let id: String

        public init(runCommandParameters: RunCommandParameters? = nil, inputTransformer: InputTransformer? = nil, arn: String, input: String? = nil, inputPath: String? = nil, ecsParameters: EcsParameters? = nil, roleArn: String? = nil, kinesisParameters: KinesisParameters? = nil, id: String) {
            self.runCommandParameters = runCommandParameters
            self.inputTransformer = inputTransformer
            self.arn = arn
            self.input = input
            self.inputPath = inputPath
            self.ecsParameters = ecsParameters
            self.roleArn = roleArn
            self.kinesisParameters = kinesisParameters
            self.id = id
        }

        public init(dictionary: [String: Any]) throws {
            if let runCommandParameters = dictionary["RunCommandParameters"] as? [String: Any] { self.runCommandParameters = try Events.RunCommandParameters(dictionary: runCommandParameters) } else { self.runCommandParameters = nil }
            if let inputTransformer = dictionary["InputTransformer"] as? [String: Any] { self.inputTransformer = try Events.InputTransformer(dictionary: inputTransformer) } else { self.inputTransformer = nil }
            guard let arn = dictionary["Arn"] as? String else { throw InitializableError.missingRequiredParam("Arn") }
            self.arn = arn
            self.input = dictionary["Input"] as? String
            self.inputPath = dictionary["InputPath"] as? String
            if let ecsParameters = dictionary["EcsParameters"] as? [String: Any] { self.ecsParameters = try Events.EcsParameters(dictionary: ecsParameters) } else { self.ecsParameters = nil }
            self.roleArn = dictionary["RoleArn"] as? String
            if let kinesisParameters = dictionary["KinesisParameters"] as? [String: Any] { self.kinesisParameters = try Events.KinesisParameters(dictionary: kinesisParameters) } else { self.kinesisParameters = nil }
            guard let id = dictionary["Id"] as? String else { throw InitializableError.missingRequiredParam("Id") }
            self.id = id
        }
    }

    public struct DisableRuleRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the rule.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
        }
    }

    public struct TestEventPatternRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The event, in JSON format, to test against the event pattern.
        public let event: String
        /// The event pattern.
        public let eventPattern: String

        public init(event: String, eventPattern: String) {
            self.event = event
            self.eventPattern = eventPattern
        }

        public init(dictionary: [String: Any]) throws {
            guard let event = dictionary["Event"] as? String else { throw InitializableError.missingRequiredParam("Event") }
            self.event = event
            guard let eventPattern = dictionary["EventPattern"] as? String else { throw InitializableError.missingRequiredParam("EventPattern") }
            self.eventPattern = eventPattern
        }
    }

    public struct RunCommandTarget: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Can be either tag: tag-key or InstanceIds.
        public let key: String
        /// If Key is tag: tag-key, Values is a list of tag values. If Key is InstanceIds, Values is a list of Amazon EC2 instance IDs.
        public let values: [String]

        public init(key: String, values: [String]) {
            self.key = key
            self.values = values
        }

        public init(dictionary: [String: Any]) throws {
            guard let key = dictionary["Key"] as? String else { throw InitializableError.missingRequiredParam("Key") }
            self.key = key
            guard let values = dictionary["Values"] as? [String] else { throw InitializableError.missingRequiredParam("Values") }
            self.values = values
        }
    }

    public struct ListRuleNamesByTargetRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The token returned by a previous call to retrieve the next set of results.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the target resource.
        public let targetArn: String
        /// The maximum number of results to return.
        public let limit: Int32?

        public init(nextToken: String? = nil, targetArn: String, limit: Int32? = nil) {
            self.nextToken = nextToken
            self.targetArn = targetArn
            self.limit = limit
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            guard let targetArn = dictionary["TargetArn"] as? String else { throw InitializableError.missingRequiredParam("TargetArn") }
            self.targetArn = targetArn
            self.limit = dictionary["Limit"] as? Int32
        }
    }

    public struct PutRuleRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A description of the rule.
        public let description: String?
        /// The scheduling expression. For example, "cron(0 20 * * ? *)", "rate(5 minutes)".
        public let scheduleExpression: String?
        /// The Amazon Resource Name (ARN) of the IAM role associated with the rule.
        public let roleArn: String?
        /// The event pattern.
        public let eventPattern: String?
        /// The name of the rule that you are creating or updating.
        public let name: String
        /// Indicates whether the rule is enabled or disabled.
        public let state: RuleState?

        public init(description: String? = nil, scheduleExpression: String? = nil, roleArn: String? = nil, eventPattern: String? = nil, name: String, state: RuleState? = nil) {
            self.description = description
            self.scheduleExpression = scheduleExpression
            self.roleArn = roleArn
            self.eventPattern = eventPattern
            self.name = name
            self.state = state
        }

        public init(dictionary: [String: Any]) throws {
            self.description = dictionary["Description"] as? String
            self.scheduleExpression = dictionary["ScheduleExpression"] as? String
            self.roleArn = dictionary["RoleArn"] as? String
            self.eventPattern = dictionary["EventPattern"] as? String
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            if let state = dictionary["State"] as? String { self.state = RuleState(rawValue: state) } else { self.state = nil }
        }
    }

    public struct RunCommandParameters: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Currently, we support including only one RunCommandTarget block, which specifies either an array of InstanceIds or a tag.
        public let runCommandTargets: [RunCommandTarget]

        public init(runCommandTargets: [RunCommandTarget]) {
            self.runCommandTargets = runCommandTargets
        }

        public init(dictionary: [String: Any]) throws {
            guard let runCommandTargets = dictionary["RunCommandTargets"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("RunCommandTargets") }
            self.runCommandTargets = try runCommandTargets.map({ try RunCommandTarget(dictionary: $0) })
        }
    }

    public struct ListTargetsByRuleResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The targets assigned to the rule.
        public let targets: [Target]?
        /// Indicates whether there are additional results to retrieve. If there are no more results, the value is null.
        public let nextToken: String?

        public init(targets: [Target]? = nil, nextToken: String? = nil) {
            self.targets = targets
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let targets = dictionary["Targets"] as? [[String: Any]] {
                self.targets = try targets.map({ try Target(dictionary: $0) })
            } else { 
                self.targets = nil
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct DeleteRuleRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the rule.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
        }
    }

    public struct DescribeRuleResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Amazon Resource Name (ARN) of the rule.
        public let arn: String?
        /// Specifies whether the rule is enabled or disabled.
        public let state: RuleState?
        /// The name of the rule.
        public let name: String?
        /// The event pattern.
        public let eventPattern: String?
        /// The Amazon Resource Name (ARN) of the IAM role associated with the rule.
        public let roleArn: String?
        /// The scheduling expression. For example, "cron(0 20 * * ? *)", "rate(5 minutes)".
        public let scheduleExpression: String?
        /// The description of the rule.
        public let description: String?

        public init(arn: String? = nil, state: RuleState? = nil, name: String? = nil, eventPattern: String? = nil, roleArn: String? = nil, scheduleExpression: String? = nil, description: String? = nil) {
            self.arn = arn
            self.state = state
            self.name = name
            self.eventPattern = eventPattern
            self.roleArn = roleArn
            self.scheduleExpression = scheduleExpression
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.arn = dictionary["Arn"] as? String
            if let state = dictionary["State"] as? String { self.state = RuleState(rawValue: state) } else { self.state = nil }
            self.name = dictionary["Name"] as? String
            self.eventPattern = dictionary["EventPattern"] as? String
            self.roleArn = dictionary["RoleArn"] as? String
            self.scheduleExpression = dictionary["ScheduleExpression"] as? String
            self.description = dictionary["Description"] as? String
        }
    }

    public struct PutEventsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The entry that defines an event in your system. You can specify several parameters for the entry such as the source and type of the event, resources associated with the event, and so on.
        public let entries: [PutEventsRequestEntry]

        public init(entries: [PutEventsRequestEntry]) {
            self.entries = entries
        }

        public init(dictionary: [String: Any]) throws {
            guard let entries = dictionary["Entries"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("Entries") }
            self.entries = try entries.map({ try PutEventsRequestEntry(dictionary: $0) })
        }
    }

    public struct RemoveTargetsResultEntry: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The error message that explains why the target removal failed.
        public let errorMessage: String?
        /// The error code that indicates why the target removal failed.
        public let errorCode: String?
        /// The ID of the target.
        public let targetId: String?

        public init(errorMessage: String? = nil, errorCode: String? = nil, targetId: String? = nil) {
            self.errorMessage = errorMessage
            self.errorCode = errorCode
            self.targetId = targetId
        }

        public init(dictionary: [String: Any]) throws {
            self.errorMessage = dictionary["ErrorMessage"] as? String
            self.errorCode = dictionary["ErrorCode"] as? String
            self.targetId = dictionary["TargetId"] as? String
        }
    }

    public struct PutEventsRequestEntry: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// In the JSON sense, an object containing fields, which may also contain nested subobjects. No constraints are imposed on its contents.
        public let detail: String?
        /// Free-form string used to decide what fields to expect in the event detail.
        public let detailType: String?
        /// The source of the event.
        public let source: String?
        /// The timestamp of the event, per RFC3339. If no timestamp is provided, the timestamp of the PutEvents call is used.
        public let time: Date?
        /// AWS resources, identified by Amazon Resource Name (ARN), which the event primarily concerns. Any number, including zero, may be present.
        public let resources: [String]?

        public init(detail: String? = nil, detailType: String? = nil, source: String? = nil, time: Date? = nil, resources: [String]? = nil) {
            self.detail = detail
            self.detailType = detailType
            self.source = source
            self.time = time
            self.resources = resources
        }

        public init(dictionary: [String: Any]) throws {
            self.detail = dictionary["Detail"] as? String
            self.detailType = dictionary["DetailType"] as? String
            self.source = dictionary["Source"] as? String
            self.time = dictionary["Time"] as? Date
            self.resources = dictionary["Resources"] as? [String]
        }
    }

    public struct TestEventPatternResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Indicates whether the event matches the event pattern.
        public let result: Bool?

        public init(result: Bool? = nil) {
            self.result = result
        }

        public init(dictionary: [String: Any]) throws {
            self.result = dictionary["Result"] as? Bool
        }
    }

    public struct PutTargetsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The targets to update or add to the rule.
        public let targets: [Target]
        /// The name of the rule.
        public let rule: String

        public init(targets: [Target], rule: String) {
            self.targets = targets
            self.rule = rule
        }

        public init(dictionary: [String: Any]) throws {
            guard let targets = dictionary["Targets"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("Targets") }
            self.targets = try targets.map({ try Target(dictionary: $0) })
            guard let rule = dictionary["Rule"] as? String else { throw InitializableError.missingRequiredParam("Rule") }
            self.rule = rule
        }
    }

    public enum RuleState: String, CustomStringConvertible {
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public struct EnableRuleRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the rule.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
        }
    }

    public struct PutTargetsResultEntry: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The error message that explains why the target addition failed.
        public let errorMessage: String?
        /// The error code that indicates why the target addition failed.
        public let errorCode: String?
        /// The ID of the target.
        public let targetId: String?

        public init(errorMessage: String? = nil, errorCode: String? = nil, targetId: String? = nil) {
            self.errorMessage = errorMessage
            self.errorCode = errorCode
            self.targetId = targetId
        }

        public init(dictionary: [String: Any]) throws {
            self.errorMessage = dictionary["ErrorMessage"] as? String
            self.errorCode = dictionary["ErrorCode"] as? String
            self.targetId = dictionary["TargetId"] as? String
        }
    }

    public struct ListRulesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Indicates whether there are additional results to retrieve. If there are no more results, the value is null.
        public let nextToken: String?
        /// The rules that match the specified criteria.
        public let rules: [Rule]?

        public init(nextToken: String? = nil, rules: [Rule]? = nil) {
            self.nextToken = nextToken
            self.rules = rules
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let rules = dictionary["Rules"] as? [[String: Any]] {
                self.rules = try rules.map({ try Rule(dictionary: $0) })
            } else { 
                self.rules = nil
            }
        }
    }

    public struct RemoveTargetsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The number of failed entries.
        public let failedEntryCount: Int32?
        /// The failed target entries.
        public let failedEntries: [RemoveTargetsResultEntry]?

        public init(failedEntryCount: Int32? = nil, failedEntries: [RemoveTargetsResultEntry]? = nil) {
            self.failedEntryCount = failedEntryCount
            self.failedEntries = failedEntries
        }

        public init(dictionary: [String: Any]) throws {
            self.failedEntryCount = dictionary["FailedEntryCount"] as? Int32
            if let failedEntries = dictionary["FailedEntries"] as? [[String: Any]] {
                self.failedEntries = try failedEntries.map({ try RemoveTargetsResultEntry(dictionary: $0) })
            } else { 
                self.failedEntries = nil
            }
        }
    }

    public struct EcsParameters: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The number of tasks to create based on the TaskDefinition. The default is one.
        public let taskCount: Int32?
        /// The ARN of the task definition to use if the event target is an Amazon ECS cluster. 
        public let taskDefinitionArn: String

        public init(taskCount: Int32? = nil, taskDefinitionArn: String) {
            self.taskCount = taskCount
            self.taskDefinitionArn = taskDefinitionArn
        }

        public init(dictionary: [String: Any]) throws {
            self.taskCount = dictionary["TaskCount"] as? Int32
            guard let taskDefinitionArn = dictionary["TaskDefinitionArn"] as? String else { throw InitializableError.missingRequiredParam("TaskDefinitionArn") }
            self.taskDefinitionArn = taskDefinitionArn
        }
    }

    public struct DescribeRuleRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the rule.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
        }
    }

    public struct RemoveTargetsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IDs of the targets to remove from the rule.
        public let ids: [String]
        /// The name of the rule.
        public let rule: String

        public init(ids: [String], rule: String) {
            self.ids = ids
            self.rule = rule
        }

        public init(dictionary: [String: Any]) throws {
            guard let ids = dictionary["Ids"] as? [String] else { throw InitializableError.missingRequiredParam("Ids") }
            self.ids = ids
            guard let rule = dictionary["Rule"] as? String else { throw InitializableError.missingRequiredParam("Rule") }
            self.rule = rule
        }
    }

    public struct PutRuleResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Amazon Resource Name (ARN) of the rule.
        public let ruleArn: String?

        public init(ruleArn: String? = nil) {
            self.ruleArn = ruleArn
        }

        public init(dictionary: [String: Any]) throws {
            self.ruleArn = dictionary["RuleArn"] as? String
        }
    }

    public struct ListRulesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The prefix matching the rule name.
        public let namePrefix: String?
        /// The token returned by a previous call to retrieve the next set of results.
        public let nextToken: String?
        /// The maximum number of results to return.
        public let limit: Int32?

        public init(namePrefix: String? = nil, nextToken: String? = nil, limit: Int32? = nil) {
            self.namePrefix = namePrefix
            self.nextToken = nextToken
            self.limit = limit
        }

        public init(dictionary: [String: Any]) throws {
            self.namePrefix = dictionary["NamePrefix"] as? String
            self.nextToken = dictionary["NextToken"] as? String
            self.limit = dictionary["Limit"] as? Int32
        }
    }

    public struct ListRuleNamesByTargetResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Indicates whether there are additional results to retrieve. If there are no more results, the value is null.
        public let nextToken: String?
        /// The names of the rules that can invoke the given target.
        public let ruleNames: [String]?

        public init(nextToken: String? = nil, ruleNames: [String]? = nil) {
            self.nextToken = nextToken
            self.ruleNames = ruleNames
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            self.ruleNames = dictionary["RuleNames"] as? [String]
        }
    }

    public struct ListTargetsByRuleRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the rule.
        public let rule: String
        /// The token returned by a previous call to retrieve the next set of results.
        public let nextToken: String?
        /// The maximum number of results to return.
        public let limit: Int32?

        public init(rule: String, nextToken: String? = nil, limit: Int32? = nil) {
            self.rule = rule
            self.nextToken = nextToken
            self.limit = limit
        }

        public init(dictionary: [String: Any]) throws {
            guard let rule = dictionary["Rule"] as? String else { throw InitializableError.missingRequiredParam("Rule") }
            self.rule = rule
            self.nextToken = dictionary["NextToken"] as? String
            self.limit = dictionary["Limit"] as? Int32
        }
    }

    public struct PutEventsResultEntry: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The error message that explains why the event submission failed.
        public let errorMessage: String?
        /// The ID of the event.
        public let eventId: String?
        /// The error code that indicates why the event submission failed.
        public let errorCode: String?

        public init(errorMessage: String? = nil, eventId: String? = nil, errorCode: String? = nil) {
            self.errorMessage = errorMessage
            self.eventId = eventId
            self.errorCode = errorCode
        }

        public init(dictionary: [String: Any]) throws {
            self.errorMessage = dictionary["ErrorMessage"] as? String
            self.eventId = dictionary["EventId"] as? String
            self.errorCode = dictionary["ErrorCode"] as? String
        }
    }

    public struct PutEventsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The number of failed entries.
        public let failedEntryCount: Int32?
        /// The successfully and unsuccessfully ingested events results. If the ingestion was successful, the entry has the event ID in it. Otherwise, you can use the error code and error message to identify the problem with the entry.
        public let entries: [PutEventsResultEntry]?

        public init(failedEntryCount: Int32? = nil, entries: [PutEventsResultEntry]? = nil) {
            self.failedEntryCount = failedEntryCount
            self.entries = entries
        }

        public init(dictionary: [String: Any]) throws {
            self.failedEntryCount = dictionary["FailedEntryCount"] as? Int32
            if let entries = dictionary["Entries"] as? [[String: Any]] {
                self.entries = try entries.map({ try PutEventsResultEntry(dictionary: $0) })
            } else { 
                self.entries = nil
            }
        }
    }

    public struct KinesisParameters: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The JSON path to be extracted from the event and used as the partition key. For more information, see Amazon Kinesis Streams Key Concepts in the Amazon Kinesis Streams Developer Guide.
        public let partitionKeyPath: String

        public init(partitionKeyPath: String) {
            self.partitionKeyPath = partitionKeyPath
        }

        public init(dictionary: [String: Any]) throws {
            guard let partitionKeyPath = dictionary["PartitionKeyPath"] as? String else { throw InitializableError.missingRequiredParam("PartitionKeyPath") }
            self.partitionKeyPath = partitionKeyPath
        }
    }

}